function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

function $parcel$export(e, n, v) {
  Object.defineProperty(e, n, {
    get: v,
    enumerable: true
  });
}

var $parcel$global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
// ASSET: node_modules/@yarnpkg/core/lib/index.js
var $b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionStatus,
    $b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionType,
    $b0ffa420366ed37c7cf8ff798018d16e$export$LinkType,
    $b0ffa420366ed37c7cf8ff798018d16e$export$YarnVersion,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Workspace,
    $b0ffa420366ed37c7cf8ff798018d16e$export$WorkspaceResolver,
    $b0ffa420366ed37c7cf8ff798018d16e$export$VirtualFetcher,
    $b0ffa420366ed37c7cf8ff798018d16e$export$ThrowReport,
    $b0ffa420366ed37c7cf8ff798018d16e$export$TelemetryManager,
    $b0ffa420366ed37c7cf8ff798018d16e$export$StreamReport,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Report,
    $b0ffa420366ed37c7cf8ff798018d16e$export$ReportError,
    $b0ffa420366ed37c7cf8ff798018d16e$export$TAG_REGEXP,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Project,
    $b0ffa420366ed37c7cf8ff798018d16e$export$MessageName,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Manifest,
    $b0ffa420366ed37c7cf8ff798018d16e$export$LightReport,
    $b0ffa420366ed37c7cf8ff798018d16e$export$BuildType,
    $b0ffa420366ed37c7cf8ff798018d16e$export$SettingsType,
    $b0ffa420366ed37c7cf8ff798018d16e$export$ProjectLookup,
    $b0ffa420366ed37c7cf8ff798018d16e$export$FormatType,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Configuration,
    $b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_LOCK_FILENAME,
    $b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_RC_FILENAME,
    $b0ffa420366ed37c7cf8ff798018d16e$export$Cache,
    $b0ffa420366ed37c7cf8ff798018d16e$exports = {};
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "__esModule", {
  value: true
});
var $b0ffa420366ed37c7cf8ff798018d16e$export$treeUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$tgzUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$structUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$semverUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$scriptUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$miscUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$formatUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$folderUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$execUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$httpUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$hashUtils = ($b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionStatus = ($b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionType = ($b0ffa420366ed37c7cf8ff798018d16e$export$LinkType = ($b0ffa420366ed37c7cf8ff798018d16e$export$YarnVersion = ($b0ffa420366ed37c7cf8ff798018d16e$export$Workspace = ($b0ffa420366ed37c7cf8ff798018d16e$export$WorkspaceResolver = ($b0ffa420366ed37c7cf8ff798018d16e$export$VirtualFetcher = ($b0ffa420366ed37c7cf8ff798018d16e$export$ThrowReport = ($b0ffa420366ed37c7cf8ff798018d16e$export$TelemetryManager = ($b0ffa420366ed37c7cf8ff798018d16e$export$StreamReport = ($b0ffa420366ed37c7cf8ff798018d16e$export$Report = ($b0ffa420366ed37c7cf8ff798018d16e$export$ReportError = ($b0ffa420366ed37c7cf8ff798018d16e$export$TAG_REGEXP = ($b0ffa420366ed37c7cf8ff798018d16e$export$Project = ($b0ffa420366ed37c7cf8ff798018d16e$export$MessageName = ($b0ffa420366ed37c7cf8ff798018d16e$export$Manifest = ($b0ffa420366ed37c7cf8ff798018d16e$export$LightReport = ($b0ffa420366ed37c7cf8ff798018d16e$export$BuildType = ($b0ffa420366ed37c7cf8ff798018d16e$export$SettingsType = ($b0ffa420366ed37c7cf8ff798018d16e$export$ProjectLookup = ($b0ffa420366ed37c7cf8ff798018d16e$export$FormatType = ($b0ffa420366ed37c7cf8ff798018d16e$export$Configuration = ($b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_LOCK_FILENAME = ($b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_RC_FILENAME = ($b0ffa420366ed37c7cf8ff798018d16e$export$Cache = void 0, $b0ffa420366ed37c7cf8ff798018d16e$exports.Cache = $b0ffa420366ed37c7cf8ff798018d16e$export$Cache), $b0ffa420366ed37c7cf8ff798018d16e$exports.DEFAULT_RC_FILENAME = $b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_RC_FILENAME), $b0ffa420366ed37c7cf8ff798018d16e$exports.DEFAULT_LOCK_FILENAME = $b0ffa420366ed37c7cf8ff798018d16e$export$DEFAULT_LOCK_FILENAME), $b0ffa420366ed37c7cf8ff798018d16e$exports.Configuration = $b0ffa420366ed37c7cf8ff798018d16e$export$Configuration), $b0ffa420366ed37c7cf8ff798018d16e$exports.FormatType = $b0ffa420366ed37c7cf8ff798018d16e$export$FormatType), $b0ffa420366ed37c7cf8ff798018d16e$exports.ProjectLookup = $b0ffa420366ed37c7cf8ff798018d16e$export$ProjectLookup), $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType = $b0ffa420366ed37c7cf8ff798018d16e$export$SettingsType), $b0ffa420366ed37c7cf8ff798018d16e$exports.BuildType = $b0ffa420366ed37c7cf8ff798018d16e$export$BuildType), $b0ffa420366ed37c7cf8ff798018d16e$exports.LightReport = $b0ffa420366ed37c7cf8ff798018d16e$export$LightReport), $b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest = $b0ffa420366ed37c7cf8ff798018d16e$export$Manifest), $b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName = $b0ffa420366ed37c7cf8ff798018d16e$export$MessageName), $b0ffa420366ed37c7cf8ff798018d16e$exports.Project = $b0ffa420366ed37c7cf8ff798018d16e$export$Project), $b0ffa420366ed37c7cf8ff798018d16e$exports.TAG_REGEXP = $b0ffa420366ed37c7cf8ff798018d16e$export$TAG_REGEXP), $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError = $b0ffa420366ed37c7cf8ff798018d16e$export$ReportError), $b0ffa420366ed37c7cf8ff798018d16e$exports.Report = $b0ffa420366ed37c7cf8ff798018d16e$export$Report), $b0ffa420366ed37c7cf8ff798018d16e$exports.StreamReport = $b0ffa420366ed37c7cf8ff798018d16e$export$StreamReport), $b0ffa420366ed37c7cf8ff798018d16e$exports.TelemetryManager = $b0ffa420366ed37c7cf8ff798018d16e$export$TelemetryManager), $b0ffa420366ed37c7cf8ff798018d16e$exports.ThrowReport = $b0ffa420366ed37c7cf8ff798018d16e$export$ThrowReport), $b0ffa420366ed37c7cf8ff798018d16e$exports.VirtualFetcher = $b0ffa420366ed37c7cf8ff798018d16e$export$VirtualFetcher), $b0ffa420366ed37c7cf8ff798018d16e$exports.WorkspaceResolver = $b0ffa420366ed37c7cf8ff798018d16e$export$WorkspaceResolver), $b0ffa420366ed37c7cf8ff798018d16e$exports.Workspace = $b0ffa420366ed37c7cf8ff798018d16e$export$Workspace), $b0ffa420366ed37c7cf8ff798018d16e$exports.YarnVersion = $b0ffa420366ed37c7cf8ff798018d16e$export$YarnVersion), $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType = $b0ffa420366ed37c7cf8ff798018d16e$export$LinkType), $b0ffa420366ed37c7cf8ff798018d16e$exports.PackageExtensionType = $b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionType), $b0ffa420366ed37c7cf8ff798018d16e$exports.PackageExtensionStatus = $b0ffa420366ed37c7cf8ff798018d16e$export$PackageExtensionStatus), $b0ffa420366ed37c7cf8ff798018d16e$exports.hashUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$hashUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$httpUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.execUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$execUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.folderUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$folderUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.formatUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$formatUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$miscUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.scriptUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$scriptUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.semverUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$semverUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$structUtils), $b0ffa420366ed37c7cf8ff798018d16e$exports.tgzUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$tgzUtils);
$b0ffa420366ed37c7cf8ff798018d16e$exports.treeUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$treeUtils;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var $4d80ac9757769a55b72ee4f0926c5df8$var$extendStatics = function (d, b) {
  $4d80ac9757769a55b72ee4f0926c5df8$var$extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return $4d80ac9757769a55b72ee4f0926c5df8$var$extendStatics(d, b);
};

var $4d80ac9757769a55b72ee4f0926c5df8$export$__assign = function () {
  $4d80ac9757769a55b72ee4f0926c5df8$export$__assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return $4d80ac9757769a55b72ee4f0926c5df8$export$__assign.apply(this, arguments);
};

;

function $4d80ac9757769a55b72ee4f0926c5df8$export$__await(v) {
  return this instanceof $4d80ac9757769a55b72ee4f0926c5df8$export$__await ? (this.v = v, this) : new $4d80ac9757769a55b72ee4f0926c5df8$export$__await(v);
}

;

function $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

// ASSET: node_modules/@yarnpkg/core/lib/execUtils.js
var $a1aaa55bbb549bd0e69fc516a4c245d6$export$EndStrategy,
    $a1aaa55bbb549bd0e69fc516a4c245d6$exports = {};
// ASSET: node_modules/process/browser.js
var $4951c6716fb2ba4f543f4ae0509a18ac$exports,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$process,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedSetTimeout,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedClearTimeout,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$queue,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$draining,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue,
    $4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex,
    $4951c6716fb2ba4f543f4ae0509a18ac$executed = false;

function $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

function $4951c6716fb2ba4f543f4ae0509a18ac$var$cleanUpNextTick() {
  if (!$4951c6716fb2ba4f543f4ae0509a18ac$var$draining || !$4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue) {
    return;
  }

  $4951c6716fb2ba4f543f4ae0509a18ac$var$draining = false;

  if ($4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue.length) {
    $4951c6716fb2ba4f543f4ae0509a18ac$var$queue = $4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue.concat($4951c6716fb2ba4f543f4ae0509a18ac$var$queue);
  } else {
    $4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex = -1;
  }

  if ($4951c6716fb2ba4f543f4ae0509a18ac$var$queue.length) {
    $4951c6716fb2ba4f543f4ae0509a18ac$var$drainQueue();
  }
}

function $4951c6716fb2ba4f543f4ae0509a18ac$var$drainQueue() {
  if ($4951c6716fb2ba4f543f4ae0509a18ac$var$draining) {
    return;
  }

  queueMicrotask($4951c6716fb2ba4f543f4ae0509a18ac$var$cleanUpNextTick);
  $4951c6716fb2ba4f543f4ae0509a18ac$var$draining = true;
  var len = $4951c6716fb2ba4f543f4ae0509a18ac$var$queue.length;

  while (len) {
    $4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue = $4951c6716fb2ba4f543f4ae0509a18ac$var$queue;
    $4951c6716fb2ba4f543f4ae0509a18ac$var$queue = [];

    while (++$4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex < len) {
      if ($4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue) {
        $4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue[$4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex].run();
      }
    }

    $4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex = -1;
    len = $4951c6716fb2ba4f543f4ae0509a18ac$var$queue.length;
  }

  $4951c6716fb2ba4f543f4ae0509a18ac$var$currentQueue = null;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$draining = false;
}

// v8 likes predictible objects
function $4951c6716fb2ba4f543f4ae0509a18ac$var$Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

function $4951c6716fb2ba4f543f4ae0509a18ac$var$noop() {}

function $4951c6716fb2ba4f543f4ae0509a18ac$exec() {
  $4951c6716fb2ba4f543f4ae0509a18ac$exports = {};
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$exports = {};

  (function () {
    try {
      if (typeof setTimeout === 'function') {
        $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedSetTimeout = setTimeout;
      } else {
        $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedSetTimeout = $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultSetTimout;
      }
    } catch (e) {
      $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedSetTimeout = $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultSetTimout;
    }

    try {
      if (typeof clearTimeout === 'function') {
        $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedClearTimeout = clearTimeout;
      } else {
        $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedClearTimeout = $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultClearTimeout;
      }
    } catch (e) {
      $4951c6716fb2ba4f543f4ae0509a18ac$var$cachedClearTimeout = $4951c6716fb2ba4f543f4ae0509a18ac$var$defaultClearTimeout;
    }
  })();

  $4951c6716fb2ba4f543f4ae0509a18ac$var$queue = [];
  $4951c6716fb2ba4f543f4ae0509a18ac$var$draining = false;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$queueIndex = -1;

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    $4951c6716fb2ba4f543f4ae0509a18ac$var$queue.push(new $4951c6716fb2ba4f543f4ae0509a18ac$var$Item(fun, args));

    if ($4951c6716fb2ba4f543f4ae0509a18ac$var$queue.length === 1 && !$4951c6716fb2ba4f543f4ae0509a18ac$var$draining) {
      queueMicrotask($4951c6716fb2ba4f543f4ae0509a18ac$var$drainQueue);
    }
  }; // v8 likes predictible objects


  $4951c6716fb2ba4f543f4ae0509a18ac$var$Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.title = 'browser';
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.browser = true;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.env = {};
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.argv = [];
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.version = ''; // empty string to avoid regexp issues

  // empty string to avoid regexp issues
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.versions = {};
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.on = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.addListener = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.once = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.off = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.removeListener = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.removeAllListeners = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.emit = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.prependListener = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;
  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.prependOnceListener = $4951c6716fb2ba4f543f4ae0509a18ac$var$noop;

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.listeners = function (name) {
    return [];
  };

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.binding = function (name) {
    throw new Error('process.binding is not supported');
  };

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.cwd = function () {
    return '/';
  };

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
  };

  $4951c6716fb2ba4f543f4ae0509a18ac$var$process.umask = function () {
    return 0;
  };
}

function $4951c6716fb2ba4f543f4ae0509a18ac$init() {
  if (!$4951c6716fb2ba4f543f4ae0509a18ac$executed) {
    $4951c6716fb2ba4f543f4ae0509a18ac$executed = true;
    $4951c6716fb2ba4f543f4ae0509a18ac$exec();
  }

  return $4951c6716fb2ba4f543f4ae0509a18ac$exports;
}

var $a1aaa55bbb549bd0e69fc516a4c245d6$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// ASSET: node_modules/base64-js/index.js
var $94e44f5a78f3357c217c3713332733f6$exports = {};
var $94e44f5a78f3357c217c3713332733f6$export$byteLength = $94e44f5a78f3357c217c3713332733f6$var$byteLength;
$94e44f5a78f3357c217c3713332733f6$exports.byteLength = $94e44f5a78f3357c217c3713332733f6$export$byteLength;
var $94e44f5a78f3357c217c3713332733f6$export$toByteArray = $94e44f5a78f3357c217c3713332733f6$var$toByteArray;
$94e44f5a78f3357c217c3713332733f6$exports.toByteArray = $94e44f5a78f3357c217c3713332733f6$export$toByteArray;
var $94e44f5a78f3357c217c3713332733f6$export$fromByteArray = $94e44f5a78f3357c217c3713332733f6$var$fromByteArray;
$94e44f5a78f3357c217c3713332733f6$exports.fromByteArray = $94e44f5a78f3357c217c3713332733f6$export$fromByteArray;
var $94e44f5a78f3357c217c3713332733f6$var$lookup = [];
var $94e44f5a78f3357c217c3713332733f6$var$revLookup = [];
var $94e44f5a78f3357c217c3713332733f6$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var $94e44f5a78f3357c217c3713332733f6$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var $94e44f5a78f3357c217c3713332733f6$var$i = 0, $94e44f5a78f3357c217c3713332733f6$var$len = $94e44f5a78f3357c217c3713332733f6$var$code.length; $94e44f5a78f3357c217c3713332733f6$var$i < $94e44f5a78f3357c217c3713332733f6$var$len; ++$94e44f5a78f3357c217c3713332733f6$var$i) {
  $94e44f5a78f3357c217c3713332733f6$var$lookup[$94e44f5a78f3357c217c3713332733f6$var$i] = $94e44f5a78f3357c217c3713332733f6$var$code[$94e44f5a78f3357c217c3713332733f6$var$i];
  $94e44f5a78f3357c217c3713332733f6$var$revLookup[$94e44f5a78f3357c217c3713332733f6$var$code.charCodeAt($94e44f5a78f3357c217c3713332733f6$var$i)] = $94e44f5a78f3357c217c3713332733f6$var$i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$94e44f5a78f3357c217c3713332733f6$var$revLookup['-'.charCodeAt(0)] = 62;
$94e44f5a78f3357c217c3713332733f6$var$revLookup['_'.charCodeAt(0)] = 63;

function $94e44f5a78f3357c217c3713332733f6$var$getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


// base64 is 4/3 + up to two characters of the original data
function $94e44f5a78f3357c217c3713332733f6$var$byteLength(b64) {
  var lens = $94e44f5a78f3357c217c3713332733f6$var$getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function $94e44f5a78f3357c217c3713332733f6$var$_byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function $94e44f5a78f3357c217c3713332733f6$var$toByteArray(b64) {
  var tmp;
  var lens = $94e44f5a78f3357c217c3713332733f6$var$getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new $94e44f5a78f3357c217c3713332733f6$var$Arr($94e44f5a78f3357c217c3713332733f6$var$_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i)] << 18 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i)] << 2 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i)] << 10 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $94e44f5a78f3357c217c3713332733f6$var$revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function $94e44f5a78f3357c217c3713332733f6$var$tripletToBase64(num) {
  return $94e44f5a78f3357c217c3713332733f6$var$lookup[num >> 18 & 0x3F] + $94e44f5a78f3357c217c3713332733f6$var$lookup[num >> 12 & 0x3F] + $94e44f5a78f3357c217c3713332733f6$var$lookup[num >> 6 & 0x3F] + $94e44f5a78f3357c217c3713332733f6$var$lookup[num & 0x3F];
}

function $94e44f5a78f3357c217c3713332733f6$var$encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push($94e44f5a78f3357c217c3713332733f6$var$tripletToBase64(tmp));
  }

  return output.join('');
}

function $94e44f5a78f3357c217c3713332733f6$var$fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push($94e44f5a78f3357c217c3713332733f6$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push($94e44f5a78f3357c217c3713332733f6$var$lookup[tmp >> 2] + $94e44f5a78f3357c217c3713332733f6$var$lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push($94e44f5a78f3357c217c3713332733f6$var$lookup[tmp >> 10] + $94e44f5a78f3357c217c3713332733f6$var$lookup[tmp >> 4 & 0x3F] + $94e44f5a78f3357c217c3713332733f6$var$lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

// ASSET: node_modules/ieee754/index.js
var $22477c9f7d9e0541aa8f587d9bc00b6e$exports = {};

var $22477c9f7d9e0541aa8f587d9bc00b6e$export$read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
$22477c9f7d9e0541aa8f587d9bc00b6e$exports.read = $22477c9f7d9e0541aa8f587d9bc00b6e$export$read;

var $22477c9f7d9e0541aa8f587d9bc00b6e$export$write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

$22477c9f7d9e0541aa8f587d9bc00b6e$exports.write = $22477c9f7d9e0541aa8f587d9bc00b6e$export$write;
// ASSET: node_modules/buffer/index.js
var $4bb8553ea3f2a3c18bc67044f716b1cc$exports,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$customInspectSymbol,
    $4bb8553ea3f2a3c18bc67044f716b1cc$export$Buffer,
    $4bb8553ea3f2a3c18bc67044f716b1cc$export$SlowBuffer,
    $4bb8553ea3f2a3c18bc67044f716b1cc$export$INSPECT_MAX_BYTES,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH,
    $4bb8553ea3f2a3c18bc67044f716b1cc$export$kMaxLength,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$MAX_ARGUMENTS_LENGTH,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$INVALID_BASE64_RE,
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexSliceLookupTable,
    $4bb8553ea3f2a3c18bc67044f716b1cc$executed = false;

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function () {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(length) {
  if (length > $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype);
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */
function $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$allocUnsafe(arg);
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$from(arg, encodingOrOffset, length);
}

// not used by this implementation
function $4bb8553ea3f2a3c18bc67044f716b1cc$var$from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayView(value);
  }

  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }

  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(value, ArrayBuffer) || value && $4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(value.buffer, ArrayBuffer)) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof SharedArrayBuffer !== 'undefined' && ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(value, SharedArrayBuffer) || value && $4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(value.buffer, SharedArrayBuffer))) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


function $4bb8553ea3f2a3c18bc67044f716b1cc$var$assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$alloc(size, fill, encoding) {
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$assertSize(size);

  if (size <= 0) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(size).fill(fill, encoding) : $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(size).fill(fill);
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


function $4bb8553ea3f2a3c18bc67044f716b1cc$var$allocUnsafe(size) {
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$assertSize(size);
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(size < 0 ? 0 : $4bb8553ea3f2a3c18bc67044f716b1cc$var$checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


function $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = $4bb8553ea3f2a3c18bc67044f716b1cc$var$byteLength(string, encoding) | 0;
  var buf = $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayLike(array) {
  var length = array.length < 0 ? 0 : $4bb8553ea3f2a3c18bc67044f716b1cc$var$checked(array.length) | 0;
  var buf = $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayView(arrayView) {
  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayLike(arrayView);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype);
  return buf;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromObject(obj) {
  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(obj)) {
    var len = $4bb8553ea3f2a3c18bc67044f716b1cc$var$checked(obj.length) | 0;
    var buf = $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || $4bb8553ea3f2a3c18bc67044f716b1cc$var$numberIsNaN(obj.length)) {
      return $4bb8553ea3f2a3c18bc67044f716b1cc$var$createBuffer(0);
    }

    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$fromArrayLike(obj.data);
  }
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.alloc(+length);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$byteLength(string, encoding) {
  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || $4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  // Use a for loop to avoid recursion
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8Slice(this, start, end);

      case 'ascii':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$latin1Slice(this, start, end);

      case 'base64':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


function $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $4bb8553ea3f2a3c18bc67044f716b1cc$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  // Coerce to Number.
  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  // Normalize val
  if (typeof val === 'string') {
    val = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8Write(buf, string, offset, length) {
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$blitBuffer($4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiWrite(buf, string, offset, length) {
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$blitBuffer($4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiToBytes(string), buf, offset, length);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64Write(buf, string, offset, length) {
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$blitBuffer($4bb8553ea3f2a3c18bc67044f716b1cc$var$base64ToBytes(string), buf, offset, length);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$ucs2Write(buf, string, offset, length) {
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$blitBuffer($4bb8553ea3f2a3c18bc67044f716b1cc$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64.fromByteArray(buf);
  } else {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64.fromByteArray(buf.slice(start, end));
  }
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


function $4bb8553ea3f2a3c18bc67044f716b1cc$var$decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= $4bb8553ea3f2a3c18bc67044f716b1cc$var$MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += $4bb8553ea3f2a3c18bc67044f716b1cc$var$MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexSliceLookupTable[buf[i]];
  }

  return out;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(buf, value, offset, ext, max, min) {
  if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace($4bb8553ea3f2a3c18bc67044f716b1cc$var$INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        // valid lead
        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64ToBytes(str) {
  return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64.toByteArray($4bb8553ea3f2a3c18bc67044f716b1cc$var$base64clean(str));
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$var$numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
} // Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219


function $4bb8553ea3f2a3c18bc67044f716b1cc$exec() {
  $4bb8553ea3f2a3c18bc67044f716b1cc$exports = {};
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64 = $94e44f5a78f3357c217c3713332733f6$exports;
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754 = $22477c9f7d9e0541aa8f587d9bc00b6e$exports;
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? // eslint-disable-line dot-notation
  Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  : // eslint-disable-line dot-notation
  null;
  $4bb8553ea3f2a3c18bc67044f716b1cc$export$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer;
  $4bb8553ea3f2a3c18bc67044f716b1cc$exports.Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$export$Buffer;
  $4bb8553ea3f2a3c18bc67044f716b1cc$export$SlowBuffer = $4bb8553ea3f2a3c18bc67044f716b1cc$var$SlowBuffer;
  $4bb8553ea3f2a3c18bc67044f716b1cc$exports.SlowBuffer = $4bb8553ea3f2a3c18bc67044f716b1cc$export$SlowBuffer;
  $4bb8553ea3f2a3c18bc67044f716b1cc$export$INSPECT_MAX_BYTES = 50;
  $4bb8553ea3f2a3c18bc67044f716b1cc$exports.INSPECT_MAX_BYTES = $4bb8553ea3f2a3c18bc67044f716b1cc$export$INSPECT_MAX_BYTES;
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH = 0x7fffffff;
  $4bb8553ea3f2a3c18bc67044f716b1cc$export$kMaxLength = $4bb8553ea3f2a3c18bc67044f716b1cc$var$K_MAX_LENGTH;
  $4bb8553ea3f2a3c18bc67044f716b1cc$exports.kMaxLength = $4bb8553ea3f2a3c18bc67044f716b1cc$export$kMaxLength;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.TYPED_ARRAY_SUPPORT = $4bb8553ea3f2a3c18bc67044f716b1cc$var$typedArraySupport();

  if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
  }

  Object.defineProperty($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.poolSize = 8192; // not used by this implementation

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from = function (value, encodingOrOffset, length) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$from(value, encodingOrOffset, length);
  }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148


  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf($4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer, Uint8Array);

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.alloc = function (size, fill, encoding) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$alloc(size, fill, encoding);
  };

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.allocUnsafe = function (size) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$allocUnsafe(size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.allocUnsafeSlow = function (size) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$allocUnsafe(size);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.compare = function compare(a, b) {
    if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(a, Uint8Array)) a = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(a, a.offset, a.byteLength);
    if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(b, Uint8Array)) b = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(b, b.offset, b.byteLength);

    if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(a) || !$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(buf).copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }

      pos += buf.length;
    }

    return buffer;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.byteLength = $4bb8553ea3f2a3c18bc67044f716b1cc$var$byteLength;
  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype._isBuffer = true;

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i, i + 1);
    }

    return this;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i, i + 3);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i + 1, i + 2);
    }

    return this;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i, i + 7);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i + 1, i + 6);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i + 2, i + 5);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$swap(this, i + 3, i + 4);
    }

    return this;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8Slice(this, 0, length);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$slowToString.apply(this, arguments);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.toLocaleString = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.toString;

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.equals = function equals(b) {
    if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.compare(this, b) === 0;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = $4bb8553ea3f2a3c18bc67044f716b1cc$export$INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };

  if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$customInspectSymbol) {
    $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype[$4bb8553ea3f2a3c18bc67044f716b1cc$var$customInspectSymbol] = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.inspect;
  }

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if ($4bb8553ea3f2a3c18bc67044f716b1cc$var$isInstance(target, Uint8Array)) {
      target = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(target, target.offset, target.byteLength);
    }

    if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;

      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return $4bb8553ea3f2a3c18bc67044f716b1cc$var$utf8Write(this, string, offset, length);

        case 'ascii':
        case 'latin1':
        case 'binary':
          return $4bb8553ea3f2a3c18bc67044f716b1cc$var$asciiWrite(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return $4bb8553ea3f2a3c18bc67044f716b1cc$var$base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return $4bb8553ea3f2a3c18bc67044f716b1cc$var$ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$MAX_ARGUMENTS_LENGTH = 0x1000;

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype);
    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUintLE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUintBE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUint8 = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 1, this.length);
    return this[offset];
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUint16LE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUint16BE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUint32LE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUint32BE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.read(this, offset, true, 23, 4);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 4, this.length);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.read(this, offset, false, 23, 4);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 8, this.length);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.read(this, offset, true, 52, 8);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkOffset(offset, 8, this.length);
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$ieee754.read(this, offset, false, 52, 8);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUintLE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUintBE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUint8 = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUint16LE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUint16BE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUint32LE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUint32BE = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4bb8553ea3f2a3c18bc67044f716b1cc$var$checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeFloat(this, value, offset, true, noAssert);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeFloat(this, value, offset, false, noAssert);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeDouble(this, value, offset, true, noAssert);
  };

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return $4bb8553ea3f2a3c18bc67044f716b1cc$var$writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    // Are we oob?
    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !$4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    } // Invalid ranges are not set to a default, so can range check early.


    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.isBuffer(val) ? val : $4bb8553ea3f2a3c18bc67044f716b1cc$var$Buffer.from(val, encoding);
      var len = bytes.length;

      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  $4bb8553ea3f2a3c18bc67044f716b1cc$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  $4bb8553ea3f2a3c18bc67044f716b1cc$var$hexSliceLookupTable = function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);

    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;

      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }

    return table;
  }();
}

function $4bb8553ea3f2a3c18bc67044f716b1cc$init() {
  if (!$4bb8553ea3f2a3c18bc67044f716b1cc$executed) {
    $4bb8553ea3f2a3c18bc67044f716b1cc$executed = true;
    $4bb8553ea3f2a3c18bc67044f716b1cc$exec();
  }

  return $4bb8553ea3f2a3c18bc67044f716b1cc$exports;
}

var $a1aaa55bbb549bd0e69fc516a4c245d6$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($a1aaa55bbb549bd0e69fc516a4c245d6$exports, "__esModule", {
  value: true
});
var $a1aaa55bbb549bd0e69fc516a4c245d6$export$execvp = ($a1aaa55bbb549bd0e69fc516a4c245d6$export$pipevp = ($a1aaa55bbb549bd0e69fc516a4c245d6$export$EndStrategy = void 0, $a1aaa55bbb549bd0e69fc516a4c245d6$exports.EndStrategy = $a1aaa55bbb549bd0e69fc516a4c245d6$export$EndStrategy), $a1aaa55bbb549bd0e69fc516a4c245d6$exports.pipevp = $a1aaa55bbb549bd0e69fc516a4c245d6$export$pipevp);
$a1aaa55bbb549bd0e69fc516a4c245d6$exports.execvp = $a1aaa55bbb549bd0e69fc516a4c245d6$export$execvp;
// ASSET: node_modules/@yarnpkg/fslib/lib/index.js
var $ea9c1e38c3e8cca334929a597a084311$export$ZipOpenFS,
    $ea9c1e38c3e8cca334929a597a084311$export$ZipFS,
    $ea9c1e38c3e8cca334929a597a084311$export$VirtualFS,
    $ea9c1e38c3e8cca334929a597a084311$export$ProxiedFS,
    $ea9c1e38c3e8cca334929a597a084311$export$PosixFS,
    $ea9c1e38c3e8cca334929a597a084311$export$NodeFS,
    $ea9c1e38c3e8cca334929a597a084311$export$NoFS,
    $ea9c1e38c3e8cca334929a597a084311$export$LazyFS,
    $ea9c1e38c3e8cca334929a597a084311$export$JailFS,
    $ea9c1e38c3e8cca334929a597a084311$export$CwdFS,
    $ea9c1e38c3e8cca334929a597a084311$export$FakeFS,
    $ea9c1e38c3e8cca334929a597a084311$export$AliasFS,
    $ea9c1e38c3e8cca334929a597a084311$export$toFilename,
    $ea9c1e38c3e8cca334929a597a084311$export$ppath,
    $ea9c1e38c3e8cca334929a597a084311$export$npath,
    $ea9c1e38c3e8cca334929a597a084311$export$Filename,
    $ea9c1e38c3e8cca334929a597a084311$export$PortablePath,
    $ea9c1e38c3e8cca334929a597a084311$export$DEFAULT_COMPRESSION_LEVEL,
    $ea9c1e38c3e8cca334929a597a084311$export$normalizeLineEndings,
    $ea9c1e38c3e8cca334929a597a084311$export$opendir,
    $ea9c1e38c3e8cca334929a597a084311$exports = {};
var $ea9c1e38c3e8cca334929a597a084311$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "__esModule", {
  value: true
});
var $ea9c1e38c3e8cca334929a597a084311$export$xfs = ($ea9c1e38c3e8cca334929a597a084311$export$extendFs = ($ea9c1e38c3e8cca334929a597a084311$export$patchFs = ($ea9c1e38c3e8cca334929a597a084311$export$ZipOpenFS = ($ea9c1e38c3e8cca334929a597a084311$export$ZipFS = ($ea9c1e38c3e8cca334929a597a084311$export$VirtualFS = ($ea9c1e38c3e8cca334929a597a084311$export$ProxiedFS = ($ea9c1e38c3e8cca334929a597a084311$export$PosixFS = ($ea9c1e38c3e8cca334929a597a084311$export$NodeFS = ($ea9c1e38c3e8cca334929a597a084311$export$NoFS = ($ea9c1e38c3e8cca334929a597a084311$export$LazyFS = ($ea9c1e38c3e8cca334929a597a084311$export$JailFS = ($ea9c1e38c3e8cca334929a597a084311$export$CwdFS = ($ea9c1e38c3e8cca334929a597a084311$export$FakeFS = ($ea9c1e38c3e8cca334929a597a084311$export$AliasFS = ($ea9c1e38c3e8cca334929a597a084311$export$toFilename = ($ea9c1e38c3e8cca334929a597a084311$export$ppath = ($ea9c1e38c3e8cca334929a597a084311$export$npath = ($ea9c1e38c3e8cca334929a597a084311$export$Filename = ($ea9c1e38c3e8cca334929a597a084311$export$PortablePath = ($ea9c1e38c3e8cca334929a597a084311$export$DEFAULT_COMPRESSION_LEVEL = ($ea9c1e38c3e8cca334929a597a084311$export$normalizeLineEndings = ($ea9c1e38c3e8cca334929a597a084311$export$statUtils = ($ea9c1e38c3e8cca334929a597a084311$export$opendir = void 0, $ea9c1e38c3e8cca334929a597a084311$exports.opendir = $ea9c1e38c3e8cca334929a597a084311$export$opendir), $ea9c1e38c3e8cca334929a597a084311$exports.statUtils = $ea9c1e38c3e8cca334929a597a084311$export$statUtils), $ea9c1e38c3e8cca334929a597a084311$exports.normalizeLineEndings = $ea9c1e38c3e8cca334929a597a084311$export$normalizeLineEndings), $ea9c1e38c3e8cca334929a597a084311$exports.DEFAULT_COMPRESSION_LEVEL = $ea9c1e38c3e8cca334929a597a084311$export$DEFAULT_COMPRESSION_LEVEL), $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath = $ea9c1e38c3e8cca334929a597a084311$export$PortablePath), $ea9c1e38c3e8cca334929a597a084311$exports.Filename = $ea9c1e38c3e8cca334929a597a084311$export$Filename), $ea9c1e38c3e8cca334929a597a084311$exports.npath = $ea9c1e38c3e8cca334929a597a084311$export$npath), $ea9c1e38c3e8cca334929a597a084311$exports.ppath = $ea9c1e38c3e8cca334929a597a084311$export$ppath), $ea9c1e38c3e8cca334929a597a084311$exports.toFilename = $ea9c1e38c3e8cca334929a597a084311$export$toFilename), $ea9c1e38c3e8cca334929a597a084311$exports.AliasFS = $ea9c1e38c3e8cca334929a597a084311$export$AliasFS), $ea9c1e38c3e8cca334929a597a084311$exports.FakeFS = $ea9c1e38c3e8cca334929a597a084311$export$FakeFS), $ea9c1e38c3e8cca334929a597a084311$exports.CwdFS = $ea9c1e38c3e8cca334929a597a084311$export$CwdFS), $ea9c1e38c3e8cca334929a597a084311$exports.JailFS = $ea9c1e38c3e8cca334929a597a084311$export$JailFS), $ea9c1e38c3e8cca334929a597a084311$exports.LazyFS = $ea9c1e38c3e8cca334929a597a084311$export$LazyFS), $ea9c1e38c3e8cca334929a597a084311$exports.NoFS = $ea9c1e38c3e8cca334929a597a084311$export$NoFS), $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS = $ea9c1e38c3e8cca334929a597a084311$export$NodeFS), $ea9c1e38c3e8cca334929a597a084311$exports.PosixFS = $ea9c1e38c3e8cca334929a597a084311$export$PosixFS), $ea9c1e38c3e8cca334929a597a084311$exports.ProxiedFS = $ea9c1e38c3e8cca334929a597a084311$export$ProxiedFS), $ea9c1e38c3e8cca334929a597a084311$exports.VirtualFS = $ea9c1e38c3e8cca334929a597a084311$export$VirtualFS), $ea9c1e38c3e8cca334929a597a084311$exports.ZipFS = $ea9c1e38c3e8cca334929a597a084311$export$ZipFS), $ea9c1e38c3e8cca334929a597a084311$exports.ZipOpenFS = $ea9c1e38c3e8cca334929a597a084311$export$ZipOpenFS), $ea9c1e38c3e8cca334929a597a084311$exports.patchFs = $ea9c1e38c3e8cca334929a597a084311$export$patchFs), $ea9c1e38c3e8cca334929a597a084311$exports.extendFs = $ea9c1e38c3e8cca334929a597a084311$export$extendFs);
$ea9c1e38c3e8cca334929a597a084311$exports.xfs = $ea9c1e38c3e8cca334929a597a084311$export$xfs;
// ASSET: node_modules/os-browserify/browser.js
var $0bbf89852e2ec8b574a90d9f54bf96d7$export$getNetworkInterfaces,
    $0bbf89852e2ec8b574a90d9f54bf96d7$export$tmpDir,
    $0bbf89852e2ec8b574a90d9f54bf96d7$exports = {};

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$endianness = function () {
  return 'LE';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.endianness = $0bbf89852e2ec8b574a90d9f54bf96d7$export$endianness;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$hostname = function () {
  if (typeof location !== 'undefined') {
    return location.hostname;
  } else return '';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.hostname = $0bbf89852e2ec8b574a90d9f54bf96d7$export$hostname;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$loadavg = function () {
  return [];
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.loadavg = $0bbf89852e2ec8b574a90d9f54bf96d7$export$loadavg;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$uptime = function () {
  return 0;
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.uptime = $0bbf89852e2ec8b574a90d9f54bf96d7$export$uptime;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$freemem = function () {
  return Number.MAX_VALUE;
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.freemem = $0bbf89852e2ec8b574a90d9f54bf96d7$export$freemem;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$totalmem = function () {
  return Number.MAX_VALUE;
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.totalmem = $0bbf89852e2ec8b574a90d9f54bf96d7$export$totalmem;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$cpus = function () {
  return [];
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.cpus = $0bbf89852e2ec8b574a90d9f54bf96d7$export$cpus;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$type = function () {
  return 'Browser';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.type = $0bbf89852e2ec8b574a90d9f54bf96d7$export$type;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$release = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.appVersion;
  }

  return '';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.release = $0bbf89852e2ec8b574a90d9f54bf96d7$export$release;
var $0bbf89852e2ec8b574a90d9f54bf96d7$export$networkInterfaces = ($0bbf89852e2ec8b574a90d9f54bf96d7$export$getNetworkInterfaces = function () {
  return {};
}, $0bbf89852e2ec8b574a90d9f54bf96d7$exports.getNetworkInterfaces = $0bbf89852e2ec8b574a90d9f54bf96d7$export$getNetworkInterfaces);
$0bbf89852e2ec8b574a90d9f54bf96d7$exports.networkInterfaces = $0bbf89852e2ec8b574a90d9f54bf96d7$export$networkInterfaces;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$arch = function () {
  return 'javascript';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.arch = $0bbf89852e2ec8b574a90d9f54bf96d7$export$arch;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$platform = function () {
  return 'browser';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.platform = $0bbf89852e2ec8b574a90d9f54bf96d7$export$platform;
var $0bbf89852e2ec8b574a90d9f54bf96d7$export$tmpdir = ($0bbf89852e2ec8b574a90d9f54bf96d7$export$tmpDir = function () {
  return '/tmp';
}, $0bbf89852e2ec8b574a90d9f54bf96d7$exports.tmpDir = $0bbf89852e2ec8b574a90d9f54bf96d7$export$tmpDir);
$0bbf89852e2ec8b574a90d9f54bf96d7$exports.tmpdir = $0bbf89852e2ec8b574a90d9f54bf96d7$export$tmpdir;
var $0bbf89852e2ec8b574a90d9f54bf96d7$export$EOL = '\n';
$0bbf89852e2ec8b574a90d9f54bf96d7$exports.EOL = $0bbf89852e2ec8b574a90d9f54bf96d7$export$EOL;

var $0bbf89852e2ec8b574a90d9f54bf96d7$export$homedir = function () {
  return '/';
};

$0bbf89852e2ec8b574a90d9f54bf96d7$exports.homedir = $0bbf89852e2ec8b574a90d9f54bf96d7$export$homedir;
const $ea9c1e38c3e8cca334929a597a084311$var$os_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($0bbf89852e2ec8b574a90d9f54bf96d7$exports);
// ASSET: node_modules/util/support/types.js
var $ddaee7ce122ed4de10c25c941bef48c3$exports = {};
// ASSET: node_modules/is-arguments/index.js
var $98de8a60a52d4e568c654f5ce60d386f$exports = {};
var $98de8a60a52d4e568c654f5ce60d386f$var$hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
// ASSET: node_modules/call-bind/callBound.js
var $c73f916f7f0e89963ff025666f564c38$exports = {};
// ASSET: node_modules/get-intrinsic/index.js
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$exports = {};

/* globals
	AggregateError,
	Atomics,
	FinalizationRegistry,
	SharedArrayBuffer,
	WeakRef,
*/
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$SyntaxError = SyntaxError;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$Function = Function;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError = TypeError; // eslint-disable-next-line consistent-return

// eslint-disable-next-line consistent-return
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getEvalledConstructor = function (expressionSyntax) {
  try {
    // eslint-disable-next-line no-new-func
    return Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD = Object.getOwnPropertyDescriptor;

if ($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD) {
  try {
    $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD({}, '');
  } catch (e) {
    $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$throwTypeError = function () {
  throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError();
};

var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$ThrowTypeError = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    // IE 8 does not throw here
    return $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$throwTypeError;
    }
  }
}() : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$throwTypeError;
// ASSET: node_modules/has-symbols/index.js
var $d041d8a0f381cf8c41a7dcbe9a6f4f30$exports = {};
var $d041d8a0f381cf8c41a7dcbe9a6f4f30$var$origSymbol = $parcel$global.Symbol;
// ASSET: node_modules/has-symbols/shams.js
var $a3a67073e3bd4bed172a330fe03814da$exports = {};

/* eslint complexity: [2, 18], max-statements: [2, 33] */
$a3a67073e3bd4bed172a330fe03814da$exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax


  // eslint-disable-line no-restricted-syntax
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

$d041d8a0f381cf8c41a7dcbe9a6f4f30$exports = function hasNativeSymbols() {
  if (typeof $d041d8a0f381cf8c41a7dcbe9a6f4f30$var$origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (typeof $d041d8a0f381cf8c41a7dcbe9a6f4f30$var$origSymbol('foo') !== 'symbol') {
    return false;
  }

  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }

  return $a3a67073e3bd4bed172a330fe03814da$exports();
};

var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols = $d041d8a0f381cf8c41a7dcbe9a6f4f30$exports();

var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


// eslint-disable-line no-proto
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunction = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getEvalledConstructor('async function* () {}');
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunctionPrototype = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunction ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunction.prototype : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenPrototype = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunctionPrototype ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunctionPrototype.prototype : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$TypedArray = typeof Uint8Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto(Uint8Array);
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto([][Symbol.iterator]()) : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%AsyncFromSyncIteratorPrototype%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%AsyncFunction%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getEvalledConstructor('async function () {}'),
  '%AsyncGenerator%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunctionPrototype,
  '%AsyncGeneratorFunction%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenFunction,
  '%AsyncIteratorPrototype%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenPrototype ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$asyncGenPrototype) : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%Atomics%': typeof Atomics === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : FinalizationRegistry,
  '%Function%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$Function,
  '%GeneratorFunction%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getEvalledConstructor('function* () {}'),
  '%Int8Array%': typeof Int8Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto([][Symbol.iterator]())) : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%Map%': typeof Map === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !$9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !$9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getProto(''[Symbol.iterator]()) : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%Symbol%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$hasSymbols ? Symbol : $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined,
  '%SyntaxError%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$SyntaxError,
  '%ThrowTypeError%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$ThrowTypeError,
  '%TypedArray%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$TypedArray,
  '%TypeError%': $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$undefined : WeakSet
};
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
// ASSET: node_modules/function-bind/index.js
var $6c5413db60467e6e27dae1ea7e336bfe$exports = {};
// ASSET: node_modules/function-bind/implementation.js
var $c2463378fbc6dd339fb80996c271c6b6$exports = {};

/* eslint no-invalid-this: 1 */
var $c2463378fbc6dd339fb80996c271c6b6$var$ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var $c2463378fbc6dd339fb80996c271c6b6$var$slice = Array.prototype.slice;
var $c2463378fbc6dd339fb80996c271c6b6$var$toStr = Object.prototype.toString;
var $c2463378fbc6dd339fb80996c271c6b6$var$funcType = '[object Function]';

$c2463378fbc6dd339fb80996c271c6b6$exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || $c2463378fbc6dd339fb80996c271c6b6$var$toStr.call(target) !== $c2463378fbc6dd339fb80996c271c6b6$var$funcType) {
    throw new TypeError($c2463378fbc6dd339fb80996c271c6b6$var$ERROR_MESSAGE + target);
  }

  var args = $c2463378fbc6dd339fb80996c271c6b6$var$slice.call(arguments, 1);
  var bound;

  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat($c2463378fbc6dd339fb80996c271c6b6$var$slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat($c2463378fbc6dd339fb80996c271c6b6$var$slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

$6c5413db60467e6e27dae1ea7e336bfe$exports = Function.prototype.bind || $c2463378fbc6dd339fb80996c271c6b6$exports;
// ASSET: node_modules/has/src/index.js
var $c51f73f3caa65e15cb23766babe247d9$exports = {};
$c51f73f3caa65e15cb23766babe247d9$exports = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.call, Object.prototype.hasOwnProperty);
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$concat = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.call, Array.prototype.concat);
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$spliceApply = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.apply, Array.prototype.splice);
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$replace = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.call, String.prototype.replace);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

/** Used to match backslashes in property paths. */
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$stringToPath = function stringToPath(string) {
  var result = [];
  $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$replace(string, $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$replace(subString, $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


/* end adaptation */
var $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if ($c51f73f3caa65e15cb23766babe247d9$exports($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$LEGACY_ALIASES, intrinsicName)) {
    alias = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if ($c51f73f3caa65e15cb23766babe247d9$exports($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS, intrinsicName)) {
    var value = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS[intrinsicName];

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$SyntaxError('intrinsic ' + name + ' does not exist!');
};

$9c1e241b5e5ef4f09d7ca6c171ee8e43$exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$spliceApply(parts, $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if ($c51f73f3caa65e15cb23766babe247d9$exports($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS, intrinsicRealName)) {
      value = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if ($9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD && i + 1 >= parts.length) {
        var desc = $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$gOPD(value, part);
        isOwn = !!desc;

        if (!allowMissing && !(part in value)) {
          throw new $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$$TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        } // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.


        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = $c51f73f3caa65e15cb23766babe247d9$exports(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        $9c1e241b5e5ef4f09d7ca6c171ee8e43$var$INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

// ASSET: node_modules/call-bind/index.js
var $b2fe57bdbeef015e6d17ecffaa00c5a0$exports,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$export$apply,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$bind,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$apply,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$call,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$reflectApply,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$applyBind,
    $b2fe57bdbeef015e6d17ecffaa00c5a0$executed = false;

function $b2fe57bdbeef015e6d17ecffaa00c5a0$exec() {
  $b2fe57bdbeef015e6d17ecffaa00c5a0$exports = {};
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$bind = $6c5413db60467e6e27dae1ea7e336bfe$exports;
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic = $9c1e241b5e5ef4f09d7ca6c171ee8e43$exports;
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$apply = $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic('%Function.prototype.apply%');
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$call = $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic('%Function.prototype.call%');
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$reflectApply = $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic('%Reflect.apply%', true) || $b2fe57bdbeef015e6d17ecffaa00c5a0$var$bind.call($b2fe57bdbeef015e6d17ecffaa00c5a0$var$$call, $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$apply);
  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty = $b2fe57bdbeef015e6d17ecffaa00c5a0$var$GetIntrinsic('%Object.defineProperty%', true);

  if ($b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty) {
    try {
      $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty({}, 'a', {
        value: 1
      });
    } catch (e) {
      // IE 8 has a broken defineProperty
      $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty = null;
    }
  }

  $b2fe57bdbeef015e6d17ecffaa00c5a0$exports = function callBind() {
    return $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$reflectApply($b2fe57bdbeef015e6d17ecffaa00c5a0$var$bind, $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$call, arguments);
  };

  $b2fe57bdbeef015e6d17ecffaa00c5a0$var$applyBind = function applyBind() {
    return $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$reflectApply($b2fe57bdbeef015e6d17ecffaa00c5a0$var$bind, $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$apply, arguments);
  };

  if ($b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty) {
    $b2fe57bdbeef015e6d17ecffaa00c5a0$var$$defineProperty($b2fe57bdbeef015e6d17ecffaa00c5a0$exports, 'apply', {
      value: $b2fe57bdbeef015e6d17ecffaa00c5a0$var$applyBind
    });
  } else {
    $b2fe57bdbeef015e6d17ecffaa00c5a0$export$apply = $b2fe57bdbeef015e6d17ecffaa00c5a0$var$applyBind;
    $b2fe57bdbeef015e6d17ecffaa00c5a0$exports.apply = $b2fe57bdbeef015e6d17ecffaa00c5a0$export$apply;
  }
}

function $b2fe57bdbeef015e6d17ecffaa00c5a0$init() {
  if (!$b2fe57bdbeef015e6d17ecffaa00c5a0$executed) {
    $b2fe57bdbeef015e6d17ecffaa00c5a0$executed = true;
    $b2fe57bdbeef015e6d17ecffaa00c5a0$exec();
  }

  return $b2fe57bdbeef015e6d17ecffaa00c5a0$exports;
}

var $c73f916f7f0e89963ff025666f564c38$var$callBind = $b2fe57bdbeef015e6d17ecffaa00c5a0$init();
var $c73f916f7f0e89963ff025666f564c38$var$$indexOf = $c73f916f7f0e89963ff025666f564c38$var$callBind($9c1e241b5e5ef4f09d7ca6c171ee8e43$exports('String.prototype.indexOf'));

$c73f916f7f0e89963ff025666f564c38$exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = $9c1e241b5e5ef4f09d7ca6c171ee8e43$exports(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $c73f916f7f0e89963ff025666f564c38$var$$indexOf(name, '.prototype.') > -1) {
    return $c73f916f7f0e89963ff025666f564c38$var$callBind(intrinsic);
  }

  return intrinsic;
};

var $98de8a60a52d4e568c654f5ce60d386f$var$$toString = $c73f916f7f0e89963ff025666f564c38$exports('Object.prototype.toString');

var $98de8a60a52d4e568c654f5ce60d386f$var$isStandardArguments = function isArguments(value) {
  if ($98de8a60a52d4e568c654f5ce60d386f$var$hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }

  return $98de8a60a52d4e568c654f5ce60d386f$var$$toString(value) === '[object Arguments]';
};

var $98de8a60a52d4e568c654f5ce60d386f$var$isLegacyArguments = function isArguments(value) {
  if ($98de8a60a52d4e568c654f5ce60d386f$var$isStandardArguments(value)) {
    return true;
  }

  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $98de8a60a52d4e568c654f5ce60d386f$var$$toString(value) !== '[object Array]' && $98de8a60a52d4e568c654f5ce60d386f$var$$toString(value.callee) === '[object Function]';
};

var $98de8a60a52d4e568c654f5ce60d386f$var$supportsStandardArguments = function () {
  return $98de8a60a52d4e568c654f5ce60d386f$var$isStandardArguments(arguments);
}();

$98de8a60a52d4e568c654f5ce60d386f$var$isStandardArguments.isLegacyArguments = $98de8a60a52d4e568c654f5ce60d386f$var$isLegacyArguments; // for tests

// for tests
$98de8a60a52d4e568c654f5ce60d386f$exports = $98de8a60a52d4e568c654f5ce60d386f$var$supportsStandardArguments ? $98de8a60a52d4e568c654f5ce60d386f$var$isStandardArguments : $98de8a60a52d4e568c654f5ce60d386f$var$isLegacyArguments;
// ASSET: node_modules/is-generator-function/index.js
var $0ea3aa360d963997274bb7c75b63d694$exports = {};
var $0ea3aa360d963997274bb7c75b63d694$var$toStr = Object.prototype.toString;
var $0ea3aa360d963997274bb7c75b63d694$var$fnToStr = Function.prototype.toString;
var $0ea3aa360d963997274bb7c75b63d694$var$isFnRegex = /^\s*(?:function)?\*/;
var $0ea3aa360d963997274bb7c75b63d694$var$hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var $0ea3aa360d963997274bb7c75b63d694$var$getProto = Object.getPrototypeOf;

var $0ea3aa360d963997274bb7c75b63d694$var$getGeneratorFunc = function () {
  // eslint-disable-line consistent-return
  if (!$0ea3aa360d963997274bb7c75b63d694$var$hasToStringTag) {
    return false;
  }

  try {
    return Function('return function*() {}')();
  } catch (e) {}
};

var $0ea3aa360d963997274bb7c75b63d694$var$generatorFunc = $0ea3aa360d963997274bb7c75b63d694$var$getGeneratorFunc();
var $0ea3aa360d963997274bb7c75b63d694$var$GeneratorFunction = $0ea3aa360d963997274bb7c75b63d694$var$getProto && $0ea3aa360d963997274bb7c75b63d694$var$generatorFunc ? $0ea3aa360d963997274bb7c75b63d694$var$getProto($0ea3aa360d963997274bb7c75b63d694$var$generatorFunc) : false;

$0ea3aa360d963997274bb7c75b63d694$exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }

  if ($0ea3aa360d963997274bb7c75b63d694$var$isFnRegex.test($0ea3aa360d963997274bb7c75b63d694$var$fnToStr.call(fn))) {
    return true;
  }

  if (!$0ea3aa360d963997274bb7c75b63d694$var$hasToStringTag) {
    var str = $0ea3aa360d963997274bb7c75b63d694$var$toStr.call(fn);
    return str === '[object GeneratorFunction]';
  }

  return $0ea3aa360d963997274bb7c75b63d694$var$getProto && $0ea3aa360d963997274bb7c75b63d694$var$getProto(fn) === $0ea3aa360d963997274bb7c75b63d694$var$GeneratorFunction;
};

// ASSET: node_modules/which-typed-array/index.js
var $aed24f28f2cf0373281f949a5acccd57$exports = {};
// ASSET: node_modules/foreach/index.js
var $2da819963987f5bd698f60c585904b51$exports = {};
var $2da819963987f5bd698f60c585904b51$var$hasOwn = Object.prototype.hasOwnProperty;
var $2da819963987f5bd698f60c585904b51$var$toString = Object.prototype.toString;

$2da819963987f5bd698f60c585904b51$exports = function forEach(obj, fn, ctx) {
  if ($2da819963987f5bd698f60c585904b51$var$toString.call(fn) !== '[object Function]') {
    throw new TypeError('iterator must be a function');
  }

  var l = obj.length;

  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if ($2da819963987f5bd698f60c585904b51$var$hasOwn.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};

// ASSET: node_modules/available-typed-arrays/index.js
var $a5ca3fd12f2d304844a63aca549eee50$exports = {};
// ASSET: node_modules/array-filter/index.js
var $7f5cd1b1d190f049883b585db8a87049$exports = {};

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */
$7f5cd1b1d190f049883b585db8a87049$exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError();
  if ('function' != typeof fn) throw new TypeError();
  var ret = [];

  for (var i = 0; i < arr.length; i++) {
    if (!$7f5cd1b1d190f049883b585db8a87049$var$hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }

  return ret;
};

var $7f5cd1b1d190f049883b585db8a87049$var$hasOwn = Object.prototype.hasOwnProperty;

$a5ca3fd12f2d304844a63aca549eee50$exports = function availableTypedArrays() {
  return $7f5cd1b1d190f049883b585db8a87049$exports(['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'], function (typedArray) {
    return typeof $parcel$global[typedArray] === 'function';
  });
};

var $aed24f28f2cf0373281f949a5acccd57$var$$toString = $c73f916f7f0e89963ff025666f564c38$exports('Object.prototype.toString');
var $aed24f28f2cf0373281f949a5acccd57$var$hasSymbols = $d041d8a0f381cf8c41a7dcbe9a6f4f30$exports();
var $aed24f28f2cf0373281f949a5acccd57$var$hasToStringTag = $aed24f28f2cf0373281f949a5acccd57$var$hasSymbols && typeof Symbol.toStringTag === 'symbol';
var $aed24f28f2cf0373281f949a5acccd57$var$typedArrays = $a5ca3fd12f2d304844a63aca549eee50$exports();
var $aed24f28f2cf0373281f949a5acccd57$var$$slice = $c73f916f7f0e89963ff025666f564c38$exports('String.prototype.slice');
var $aed24f28f2cf0373281f949a5acccd57$var$toStrTags = {};
// ASSET: node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var $b08e44a11929a766aa4a69ae3f465fd5$exports = {};
// ASSET: node_modules/es-abstract/GetIntrinsic.js
var $a329b5bdd611ac1192a515368e610813$exports = {};

/* globals
	AggregateError,
	Atomics,
	FinalizationRegistry,
	SharedArrayBuffer,
	WeakRef,
*/
var $a329b5bdd611ac1192a515368e610813$var$undefined;
var $a329b5bdd611ac1192a515368e610813$var$$SyntaxError = SyntaxError;
var $a329b5bdd611ac1192a515368e610813$var$$Function = Function;
var $a329b5bdd611ac1192a515368e610813$var$$TypeError = TypeError; // eslint-disable-next-line consistent-return

// eslint-disable-next-line consistent-return
var $a329b5bdd611ac1192a515368e610813$var$getEvalledConstructor = function (expressionSyntax) {
  try {
    // eslint-disable-next-line no-new-func
    return Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $a329b5bdd611ac1192a515368e610813$var$$gOPD = Object.getOwnPropertyDescriptor;

if ($a329b5bdd611ac1192a515368e610813$var$$gOPD) {
  try {
    $a329b5bdd611ac1192a515368e610813$var$$gOPD({}, '');
  } catch (e) {
    $a329b5bdd611ac1192a515368e610813$var$$gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var $a329b5bdd611ac1192a515368e610813$var$throwTypeError = function () {
  throw new $a329b5bdd611ac1192a515368e610813$var$$TypeError();
};

var $a329b5bdd611ac1192a515368e610813$var$ThrowTypeError = $a329b5bdd611ac1192a515368e610813$var$$gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    // IE 8 does not throw here
    return $a329b5bdd611ac1192a515368e610813$var$throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $a329b5bdd611ac1192a515368e610813$var$$gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return $a329b5bdd611ac1192a515368e610813$var$throwTypeError;
    }
  }
}() : $a329b5bdd611ac1192a515368e610813$var$throwTypeError;
var $a329b5bdd611ac1192a515368e610813$var$hasSymbols = $d041d8a0f381cf8c41a7dcbe9a6f4f30$exports();

var $a329b5bdd611ac1192a515368e610813$var$getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


// eslint-disable-line no-proto
var $a329b5bdd611ac1192a515368e610813$var$asyncGenFunction = $a329b5bdd611ac1192a515368e610813$var$getEvalledConstructor('async function* () {}');
var $a329b5bdd611ac1192a515368e610813$var$asyncGenFunctionPrototype = $a329b5bdd611ac1192a515368e610813$var$asyncGenFunction ? $a329b5bdd611ac1192a515368e610813$var$asyncGenFunction.prototype : $a329b5bdd611ac1192a515368e610813$var$undefined;
var $a329b5bdd611ac1192a515368e610813$var$asyncGenPrototype = $a329b5bdd611ac1192a515368e610813$var$asyncGenFunctionPrototype ? $a329b5bdd611ac1192a515368e610813$var$asyncGenFunctionPrototype.prototype : $a329b5bdd611ac1192a515368e610813$var$undefined;
var $a329b5bdd611ac1192a515368e610813$var$TypedArray = typeof Uint8Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : $a329b5bdd611ac1192a515368e610813$var$getProto(Uint8Array);
var $a329b5bdd611ac1192a515368e610813$var$INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': $a329b5bdd611ac1192a515368e610813$var$hasSymbols ? $a329b5bdd611ac1192a515368e610813$var$getProto([][Symbol.iterator]()) : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%AsyncFromSyncIteratorPrototype%': $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%AsyncFunction%': $a329b5bdd611ac1192a515368e610813$var$getEvalledConstructor('async function () {}'),
  '%AsyncGenerator%': $a329b5bdd611ac1192a515368e610813$var$asyncGenFunctionPrototype,
  '%AsyncGeneratorFunction%': $a329b5bdd611ac1192a515368e610813$var$asyncGenFunction,
  '%AsyncIteratorPrototype%': $a329b5bdd611ac1192a515368e610813$var$asyncGenPrototype ? $a329b5bdd611ac1192a515368e610813$var$getProto($a329b5bdd611ac1192a515368e610813$var$asyncGenPrototype) : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%Atomics%': typeof Atomics === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : FinalizationRegistry,
  '%Function%': $a329b5bdd611ac1192a515368e610813$var$$Function,
  '%GeneratorFunction%': $a329b5bdd611ac1192a515368e610813$var$getEvalledConstructor('function* () {}'),
  '%Int8Array%': typeof Int8Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': $a329b5bdd611ac1192a515368e610813$var$hasSymbols ? $a329b5bdd611ac1192a515368e610813$var$getProto($a329b5bdd611ac1192a515368e610813$var$getProto([][Symbol.iterator]())) : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%Map%': typeof Map === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !$a329b5bdd611ac1192a515368e610813$var$hasSymbols ? $a329b5bdd611ac1192a515368e610813$var$undefined : $a329b5bdd611ac1192a515368e610813$var$getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !$a329b5bdd611ac1192a515368e610813$var$hasSymbols ? $a329b5bdd611ac1192a515368e610813$var$undefined : $a329b5bdd611ac1192a515368e610813$var$getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': $a329b5bdd611ac1192a515368e610813$var$hasSymbols ? $a329b5bdd611ac1192a515368e610813$var$getProto(''[Symbol.iterator]()) : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%Symbol%': $a329b5bdd611ac1192a515368e610813$var$hasSymbols ? Symbol : $a329b5bdd611ac1192a515368e610813$var$undefined,
  '%SyntaxError%': $a329b5bdd611ac1192a515368e610813$var$$SyntaxError,
  '%ThrowTypeError%': $a329b5bdd611ac1192a515368e610813$var$ThrowTypeError,
  '%TypedArray%': $a329b5bdd611ac1192a515368e610813$var$TypedArray,
  '%TypeError%': $a329b5bdd611ac1192a515368e610813$var$$TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? $a329b5bdd611ac1192a515368e610813$var$undefined : WeakSet
};
var $a329b5bdd611ac1192a515368e610813$var$LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var $a329b5bdd611ac1192a515368e610813$var$$concat = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.call, Array.prototype.concat);
var $a329b5bdd611ac1192a515368e610813$var$$spliceApply = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.apply, Array.prototype.splice);
var $a329b5bdd611ac1192a515368e610813$var$$replace = $6c5413db60467e6e27dae1ea7e336bfe$exports.call(Function.call, String.prototype.replace);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var $a329b5bdd611ac1192a515368e610813$var$rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var $a329b5bdd611ac1192a515368e610813$var$reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

/** Used to match backslashes in property paths. */
var $a329b5bdd611ac1192a515368e610813$var$stringToPath = function stringToPath(string) {
  var result = [];
  $a329b5bdd611ac1192a515368e610813$var$$replace(string, $a329b5bdd611ac1192a515368e610813$var$rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $a329b5bdd611ac1192a515368e610813$var$$replace(subString, $a329b5bdd611ac1192a515368e610813$var$reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


/* end adaptation */
var $a329b5bdd611ac1192a515368e610813$var$getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if ($c51f73f3caa65e15cb23766babe247d9$exports($a329b5bdd611ac1192a515368e610813$var$LEGACY_ALIASES, intrinsicName)) {
    alias = $a329b5bdd611ac1192a515368e610813$var$LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if ($c51f73f3caa65e15cb23766babe247d9$exports($a329b5bdd611ac1192a515368e610813$var$INTRINSICS, intrinsicName)) {
    var value = $a329b5bdd611ac1192a515368e610813$var$INTRINSICS[intrinsicName];

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $a329b5bdd611ac1192a515368e610813$var$$TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $a329b5bdd611ac1192a515368e610813$var$$SyntaxError('intrinsic ' + name + ' does not exist!');
};

$a329b5bdd611ac1192a515368e610813$exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $a329b5bdd611ac1192a515368e610813$var$$TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $a329b5bdd611ac1192a515368e610813$var$$TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = $a329b5bdd611ac1192a515368e610813$var$stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = $a329b5bdd611ac1192a515368e610813$var$getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $a329b5bdd611ac1192a515368e610813$var$$spliceApply(parts, $a329b5bdd611ac1192a515368e610813$var$$concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if ($c51f73f3caa65e15cb23766babe247d9$exports($a329b5bdd611ac1192a515368e610813$var$INTRINSICS, intrinsicRealName)) {
      value = $a329b5bdd611ac1192a515368e610813$var$INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if ($a329b5bdd611ac1192a515368e610813$var$$gOPD && i + 1 >= parts.length) {
        var desc = $a329b5bdd611ac1192a515368e610813$var$$gOPD(value, part);
        isOwn = !!desc;

        if (!allowMissing && !(part in value)) {
          throw new $a329b5bdd611ac1192a515368e610813$var$$TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        } // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.


        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = $c51f73f3caa65e15cb23766babe247d9$exports(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        $a329b5bdd611ac1192a515368e610813$var$INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

var $b08e44a11929a766aa4a69ae3f465fd5$var$$gOPD = $a329b5bdd611ac1192a515368e610813$exports('%Object.getOwnPropertyDescriptor%');

if ($b08e44a11929a766aa4a69ae3f465fd5$var$$gOPD) {
  try {
    $b08e44a11929a766aa4a69ae3f465fd5$var$$gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $b08e44a11929a766aa4a69ae3f465fd5$var$$gOPD = null;
  }
}

$b08e44a11929a766aa4a69ae3f465fd5$exports = $b08e44a11929a766aa4a69ae3f465fd5$var$$gOPD;
var $aed24f28f2cf0373281f949a5acccd57$var$getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

// require('getprototypeof');
if ($aed24f28f2cf0373281f949a5acccd57$var$hasToStringTag && $b08e44a11929a766aa4a69ae3f465fd5$exports && $aed24f28f2cf0373281f949a5acccd57$var$getPrototypeOf) {
  $2da819963987f5bd698f60c585904b51$exports($aed24f28f2cf0373281f949a5acccd57$var$typedArrays, function (typedArray) {
    if (typeof $parcel$global[typedArray] === 'function') {
      var arr = new $parcel$global[typedArray]();

      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
      }

      var proto = $aed24f28f2cf0373281f949a5acccd57$var$getPrototypeOf(arr);
      var descriptor = $b08e44a11929a766aa4a69ae3f465fd5$exports(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = $aed24f28f2cf0373281f949a5acccd57$var$getPrototypeOf(proto);
        descriptor = $b08e44a11929a766aa4a69ae3f465fd5$exports(superProto, Symbol.toStringTag);
      }

      $aed24f28f2cf0373281f949a5acccd57$var$toStrTags[typedArray] = descriptor.get;
    }
  });
}

var $aed24f28f2cf0373281f949a5acccd57$var$tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  $2da819963987f5bd698f60c585904b51$exports($aed24f28f2cf0373281f949a5acccd57$var$toStrTags, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);

        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};

// ASSET: node_modules/is-typed-array/index.js
var $c096699d1d2332fbd9be4d7132241dc1$exports = {};
var $c096699d1d2332fbd9be4d7132241dc1$var$$toString = $c73f916f7f0e89963ff025666f564c38$exports('Object.prototype.toString');
var $c096699d1d2332fbd9be4d7132241dc1$var$hasSymbols = $d041d8a0f381cf8c41a7dcbe9a6f4f30$exports();
var $c096699d1d2332fbd9be4d7132241dc1$var$hasToStringTag = $c096699d1d2332fbd9be4d7132241dc1$var$hasSymbols && typeof Symbol.toStringTag === 'symbol';
var $c096699d1d2332fbd9be4d7132241dc1$var$typedArrays = $a5ca3fd12f2d304844a63aca549eee50$exports();

var $c096699d1d2332fbd9be4d7132241dc1$var$$indexOf = $c73f916f7f0e89963ff025666f564c38$exports('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }

  return -1;
};

var $c096699d1d2332fbd9be4d7132241dc1$var$$slice = $c73f916f7f0e89963ff025666f564c38$exports('String.prototype.slice');
var $c096699d1d2332fbd9be4d7132241dc1$var$toStrTags = {};
var $c096699d1d2332fbd9be4d7132241dc1$var$getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

// require('getprototypeof');
if ($c096699d1d2332fbd9be4d7132241dc1$var$hasToStringTag && $b08e44a11929a766aa4a69ae3f465fd5$exports && $c096699d1d2332fbd9be4d7132241dc1$var$getPrototypeOf) {
  $2da819963987f5bd698f60c585904b51$exports($c096699d1d2332fbd9be4d7132241dc1$var$typedArrays, function (typedArray) {
    var arr = new $parcel$global[typedArray]();

    if (!(Symbol.toStringTag in arr)) {
      throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
    }

    var proto = $c096699d1d2332fbd9be4d7132241dc1$var$getPrototypeOf(arr);
    var descriptor = $b08e44a11929a766aa4a69ae3f465fd5$exports(proto, Symbol.toStringTag);

    if (!descriptor) {
      var superProto = $c096699d1d2332fbd9be4d7132241dc1$var$getPrototypeOf(proto);
      descriptor = $b08e44a11929a766aa4a69ae3f465fd5$exports(superProto, Symbol.toStringTag);
    }

    $c096699d1d2332fbd9be4d7132241dc1$var$toStrTags[typedArray] = descriptor.get;
  });
}

var $c096699d1d2332fbd9be4d7132241dc1$var$tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  $2da819963987f5bd698f60c585904b51$exports($c096699d1d2332fbd9be4d7132241dc1$var$toStrTags, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
        /**/
      }
    }
  });
  return anyTrue;
};

$c096699d1d2332fbd9be4d7132241dc1$exports = function isTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }

  if (!$c096699d1d2332fbd9be4d7132241dc1$var$hasToStringTag) {
    var tag = $c096699d1d2332fbd9be4d7132241dc1$var$$slice($c096699d1d2332fbd9be4d7132241dc1$var$$toString(value), 8, -1);
    return $c096699d1d2332fbd9be4d7132241dc1$var$$indexOf($c096699d1d2332fbd9be4d7132241dc1$var$typedArrays, tag) > -1;
  }

  if (!$b08e44a11929a766aa4a69ae3f465fd5$exports) {
    return false;
  }

  return $c096699d1d2332fbd9be4d7132241dc1$var$tryTypedArrays(value);
};

$aed24f28f2cf0373281f949a5acccd57$exports = function whichTypedArray(value) {
  if (!$c096699d1d2332fbd9be4d7132241dc1$exports(value)) {
    return false;
  }

  if (!$aed24f28f2cf0373281f949a5acccd57$var$hasToStringTag) {
    return $aed24f28f2cf0373281f949a5acccd57$var$$slice($aed24f28f2cf0373281f949a5acccd57$var$$toString(value), 8, -1);
  }

  return $aed24f28f2cf0373281f949a5acccd57$var$tryTypedArrays(value);
};

function $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(f) {
  return f.call.bind(f);
}

var $ddaee7ce122ed4de10c25c941bef48c3$var$BigIntSupported = typeof BigInt !== 'undefined';
var $ddaee7ce122ed4de10c25c941bef48c3$var$SymbolSupported = typeof Symbol !== 'undefined';
var $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(Object.prototype.toString);
var $ddaee7ce122ed4de10c25c941bef48c3$var$numberValue = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(Number.prototype.valueOf);
var $ddaee7ce122ed4de10c25c941bef48c3$var$stringValue = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(String.prototype.valueOf);
var $ddaee7ce122ed4de10c25c941bef48c3$var$booleanValue = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(Boolean.prototype.valueOf);

if ($ddaee7ce122ed4de10c25c941bef48c3$var$BigIntSupported) {
  var $ddaee7ce122ed4de10c25c941bef48c3$var$bigIntValue = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(BigInt.prototype.valueOf);
}

if ($ddaee7ce122ed4de10c25c941bef48c3$var$SymbolSupported) {
  var $ddaee7ce122ed4de10c25c941bef48c3$var$symbolValue = $ddaee7ce122ed4de10c25c941bef48c3$var$uncurryThis(Symbol.prototype.valueOf);
}

function $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }

  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}

$ddaee7ce122ed4de10c25c941bef48c3$exports.isArgumentsObject = $98de8a60a52d4e568c654f5ce60d386f$exports;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isGeneratorFunction = $0ea3aa360d963997274bb7c75b63d694$exports;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isTypedArray = $c096699d1d2332fbd9be4d7132241dc1$exports; // Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function $ddaee7ce122ed4de10c25c941bef48c3$var$isPromise(input) {
  return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isPromise = $ddaee7ce122ed4de10c25c941bef48c3$var$isPromise;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isPromise = $ddaee7ce122ed4de10c25c941bef48c3$export$isPromise;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return $c096699d1d2332fbd9be4d7132241dc1$exports(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isDataView(value);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isArrayBufferView = $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferView;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isArrayBufferView = $ddaee7ce122ed4de10c25c941bef48c3$export$isArrayBufferView;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isUint8Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Uint8Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isUint8Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isUint8Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isUint8Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isUint8Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isUint8ClampedArray(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Uint8ClampedArray';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isUint8ClampedArray = $ddaee7ce122ed4de10c25c941bef48c3$var$isUint8ClampedArray;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isUint8ClampedArray = $ddaee7ce122ed4de10c25c941bef48c3$export$isUint8ClampedArray;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isUint16Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Uint16Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isUint16Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isUint16Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isUint16Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isUint16Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isUint32Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Uint32Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isUint32Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isUint32Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isUint32Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isUint32Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isInt8Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Int8Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isInt8Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isInt8Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isInt8Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isInt8Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isInt16Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Int16Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isInt16Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isInt16Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isInt16Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isInt16Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isInt32Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Int32Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isInt32Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isInt32Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isInt32Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isInt32Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isFloat32Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Float32Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isFloat32Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isFloat32Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isFloat32Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isFloat32Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isFloat64Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'Float64Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isFloat64Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isFloat64Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isFloat64Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isFloat64Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isBigInt64Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'BigInt64Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isBigInt64Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isBigInt64Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isBigInt64Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isBigInt64Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isBigUint64Array(value) {
  return $aed24f28f2cf0373281f949a5acccd57$exports(value) === 'BigUint64Array';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isBigUint64Array = $ddaee7ce122ed4de10c25c941bef48c3$var$isBigUint64Array;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isBigUint64Array = $ddaee7ce122ed4de10c25c941bef48c3$export$isBigUint64Array;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isMapToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object Map]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isMapToString.working = typeof Map !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isMapToString(new Map());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isMapToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isMapToString(value) : value instanceof Map;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isMap = $ddaee7ce122ed4de10c25c941bef48c3$var$isMap;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isMap = $ddaee7ce122ed4de10c25c941bef48c3$export$isMap;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSetToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object Set]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isSetToString.working = typeof Set !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isSetToString(new Set());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isSetToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isSetToString(value) : value instanceof Set;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isSet = $ddaee7ce122ed4de10c25c941bef48c3$var$isSet;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isSet = $ddaee7ce122ed4de10c25c941bef48c3$export$isSet;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMapToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object WeakMap]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMapToString.working = typeof WeakMap !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMapToString(new WeakMap());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMapToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMapToString(value) : value instanceof WeakMap;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isWeakMap = $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakMap;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isWeakMap = $ddaee7ce122ed4de10c25c941bef48c3$export$isWeakMap;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSetToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object WeakSet]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSetToString.working = typeof WeakSet !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSetToString(new WeakSet());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSet(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSetToString(value);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isWeakSet = $ddaee7ce122ed4de10c25c941bef48c3$var$isWeakSet;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isWeakSet = $ddaee7ce122ed4de10c25c941bef48c3$export$isWeakSet;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object ArrayBuffer]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferToString(new ArrayBuffer());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBufferToString(value) : value instanceof ArrayBuffer;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBuffer;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$export$isArrayBuffer;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isDataViewToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object DataView]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

function $ddaee7ce122ed4de10c25c941bef48c3$var$isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isDataViewToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isDataViewToString(value) : value instanceof DataView;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isDataView = $ddaee7ce122ed4de10c25c941bef48c3$var$isDataView;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isDataView = $ddaee7ce122ed4de10c25c941bef48c3$export$isDataView;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBufferToString(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object SharedArrayBuffer]';
}

$ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== 'undefined' && $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBufferToString(new SharedArrayBuffer());

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBufferToString.working ? $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isSharedArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBuffer;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isSharedArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$export$isSharedArrayBuffer;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isAsyncFunction(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object AsyncFunction]';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isAsyncFunction = $ddaee7ce122ed4de10c25c941bef48c3$var$isAsyncFunction;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isAsyncFunction = $ddaee7ce122ed4de10c25c941bef48c3$export$isAsyncFunction;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isMapIterator(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object Map Iterator]';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isMapIterator = $ddaee7ce122ed4de10c25c941bef48c3$var$isMapIterator;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isMapIterator = $ddaee7ce122ed4de10c25c941bef48c3$export$isMapIterator;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSetIterator(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object Set Iterator]';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isSetIterator = $ddaee7ce122ed4de10c25c941bef48c3$var$isSetIterator;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isSetIterator = $ddaee7ce122ed4de10c25c941bef48c3$export$isSetIterator;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isGeneratorObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object Generator]';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isGeneratorObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isGeneratorObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isGeneratorObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isGeneratorObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isWebAssemblyCompiledModule(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$ObjectToString(value) === '[object WebAssembly.Module]';
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isWebAssemblyCompiledModule = $ddaee7ce122ed4de10c25c941bef48c3$var$isWebAssemblyCompiledModule;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isWebAssemblyCompiledModule = $ddaee7ce122ed4de10c25c941bef48c3$export$isWebAssemblyCompiledModule;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isNumberObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, $ddaee7ce122ed4de10c25c941bef48c3$var$numberValue);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isNumberObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isNumberObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isNumberObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isNumberObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isStringObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, $ddaee7ce122ed4de10c25c941bef48c3$var$stringValue);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isStringObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isStringObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isStringObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isStringObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isBooleanObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, $ddaee7ce122ed4de10c25c941bef48c3$var$booleanValue);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isBooleanObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isBooleanObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isBooleanObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isBooleanObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isBigIntObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$BigIntSupported && $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, $ddaee7ce122ed4de10c25c941bef48c3$var$bigIntValue);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isBigIntObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isBigIntObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isBigIntObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isBigIntObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isSymbolObject(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$SymbolSupported && $ddaee7ce122ed4de10c25c941bef48c3$var$checkBoxedPrimitive(value, $ddaee7ce122ed4de10c25c941bef48c3$var$symbolValue);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isSymbolObject = $ddaee7ce122ed4de10c25c941bef48c3$var$isSymbolObject;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isSymbolObject = $ddaee7ce122ed4de10c25c941bef48c3$export$isSymbolObject;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isBoxedPrimitive(value) {
  return $ddaee7ce122ed4de10c25c941bef48c3$var$isNumberObject(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isStringObject(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isBooleanObject(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isBigIntObject(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isSymbolObject(value);
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isBoxedPrimitive = $ddaee7ce122ed4de10c25c941bef48c3$var$isBoxedPrimitive;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isBoxedPrimitive = $ddaee7ce122ed4de10c25c941bef48c3$export$isBoxedPrimitive;

function $ddaee7ce122ed4de10c25c941bef48c3$var$isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && ($ddaee7ce122ed4de10c25c941bef48c3$var$isArrayBuffer(value) || $ddaee7ce122ed4de10c25c941bef48c3$var$isSharedArrayBuffer(value));
}

var $ddaee7ce122ed4de10c25c941bef48c3$export$isAnyArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$var$isAnyArrayBuffer;
$ddaee7ce122ed4de10c25c941bef48c3$exports.isAnyArrayBuffer = $ddaee7ce122ed4de10c25c941bef48c3$export$isAnyArrayBuffer;
['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
  Object.defineProperty($ddaee7ce122ed4de10c25c941bef48c3$exports, method, {
    enumerable: false,
    value: function () {
      throw new Error(method + ' is not supported in userland');
    }
  });
});
// ASSET: node_modules/util/support/isBufferBrowser.js
var $57f86b62d098d8ba5edd162e212d3b62$exports = {};

$57f86b62d098d8ba5edd162e212d3b62$exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

// ASSET: node_modules/inherits/inherits_browser.js
var $5e04eef67f3cc70b90141a363590b6ee$exports,
    $5e04eef67f3cc70b90141a363590b6ee$executed = false;

function $5e04eef67f3cc70b90141a363590b6ee$exec() {
  $5e04eef67f3cc70b90141a363590b6ee$exports = {};

  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    $5e04eef67f3cc70b90141a363590b6ee$exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    $5e04eef67f3cc70b90141a363590b6ee$exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function () {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
}

function $5e04eef67f3cc70b90141a363590b6ee$init() {
  if (!$5e04eef67f3cc70b90141a363590b6ee$executed) {
    $5e04eef67f3cc70b90141a363590b6ee$executed = true;
    $5e04eef67f3cc70b90141a363590b6ee$exec();
  }

  return $5e04eef67f3cc70b90141a363590b6ee$exports;
}

// ASSET: node_modules/util/util.js
var $69678d3e0618202337016e1b4ed76965$exports,
    $69678d3e0618202337016e1b4ed76965$var$process,
    $69678d3e0618202337016e1b4ed76965$var$getOwnPropertyDescriptors,
    $69678d3e0618202337016e1b4ed76965$var$formatRegExp,
    $69678d3e0618202337016e1b4ed76965$export$format,
    $69678d3e0618202337016e1b4ed76965$export$deprecate,
    $69678d3e0618202337016e1b4ed76965$var$debugs,
    $69678d3e0618202337016e1b4ed76965$var$debugEnvRegex,
    $69678d3e0618202337016e1b4ed76965$var$debugEnv,
    $69678d3e0618202337016e1b4ed76965$export$debuglog,
    $69678d3e0618202337016e1b4ed76965$export$inspect,
    $69678d3e0618202337016e1b4ed76965$export$types,
    $69678d3e0618202337016e1b4ed76965$export$isArray,
    $69678d3e0618202337016e1b4ed76965$export$isBoolean,
    $69678d3e0618202337016e1b4ed76965$export$isNull,
    $69678d3e0618202337016e1b4ed76965$export$isNullOrUndefined,
    $69678d3e0618202337016e1b4ed76965$export$isNumber,
    $69678d3e0618202337016e1b4ed76965$export$isString,
    $69678d3e0618202337016e1b4ed76965$export$isSymbol,
    $69678d3e0618202337016e1b4ed76965$export$isUndefined,
    $69678d3e0618202337016e1b4ed76965$export$isRegExp,
    $69678d3e0618202337016e1b4ed76965$export$isObject,
    $69678d3e0618202337016e1b4ed76965$export$isDate,
    $69678d3e0618202337016e1b4ed76965$export$isError,
    $69678d3e0618202337016e1b4ed76965$export$isFunction,
    $69678d3e0618202337016e1b4ed76965$export$isPrimitive,
    $69678d3e0618202337016e1b4ed76965$export$isBuffer,
    $69678d3e0618202337016e1b4ed76965$var$months,
    $69678d3e0618202337016e1b4ed76965$export$log,
    $69678d3e0618202337016e1b4ed76965$export$inherits,
    $69678d3e0618202337016e1b4ed76965$export$_extend,
    $69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol,
    $69678d3e0618202337016e1b4ed76965$export$promisify,
    $69678d3e0618202337016e1b4ed76965$export$callbackify,
    $69678d3e0618202337016e1b4ed76965$executed = false;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/
function $69678d3e0618202337016e1b4ed76965$var$inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: $69678d3e0618202337016e1b4ed76965$var$stylizeNoColor
  }; // legacy...

  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if ($69678d3e0618202337016e1b4ed76965$var$isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    $69678d3e0618202337016e1b4ed76965$exports._extend(ctx, opts);
  } // set default options


  // set default options
  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(ctx.depth)) ctx.depth = 2;
  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(ctx.colors)) ctx.colors = false;
  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = $69678d3e0618202337016e1b4ed76965$var$stylizeWithColor;
  return $69678d3e0618202337016e1b4ed76965$var$formatValue(ctx, obj, ctx.depth);
}

function $69678d3e0618202337016e1b4ed76965$var$stylizeWithColor(str, styleType) {
  var style = $69678d3e0618202337016e1b4ed76965$var$inspect.styles[styleType];

  if (style) {
    return '\u001b[' + $69678d3e0618202337016e1b4ed76965$var$inspect.colors[style][0] + 'm' + str + '\u001b[' + $69678d3e0618202337016e1b4ed76965$var$inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function $69678d3e0618202337016e1b4ed76965$var$stylizeNoColor(str, styleType) {
  return str;
}

function $69678d3e0618202337016e1b4ed76965$var$arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function $69678d3e0618202337016e1b4ed76965$var$formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && $69678d3e0618202337016e1b4ed76965$var$isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== $69678d3e0618202337016e1b4ed76965$exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!$69678d3e0618202337016e1b4ed76965$var$isString(ret)) {
      ret = $69678d3e0618202337016e1b4ed76965$var$formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  // Primitive types cannot have properties
  var primitive = $69678d3e0618202337016e1b4ed76965$var$formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = $69678d3e0618202337016e1b4ed76965$var$arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if ($69678d3e0618202337016e1b4ed76965$var$isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return $69678d3e0618202337016e1b4ed76965$var$formatError(value);
  } // Some type of object without properties can be shortcutted.


  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if ($69678d3e0618202337016e1b4ed76965$var$isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if ($69678d3e0618202337016e1b4ed76965$var$isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if ($69678d3e0618202337016e1b4ed76965$var$isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if ($69678d3e0618202337016e1b4ed76965$var$isError(value)) {
      return $69678d3e0618202337016e1b4ed76965$var$formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  // Make Array say that they are Array
  if ($69678d3e0618202337016e1b4ed76965$var$isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  // Make functions say that they are functions
  if ($69678d3e0618202337016e1b4ed76965$var$isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  // Make RegExps say that they are RegExps
  if ($69678d3e0618202337016e1b4ed76965$var$isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  // Make dates with properties first say the date
  if ($69678d3e0618202337016e1b4ed76965$var$isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  // Make error with message first say the error
  if ($69678d3e0618202337016e1b4ed76965$var$isError(value)) {
    base = ' ' + $69678d3e0618202337016e1b4ed76965$var$formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if ($69678d3e0618202337016e1b4ed76965$var$isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = $69678d3e0618202337016e1b4ed76965$var$formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return $69678d3e0618202337016e1b4ed76965$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return $69678d3e0618202337016e1b4ed76965$var$reduceToSingleString(output, base, braces);
}

function $69678d3e0618202337016e1b4ed76965$var$formatPrimitive(ctx, value) {
  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if ($69678d3e0618202337016e1b4ed76965$var$isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if ($69678d3e0618202337016e1b4ed76965$var$isNumber(value)) return ctx.stylize('' + value, 'number');
  if ($69678d3e0618202337016e1b4ed76965$var$isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  // For some reason typeof null is "object", so special case here.
  if ($69678d3e0618202337016e1b4ed76965$var$isNull(value)) return ctx.stylize('null', 'null');
}

function $69678d3e0618202337016e1b4ed76965$var$formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function $69678d3e0618202337016e1b4ed76965$var$formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if ($69678d3e0618202337016e1b4ed76965$var$hasOwnProperty(value, String(i))) {
      output.push($69678d3e0618202337016e1b4ed76965$var$formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push($69678d3e0618202337016e1b4ed76965$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function $69678d3e0618202337016e1b4ed76965$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!$69678d3e0618202337016e1b4ed76965$var$hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if ($69678d3e0618202337016e1b4ed76965$var$isNull(recurseTimes)) {
        str = $69678d3e0618202337016e1b4ed76965$var$formatValue(ctx, desc.value, null);
      } else {
        str = $69678d3e0618202337016e1b4ed76965$var$formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if ($69678d3e0618202337016e1b4ed76965$var$isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function $69678d3e0618202337016e1b4ed76965$var$reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function $69678d3e0618202337016e1b4ed76965$var$isArray(ar) {
  return Array.isArray(ar);
}

function $69678d3e0618202337016e1b4ed76965$var$isBoolean(arg) {
  return typeof arg === 'boolean';
}

function $69678d3e0618202337016e1b4ed76965$var$isNull(arg) {
  return arg === null;
}

function $69678d3e0618202337016e1b4ed76965$var$isNullOrUndefined(arg) {
  return arg == null;
}

function $69678d3e0618202337016e1b4ed76965$var$isNumber(arg) {
  return typeof arg === 'number';
}

function $69678d3e0618202337016e1b4ed76965$var$isString(arg) {
  return typeof arg === 'string';
}

function $69678d3e0618202337016e1b4ed76965$var$isSymbol(arg) {
  return typeof arg === 'symbol';
}

function $69678d3e0618202337016e1b4ed76965$var$isUndefined(arg) {
  return arg === void 0;
}

function $69678d3e0618202337016e1b4ed76965$var$isRegExp(re) {
  return $69678d3e0618202337016e1b4ed76965$var$isObject(re) && $69678d3e0618202337016e1b4ed76965$var$objectToString(re) === '[object RegExp]';
}

function $69678d3e0618202337016e1b4ed76965$var$isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function $69678d3e0618202337016e1b4ed76965$var$isDate(d) {
  return $69678d3e0618202337016e1b4ed76965$var$isObject(d) && $69678d3e0618202337016e1b4ed76965$var$objectToString(d) === '[object Date]';
}

function $69678d3e0618202337016e1b4ed76965$var$isError(e) {
  return $69678d3e0618202337016e1b4ed76965$var$isObject(e) && ($69678d3e0618202337016e1b4ed76965$var$objectToString(e) === '[object Error]' || e instanceof Error);
}

function $69678d3e0618202337016e1b4ed76965$var$isFunction(arg) {
  return typeof arg === 'function';
}

function $69678d3e0618202337016e1b4ed76965$var$isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

function $69678d3e0618202337016e1b4ed76965$var$objectToString(o) {
  return Object.prototype.toString.call(o);
}

function $69678d3e0618202337016e1b4ed76965$var$pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

// 26 Feb 16:19:34
function $69678d3e0618202337016e1b4ed76965$var$timestamp() {
  var d = new Date();
  var time = [$69678d3e0618202337016e1b4ed76965$var$pad(d.getHours()), $69678d3e0618202337016e1b4ed76965$var$pad(d.getMinutes()), $69678d3e0618202337016e1b4ed76965$var$pad(d.getSeconds())].join(':');
  return [d.getDate(), $69678d3e0618202337016e1b4ed76965$var$months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


function $69678d3e0618202337016e1b4ed76965$var$hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function $69678d3e0618202337016e1b4ed76965$var$callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function $69678d3e0618202337016e1b4ed76965$var$callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      $69678d3e0618202337016e1b4ed76965$var$process.nextTick(cb.bind(null, null, ret));
    }, function (rej) {
      $69678d3e0618202337016e1b4ed76965$var$process.nextTick($69678d3e0618202337016e1b4ed76965$var$callbackifyOnRejected.bind(null, rej, cb));
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, $69678d3e0618202337016e1b4ed76965$var$getOwnPropertyDescriptors(original));
  return callbackified;
}

function $69678d3e0618202337016e1b4ed76965$exec() {
  $69678d3e0618202337016e1b4ed76965$exports = {};
  $69678d3e0618202337016e1b4ed76965$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

  $69678d3e0618202337016e1b4ed76965$var$getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};

    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }

    return descriptors;
  };

  $69678d3e0618202337016e1b4ed76965$var$formatRegExp = /%[sdj%]/g;

  $69678d3e0618202337016e1b4ed76965$export$format = function (f) {
    if (!$69678d3e0618202337016e1b4ed76965$var$isString(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push($69678d3e0618202337016e1b4ed76965$var$inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace($69678d3e0618202337016e1b4ed76965$var$formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if ($69678d3e0618202337016e1b4ed76965$var$isNull(x) || !$69678d3e0618202337016e1b4ed76965$var$isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + $69678d3e0618202337016e1b4ed76965$var$inspect(x);
      }
    }

    return str;
  };

  $69678d3e0618202337016e1b4ed76965$exports.format = $69678d3e0618202337016e1b4ed76965$export$format; // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.

  $69678d3e0618202337016e1b4ed76965$export$deprecate = function (fn, msg) {
    if (typeof $69678d3e0618202337016e1b4ed76965$var$process !== 'undefined' && $69678d3e0618202337016e1b4ed76965$var$process.noDeprecation === true) {
      return fn;
    } // Allow for deprecating things in the process of starting up.


    // Allow for deprecating things in the process of starting up.
    if (typeof $69678d3e0618202337016e1b4ed76965$var$process === 'undefined') {
      return function () {
        return $69678d3e0618202337016e1b4ed76965$exports.deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if ($69678d3e0618202337016e1b4ed76965$var$process.throwDeprecation) {
          throw new Error(msg);
        } else if ($69678d3e0618202337016e1b4ed76965$var$process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  };

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  $69678d3e0618202337016e1b4ed76965$exports.deprecate = $69678d3e0618202337016e1b4ed76965$export$deprecate;
  $69678d3e0618202337016e1b4ed76965$var$debugs = {};
  $69678d3e0618202337016e1b4ed76965$var$debugEnvRegex = /^$/;

  if (undefined) {
    $69678d3e0618202337016e1b4ed76965$var$debugEnv = undefined;
    $69678d3e0618202337016e1b4ed76965$var$debugEnv = $69678d3e0618202337016e1b4ed76965$var$debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
    $69678d3e0618202337016e1b4ed76965$var$debugEnvRegex = new RegExp('^' + $69678d3e0618202337016e1b4ed76965$var$debugEnv + '$', 'i');
  }

  $69678d3e0618202337016e1b4ed76965$export$debuglog = function (set) {
    set = set.toUpperCase();

    if (!$69678d3e0618202337016e1b4ed76965$var$debugs[set]) {
      if ($69678d3e0618202337016e1b4ed76965$var$debugEnvRegex.test(set)) {
        var pid = $69678d3e0618202337016e1b4ed76965$var$process.pid;

        $69678d3e0618202337016e1b4ed76965$var$debugs[set] = function () {
          var msg = $69678d3e0618202337016e1b4ed76965$exports.format.apply($69678d3e0618202337016e1b4ed76965$exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        $69678d3e0618202337016e1b4ed76965$var$debugs[set] = function () {};
      }
    }

    return $69678d3e0618202337016e1b4ed76965$var$debugs[set];
  };

  $69678d3e0618202337016e1b4ed76965$exports.debuglog = $69678d3e0618202337016e1b4ed76965$export$debuglog;
  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */

  /* legacy: obj, showHidden, depth, colors*/

  $69678d3e0618202337016e1b4ed76965$export$inspect = $69678d3e0618202337016e1b4ed76965$var$inspect;
  $69678d3e0618202337016e1b4ed76965$exports.inspect = $69678d3e0618202337016e1b4ed76965$export$inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  $69678d3e0618202337016e1b4ed76965$var$inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  }; // Don't use 'blue' not visible on cmd.exe

  // Don't use 'blue' not visible on cmd.exe
  $69678d3e0618202337016e1b4ed76965$var$inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };
  $69678d3e0618202337016e1b4ed76965$export$types = $ddaee7ce122ed4de10c25c941bef48c3$exports;
  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  $69678d3e0618202337016e1b4ed76965$exports.types = $69678d3e0618202337016e1b4ed76965$export$types;
  $69678d3e0618202337016e1b4ed76965$export$isArray = $69678d3e0618202337016e1b4ed76965$var$isArray;
  $69678d3e0618202337016e1b4ed76965$exports.isArray = $69678d3e0618202337016e1b4ed76965$export$isArray;
  $69678d3e0618202337016e1b4ed76965$export$isBoolean = $69678d3e0618202337016e1b4ed76965$var$isBoolean;
  $69678d3e0618202337016e1b4ed76965$exports.isBoolean = $69678d3e0618202337016e1b4ed76965$export$isBoolean;
  $69678d3e0618202337016e1b4ed76965$export$isNull = $69678d3e0618202337016e1b4ed76965$var$isNull;
  $69678d3e0618202337016e1b4ed76965$exports.isNull = $69678d3e0618202337016e1b4ed76965$export$isNull;
  $69678d3e0618202337016e1b4ed76965$export$isNullOrUndefined = $69678d3e0618202337016e1b4ed76965$var$isNullOrUndefined;
  $69678d3e0618202337016e1b4ed76965$exports.isNullOrUndefined = $69678d3e0618202337016e1b4ed76965$export$isNullOrUndefined;
  $69678d3e0618202337016e1b4ed76965$export$isNumber = $69678d3e0618202337016e1b4ed76965$var$isNumber;
  $69678d3e0618202337016e1b4ed76965$exports.isNumber = $69678d3e0618202337016e1b4ed76965$export$isNumber;
  $69678d3e0618202337016e1b4ed76965$export$isString = $69678d3e0618202337016e1b4ed76965$var$isString;
  $69678d3e0618202337016e1b4ed76965$exports.isString = $69678d3e0618202337016e1b4ed76965$export$isString;
  $69678d3e0618202337016e1b4ed76965$export$isSymbol = $69678d3e0618202337016e1b4ed76965$var$isSymbol;
  $69678d3e0618202337016e1b4ed76965$exports.isSymbol = $69678d3e0618202337016e1b4ed76965$export$isSymbol;
  $69678d3e0618202337016e1b4ed76965$export$isUndefined = $69678d3e0618202337016e1b4ed76965$var$isUndefined;
  $69678d3e0618202337016e1b4ed76965$exports.isUndefined = $69678d3e0618202337016e1b4ed76965$export$isUndefined;
  $69678d3e0618202337016e1b4ed76965$export$isRegExp = $69678d3e0618202337016e1b4ed76965$var$isRegExp;
  $69678d3e0618202337016e1b4ed76965$exports.isRegExp = $69678d3e0618202337016e1b4ed76965$export$isRegExp;
  $69678d3e0618202337016e1b4ed76965$exports.types.isRegExp = $69678d3e0618202337016e1b4ed76965$var$isRegExp;
  $69678d3e0618202337016e1b4ed76965$export$isObject = $69678d3e0618202337016e1b4ed76965$var$isObject;
  $69678d3e0618202337016e1b4ed76965$exports.isObject = $69678d3e0618202337016e1b4ed76965$export$isObject;
  $69678d3e0618202337016e1b4ed76965$export$isDate = $69678d3e0618202337016e1b4ed76965$var$isDate;
  $69678d3e0618202337016e1b4ed76965$exports.isDate = $69678d3e0618202337016e1b4ed76965$export$isDate;
  $69678d3e0618202337016e1b4ed76965$exports.types.isDate = $69678d3e0618202337016e1b4ed76965$var$isDate;
  $69678d3e0618202337016e1b4ed76965$export$isError = $69678d3e0618202337016e1b4ed76965$var$isError;
  $69678d3e0618202337016e1b4ed76965$exports.isError = $69678d3e0618202337016e1b4ed76965$export$isError;
  $69678d3e0618202337016e1b4ed76965$exports.types.isNativeError = $69678d3e0618202337016e1b4ed76965$var$isError;
  $69678d3e0618202337016e1b4ed76965$export$isFunction = $69678d3e0618202337016e1b4ed76965$var$isFunction;
  $69678d3e0618202337016e1b4ed76965$exports.isFunction = $69678d3e0618202337016e1b4ed76965$export$isFunction;
  $69678d3e0618202337016e1b4ed76965$export$isPrimitive = $69678d3e0618202337016e1b4ed76965$var$isPrimitive;
  $69678d3e0618202337016e1b4ed76965$exports.isPrimitive = $69678d3e0618202337016e1b4ed76965$export$isPrimitive;
  $69678d3e0618202337016e1b4ed76965$export$isBuffer = $57f86b62d098d8ba5edd162e212d3b62$exports;
  $69678d3e0618202337016e1b4ed76965$exports.isBuffer = $69678d3e0618202337016e1b4ed76965$export$isBuffer;
  $69678d3e0618202337016e1b4ed76965$var$months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  $69678d3e0618202337016e1b4ed76965$export$log = function () {
    console.log('%s - %s', $69678d3e0618202337016e1b4ed76965$var$timestamp(), $69678d3e0618202337016e1b4ed76965$exports.format.apply($69678d3e0618202337016e1b4ed76965$exports, arguments));
  };

  // log is just a thin wrapper to console.log that prepends a timestamp
  $69678d3e0618202337016e1b4ed76965$exports.log = $69678d3e0618202337016e1b4ed76965$export$log;
  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */

  $69678d3e0618202337016e1b4ed76965$export$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();

  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */
  $69678d3e0618202337016e1b4ed76965$exports.inherits = $69678d3e0618202337016e1b4ed76965$export$inherits;

  $69678d3e0618202337016e1b4ed76965$export$_extend = function (origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !$69678d3e0618202337016e1b4ed76965$var$isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  };

  $69678d3e0618202337016e1b4ed76965$exports._extend = $69678d3e0618202337016e1b4ed76965$export$_extend;
  $69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

  $69678d3e0618202337016e1b4ed76965$export$promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

    if ($69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol && original[$69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol]) {
      var fn = original[$69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol];

      if (typeof fn !== 'function') {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }

      Object.defineProperty(fn, $69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }

    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function (resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      args.push(function (err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });

      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }

      return promise;
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if ($69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol) Object.defineProperty(fn, $69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return Object.defineProperties(fn, $69678d3e0618202337016e1b4ed76965$var$getOwnPropertyDescriptors(original));
  };

  $69678d3e0618202337016e1b4ed76965$exports.promisify = $69678d3e0618202337016e1b4ed76965$export$promisify;
  $69678d3e0618202337016e1b4ed76965$exports.promisify.custom = $69678d3e0618202337016e1b4ed76965$var$kCustomPromisifiedSymbol;
  $69678d3e0618202337016e1b4ed76965$export$callbackify = $69678d3e0618202337016e1b4ed76965$var$callbackify;
  $69678d3e0618202337016e1b4ed76965$exports.callbackify = $69678d3e0618202337016e1b4ed76965$export$callbackify;
}

function $69678d3e0618202337016e1b4ed76965$init() {
  if (!$69678d3e0618202337016e1b4ed76965$executed) {
    $69678d3e0618202337016e1b4ed76965$executed = true;
    $69678d3e0618202337016e1b4ed76965$exec();
  }

  return $69678d3e0618202337016e1b4ed76965$exports;
}

const $ea9c1e38c3e8cca334929a597a084311$var$util_1 = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/@yarnpkg/fslib/lib/NodeFS.js
var $12d39dac46e76cf7bd93ac42e706530e$exports = {};
Object.defineProperty($12d39dac46e76cf7bd93ac42e706530e$exports, "__esModule", {
  value: true
});
var $12d39dac46e76cf7bd93ac42e706530e$export$NodeFS = void 0;
$12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS = $12d39dac46e76cf7bd93ac42e706530e$export$NodeFS;
// ASSET: src/fs.cjs
var $b51e58cb62baab57a1eab33a0ac3b3ad$exports,
    $b51e58cb62baab57a1eab33a0ac3b3ad$var$fs,
    $b51e58cb62baab57a1eab33a0ac3b3ad$export$methods,
    $b51e58cb62baab57a1eab33a0ac3b3ad$var$constants,
    $4b4b2ca65c544aeebbd8703f9d50bd90$executed = false;

function $b51e58cb62baab57a1eab33a0ac3b3ad$var$__override(_fs) {
  $b51e58cb62baab57a1eab33a0ac3b3ad$var$fs = _fs;
}

function $4b4b2ca65c544aeebbd8703f9d50bd90$exec() {
  $b51e58cb62baab57a1eab33a0ac3b3ad$exports = {};
  $b51e58cb62baab57a1eab33a0ac3b3ad$var$fs = {};
  $b51e58cb62baab57a1eab33a0ac3b3ad$export$methods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream", "rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
  $parcel$export($b51e58cb62baab57a1eab33a0ac3b3ad$exports, "methods", function () {
    return $b51e58cb62baab57a1eab33a0ac3b3ad$export$methods;
  });
  $b51e58cb62baab57a1eab33a0ac3b3ad$var$constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4,
    ISUID: 0b100000000000,
    ISGID: 0b10000000000,
    ISVTX: 0b1000000000,
    IRUSR: 0b100000000,
    IWUSR: 0b10000000,
    IXUSR: 0b1000000,
    IRGRP: 0b100000,
    IWGRP: 0b10000,
    IXGRP: 0b1000,
    IROTH: 0b100,
    IWOTH: 0b10,
    IXOTH: 0b1
  };
  $b51e58cb62baab57a1eab33a0ac3b3ad$exports = new Proxy({}, {
    get: (target, prop) => {
      if (prop === "__override") {
        return $b51e58cb62baab57a1eab33a0ac3b3ad$var$__override;
      } else if ($b51e58cb62baab57a1eab33a0ac3b3ad$export$methods.includes(prop)) {
        return (...args) => {
          if ($b51e58cb62baab57a1eab33a0ac3b3ad$var$fs[prop] == null) {
            throw new Error(prop);
          } else {
            return $b51e58cb62baab57a1eab33a0ac3b3ad$var$fs[prop](...args);
          }
        };
      } else if (prop === "constants") {
        return $b51e58cb62baab57a1eab33a0ac3b3ad$var$constants;
      }
    },

    ownKeys() {
      return [...$b51e58cb62baab57a1eab33a0ac3b3ad$export$methods, "constants"];
    },

    getOwnPropertyDescriptor(target, name) {
      return {
        value: this.get(target, name),
        configurable: true,
        enumerable: true
      };
    }

  });
}

function $4b4b2ca65c544aeebbd8703f9d50bd90$init() {
  if (!$4b4b2ca65c544aeebbd8703f9d50bd90$executed) {
    $4b4b2ca65c544aeebbd8703f9d50bd90$executed = true;
    $4b4b2ca65c544aeebbd8703f9d50bd90$exec();
  }

  return $b51e58cb62baab57a1eab33a0ac3b3ad$exports;
}

const $12d39dac46e76cf7bd93ac42e706530e$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
// ASSET: node_modules/@yarnpkg/fslib/lib/FakeFS.js
var $3d7a702246aa4634d36ede659b8d4727$exports = {};
var $3d7a702246aa4634d36ede659b8d4727$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $3d7a702246aa4634d36ede659b8d4727$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($3d7a702246aa4634d36ede659b8d4727$exports, "__esModule", {
  value: true
});
var $3d7a702246aa4634d36ede659b8d4727$export$normalizeLineEndings = ($3d7a702246aa4634d36ede659b8d4727$export$BasePortableFakeFS = ($3d7a702246aa4634d36ede659b8d4727$export$FakeFS = void 0, $3d7a702246aa4634d36ede659b8d4727$exports.FakeFS = $3d7a702246aa4634d36ede659b8d4727$export$FakeFS), $3d7a702246aa4634d36ede659b8d4727$exports.BasePortableFakeFS = $3d7a702246aa4634d36ede659b8d4727$export$BasePortableFakeFS);
$3d7a702246aa4634d36ede659b8d4727$exports.normalizeLineEndings = $3d7a702246aa4634d36ede659b8d4727$export$normalizeLineEndings;
// ASSET: node_modules/@yarnpkg/fslib/lib/algorithms/copyPromise.js
var $857c3fe6581274a65cf3df311c3173b8$exports = {};
Object.defineProperty($857c3fe6581274a65cf3df311c3173b8$exports, "__esModule", {
  value: true
});
var $857c3fe6581274a65cf3df311c3173b8$export$copyPromise = void 0;
$857c3fe6581274a65cf3df311c3173b8$exports.copyPromise = $857c3fe6581274a65cf3df311c3173b8$export$copyPromise;
const $857c3fe6581274a65cf3df311c3173b8$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
// ASSET: node_modules/@yarnpkg/fslib/lib/path.js
var $68fec5135ffa9bcaf015baca3dd61152$exports = {};
var $68fec5135ffa9bcaf015baca3dd61152$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($68fec5135ffa9bcaf015baca3dd61152$exports, "__esModule", {
  value: true
});
var $68fec5135ffa9bcaf015baca3dd61152$export$toFilename = ($68fec5135ffa9bcaf015baca3dd61152$export$convertPath = ($68fec5135ffa9bcaf015baca3dd61152$export$ppath = ($68fec5135ffa9bcaf015baca3dd61152$export$npath = ($68fec5135ffa9bcaf015baca3dd61152$export$Filename = ($68fec5135ffa9bcaf015baca3dd61152$export$PortablePath = void 0, $68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath = $68fec5135ffa9bcaf015baca3dd61152$export$PortablePath), $68fec5135ffa9bcaf015baca3dd61152$exports.Filename = $68fec5135ffa9bcaf015baca3dd61152$export$Filename), $68fec5135ffa9bcaf015baca3dd61152$exports.npath = $68fec5135ffa9bcaf015baca3dd61152$export$npath), $68fec5135ffa9bcaf015baca3dd61152$exports.ppath = $68fec5135ffa9bcaf015baca3dd61152$export$ppath), $68fec5135ffa9bcaf015baca3dd61152$exports.convertPath = $68fec5135ffa9bcaf015baca3dd61152$export$convertPath);
$68fec5135ffa9bcaf015baca3dd61152$exports.toFilename = $68fec5135ffa9bcaf015baca3dd61152$export$toFilename;
// ASSET: node_modules/path-browserify/index.js
var $0111874a9358ffa1d71ad8eb9f6f16f8$exports,
    $0111874a9358ffa1d71ad8eb9f6f16f8$var$process,
    $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix,
    $0111874a9358ffa1d71ad8eb9f6f16f8$executed = false;

function $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
} // Resolves . and .. elements in a path with directory names


// Resolves . and .. elements in a path with directory names
function $0111874a9358ffa1d71ad8eb9f6f16f8$var$normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;

  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length) code = path.charCodeAt(i);else if (code === 47
    /*/*/
    )
      /*/*/
      break;else code = 47
    /*/*/
    ;

    if (code === 47
    /*/*/
    )
      /*/*/
      {
        if (lastSlash === i - 1 || dots === 1) {// NOOP
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
          /*.*/
          ||
          /*.*/
          res.charCodeAt(res.length - 2) !== 46
          /*.*/
          )
            /*.*/
            {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf('/');

                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = '';
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                  }

                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = '';
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }

          if (allowAboveRoot) {
            if (res.length > 0) res += '/..';else res = '..';
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
    /*.*/
    &&
    /*.*/
    dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }

  return res;
}

function $0111874a9358ffa1d71ad8eb9f6f16f8$var$_format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');

  if (!dir) {
    return base;
  }

  if (dir === pathObject.root) {
    return dir + base;
  }

  return dir + sep + base;
}

function $0111874a9358ffa1d71ad8eb9f6f16f8$exec() {
  $0111874a9358ffa1d71ad8eb9f6f16f8$exports = {};
  $0111874a9358ffa1d71ad8eb9f6f16f8$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var resolvedPath = '';
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) path = arguments[i];else {
          if (cwd === undefined) cwd = $0111874a9358ffa1d71ad8eb9f6f16f8$var$process.cwd();
          path = cwd;
        }
        $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path); // Skip empty entries

        // Skip empty entries
        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47
        /*/*/
        ;
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path
      resolvedPath = $0111874a9358ffa1d71ad8eb9f6f16f8$var$normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return '.';
      }
    },
    normalize: function normalize(path) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      if (path.length === 0) return '.';
      var isAbsolute = path.charCodeAt(0) === 47
      /*/*/
      ;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47
      /*/*/
      ; // Normalize the path

      // Normalize the path
      path = $0111874a9358ffa1d71ad8eb9f6f16f8$var$normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) path = '.';
      if (path.length > 0 && trailingSeparator) path += '/';
      if (isAbsolute) return '/' + path;
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47
      /*/*/
      ;
    },
    join: function join() {
      if (arguments.length === 0) return '.';
      var joined;

      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(arg);

        if (arg.length > 0) {
          if (joined === undefined) joined = arg;else joined += '/' + arg;
        }
      }

      if (joined === undefined) return '.';
      return $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix.normalize(joined);
    },
    relative: function relative(from, to) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(from);
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(to);
      if (from === to) return '';
      from = $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix.resolve(from);
      to = $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix.resolve(to);
      if (from === to) return ''; // Trim any leading backslashes

      // Trim any leading backslashes
      var fromStart = 1;

      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47
        /*/*/
        )
          /*/*/
          break;
      }

      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart; // Trim any leading backslashes

      // Trim any leading backslashes
      var toStart = 1;

      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47
        /*/*/
        )
          /*/*/
          break;
      }

      var toEnd = to.length;
      var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

      // Compare paths to find the longest common path from root
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;

      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47
            /*/*/
            )
              /*/*/
              {
                // We get here if `from` is the exact base path for `to`.
                // For example: from='/foo/bar'; to='/foo/bar/baz'
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47
            /*/*/
            )
              /*/*/
              {
                // We get here if `to` is the exact base path for `from`.
                // For example: from='/foo/bar/baz'; to='/foo/bar'
                lastCommonSep = i;
              } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }

          break;
        }

        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;else if (fromCode === 47
        /*/*/
        )
          /*/*/
          lastCommonSep = i;
      }

      var out = ''; // Generate the relative path based on the path difference between `to`
      // and `from`

      // Generate the relative path based on the path difference between `to`
      // and `from`
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47
        /*/*/
        )
          /*/*/
          {
            if (out.length === 0) out += '..';else out += '/..';
          }
      } // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts


      // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts
      if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47
        /*/*/
        )
          /*/*/
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      if (path.length === 0) return '.';
      var code = path.charCodeAt(0);
      var hasRoot = code === 47
      /*/*/
      ;
      var end = -1;
      var matchedSlash = true;

      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        )
          /*/*/
          {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) return hasRoot ? '/' : '.';
      if (hasRoot && end === 1) return '//';
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return '';
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;

        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);

          if (code === 47
          /*/*/
          )
            /*/*/
            {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }

            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47
          /*/*/
          )
            /*/*/
            {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) return '';
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0;

      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        )
          /*/*/
          {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }

            continue;
          }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        )
          /*.*/
          {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return '';
      }

      return path.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== 'object') {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }

      return $0111874a9358ffa1d71ad8eb9f6f16f8$var$_format('/', pathObject);
    },
    parse: function parse(path) {
      $0111874a9358ffa1d71ad8eb9f6f16f8$var$assertPath(path);
      var ret = {
        root: '',
        dir: '',
        base: '',
        ext: '',
        name: ''
      };
      if (path.length === 0) return ret;
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47
      /*/*/
      ;
      var start;

      if (isAbsolute) {
        ret.root = '/';
        start = 1;
      } else {
        start = 0;
      }

      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0; // Get non-dir info

      // Get non-dir info
      for (; i >= start; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        )
          /*/*/
          {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }

            continue;
          }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        )
          /*.*/
          {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }

        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
      return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
  };
  $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix.posix = $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix;
  $0111874a9358ffa1d71ad8eb9f6f16f8$exports = $0111874a9358ffa1d71ad8eb9f6f16f8$var$posix;
}

function $0111874a9358ffa1d71ad8eb9f6f16f8$init() {
  if (!$0111874a9358ffa1d71ad8eb9f6f16f8$executed) {
    $0111874a9358ffa1d71ad8eb9f6f16f8$executed = true;
    $0111874a9358ffa1d71ad8eb9f6f16f8$exec();
  }

  return $0111874a9358ffa1d71ad8eb9f6f16f8$exports;
}

const $68fec5135ffa9bcaf015baca3dd61152$var$path_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($0111874a9358ffa1d71ad8eb9f6f16f8$init());
var $68fec5135ffa9bcaf015baca3dd61152$var$PathType;

(function (PathType) {
  PathType[PathType["File"] = 0] = "File";
  PathType[PathType["Portable"] = 1] = "Portable";
  PathType[PathType["Native"] = 2] = "Native";
})($68fec5135ffa9bcaf015baca3dd61152$var$PathType || ($68fec5135ffa9bcaf015baca3dd61152$var$PathType = {}));

var $68fec5135ffa9bcaf015baca3dd61152$export$PortablePath = {
  root: `/`,
  dot: `.`
};
$68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath = $68fec5135ffa9bcaf015baca3dd61152$export$PortablePath;
var $68fec5135ffa9bcaf015baca3dd61152$export$Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  pnpJs: `.pnp.js`,
  rc: `.yarnrc.yml`
};
$68fec5135ffa9bcaf015baca3dd61152$exports.Filename = $68fec5135ffa9bcaf015baca3dd61152$export$Filename;
var $68fec5135ffa9bcaf015baca3dd61152$export$npath = Object.create($68fec5135ffa9bcaf015baca3dd61152$var$path_1.default);
$68fec5135ffa9bcaf015baca3dd61152$exports.npath = $68fec5135ffa9bcaf015baca3dd61152$export$npath;
var $68fec5135ffa9bcaf015baca3dd61152$export$ppath = Object.create($68fec5135ffa9bcaf015baca3dd61152$var$path_1.default.posix);
$68fec5135ffa9bcaf015baca3dd61152$exports.ppath = $68fec5135ffa9bcaf015baca3dd61152$export$ppath;

$68fec5135ffa9bcaf015baca3dd61152$exports.npath.cwd = () => $68fec5135ffa9bcaf015baca3dd61152$var$process.cwd();

$68fec5135ffa9bcaf015baca3dd61152$exports.ppath.cwd = () => $68fec5135ffa9bcaf015baca3dd61152$var$toPortablePath($68fec5135ffa9bcaf015baca3dd61152$var$process.cwd());

$68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve = (...segments) => {
  if (segments.length > 0 && $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.isAbsolute(segments[0])) {
    return $68fec5135ffa9bcaf015baca3dd61152$var$path_1.default.posix.resolve(...segments);
  } else {
    return $68fec5135ffa9bcaf015baca3dd61152$var$path_1.default.posix.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.cwd(), ...segments);
  }
};

const $68fec5135ffa9bcaf015baca3dd61152$var$contains = function (pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to) return `.`;
  if (!from.endsWith(pathUtils.sep)) from = from + pathUtils.sep;

  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};

$68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath = $68fec5135ffa9bcaf015baca3dd61152$var$fromPortablePath;
$68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath = $68fec5135ffa9bcaf015baca3dd61152$var$toPortablePath;

$68fec5135ffa9bcaf015baca3dd61152$exports.npath.contains = (from, to) => $68fec5135ffa9bcaf015baca3dd61152$var$contains($68fec5135ffa9bcaf015baca3dd61152$exports.npath, from, to);

$68fec5135ffa9bcaf015baca3dd61152$exports.ppath.contains = (from, to) => $68fec5135ffa9bcaf015baca3dd61152$var$contains($68fec5135ffa9bcaf015baca3dd61152$exports.ppath, from, to);

const $68fec5135ffa9bcaf015baca3dd61152$var$WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const $68fec5135ffa9bcaf015baca3dd61152$var$UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
const $68fec5135ffa9bcaf015baca3dd61152$var$PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const $68fec5135ffa9bcaf015baca3dd61152$var$UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/; // Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"

// Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"
function $68fec5135ffa9bcaf015baca3dd61152$var$fromPortablePath(p) {
  if ($68fec5135ffa9bcaf015baca3dd61152$var$process.platform !== `win32`) return p;
  if (p.match($68fec5135ffa9bcaf015baca3dd61152$var$PORTABLE_PATH_REGEXP)) p = p.replace($68fec5135ffa9bcaf015baca3dd61152$var$PORTABLE_PATH_REGEXP, `$1`);else if (p.match($68fec5135ffa9bcaf015baca3dd61152$var$UNC_PORTABLE_PATH_REGEXP)) p = p.replace($68fec5135ffa9bcaf015baca3dd61152$var$UNC_PORTABLE_PATH_REGEXP, (match, p1, p2) => `\\\\${p1 ? `.\\` : ``}${p2}`);else return p;
  return p.replace(/\//g, `\\`);
} // Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"


// Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"
function $68fec5135ffa9bcaf015baca3dd61152$var$toPortablePath(p) {
  if ($68fec5135ffa9bcaf015baca3dd61152$var$process.platform !== `win32`) return p;
  if (p.match($68fec5135ffa9bcaf015baca3dd61152$var$WINDOWS_PATH_REGEXP)) p = p.replace($68fec5135ffa9bcaf015baca3dd61152$var$WINDOWS_PATH_REGEXP, `/$1`);else if (p.match($68fec5135ffa9bcaf015baca3dd61152$var$UNC_WINDOWS_PATH_REGEXP)) p = p.replace($68fec5135ffa9bcaf015baca3dd61152$var$UNC_WINDOWS_PATH_REGEXP, (match, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
  return p.replace(/\\/g, `/`);
}

function $68fec5135ffa9bcaf015baca3dd61152$var$convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === $68fec5135ffa9bcaf015baca3dd61152$exports.npath ? $68fec5135ffa9bcaf015baca3dd61152$var$fromPortablePath(sourcePath) : $68fec5135ffa9bcaf015baca3dd61152$var$toPortablePath(sourcePath);
}

var $68fec5135ffa9bcaf015baca3dd61152$export$convertPath = $68fec5135ffa9bcaf015baca3dd61152$var$convertPath;
$68fec5135ffa9bcaf015baca3dd61152$exports.convertPath = $68fec5135ffa9bcaf015baca3dd61152$export$convertPath;

function $68fec5135ffa9bcaf015baca3dd61152$var$toFilename(filename) {
  if ($68fec5135ffa9bcaf015baca3dd61152$exports.npath.parse(filename).dir !== `` || $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.parse(filename).dir !== ``) throw new Error(`Invalid filename: "${filename}"`);
  return filename;
}

$68fec5135ffa9bcaf015baca3dd61152$export$toFilename = $68fec5135ffa9bcaf015baca3dd61152$var$toFilename;
$68fec5135ffa9bcaf015baca3dd61152$exports.toFilename = $68fec5135ffa9bcaf015baca3dd61152$export$toFilename;
// 1980-01-01, like Fedora
const $857c3fe6581274a65cf3df311c3173b8$var$defaultTime = new Date(315532800 * 1000);

async function $857c3fe6581274a65cf3df311c3173b8$var$copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  await destinationFs.mkdirPromise(destinationFs.pathUtils.dirname(destination), {
    recursive: true
  });
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await $857c3fe6581274a65cf3df311c3173b8$var$copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, opts);

  for (const operation of prelayout) await operation();

  await Promise.all(postlayout.map(operation => {
    return operation();
  }));
}

$857c3fe6581274a65cf3df311c3173b8$export$copyPromise = $857c3fe6581274a65cf3df311c3173b8$var$copyPromise;
$857c3fe6581274a65cf3df311c3173b8$exports.copyPromise = $857c3fe6581274a65cf3df311c3173b8$export$copyPromise;

async function $857c3fe6581274a65cf3df311c3173b8$var$copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b;

  const destinationStat = await $857c3fe6581274a65cf3df311c3173b8$var$maybeLStat(destinationFs, destination);
  const sourceStat = await sourceFs.lstatPromise(source);
  const referenceTime = opts.stableTime ? {
    mtime: $857c3fe6581274a65cf3df311c3173b8$var$defaultTime,
    atime: $857c3fe6581274a65cf3df311c3173b8$var$defaultTime
  } : sourceStat;
  let updated;

  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await $857c3fe6581274a65cf3df311c3173b8$var$copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isFile():
      {
        updated = await $857c3fe6581274a65cf3df311c3173b8$var$copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isSymbolicLink():
      {
        updated = await $857c3fe6581274a65cf3df311c3173b8$var$copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
      break;
  }

  if (updated || ((_a = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.mtime) === null || _a === void 0 ? void 0 : _a.getTime()) !== referenceTime.mtime.getTime() || ((_b = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.atime) === null || _b === void 0 ? void 0 : _b.getTime()) !== referenceTime.atime.getTime()) {
    postlayout.push(() => updateTime(destination, referenceTime.atime, referenceTime.mtime));
    updated = true;
  }

  if (destinationStat === null || (destinationStat.mode & 0o777) !== (sourceStat.mode & 0o777)) {
    postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 0o777));
    updated = true;
  }

  return updated;
}

async function $857c3fe6581274a65cf3df311c3173b8$var$maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}

async function $857c3fe6581274a65cf3df311c3173b8$var$copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  let updated = false;

  if (destinationStat === null) {
    prelayout.push(async () => destinationFs.mkdirPromise(destination, {
      mode: sourceStat.mode
    }));
    updated = true;
  }

  const entries = await sourceFs.readdirPromise(source);

  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await $857c3fe6581274a65cf3df311c3173b8$var$copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async entry => {
      await $857c3fe6581274a65cf3df311c3173b8$var$copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
    }));

    if (entriesUpdateStatus.some(status => status)) {
      updated = true;
    }
  }

  return updated;
}

async function $857c3fe6581274a65cf3df311c3173b8$var$copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  const op = destinationFs === sourceFs ? async () => destinationFs.copyFilePromise(source, destination, $857c3fe6581274a65cf3df311c3173b8$var$fs_1.default.constants.COPYFILE_FICLONE) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
  prelayout.push(async () => op());
  return true;
}

async function $857c3fe6581274a65cf3df311c3173b8$var$copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  prelayout.push(async () => {
    await destinationFs.symlinkPromise($68fec5135ffa9bcaf015baca3dd61152$exports.convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class $3d7a702246aa4634d36ede659b8d4727$var$FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }

  async *genTraversePromise(init, {
    stableSort = false
  } = {}) {
    const stack = [init];

    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);

      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);

        if (stableSort) {
          for (const entry of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }

  async removePromise(p, {
    recursive = true,
    maxRetries = 5
  } = {}) {
    let stat;

    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of await this.readdirPromise(p)) await this.removePromise(this.pathUtils.resolve(p, entry)); // 5 gives 1s worth of retries at worst

      // 5 gives 1s worth of retries at worst
      let t = 0;

      do {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
            if (maxRetries === 0) {
              break;
            } else {
              await new Promise(resolve => setTimeout(resolve, t * 100));
              continue;
            }
          } else {
            throw error;
          }
        }
      } while (t++ < maxRetries);
    } else {
      await this.unlinkPromise(p);
    }
  }

  removeSync(p, {
    recursive = true
  } = {}) {
    let stat;

    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of this.readdirSync(p)) this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }

  async mkdirpPromise(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) await this.chmodPromise(subPath, chmod);

        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  mkdirpSync(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) this.chmodSync(subPath, chmod);

        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  async copyPromise(destination, source, {
    baseFs = this,
    overwrite = true,
    stableSort = false,
    stableTime = false
  } = {}) {
    return await $857c3fe6581274a65cf3df311c3173b8$exports.copyPromise(this, destination, baseFs, source, {
      overwrite,
      stableSort,
      stableTime
    });
  }

  copySync(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);

    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);

      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync($68fec5135ffa9bcaf015baca3dd61152$exports.convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    this.chmodSync(destination, mode);
  }

  async changeFilePromise(p, content, opts = {}) {
    if ($3d7a702246aa4634d36ede659b8d4727$var$Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }

  async changeFileBufferPromise(p, content) {
    let current = $3d7a702246aa4634d36ede659b8d4727$var$Buffer.alloc(0);

    try {
      current = await this.readFilePromise(p);
    } catch (error) {// ignore errors, no big deal
    }

    if ($3d7a702246aa4634d36ede659b8d4727$var$Buffer.compare(current, content) === 0) return;
    await this.writeFilePromise(p, content);
  }

  async changeFileTextPromise(p, content, {
    automaticNewlines
  } = {}) {
    let current = ``;

    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? $3d7a702246aa4634d36ede659b8d4727$var$normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    await this.writeFilePromise(p, normalizedContent);
  }

  changeFileSync(p, content, opts = {}) {
    if ($3d7a702246aa4634d36ede659b8d4727$var$Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }

  changeFileBufferSync(p, content) {
    let current = $3d7a702246aa4634d36ede659b8d4727$var$Buffer.alloc(0);

    try {
      current = this.readFileSync(p);
    } catch (error) {// ignore errors, no big deal
    }

    if ($3d7a702246aa4634d36ede659b8d4727$var$Buffer.compare(current, content) === 0) return;
    this.writeFileSync(p, content);
  }

  changeFileTextSync(p, content, {
    automaticNewlines = false
  } = {}) {
    let current = ``;

    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? $3d7a702246aa4634d36ede659b8d4727$var$normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    this.writeFileSync(p, normalizedContent);
  }

  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }

  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }

  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1000 / 60;
    const startTime = Date.now();
    let fd = null; // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.

    // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.
    const isAlive = async () => {
      let pid;

      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        // If we can't read the file repeatedly, we assume the process was
        // aborted before even writing finishing writing the payload.
        return Date.now() - startTime < 500;
      }

      try {
        // "As a special case, a signal of 0 can be used to test for the
        // existence of a process" - so we check whether it's alive.
        $3d7a702246aa4634d36ede659b8d4727$var$process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };

    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!(await isAlive())) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error) {// No big deal if we can't remove it. Just fallback to wait for
              // it to be eventually released by its owner.
            }
          }

          if (Date.now() - startTime < 60 * 1000) {
            await new Promise(resolve => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }

    await this.writePromise(fd, JSON.stringify([$3d7a702246aa4634d36ede659b8d4727$var$process.pid]));

    try {
      return await callback();
    } finally {
      try {
        // closePromise needs to come before unlinkPromise otherwise another process can attempt
        // to get the file handle after the unlink but before close resuling in
        // EPERM: operation not permitted, open
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {// noop
      }
    }
  }

  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }

  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }

}

var $3d7a702246aa4634d36ede659b8d4727$export$FakeFS = $3d7a702246aa4634d36ede659b8d4727$var$FakeFS;
$3d7a702246aa4634d36ede659b8d4727$exports.FakeFS = $3d7a702246aa4634d36ede659b8d4727$export$FakeFS;
$3d7a702246aa4634d36ede659b8d4727$var$FakeFS.DEFAULT_TIME = 315532800;

class $3d7a702246aa4634d36ede659b8d4727$var$BasePortableFakeFS extends $3d7a702246aa4634d36ede659b8d4727$var$FakeFS {
  constructor() {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.ppath);
  }

}

var $3d7a702246aa4634d36ede659b8d4727$export$BasePortableFakeFS = $3d7a702246aa4634d36ede659b8d4727$var$BasePortableFakeFS;
$3d7a702246aa4634d36ede659b8d4727$exports.BasePortableFakeFS = $3d7a702246aa4634d36ede659b8d4727$export$BasePortableFakeFS;

function $3d7a702246aa4634d36ede659b8d4727$var$getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null) return $0bbf89852e2ec8b574a90d9f54bf96d7$export$EOL;
  const crlf = matches.filter(nl => nl === `\r\n`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r\n` : `\n`;
}

function $3d7a702246aa4634d36ede659b8d4727$var$normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, $3d7a702246aa4634d36ede659b8d4727$var$getEndOfLine(originalContent));
}

$3d7a702246aa4634d36ede659b8d4727$export$normalizeLineEndings = $3d7a702246aa4634d36ede659b8d4727$var$normalizeLineEndings;
$3d7a702246aa4634d36ede659b8d4727$exports.normalizeLineEndings = $3d7a702246aa4634d36ede659b8d4727$export$normalizeLineEndings;
// ASSET: node_modules/@yarnpkg/fslib/lib/errors.js
var $e48497dbe7c3225ab014a812e5154d30$exports = {};
Object.defineProperty($e48497dbe7c3225ab014a812e5154d30$exports, "__esModule", {
  value: true
});
var $e48497dbe7c3225ab014a812e5154d30$export$LibzipError = ($e48497dbe7c3225ab014a812e5154d30$export$ERR_DIR_CLOSED = ($e48497dbe7c3225ab014a812e5154d30$export$EOPNOTSUPP = ($e48497dbe7c3225ab014a812e5154d30$export$ENOTEMPTY = ($e48497dbe7c3225ab014a812e5154d30$export$EROFS = ($e48497dbe7c3225ab014a812e5154d30$export$EEXIST = ($e48497dbe7c3225ab014a812e5154d30$export$EISDIR = ($e48497dbe7c3225ab014a812e5154d30$export$ENOTDIR = ($e48497dbe7c3225ab014a812e5154d30$export$ENOENT = ($e48497dbe7c3225ab014a812e5154d30$export$EBADF = ($e48497dbe7c3225ab014a812e5154d30$export$EINVAL = ($e48497dbe7c3225ab014a812e5154d30$export$ENOSYS = ($e48497dbe7c3225ab014a812e5154d30$export$EBUSY = void 0, $e48497dbe7c3225ab014a812e5154d30$exports.EBUSY = $e48497dbe7c3225ab014a812e5154d30$export$EBUSY), $e48497dbe7c3225ab014a812e5154d30$exports.ENOSYS = $e48497dbe7c3225ab014a812e5154d30$export$ENOSYS), $e48497dbe7c3225ab014a812e5154d30$exports.EINVAL = $e48497dbe7c3225ab014a812e5154d30$export$EINVAL), $e48497dbe7c3225ab014a812e5154d30$exports.EBADF = $e48497dbe7c3225ab014a812e5154d30$export$EBADF), $e48497dbe7c3225ab014a812e5154d30$exports.ENOENT = $e48497dbe7c3225ab014a812e5154d30$export$ENOENT), $e48497dbe7c3225ab014a812e5154d30$exports.ENOTDIR = $e48497dbe7c3225ab014a812e5154d30$export$ENOTDIR), $e48497dbe7c3225ab014a812e5154d30$exports.EISDIR = $e48497dbe7c3225ab014a812e5154d30$export$EISDIR), $e48497dbe7c3225ab014a812e5154d30$exports.EEXIST = $e48497dbe7c3225ab014a812e5154d30$export$EEXIST), $e48497dbe7c3225ab014a812e5154d30$exports.EROFS = $e48497dbe7c3225ab014a812e5154d30$export$EROFS), $e48497dbe7c3225ab014a812e5154d30$exports.ENOTEMPTY = $e48497dbe7c3225ab014a812e5154d30$export$ENOTEMPTY), $e48497dbe7c3225ab014a812e5154d30$exports.EOPNOTSUPP = $e48497dbe7c3225ab014a812e5154d30$export$EOPNOTSUPP), $e48497dbe7c3225ab014a812e5154d30$exports.ERR_DIR_CLOSED = $e48497dbe7c3225ab014a812e5154d30$export$ERR_DIR_CLOSED);
$e48497dbe7c3225ab014a812e5154d30$exports.LibzipError = $e48497dbe7c3225ab014a812e5154d30$export$LibzipError;

function $e48497dbe7c3225ab014a812e5154d30$var$makeError(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {
    code
  });
}

function $e48497dbe7c3225ab014a812e5154d30$var$EBUSY(message) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EBUSY`, message);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EBUSY = $e48497dbe7c3225ab014a812e5154d30$var$EBUSY;
$e48497dbe7c3225ab014a812e5154d30$exports.EBUSY = $e48497dbe7c3225ab014a812e5154d30$export$EBUSY;

function $e48497dbe7c3225ab014a812e5154d30$var$ENOSYS(message, reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`ENOSYS`, `${message}, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$ENOSYS = $e48497dbe7c3225ab014a812e5154d30$var$ENOSYS;
$e48497dbe7c3225ab014a812e5154d30$exports.ENOSYS = $e48497dbe7c3225ab014a812e5154d30$export$ENOSYS;

function $e48497dbe7c3225ab014a812e5154d30$var$EINVAL(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EINVAL`, `invalid argument, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EINVAL = $e48497dbe7c3225ab014a812e5154d30$var$EINVAL;
$e48497dbe7c3225ab014a812e5154d30$exports.EINVAL = $e48497dbe7c3225ab014a812e5154d30$export$EINVAL;

function $e48497dbe7c3225ab014a812e5154d30$var$EBADF(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EBADF`, `bad file descriptor, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EBADF = $e48497dbe7c3225ab014a812e5154d30$var$EBADF;
$e48497dbe7c3225ab014a812e5154d30$exports.EBADF = $e48497dbe7c3225ab014a812e5154d30$export$EBADF;

function $e48497dbe7c3225ab014a812e5154d30$var$ENOENT(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`ENOENT`, `no such file or directory, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$ENOENT = $e48497dbe7c3225ab014a812e5154d30$var$ENOENT;
$e48497dbe7c3225ab014a812e5154d30$exports.ENOENT = $e48497dbe7c3225ab014a812e5154d30$export$ENOENT;

function $e48497dbe7c3225ab014a812e5154d30$var$ENOTDIR(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`ENOTDIR`, `not a directory, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$ENOTDIR = $e48497dbe7c3225ab014a812e5154d30$var$ENOTDIR;
$e48497dbe7c3225ab014a812e5154d30$exports.ENOTDIR = $e48497dbe7c3225ab014a812e5154d30$export$ENOTDIR;

function $e48497dbe7c3225ab014a812e5154d30$var$EISDIR(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EISDIR = $e48497dbe7c3225ab014a812e5154d30$var$EISDIR;
$e48497dbe7c3225ab014a812e5154d30$exports.EISDIR = $e48497dbe7c3225ab014a812e5154d30$export$EISDIR;

function $e48497dbe7c3225ab014a812e5154d30$var$EEXIST(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EEXIST`, `file already exists, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EEXIST = $e48497dbe7c3225ab014a812e5154d30$var$EEXIST;
$e48497dbe7c3225ab014a812e5154d30$exports.EEXIST = $e48497dbe7c3225ab014a812e5154d30$export$EEXIST;

function $e48497dbe7c3225ab014a812e5154d30$var$EROFS(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EROFS`, `read-only filesystem, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EROFS = $e48497dbe7c3225ab014a812e5154d30$var$EROFS;
$e48497dbe7c3225ab014a812e5154d30$exports.EROFS = $e48497dbe7c3225ab014a812e5154d30$export$EROFS;

function $e48497dbe7c3225ab014a812e5154d30$var$ENOTEMPTY(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$ENOTEMPTY = $e48497dbe7c3225ab014a812e5154d30$var$ENOTEMPTY;
$e48497dbe7c3225ab014a812e5154d30$exports.ENOTEMPTY = $e48497dbe7c3225ab014a812e5154d30$export$ENOTEMPTY;

function $e48497dbe7c3225ab014a812e5154d30$var$EOPNOTSUPP(reason) {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`EOPNOTSUPP`, `operation not supported, ${reason}`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$EOPNOTSUPP = $e48497dbe7c3225ab014a812e5154d30$var$EOPNOTSUPP;
$e48497dbe7c3225ab014a812e5154d30$exports.EOPNOTSUPP = $e48497dbe7c3225ab014a812e5154d30$export$EOPNOTSUPP; // ------------------------------------------------------------------------

// ------------------------------------------------------------------------
function $e48497dbe7c3225ab014a812e5154d30$var$ERR_DIR_CLOSED() {
  return $e48497dbe7c3225ab014a812e5154d30$var$makeError(`ERR_DIR_CLOSED`, `Directory handle was closed`);
}

var $e48497dbe7c3225ab014a812e5154d30$export$ERR_DIR_CLOSED = $e48497dbe7c3225ab014a812e5154d30$var$ERR_DIR_CLOSED;
$e48497dbe7c3225ab014a812e5154d30$exports.ERR_DIR_CLOSED = $e48497dbe7c3225ab014a812e5154d30$export$ERR_DIR_CLOSED; // ------------------------------------------------------------------------

// ------------------------------------------------------------------------
class $e48497dbe7c3225ab014a812e5154d30$var$LibzipError extends Error {
  constructor(message, code) {
    super(message);
    this.name = `Libzip Error`;
    this.code = code;
  }

}

$e48497dbe7c3225ab014a812e5154d30$export$LibzipError = $e48497dbe7c3225ab014a812e5154d30$var$LibzipError;
$e48497dbe7c3225ab014a812e5154d30$exports.LibzipError = $e48497dbe7c3225ab014a812e5154d30$export$LibzipError;

class $12d39dac46e76cf7bd93ac42e706530e$var$NodeFS extends $3d7a702246aa4634d36ede659b8d4727$exports.BasePortableFakeFS {
  constructor(realFs = $12d39dac46e76cf7bd93ac42e706530e$var$fs_1.default) {
    super();
    this.realFs = realFs; // @ts-expect-error

    // @ts-expect-error
    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }

  getExtractHint() {
    return false;
  }

  getRealPath() {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root;
  }

  resolve(p) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve(p);
  }

  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }

  openSync(p, flags, mode) {
    return this.realFs.openSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then(dir => {
      return Object.defineProperty(dir, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
    });
  }

  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts) : this.realFs.opendirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
  }

  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }

  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }

  closeSync(fd) {
    this.realFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    const realPath = p !== null ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }

  createWriteStream(p, opts) {
    const realPath = p !== null ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }

  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then(path => {
      return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath(path);
    });
  }

  realpathSync(p) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath(this.realFs.realpathSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), {}));
  }

  async existsPromise(p) {
    return await new Promise(resolve => {
      this.realFs.exists($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), resolve);
    });
  }

  accessSync(p, mode) {
    return this.realFs.accessSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), mode);
  }

  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }

  existsSync(p) {
    return this.realFs.existsSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
  }

  async statPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.stat($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  statSync(p) {
    return this.realFs.statSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
  }

  async lstatPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.lstat($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  lstatSync(p) {
    return this.realFs.lstatSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
  }

  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }

  chmodSync(p, mask) {
    return this.realFs.chmodSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }

  chownSync(p, uid, gid) {
    return this.realFs.chownSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(oldP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  renameSync(oldP, newP) {
    return this.realFs.renameSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(oldP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(sourceP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(sourceP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }

  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }

  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  unlinkSync(p) {
    return this.realFs.unlinkSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), atime, mtime);
  }

  async lutimesPromiseImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`) throw $e48497dbe7c3225ab014a812e5154d30$exports.ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  lutimesSyncImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`) throw $e48497dbe7c3225ab014a812e5154d30$exports.ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }

  mkdirSync(p, opts) {
    return this.realFs.mkdirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts);
  }

  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      // TODO: always pass opts when min node version is 12.10+
      if (opts) {
        this.realFs.rmdir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }

  rmdirSync(p, opts) {
    return this.realFs.rmdirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), opts);
  }

  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(existingP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  linkSync(existingP, newP) {
    return this.realFs.linkSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(existingP), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(newP));
  }

  async symlinkPromise(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return await new Promise((resolve, reject) => {
      this.realFs.symlink($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(target.replace(/\/+$/, ``)), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), symlinkType, this.makeCallback(resolve, reject));
    });
  }

  symlinkSync(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return this.realFs.symlinkSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(target.replace(/\/+$/, ``)), $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), symlinkType);
  }

  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }

  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await new Promise((resolve, reject) => {
      if (withFileTypes) {
        this.realFs.readdir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), {
          withFileTypes: true
        }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(value => resolve(value), reject));
      }
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    if (withFileTypes) {
      return this.realFs.readdirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), {
        withFileTypes: true
      });
    } else {
      return this.realFs.readdirSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p));
    }
  }

  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then(path => {
      return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath(path);
    });
  }

  readlinkSync(p) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath(this.realFs.readlinkSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p)));
  }

  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }

  truncateSync(p, len) {
    return this.realFs.truncateSync($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), len);
  }

  watch(p, a, b) {
    return this.realFs.watch($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.realFs.watchFile($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.realFs.unwatchFile($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(p), cb);
  }

  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }

}

$12d39dac46e76cf7bd93ac42e706530e$export$NodeFS = $12d39dac46e76cf7bd93ac42e706530e$var$NodeFS;
$12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS = $12d39dac46e76cf7bd93ac42e706530e$export$NodeFS;
// ASSET: node_modules/@yarnpkg/fslib/lib/statUtils.js
var $0be3cf17f95cc3f98aedc294fb6f7f45$exports = {};
Object.defineProperty($0be3cf17f95cc3f98aedc294fb6f7f45$exports, "__esModule", {
  value: true
});
var $0be3cf17f95cc3f98aedc294fb6f7f45$export$areStatsEqual = ($0be3cf17f95cc3f98aedc294fb6f7f45$export$makeEmptyStats = ($0be3cf17f95cc3f98aedc294fb6f7f45$export$makeDefaultStats = ($0be3cf17f95cc3f98aedc294fb6f7f45$export$StatEntry = ($0be3cf17f95cc3f98aedc294fb6f7f45$export$DirEntry = void 0, $0be3cf17f95cc3f98aedc294fb6f7f45$exports.DirEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$export$DirEntry), $0be3cf17f95cc3f98aedc294fb6f7f45$exports.StatEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$export$StatEntry), $0be3cf17f95cc3f98aedc294fb6f7f45$exports.makeDefaultStats = $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeDefaultStats), $0be3cf17f95cc3f98aedc294fb6f7f45$exports.makeEmptyStats = $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeEmptyStats);
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.areStatsEqual = $0be3cf17f95cc3f98aedc294fb6f7f45$export$areStatsEqual;
// ASSET: node_modules/@yarnpkg/fslib/lib/constants.js
var $7fb32670047e8d9f167a62d4977192ea$exports = {};
Object.defineProperty($7fb32670047e8d9f167a62d4977192ea$exports, "__esModule", {
  value: true
});
var $7fb32670047e8d9f167a62d4977192ea$export$S_IFLNK = ($7fb32670047e8d9f167a62d4977192ea$export$S_IFREG = ($7fb32670047e8d9f167a62d4977192ea$export$S_IFDIR = ($7fb32670047e8d9f167a62d4977192ea$export$S_IFMT = void 0, $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT = $7fb32670047e8d9f167a62d4977192ea$export$S_IFMT), $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR = $7fb32670047e8d9f167a62d4977192ea$export$S_IFDIR), $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG = $7fb32670047e8d9f167a62d4977192ea$export$S_IFREG);
$7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK = $7fb32670047e8d9f167a62d4977192ea$export$S_IFLNK;
var $7fb32670047e8d9f167a62d4977192ea$export$S_IFMT = 0o170000;
$7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT = $7fb32670047e8d9f167a62d4977192ea$export$S_IFMT;
var $7fb32670047e8d9f167a62d4977192ea$export$S_IFDIR = 0o040000;
$7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR = $7fb32670047e8d9f167a62d4977192ea$export$S_IFDIR;
var $7fb32670047e8d9f167a62d4977192ea$export$S_IFREG = 0o100000;
$7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG = $7fb32670047e8d9f167a62d4977192ea$export$S_IFREG;
$7fb32670047e8d9f167a62d4977192ea$export$S_IFLNK = 0o120000;
$7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK = $7fb32670047e8d9f167a62d4977192ea$export$S_IFLNK;

class $0be3cf17f95cc3f98aedc294fb6f7f45$var$DirEntry {
  constructor() {
    this.name = ``;
    this.mode = 0;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK;
  }

}

var $0be3cf17f95cc3f98aedc294fb6f7f45$export$DirEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$var$DirEntry;
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.DirEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$export$DirEntry;

class $0be3cf17f95cc3f98aedc294fb6f7f45$var$StatEntry {
  constructor() {
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 1;
    this.rdev = 0;
    this.blocks = 1;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK;
  }

}

var $0be3cf17f95cc3f98aedc294fb6f7f45$export$StatEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$var$StatEntry;
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.StatEntry = $0be3cf17f95cc3f98aedc294fb6f7f45$export$StatEntry;

function $0be3cf17f95cc3f98aedc294fb6f7f45$var$makeDefaultStats() {
  return Object.assign(new $0be3cf17f95cc3f98aedc294fb6f7f45$var$StatEntry(), {
    uid: 0,
    gid: 0,
    size: 0,
    blksize: 0,
    atimeMs: 0,
    mtimeMs: 0,
    ctimeMs: 0,
    birthtimeMs: 0,
    atime: new Date(0),
    mtime: new Date(0),
    ctime: new Date(0),
    birthtime: new Date(0),
    mode: $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG | 0o644
  });
}

var $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeDefaultStats = $0be3cf17f95cc3f98aedc294fb6f7f45$var$makeDefaultStats;
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.makeDefaultStats = $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeDefaultStats;

function $0be3cf17f95cc3f98aedc294fb6f7f45$var$makeEmptyStats() {
  return Object.assign($0be3cf17f95cc3f98aedc294fb6f7f45$var$makeDefaultStats(), {
    nlink: 0,
    blocks: 0,
    mode: 0
  });
}

var $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeEmptyStats = $0be3cf17f95cc3f98aedc294fb6f7f45$var$makeEmptyStats;
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.makeEmptyStats = $0be3cf17f95cc3f98aedc294fb6f7f45$export$makeEmptyStats;

function $0be3cf17f95cc3f98aedc294fb6f7f45$var$areStatsEqual(a, b) {
  if (a.atimeMs !== b.atimeMs) return false;
  if (a.birthtimeMs !== b.birthtimeMs) return false;
  if (a.blksize !== b.blksize) return false;
  if (a.blocks !== b.blocks) return false;
  if (a.ctimeMs !== b.ctimeMs) return false;
  if (a.dev !== b.dev) return false;
  if (a.gid !== b.gid) return false;
  if (a.ino !== b.ino) return false;
  if (a.isBlockDevice() !== b.isBlockDevice()) return false;
  if (a.isCharacterDevice() !== b.isCharacterDevice()) return false;
  if (a.isDirectory() !== b.isDirectory()) return false;
  if (a.isFIFO() !== b.isFIFO()) return false;
  if (a.isFile() !== b.isFile()) return false;
  if (a.isSocket() !== b.isSocket()) return false;
  if (a.isSymbolicLink() !== b.isSymbolicLink()) return false;
  if (a.mode !== b.mode) return false;
  if (a.mtimeMs !== b.mtimeMs) return false;
  if (a.nlink !== b.nlink) return false;
  if (a.rdev !== b.rdev) return false;
  if (a.size !== b.size) return false;
  if (a.uid !== b.uid) return false;
  return true;
}

$0be3cf17f95cc3f98aedc294fb6f7f45$export$areStatsEqual = $0be3cf17f95cc3f98aedc294fb6f7f45$var$areStatsEqual;
$0be3cf17f95cc3f98aedc294fb6f7f45$exports.areStatsEqual = $0be3cf17f95cc3f98aedc294fb6f7f45$export$areStatsEqual;
const $ea9c1e38c3e8cca334929a597a084311$var$statUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($0be3cf17f95cc3f98aedc294fb6f7f45$exports);
var $ea9c1e38c3e8cca334929a597a084311$export$statUtils = $ea9c1e38c3e8cca334929a597a084311$var$statUtils;
$ea9c1e38c3e8cca334929a597a084311$exports.statUtils = $ea9c1e38c3e8cca334929a597a084311$export$statUtils;
// ASSET: node_modules/@yarnpkg/fslib/lib/algorithms/opendir.js
var $8a2b416ad49313b6a58ccb22c63fdf6d$exports = {};
Object.defineProperty($8a2b416ad49313b6a58ccb22c63fdf6d$exports, "__esModule", {
  value: true
});
var $8a2b416ad49313b6a58ccb22c63fdf6d$export$opendir = ($8a2b416ad49313b6a58ccb22c63fdf6d$export$CustomDir = void 0, $8a2b416ad49313b6a58ccb22c63fdf6d$exports.CustomDir = $8a2b416ad49313b6a58ccb22c63fdf6d$export$CustomDir);
$8a2b416ad49313b6a58ccb22c63fdf6d$exports.opendir = $8a2b416ad49313b6a58ccb22c63fdf6d$export$opendir;
const $8a2b416ad49313b6a58ccb22c63fdf6d$var$errors = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($e48497dbe7c3225ab014a812e5154d30$exports);

class $8a2b416ad49313b6a58ccb22c63fdf6d$var$CustomDir {
  constructor(path, nextDirent, opts = {}) {
    this.path = path;
    this.nextDirent = nextDirent;
    this.opts = opts;
    this.closed = false;
  }

  throwIfClosed() {
    if (this.closed) {
      throw $8a2b416ad49313b6a58ccb22c63fdf6d$var$errors.ERR_DIR_CLOSED();
    }
  }

  async *[Symbol.asyncIterator]() {
    try {
      let dirent; // eslint-disable-next-line no-cond-assign

      // eslint-disable-next-line no-cond-assign
      while ((dirent = await this.read()) !== null) {
        yield dirent;
      }
    } finally {
      await this.close();
    }
  }

  read(cb) {
    const dirent = this.readSync();
    if (typeof cb !== `undefined`) return cb(null, dirent);
    return Promise.resolve(dirent);
  }

  readSync() {
    this.throwIfClosed();
    return this.nextDirent();
  }

  close(cb) {
    this.closeSync();
    if (typeof cb !== `undefined`) return cb(null);
    return Promise.resolve();
  }

  closeSync() {
    var _a, _b;

    this.throwIfClosed();
    (_b = (_a = this.opts).onClose) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.closed = true;
  }

}

var $8a2b416ad49313b6a58ccb22c63fdf6d$export$CustomDir = $8a2b416ad49313b6a58ccb22c63fdf6d$var$CustomDir;
$8a2b416ad49313b6a58ccb22c63fdf6d$exports.CustomDir = $8a2b416ad49313b6a58ccb22c63fdf6d$export$CustomDir;

function $8a2b416ad49313b6a58ccb22c63fdf6d$var$opendir(fakeFs, path, entries, opts) {
  const nextDirent = () => {
    const filename = entries.shift();
    if (typeof filename === `undefined`) return null;
    return Object.assign(fakeFs.statSync(fakeFs.pathUtils.join(path, filename)), {
      name: filename
    });
  };

  return new $8a2b416ad49313b6a58ccb22c63fdf6d$var$CustomDir(path, nextDirent, opts);
}

$8a2b416ad49313b6a58ccb22c63fdf6d$export$opendir = $8a2b416ad49313b6a58ccb22c63fdf6d$var$opendir;
$8a2b416ad49313b6a58ccb22c63fdf6d$exports.opendir = $8a2b416ad49313b6a58ccb22c63fdf6d$export$opendir;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "opendir", {
  enumerable: true,
  get: function () {
    return $8a2b416ad49313b6a58ccb22c63fdf6d$exports.opendir;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "normalizeLineEndings", {
  enumerable: true,
  get: function () {
    return $3d7a702246aa4634d36ede659b8d4727$exports.normalizeLineEndings;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/ZipFS.js
var $96dc529002d169e2098dfb4902acf701$exports = {};
var $96dc529002d169e2098dfb4902acf701$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($96dc529002d169e2098dfb4902acf701$exports, "__esModule", {
  value: true
});
var $96dc529002d169e2098dfb4902acf701$export$ZipFS = ($96dc529002d169e2098dfb4902acf701$export$DEFAULT_COMPRESSION_LEVEL = void 0, $96dc529002d169e2098dfb4902acf701$exports.DEFAULT_COMPRESSION_LEVEL = $96dc529002d169e2098dfb4902acf701$export$DEFAULT_COMPRESSION_LEVEL);
$96dc529002d169e2098dfb4902acf701$exports.ZipFS = $96dc529002d169e2098dfb4902acf701$export$ZipFS;
const $96dc529002d169e2098dfb4902acf701$var$fs_1 = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
// ASSET: node_modules/readable-stream/readable-browser.js
var $77f1f3b73e58a1193c01fee8e7b8ba28$cjs_exports,
    $77f1f3b73e58a1193c01fee8e7b8ba28$exports = {};
// ASSET: node_modules/events/events.js
var $2bae5ce106cac4278e8cb55eab7c7380$exports = {};
var $2bae5ce106cac4278e8cb55eab7c7380$var$R = typeof Reflect === 'object' ? Reflect : null;
var $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectApply = $2bae5ce106cac4278e8cb55eab7c7380$var$R && typeof $2bae5ce106cac4278e8cb55eab7c7380$var$R.apply === 'function' ? $2bae5ce106cac4278e8cb55eab7c7380$var$R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectOwnKeys;

if ($2bae5ce106cac4278e8cb55eab7c7380$var$R && typeof $2bae5ce106cac4278e8cb55eab7c7380$var$R.ownKeys === 'function') {
  $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectOwnKeys = $2bae5ce106cac4278e8cb55eab7c7380$var$R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function $2bae5ce106cac4278e8cb55eab7c7380$var$ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var $2bae5ce106cac4278e8cb55eab7c7380$var$NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter() {
  $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.init.call(this);
}

$2bae5ce106cac4278e8cb55eab7c7380$exports = $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter;
var $2bae5ce106cac4278e8cb55eab7c7380$export$once = $2bae5ce106cac4278e8cb55eab7c7380$var$once;
$2bae5ce106cac4278e8cb55eab7c7380$exports.once = $2bae5ce106cac4278e8cb55eab7c7380$export$once; // Backwards-compat with node 0.10.x

// Backwards-compat with node 0.10.x
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.EventEmitter = $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter;
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype._events = undefined;
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype._eventsCount = 0;
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var $2bae5ce106cac4278e8cb55eab7c7380$var$defaultMaxListeners = 10;

function $2bae5ce106cac4278e8cb55eab7c7380$var$checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty($2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return $2bae5ce106cac4278e8cb55eab7c7380$var$defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || $2bae5ce106cac4278e8cb55eab7c7380$var$NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    $2bae5ce106cac4278e8cb55eab7c7380$var$defaultMaxListeners = arg;
  }
});

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || $2bae5ce106cac4278e8cb55eab7c7380$var$NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$_getMaxListeners(that) {
  if (that._maxListeners === undefined) return $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $2bae5ce106cac4278e8cb55eab7c7380$var$_getMaxListeners(this);
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = $2bae5ce106cac4278e8cb55eab7c7380$var$arrayClone(handler, len);

    for (var i = 0; i < len; ++i) $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectApply(listeners[i], this, args);
  }

  return true;
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$_addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  $2bae5ce106cac4278e8cb55eab7c7380$var$checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    // Check for listener leak
    m = $2bae5ce106cac4278e8cb55eab7c7380$var$_getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      $2bae5ce106cac4278e8cb55eab7c7380$var$ProcessEmitWarning(w);
    }
  }

  return target;
}

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.addListener = function addListener(type, listener) {
  return $2bae5ce106cac4278e8cb55eab7c7380$var$_addListener(this, type, listener, false);
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.on = $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.addListener;

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return $2bae5ce106cac4278e8cb55eab7c7380$var$_addListener(this, type, listener, true);
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function $2bae5ce106cac4278e8cb55eab7c7380$var$_onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = $2bae5ce106cac4278e8cb55eab7c7380$var$onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.once = function once(type, listener) {
  $2bae5ce106cac4278e8cb55eab7c7380$var$checkListener(listener);
  this.on(type, $2bae5ce106cac4278e8cb55eab7c7380$var$_onceWrap(this, type, listener));
  return this;
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  $2bae5ce106cac4278e8cb55eab7c7380$var$checkListener(listener);
  this.prependListener(type, $2bae5ce106cac4278e8cb55eab7c7380$var$_onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


// Emits a 'removeListener' event if and only if the listener was removed.
$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  $2bae5ce106cac4278e8cb55eab7c7380$var$checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      $2bae5ce106cac4278e8cb55eab7c7380$var$spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.off = $2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.removeListener;

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$_listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? $2bae5ce106cac4278e8cb55eab7c7380$var$unwrapListeners(evlistener) : $2bae5ce106cac4278e8cb55eab7c7380$var$arrayClone(evlistener, evlistener.length);
}

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.listeners = function listeners(type) {
  return $2bae5ce106cac4278e8cb55eab7c7380$var$_listeners(this, type, true);
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return $2bae5ce106cac4278e8cb55eab7c7380$var$_listeners(this, type, false);
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return $2bae5ce106cac4278e8cb55eab7c7380$var$listenerCount.call(emitter, type);
  }
};

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.listenerCount = $2bae5ce106cac4278e8cb55eab7c7380$var$listenerCount;

function $2bae5ce106cac4278e8cb55eab7c7380$var$listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

$2bae5ce106cac4278e8cb55eab7c7380$var$EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? $2bae5ce106cac4278e8cb55eab7c7380$var$ReflectOwnKeys(this._events) : [];
};

function $2bae5ce106cac4278e8cb55eab7c7380$var$arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function $2bae5ce106cac4278e8cb55eab7c7380$var$spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function $2bae5ce106cac4278e8cb55eab7c7380$var$unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function $2bae5ce106cac4278e8cb55eab7c7380$var$once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

// ASSET: node_modules/readable-stream/lib/internal/streams/stream-browser.js
var $bbc98a712e7b59e43db394c1c9638888$exports,
    $bbc98a712e7b59e43db394c1c9638888$executed = false;

function $bbc98a712e7b59e43db394c1c9638888$exec() {
  $bbc98a712e7b59e43db394c1c9638888$exports = {};
  $bbc98a712e7b59e43db394c1c9638888$exports = $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter;
}

function $bbc98a712e7b59e43db394c1c9638888$init() {
  if (!$bbc98a712e7b59e43db394c1c9638888$executed) {
    $bbc98a712e7b59e43db394c1c9638888$executed = true;
    $bbc98a712e7b59e43db394c1c9638888$exec();
  }

  return $bbc98a712e7b59e43db394c1c9638888$exports;
}

// ASSET: node_modules/readable-stream/lib/internal/streams/buffer_list.js
var $8b1e4502124440ec13f9215790905328$exports = {};

function $8b1e4502124440ec13f9215790905328$var$ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function $8b1e4502124440ec13f9215790905328$var$_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      $8b1e4502124440ec13f9215790905328$var$ownKeys(Object(source), true).forEach(function (key) {
        $8b1e4502124440ec13f9215790905328$var$_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      $8b1e4502124440ec13f9215790905328$var$ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function $8b1e4502124440ec13f9215790905328$var$_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function $8b1e4502124440ec13f9215790905328$var$_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function $8b1e4502124440ec13f9215790905328$var$_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function $8b1e4502124440ec13f9215790905328$var$_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) $8b1e4502124440ec13f9215790905328$var$_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) $8b1e4502124440ec13f9215790905328$var$_defineProperties(Constructor, staticProps);
  return Constructor;
}

var $8b1e4502124440ec13f9215790905328$var$_require = $4bb8553ea3f2a3c18bc67044f716b1cc$init(),
    $8b1e4502124440ec13f9215790905328$var$Buffer = $8b1e4502124440ec13f9215790905328$var$_require.Buffer;
var $8b1e4502124440ec13f9215790905328$var$_require2 = {},
    $8b1e4502124440ec13f9215790905328$var$inspect = $8b1e4502124440ec13f9215790905328$var$_require2.inspect;
var $8b1e4502124440ec13f9215790905328$var$custom = $8b1e4502124440ec13f9215790905328$var$inspect && $8b1e4502124440ec13f9215790905328$var$inspect.custom || 'inspect';

function $8b1e4502124440ec13f9215790905328$var$copyBuffer(src, target, offset) {
  $8b1e4502124440ec13f9215790905328$var$Buffer.prototype.copy.call(src, target, offset);
}

$8b1e4502124440ec13f9215790905328$exports = /*#__PURE__*/function () {
  function BufferList() {
    $8b1e4502124440ec13f9215790905328$var$_classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  $8b1e4502124440ec13f9215790905328$var$_createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return $8b1e4502124440ec13f9215790905328$var$Buffer.alloc(0);
      var ret = $8b1e4502124440ec13f9215790905328$var$Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        $8b1e4502124440ec13f9215790905328$var$copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = $8b1e4502124440ec13f9215790905328$var$Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: $8b1e4502124440ec13f9215790905328$var$custom,
    value: function value(_, options) {
      return $8b1e4502124440ec13f9215790905328$var$inspect(this, $8b1e4502124440ec13f9215790905328$var$_objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

// ASSET: node_modules/readable-stream/lib/internal/streams/destroy.js
var $5aa3e98abd1a522a9b1e072175fe86f5$exports,
    $5aa3e98abd1a522a9b1e072175fe86f5$var$process,
    $5aa3e98abd1a522a9b1e072175fe86f5$executed = false;

// undocumented cb() API, needed for core, not for public API
function $5aa3e98abd1a522a9b1e072175fe86f5$var$destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks
  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorAndCloseNT, _this, err);
      } else {
        $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitCloseNT, _this);
      }
    } else if (cb) {
      $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitCloseNT, _this);
      cb(err);
    } else {
      $5aa3e98abd1a522a9b1e072175fe86f5$var$process.nextTick($5aa3e98abd1a522a9b1e072175fe86f5$var$emitCloseNT, _this);
    }
  });

  return this;
}

function $5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorAndCloseNT(self, err) {
  $5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorNT(self, err);
  $5aa3e98abd1a522a9b1e072175fe86f5$var$emitCloseNT(self);
}

function $5aa3e98abd1a522a9b1e072175fe86f5$var$emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function $5aa3e98abd1a522a9b1e072175fe86f5$var$undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function $5aa3e98abd1a522a9b1e072175fe86f5$var$emitErrorNT(self, err) {
  self.emit('error', err);
}

function $5aa3e98abd1a522a9b1e072175fe86f5$var$errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

function $5aa3e98abd1a522a9b1e072175fe86f5$exec() {
  $5aa3e98abd1a522a9b1e072175fe86f5$exports = {};
  $5aa3e98abd1a522a9b1e072175fe86f5$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $5aa3e98abd1a522a9b1e072175fe86f5$exports = {
    destroy: $5aa3e98abd1a522a9b1e072175fe86f5$var$destroy,
    undestroy: $5aa3e98abd1a522a9b1e072175fe86f5$var$undestroy,
    errorOrDestroy: $5aa3e98abd1a522a9b1e072175fe86f5$var$errorOrDestroy
  };
}

function $5aa3e98abd1a522a9b1e072175fe86f5$init() {
  if (!$5aa3e98abd1a522a9b1e072175fe86f5$executed) {
    $5aa3e98abd1a522a9b1e072175fe86f5$executed = true;
    $5aa3e98abd1a522a9b1e072175fe86f5$exec();
  }

  return $5aa3e98abd1a522a9b1e072175fe86f5$exports;
}

// ASSET: node_modules/readable-stream/errors-browser.js
var $ce1e48c839fd190a908ad6f8f735675a$exports,
    $ce1e48c839fd190a908ad6f8f735675a$var$codes,
    $ce1e48c839fd190a908ad6f8f735675a$export$codes,
    $ce1e48c839fd190a908ad6f8f735675a$executed = false;

function $ce1e48c839fd190a908ad6f8f735675a$var$_inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    $ce1e48c839fd190a908ad6f8f735675a$var$_inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  $ce1e48c839fd190a908ad6f8f735675a$var$codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function $ce1e48c839fd190a908ad6f8f735675a$var$oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function $ce1e48c839fd190a908ad6f8f735675a$var$startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function $ce1e48c839fd190a908ad6f8f735675a$var$endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function $ce1e48c839fd190a908ad6f8f735675a$var$includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

function $ce1e48c839fd190a908ad6f8f735675a$exec() {
  $ce1e48c839fd190a908ad6f8f735675a$exports = {};
  $ce1e48c839fd190a908ad6f8f735675a$var$codes = {};
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;

    if (typeof expected === 'string' && $ce1e48c839fd190a908ad6f8f735675a$var$startsWith(expected, 'not ')) {
      determiner = 'must not be';
      expected = expected.replace(/^not /, '');
    } else {
      determiner = 'must be';
    }

    var msg;

    if ($ce1e48c839fd190a908ad6f8f735675a$var$endsWith(name, ' argument')) {
      // For cases like 'first argument'
      msg = "The ".concat(name, " ").concat(determiner, " ").concat($ce1e48c839fd190a908ad6f8f735675a$var$oneOf(expected, 'type'));
    } else {
      var type = $ce1e48c839fd190a908ad6f8f735675a$var$includes(name, '.') ? 'property' : 'argument';
      msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat($ce1e48c839fd190a908ad6f8f735675a$var$oneOf(expected, 'type'));
    }

    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
    return 'The ' + name + ' method is not implemented';
  });
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_DESTROYED', function (name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
  });
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
    return 'Unknown encoding: ' + arg;
  }, TypeError);
  $ce1e48c839fd190a908ad6f8f735675a$var$createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
  $ce1e48c839fd190a908ad6f8f735675a$export$codes = $ce1e48c839fd190a908ad6f8f735675a$var$codes;
  $ce1e48c839fd190a908ad6f8f735675a$exports.codes = $ce1e48c839fd190a908ad6f8f735675a$export$codes;
}

function $ce1e48c839fd190a908ad6f8f735675a$init() {
  if (!$ce1e48c839fd190a908ad6f8f735675a$executed) {
    $ce1e48c839fd190a908ad6f8f735675a$executed = true;
    $ce1e48c839fd190a908ad6f8f735675a$exec();
  }

  return $ce1e48c839fd190a908ad6f8f735675a$exports;
}

// ASSET: node_modules/readable-stream/lib/internal/streams/state.js
var $afaf2a5946bd26a0d4bfb0d521b5acad$exports,
    $afaf2a5946bd26a0d4bfb0d521b5acad$var$ERR_INVALID_OPT_VALUE,
    $afaf2a5946bd26a0d4bfb0d521b5acad$executed = false;

function $afaf2a5946bd26a0d4bfb0d521b5acad$var$highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function $afaf2a5946bd26a0d4bfb0d521b5acad$var$getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = $afaf2a5946bd26a0d4bfb0d521b5acad$var$highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new $afaf2a5946bd26a0d4bfb0d521b5acad$var$ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}

function $afaf2a5946bd26a0d4bfb0d521b5acad$exec() {
  $afaf2a5946bd26a0d4bfb0d521b5acad$exports = {};
  $afaf2a5946bd26a0d4bfb0d521b5acad$var$ERR_INVALID_OPT_VALUE = $ce1e48c839fd190a908ad6f8f735675a$init().codes.ERR_INVALID_OPT_VALUE;
  $afaf2a5946bd26a0d4bfb0d521b5acad$exports = {
    getHighWaterMark: $afaf2a5946bd26a0d4bfb0d521b5acad$var$getHighWaterMark
  };
}

function $afaf2a5946bd26a0d4bfb0d521b5acad$init() {
  if (!$afaf2a5946bd26a0d4bfb0d521b5acad$executed) {
    $afaf2a5946bd26a0d4bfb0d521b5acad$executed = true;
    $afaf2a5946bd26a0d4bfb0d521b5acad$exec();
  }

  return $afaf2a5946bd26a0d4bfb0d521b5acad$exports;
}

// ASSET: node_modules/util-deprecate/browser.js
var $64ab3031dbdbcbf4db62dde9b69b6ee5$exports,
    $64ab3031dbdbcbf4db62dde9b69b6ee5$executed = false;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */
function $64ab3031dbdbcbf4db62dde9b69b6ee5$var$deprecate(fn, msg) {
  if ($64ab3031dbdbcbf4db62dde9b69b6ee5$var$config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if ($64ab3031dbdbcbf4db62dde9b69b6ee5$var$config('throwDeprecation')) {
        throw new Error(msg);
      } else if ($64ab3031dbdbcbf4db62dde9b69b6ee5$var$config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */
function $64ab3031dbdbcbf4db62dde9b69b6ee5$var$config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!$parcel$global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = $parcel$global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

function $64ab3031dbdbcbf4db62dde9b69b6ee5$exec() {
  $64ab3031dbdbcbf4db62dde9b69b6ee5$exports = {};

  /**
   * Module exports.
   */
  $64ab3031dbdbcbf4db62dde9b69b6ee5$exports = $64ab3031dbdbcbf4db62dde9b69b6ee5$var$deprecate;
  /**
   * Mark that a method should not be used.
   * Returns a modified function which warns once by default.
   *
   * If `localStorage.noDeprecation = true` is set, then it is a no-op.
   *
   * If `localStorage.throwDeprecation = true` is set, then deprecated functions
   * will throw an Error when invoked.
   *
   * If `localStorage.traceDeprecation = true` is set, then deprecated functions
   * will invoke `console.trace()` instead of `console.error()`.
   *
   * @param {Function} fn - the function to deprecate
   * @param {String} msg - the string to print to the console when `fn` is invoked
   * @returns {Function} a new "deprecated" version of `fn`
   * @api public
   */
}

function $64ab3031dbdbcbf4db62dde9b69b6ee5$init() {
  if (!$64ab3031dbdbcbf4db62dde9b69b6ee5$executed) {
    $64ab3031dbdbcbf4db62dde9b69b6ee5$executed = true;
    $64ab3031dbdbcbf4db62dde9b69b6ee5$exec();
  }

  return $64ab3031dbdbcbf4db62dde9b69b6ee5$exports;
}

// ASSET: node_modules/readable-stream/lib/_stream_writable.js
var $df00fcec4dc8b52161bed6287b75d28f$exports,
    $df00fcec4dc8b52161bed6287b75d28f$var$process,
    $df00fcec4dc8b52161bed6287b75d28f$var$Duplex,
    $df00fcec4dc8b52161bed6287b75d28f$var$internalUtil,
    $df00fcec4dc8b52161bed6287b75d28f$var$Stream,
    $df00fcec4dc8b52161bed6287b75d28f$var$Buffer,
    $df00fcec4dc8b52161bed6287b75d28f$var$OurUint8Array,
    $df00fcec4dc8b52161bed6287b75d28f$var$destroyImpl,
    $df00fcec4dc8b52161bed6287b75d28f$var$_require,
    $df00fcec4dc8b52161bed6287b75d28f$var$getHighWaterMark,
    $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_INVALID_ARG_TYPE,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_METHOD_NOT_IMPLEMENTED,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_MULTIPLE_CALLBACK,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_CANNOT_PIPE,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_DESTROYED,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_NULL_VALUES,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_WRITE_AFTER_END,
    $df00fcec4dc8b52161bed6287b75d28f$var$ERR_UNKNOWN_ENCODING,
    $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy,
    $df00fcec4dc8b52161bed6287b75d28f$var$realHasInstance,
    $df00fcec4dc8b52161bed6287b75d28f$executed = false;

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function $df00fcec4dc8b52161bed6287b75d28f$var$CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    $df00fcec4dc8b52161bed6287b75d28f$var$onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


function $df00fcec4dc8b52161bed6287b75d28f$var$_uint8ArrayToBuffer(chunk) {
  return $df00fcec4dc8b52161bed6287b75d28f$var$Buffer.from(chunk);
}

function $df00fcec4dc8b52161bed6287b75d28f$var$_isUint8Array(obj) {
  return $df00fcec4dc8b52161bed6287b75d28f$var$Buffer.isBuffer(obj) || obj instanceof $df00fcec4dc8b52161bed6287b75d28f$var$OurUint8Array;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$nop() {}

function $df00fcec4dc8b52161bed6287b75d28f$var$WritableState(options, stream, isDuplex) {
  $df00fcec4dc8b52161bed6287b75d28f$var$Duplex = $df00fcec4dc8b52161bed6287b75d28f$var$Duplex || $709c29857bc9580aaf7a4e519b9362cf$init();
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof $df00fcec4dc8b52161bed6287b75d28f$var$Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = $df00fcec4dc8b52161bed6287b75d28f$var$getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  // if _final has been called
  this.finalCalled = false; // drain event flag.

  // drain event flag.
  this.needDrain = false; // at the start of calling end()

  // at the start of calling end()
  this.ending = false; // when end() has been called, and returned

  // when end() has been called, and returned
  this.ended = false; // when 'finish' is emitted

  // when 'finish' is emitted
  this.finished = false; // has it been destroyed

  // has it been destroyed
  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0; // a flag to see when we're in the middle of a write.

  // a flag to see when we're in the middle of a write.
  this.writing = false; // when true all writes will be buffered until .uncork() call

  // when true all writes will be buffered until .uncork() call
  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    $df00fcec4dc8b52161bed6287b75d28f$var$onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null; // the amount that is being written when _write is called.

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  // count buffered requests
  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new $df00fcec4dc8b52161bed6287b75d28f$var$CorkedRequest(this);
}

function $df00fcec4dc8b52161bed6287b75d28f$var$Writable(options) {
  $df00fcec4dc8b52161bed6287b75d28f$var$Duplex = $df00fcec4dc8b52161bed6287b75d28f$var$Duplex || $709c29857bc9580aaf7a4e519b9362cf$init(); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof $df00fcec4dc8b52161bed6287b75d28f$var$Duplex;
  if (!isDuplex && !$df00fcec4dc8b52161bed6287b75d28f$var$realHasInstance.call($df00fcec4dc8b52161bed6287b75d28f$var$Writable, this)) return new $df00fcec4dc8b52161bed6287b75d28f$var$Writable(options);
  this._writableState = new $df00fcec4dc8b52161bed6287b75d28f$var$WritableState(options, this, isDuplex); // legacy.

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  $df00fcec4dc8b52161bed6287b75d28f$var$Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


function $df00fcec4dc8b52161bed6287b75d28f$var$writeAfterEnd(stream, cb) {
  var er = new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  // TODO: defer error events consistently everywhere, not just the cb
  $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(stream, er);
  $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function $df00fcec4dc8b52161bed6287b75d28f$var$validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(stream, er);
    $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick(cb, er);
    return false;
  }

  return true;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = $df00fcec4dc8b52161bed6287b75d28f$var$Buffer.from(chunk, encoding);
  }

  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function $df00fcec4dc8b52161bed6287b75d28f$var$writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = $df00fcec4dc8b52161bed6287b75d28f$var$decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    $df00fcec4dc8b52161bed6287b75d28f$var$doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    // this can emit finish, and it will always happen
    // after error
    $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick($df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    // this can emit finish, but finish must
    // always follow error
    $df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe(stream, state);
  }
}

function $df00fcec4dc8b52161bed6287b75d28f$var$onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_MULTIPLE_CALLBACK();
  $df00fcec4dc8b52161bed6287b75d28f$var$onwriteStateUpdate(state);
  if (er) $df00fcec4dc8b52161bed6287b75d28f$var$onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = $df00fcec4dc8b52161bed6287b75d28f$var$needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      $df00fcec4dc8b52161bed6287b75d28f$var$clearBuffer(stream, state);
    }

    if (sync) {
      $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick($df00fcec4dc8b52161bed6287b75d28f$var$afterWrite, stream, state, finished, cb);
    } else {
      $df00fcec4dc8b52161bed6287b75d28f$var$afterWrite(stream, state, finished, cb);
    }
  }
}

function $df00fcec4dc8b52161bed6287b75d28f$var$afterWrite(stream, state, finished, cb) {
  if (!finished) $df00fcec4dc8b52161bed6287b75d28f$var$onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  $df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function $df00fcec4dc8b52161bed6287b75d28f$var$onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


// if there's something in the buffer waiting, then process it
function $df00fcec4dc8b52161bed6287b75d28f$var$clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    $df00fcec4dc8b52161bed6287b75d28f$var$doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new $df00fcec4dc8b52161bed6287b75d28f$var$CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      $df00fcec4dc8b52161bed6287b75d28f$var$doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    $df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe(stream, state);
  });
}

function $df00fcec4dc8b52161bed6287b75d28f$var$prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick($df00fcec4dc8b52161bed6287b75d28f$var$callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function $df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe(stream, state) {
  var need = $df00fcec4dc8b52161bed6287b75d28f$var$needFinish(state);

  if (need) {
    $df00fcec4dc8b52161bed6287b75d28f$var$prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$endWritable(stream, state, cb) {
  state.ending = true;
  $df00fcec4dc8b52161bed6287b75d28f$var$finishMaybe(stream, state);

  if (cb) {
    if (state.finished) $df00fcec4dc8b52161bed6287b75d28f$var$process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function $df00fcec4dc8b52161bed6287b75d28f$var$onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}

function $df00fcec4dc8b52161bed6287b75d28f$exec() {
  $df00fcec4dc8b52161bed6287b75d28f$exports = {};
  $df00fcec4dc8b52161bed6287b75d28f$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $df00fcec4dc8b52161bed6287b75d28f$exports = $df00fcec4dc8b52161bed6287b75d28f$var$Writable;
  /* <replacement> */

  /*</replacement>*/
  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.WritableState = $df00fcec4dc8b52161bed6287b75d28f$var$WritableState;
  /*<replacement>*/

  $df00fcec4dc8b52161bed6287b75d28f$var$internalUtil = {
    deprecate: $64ab3031dbdbcbf4db62dde9b69b6ee5$init()
  };
  $df00fcec4dc8b52161bed6287b75d28f$var$Stream = $bbc98a712e7b59e43db394c1c9638888$init();
  $df00fcec4dc8b52161bed6287b75d28f$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;

  $df00fcec4dc8b52161bed6287b75d28f$var$OurUint8Array = $parcel$global.Uint8Array || function () {};

  $df00fcec4dc8b52161bed6287b75d28f$var$destroyImpl = $5aa3e98abd1a522a9b1e072175fe86f5$init();
  $df00fcec4dc8b52161bed6287b75d28f$var$_require = $afaf2a5946bd26a0d4bfb0d521b5acad$init(), $df00fcec4dc8b52161bed6287b75d28f$var$getHighWaterMark = $df00fcec4dc8b52161bed6287b75d28f$var$_require.getHighWaterMark;
  $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes = $ce1e48c839fd190a908ad6f8f735675a$init().codes, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_INVALID_ARG_TYPE = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_INVALID_ARG_TYPE, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_METHOD_NOT_IMPLEMENTED = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_MULTIPLE_CALLBACK = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_MULTIPLE_CALLBACK, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_CANNOT_PIPE = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_STREAM_CANNOT_PIPE, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_DESTROYED = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_STREAM_DESTROYED, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_NULL_VALUES = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_STREAM_NULL_VALUES, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_WRITE_AFTER_END = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_STREAM_WRITE_AFTER_END, $df00fcec4dc8b52161bed6287b75d28f$var$ERR_UNKNOWN_ENCODING = $df00fcec4dc8b52161bed6287b75d28f$var$_require$codes.ERR_UNKNOWN_ENCODING;
  $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy = $df00fcec4dc8b52161bed6287b75d28f$var$destroyImpl.errorOrDestroy;
  $5e04eef67f3cc70b90141a363590b6ee$init()($df00fcec4dc8b52161bed6287b75d28f$var$Writable, $df00fcec4dc8b52161bed6287b75d28f$var$Stream);

  $df00fcec4dc8b52161bed6287b75d28f$var$WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };

  (function () {
    try {
      Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$WritableState.prototype, 'buffer', {
        get: $df00fcec4dc8b52161bed6287b75d28f$var$internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })(); // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.


  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    $df00fcec4dc8b52161bed6287b75d28f$var$realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$Writable, Symbol.hasInstance, {
      value: function value(object) {
        if ($df00fcec4dc8b52161bed6287b75d28f$var$realHasInstance.call(this, object)) return true;
        if (this !== $df00fcec4dc8b52161bed6287b75d28f$var$Writable) return false;
        return object && object._writableState instanceof $df00fcec4dc8b52161bed6287b75d28f$var$WritableState;
      }
    });
  } else {
    $df00fcec4dc8b52161bed6287b75d28f$var$realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.pipe = function () {
    $df00fcec4dc8b52161bed6287b75d28f$var$errorOrDestroy(this, new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_STREAM_CANNOT_PIPE());
  };

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && $df00fcec4dc8b52161bed6287b75d28f$var$_isUint8Array(chunk);

    if (isBuf && !$df00fcec4dc8b52161bed6287b75d28f$var$Buffer.isBuffer(chunk)) {
      chunk = $df00fcec4dc8b52161bed6287b75d28f$var$_uint8ArrayToBuffer(chunk);
    }

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = $df00fcec4dc8b52161bed6287b75d28f$var$nop;
    if (state.ending) $df00fcec4dc8b52161bed6287b75d28f$var$writeAfterEnd(this, cb);else if (isBuf || $df00fcec4dc8b52161bed6287b75d28f$var$validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = $df00fcec4dc8b52161bed6287b75d28f$var$writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.cork = function () {
    this._writableState.corked++;
  };

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) $df00fcec4dc8b52161bed6287b75d28f$var$clearBuffer(this, state);
    }
  };

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  }); // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new $df00fcec4dc8b52161bed6287b75d28f$var$ERR_METHOD_NOT_IMPLEMENTED('_write()'));
  };

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype._writev = null;

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    // ignore unnecessary end() calls.
    if (!state.ending) $df00fcec4dc8b52161bed6287b75d28f$var$endWritable(this, state, cb);
    return this;
  };

  Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty($df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }

      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      // backward compatibility, the user is explicitly
      // managing destroyed
      this._writableState.destroyed = value;
    }
  });
  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype.destroy = $df00fcec4dc8b52161bed6287b75d28f$var$destroyImpl.destroy;
  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype._undestroy = $df00fcec4dc8b52161bed6287b75d28f$var$destroyImpl.undestroy;

  $df00fcec4dc8b52161bed6287b75d28f$var$Writable.prototype._destroy = function (err, cb) {
    cb(err);
  };
}

function $df00fcec4dc8b52161bed6287b75d28f$init() {
  if (!$df00fcec4dc8b52161bed6287b75d28f$executed) {
    $df00fcec4dc8b52161bed6287b75d28f$executed = true;
    $df00fcec4dc8b52161bed6287b75d28f$exec();
  }

  return $df00fcec4dc8b52161bed6287b75d28f$exports;
}

// ASSET: node_modules/readable-stream/lib/_stream_duplex.js
var $709c29857bc9580aaf7a4e519b9362cf$exports,
    $709c29857bc9580aaf7a4e519b9362cf$var$process,
    $709c29857bc9580aaf7a4e519b9362cf$var$objectKeys,
    $709c29857bc9580aaf7a4e519b9362cf$var$Readable,
    $709c29857bc9580aaf7a4e519b9362cf$var$Writable,
    $709c29857bc9580aaf7a4e519b9362cf$var$keys,
    $709c29857bc9580aaf7a4e519b9362cf$var$v,
    $709c29857bc9580aaf7a4e519b9362cf$var$method,
    $709c29857bc9580aaf7a4e519b9362cf$executed = false;

function $709c29857bc9580aaf7a4e519b9362cf$var$Duplex(options) {
  if (!(this instanceof $709c29857bc9580aaf7a4e519b9362cf$var$Duplex)) return new $709c29857bc9580aaf7a4e519b9362cf$var$Duplex(options);
  $709c29857bc9580aaf7a4e519b9362cf$var$Readable.call(this, options);
  $709c29857bc9580aaf7a4e519b9362cf$var$Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', $709c29857bc9580aaf7a4e519b9362cf$var$onend);
    }
  }
}

// the no-half-open enforcer
function $709c29857bc9580aaf7a4e519b9362cf$var$onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  // no more data can be written.
  // But allow more writes to happen in this tick.
  $709c29857bc9580aaf7a4e519b9362cf$var$process.nextTick($709c29857bc9580aaf7a4e519b9362cf$var$onEndNT, this);
}

function $709c29857bc9580aaf7a4e519b9362cf$var$onEndNT(self) {
  self.end();
}

function $709c29857bc9580aaf7a4e519b9362cf$exec() {
  $709c29857bc9580aaf7a4e519b9362cf$exports = {};
  $709c29857bc9580aaf7a4e519b9362cf$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

  $709c29857bc9580aaf7a4e519b9362cf$var$objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  };

  /*</replacement>*/
  $709c29857bc9580aaf7a4e519b9362cf$exports = $709c29857bc9580aaf7a4e519b9362cf$var$Duplex;
  $709c29857bc9580aaf7a4e519b9362cf$var$Readable = $e4e1dbd0ad8e2f0fc748e7678eaf7991$init();
  $709c29857bc9580aaf7a4e519b9362cf$var$Writable = $df00fcec4dc8b52161bed6287b75d28f$init();
  $5e04eef67f3cc70b90141a363590b6ee$init()($709c29857bc9580aaf7a4e519b9362cf$var$Duplex, $709c29857bc9580aaf7a4e519b9362cf$var$Readable);
  {
    $709c29857bc9580aaf7a4e519b9362cf$var$keys = $709c29857bc9580aaf7a4e519b9362cf$var$objectKeys($709c29857bc9580aaf7a4e519b9362cf$var$Writable.prototype);

    for ($709c29857bc9580aaf7a4e519b9362cf$var$v = 0; $709c29857bc9580aaf7a4e519b9362cf$var$v < $709c29857bc9580aaf7a4e519b9362cf$var$keys.length; $709c29857bc9580aaf7a4e519b9362cf$var$v++) {
      $709c29857bc9580aaf7a4e519b9362cf$var$method = $709c29857bc9580aaf7a4e519b9362cf$var$keys[$709c29857bc9580aaf7a4e519b9362cf$var$v];
      if (!$709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype[$709c29857bc9580aaf7a4e519b9362cf$var$method]) $709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype[$709c29857bc9580aaf7a4e519b9362cf$var$method] = $709c29857bc9580aaf7a4e519b9362cf$var$Writable.prototype[$709c29857bc9580aaf7a4e519b9362cf$var$method];
    }
  }
  Object.defineProperty($709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty($709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty($709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  }); // the no-half-open enforcer

  Object.defineProperty($709c29857bc9580aaf7a4e519b9362cf$var$Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }

      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
}

function $709c29857bc9580aaf7a4e519b9362cf$init() {
  if (!$709c29857bc9580aaf7a4e519b9362cf$executed) {
    $709c29857bc9580aaf7a4e519b9362cf$executed = true;
    $709c29857bc9580aaf7a4e519b9362cf$exec();
  }

  return $709c29857bc9580aaf7a4e519b9362cf$exports;
}

// ASSET: node_modules/safe-buffer/index.js
var $2efb4c9703742d153fc2ca8a48c47fc1$exports,
    $2efb4c9703742d153fc2ca8a48c47fc1$export$Buffer,
    $2efb4c9703742d153fc2ca8a48c47fc1$var$buffer,
    $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer,
    $2efb4c9703742d153fc2ca8a48c47fc1$executed = false;

// alternative to using Object.keys for old browsers
function $2efb4c9703742d153fc2ca8a48c47fc1$var$copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

function $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer(arg, encodingOrOffset, length) {
  return $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer(arg, encodingOrOffset, length);
}

function $2efb4c9703742d153fc2ca8a48c47fc1$exec() {
  $2efb4c9703742d153fc2ca8a48c47fc1$exports = {};
  $2efb4c9703742d153fc2ca8a48c47fc1$var$buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init();
  $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$var$buffer.Buffer;

  if ($2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer.from && $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer.alloc && $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer.allocUnsafe && $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer.allocUnsafeSlow) {
    $2efb4c9703742d153fc2ca8a48c47fc1$exports = $2efb4c9703742d153fc2ca8a48c47fc1$var$buffer;
  } else {
    // Copy properties from require('buffer')
    $2efb4c9703742d153fc2ca8a48c47fc1$var$copyProps($2efb4c9703742d153fc2ca8a48c47fc1$var$buffer, $2efb4c9703742d153fc2ca8a48c47fc1$exports);
    $2efb4c9703742d153fc2ca8a48c47fc1$export$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer;
    $2efb4c9703742d153fc2ca8a48c47fc1$exports.Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$export$Buffer;
  }

  $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer.prototype = Object.create($2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer.prototype); // Copy static methods from Buffer

  // Copy static methods from Buffer
  $2efb4c9703742d153fc2ca8a48c47fc1$var$copyProps($2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer, $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer);

  $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }

    return $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer(arg, encodingOrOffset, length);
  };

  $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    var buf = $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return $2efb4c9703742d153fc2ca8a48c47fc1$var$Buffer(size);
  };

  $2efb4c9703742d153fc2ca8a48c47fc1$var$SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return $2efb4c9703742d153fc2ca8a48c47fc1$var$buffer.SlowBuffer(size);
  };
}

function $2efb4c9703742d153fc2ca8a48c47fc1$init() {
  if (!$2efb4c9703742d153fc2ca8a48c47fc1$executed) {
    $2efb4c9703742d153fc2ca8a48c47fc1$executed = true;
    $2efb4c9703742d153fc2ca8a48c47fc1$exec();
  }

  return $2efb4c9703742d153fc2ca8a48c47fc1$exports;
}

// ASSET: node_modules/string_decoder/lib/string_decoder.js
var $9902be2109033b88050ebe7f370f9452$exports,
    $9902be2109033b88050ebe7f370f9452$var$Buffer,
    $9902be2109033b88050ebe7f370f9452$var$isEncoding,
    $9902be2109033b88050ebe7f370f9452$export$StringDecoder,
    $9902be2109033b88050ebe7f370f9452$executed = false;

function $9902be2109033b88050ebe7f370f9452$var$_normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function $9902be2109033b88050ebe7f370f9452$var$normalizeEncoding(enc) {
  var nenc = $9902be2109033b88050ebe7f370f9452$var$_normalizeEncoding(enc);
  if (typeof nenc !== 'string' && ($9902be2109033b88050ebe7f370f9452$var$Buffer.isEncoding === $9902be2109033b88050ebe7f370f9452$var$isEncoding || !$9902be2109033b88050ebe7f370f9452$var$isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


function $9902be2109033b88050ebe7f370f9452$var$StringDecoder(encoding) {
  this.encoding = $9902be2109033b88050ebe7f370f9452$var$normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = $9902be2109033b88050ebe7f370f9452$var$utf16Text;
      this.end = $9902be2109033b88050ebe7f370f9452$var$utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = $9902be2109033b88050ebe7f370f9452$var$utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = $9902be2109033b88050ebe7f370f9452$var$base64Text;
      this.end = $9902be2109033b88050ebe7f370f9452$var$base64End;
      nb = 3;
      break;

    default:
      this.write = $9902be2109033b88050ebe7f370f9452$var$simpleWrite;
      this.end = $9902be2109033b88050ebe7f370f9452$var$simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = $9902be2109033b88050ebe7f370f9452$var$Buffer.allocUnsafe(nb);
}

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function $9902be2109033b88050ebe7f370f9452$var$utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function $9902be2109033b88050ebe7f370f9452$var$utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = $9902be2109033b88050ebe7f370f9452$var$utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = $9902be2109033b88050ebe7f370f9452$var$utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = $9902be2109033b88050ebe7f370f9452$var$utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function $9902be2109033b88050ebe7f370f9452$var$utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function $9902be2109033b88050ebe7f370f9452$var$utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = $9902be2109033b88050ebe7f370f9452$var$utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function $9902be2109033b88050ebe7f370f9452$var$utf8Text(buf, i) {
  var total = $9902be2109033b88050ebe7f370f9452$var$utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


// For UTF-8, a replacement character is added when ending on a partial
// character.
function $9902be2109033b88050ebe7f370f9452$var$utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function $9902be2109033b88050ebe7f370f9452$var$utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function $9902be2109033b88050ebe7f370f9452$var$utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function $9902be2109033b88050ebe7f370f9452$var$base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function $9902be2109033b88050ebe7f370f9452$var$base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function $9902be2109033b88050ebe7f370f9452$var$simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function $9902be2109033b88050ebe7f370f9452$var$simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

function $9902be2109033b88050ebe7f370f9452$exec() {
  $9902be2109033b88050ebe7f370f9452$exports = {};
  $9902be2109033b88050ebe7f370f9452$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;

  $9902be2109033b88050ebe7f370f9452$var$isEncoding = $9902be2109033b88050ebe7f370f9452$var$Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding;

    switch (encoding && encoding.toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;

      default:
        return false;
    }
  };

  ; // Do not cache `Buffer.isEncoding` when checking encoding names as some
  // modules monkey-patch it to support additional encodings

  $9902be2109033b88050ebe7f370f9452$export$StringDecoder = $9902be2109033b88050ebe7f370f9452$var$StringDecoder;
  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters.
  $9902be2109033b88050ebe7f370f9452$exports.StringDecoder = $9902be2109033b88050ebe7f370f9452$export$StringDecoder;

  $9902be2109033b88050ebe7f370f9452$var$StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0) return '';
    var r;
    var i;

    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined) return '';
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }

    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
  };

  $9902be2109033b88050ebe7f370f9452$var$StringDecoder.prototype.end = $9902be2109033b88050ebe7f370f9452$var$utf8End; // Returns only complete characters in a Buffer

  // Returns only complete characters in a Buffer
  $9902be2109033b88050ebe7f370f9452$var$StringDecoder.prototype.text = $9902be2109033b88050ebe7f370f9452$var$utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

  // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  $9902be2109033b88050ebe7f370f9452$var$StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }

    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  // continuation byte. If an invalid byte is detected, -2 is returned.

}

function $9902be2109033b88050ebe7f370f9452$init() {
  if (!$9902be2109033b88050ebe7f370f9452$executed) {
    $9902be2109033b88050ebe7f370f9452$executed = true;
    $9902be2109033b88050ebe7f370f9452$exec();
  }

  return $9902be2109033b88050ebe7f370f9452$exports;
}

// ASSET: node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var $34df0867d9bc906fb1020697ef28b46c$exports,
    $34df0867d9bc906fb1020697ef28b46c$var$ERR_STREAM_PREMATURE_CLOSE,
    $34df0867d9bc906fb1020697ef28b46c$executed = false;

function $34df0867d9bc906fb1020697ef28b46c$var$once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function $34df0867d9bc906fb1020697ef28b46c$var$noop() {}

function $34df0867d9bc906fb1020697ef28b46c$var$isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function $34df0867d9bc906fb1020697ef28b46c$var$eos(stream, opts, callback) {
  if (typeof opts === 'function') return $34df0867d9bc906fb1020697ef28b46c$var$eos(stream, null, opts);
  if (!opts) opts = {};
  callback = $34df0867d9bc906fb1020697ef28b46c$var$once(callback || $34df0867d9bc906fb1020697ef28b46c$var$noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new $34df0867d9bc906fb1020697ef28b46c$var$ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new $34df0867d9bc906fb1020697ef28b46c$var$ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if ($34df0867d9bc906fb1020697ef28b46c$var$isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

function $34df0867d9bc906fb1020697ef28b46c$exec() {
  $34df0867d9bc906fb1020697ef28b46c$exports = {};
  $34df0867d9bc906fb1020697ef28b46c$var$ERR_STREAM_PREMATURE_CLOSE = $ce1e48c839fd190a908ad6f8f735675a$init().codes.ERR_STREAM_PREMATURE_CLOSE;
  $34df0867d9bc906fb1020697ef28b46c$exports = $34df0867d9bc906fb1020697ef28b46c$var$eos;
}

function $34df0867d9bc906fb1020697ef28b46c$init() {
  if (!$34df0867d9bc906fb1020697ef28b46c$executed) {
    $34df0867d9bc906fb1020697ef28b46c$executed = true;
    $34df0867d9bc906fb1020697ef28b46c$exec();
  }

  return $34df0867d9bc906fb1020697ef28b46c$exports;
}

// ASSET: node_modules/readable-stream/lib/internal/streams/async_iterator.js
var $15421ca23a4ea5bb56764f657128ed7d$exports,
    $15421ca23a4ea5bb56764f657128ed7d$var$process,
    $15421ca23a4ea5bb56764f657128ed7d$var$_Object$setPrototypeO,
    $15421ca23a4ea5bb56764f657128ed7d$var$finished,
    $15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve,
    $15421ca23a4ea5bb56764f657128ed7d$var$kLastReject,
    $15421ca23a4ea5bb56764f657128ed7d$var$kError,
    $15421ca23a4ea5bb56764f657128ed7d$var$kEnded,
    $15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise,
    $15421ca23a4ea5bb56764f657128ed7d$var$kHandlePromise,
    $15421ca23a4ea5bb56764f657128ed7d$var$kStream,
    $15421ca23a4ea5bb56764f657128ed7d$var$AsyncIteratorPrototype,
    $15421ca23a4ea5bb56764f657128ed7d$var$ReadableStreamAsyncIteratorPrototype,
    $15421ca23a4ea5bb56764f657128ed7d$var$createReadableStreamAsyncIterator,
    $15421ca23a4ea5bb56764f657128ed7d$executed = false;

function $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function $15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function $15421ca23a4ea5bb56764f657128ed7d$var$readAndResolve(iter) {
  var resolve = iter[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve];

  if (resolve !== null) {
    var data = iter[$15421ca23a4ea5bb56764f657128ed7d$var$kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = null;
      iter[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve] = null;
      iter[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject] = null;
      resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(data, false));
    }
  }
}

function $15421ca23a4ea5bb56764f657128ed7d$var$onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  $15421ca23a4ea5bb56764f657128ed7d$var$process.nextTick($15421ca23a4ea5bb56764f657128ed7d$var$readAndResolve, iter);
}

function $15421ca23a4ea5bb56764f657128ed7d$var$wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[$15421ca23a4ea5bb56764f657128ed7d$var$kEnded]) {
        resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(undefined, true));
        return;
      }

      iter[$15421ca23a4ea5bb56764f657128ed7d$var$kHandlePromise](resolve, reject);
    }, reject);
  };
}

function $15421ca23a4ea5bb56764f657128ed7d$exec() {
  $15421ca23a4ea5bb56764f657128ed7d$exports = {};
  $15421ca23a4ea5bb56764f657128ed7d$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $15421ca23a4ea5bb56764f657128ed7d$var$finished = $34df0867d9bc906fb1020697ef28b46c$init();
  $15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve = Symbol('lastResolve');
  $15421ca23a4ea5bb56764f657128ed7d$var$kLastReject = Symbol('lastReject');
  $15421ca23a4ea5bb56764f657128ed7d$var$kError = Symbol('error');
  $15421ca23a4ea5bb56764f657128ed7d$var$kEnded = Symbol('ended');
  $15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise = Symbol('lastPromise');
  $15421ca23a4ea5bb56764f657128ed7d$var$kHandlePromise = Symbol('handlePromise');
  $15421ca23a4ea5bb56764f657128ed7d$var$kStream = Symbol('stream');
  $15421ca23a4ea5bb56764f657128ed7d$var$AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  $15421ca23a4ea5bb56764f657128ed7d$var$ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(($15421ca23a4ea5bb56764f657128ed7d$var$_Object$setPrototypeO = {
    get stream() {
      return this[$15421ca23a4ea5bb56764f657128ed7d$var$kStream];
    },

    next: function next() {
      var _this = this; // if we have detected an error in the meanwhile
      // reject straight away


      // if we have detected an error in the meanwhile
      // reject straight away
      var error = this[$15421ca23a4ea5bb56764f657128ed7d$var$kError];

      if (error !== null) {
        return Promise.reject(error);
      }

      if (this[$15421ca23a4ea5bb56764f657128ed7d$var$kEnded]) {
        return Promise.resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(undefined, true));
      }

      if (this[$15421ca23a4ea5bb56764f657128ed7d$var$kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          $15421ca23a4ea5bb56764f657128ed7d$var$process.nextTick(function () {
            if (_this[$15421ca23a4ea5bb56764f657128ed7d$var$kError]) {
              reject(_this[$15421ca23a4ea5bb56764f657128ed7d$var$kError]);
            } else {
              resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(undefined, true));
            }
          });
        });
      } // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time


      // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time
      var lastPromise = this[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise];
      var promise;

      if (lastPromise) {
        promise = new Promise($15421ca23a4ea5bb56764f657128ed7d$var$wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[$15421ca23a4ea5bb56764f657128ed7d$var$kStream].read();

        if (data !== null) {
          return Promise.resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(data, false));
        }

        promise = new Promise(this[$15421ca23a4ea5bb56764f657128ed7d$var$kHandlePromise]);
      }

      this[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = promise;
      return promise;
    }
  }, $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty($15421ca23a4ea5bb56764f657128ed7d$var$_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty($15421ca23a4ea5bb56764f657128ed7d$var$_Object$setPrototypeO, "return", function _return() {
    var _this2 = this; // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to


    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function (resolve, reject) {
      _this2[$15421ca23a4ea5bb56764f657128ed7d$var$kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }

        resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(undefined, true));
      });
    });
  }), $15421ca23a4ea5bb56764f657128ed7d$var$_Object$setPrototypeO), $15421ca23a4ea5bb56764f657128ed7d$var$AsyncIteratorPrototype);

  $15421ca23a4ea5bb56764f657128ed7d$var$createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;

    var iterator = Object.create($15421ca23a4ea5bb56764f657128ed7d$var$ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kStream, {
      value: stream,
      writable: true
    }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve, {
      value: null,
      writable: true
    }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kLastReject, {
      value: null,
      writable: true
    }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kError, {
      value: null,
      writable: true
    }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), $15421ca23a4ea5bb56764f657128ed7d$var$_defineProperty(_Object$create, $15421ca23a4ea5bb56764f657128ed7d$var$kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kStream].read();

        if (data) {
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = null;
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve] = null;
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject] = null;
          resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(data, false));
        } else {
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve] = resolve;
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = null;
    $15421ca23a4ea5bb56764f657128ed7d$var$finished(stream, function (err) {
      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
        var reject = iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject]; // reject if we are waiting for data in the Promise
        // returned by next() and store the error

        // reject if we are waiting for data in the Promise
        // returned by next() and store the error
        if (reject !== null) {
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = null;
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve] = null;
          iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject] = null;
          reject(err);
        }

        iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kError] = err;
        return;
      }

      var resolve = iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve];

      if (resolve !== null) {
        iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastPromise] = null;
        iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastResolve] = null;
        iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kLastReject] = null;
        resolve($15421ca23a4ea5bb56764f657128ed7d$var$createIterResult(undefined, true));
      }

      iterator[$15421ca23a4ea5bb56764f657128ed7d$var$kEnded] = true;
    });
    stream.on('readable', $15421ca23a4ea5bb56764f657128ed7d$var$onReadable.bind(null, iterator));
    return iterator;
  };

  $15421ca23a4ea5bb56764f657128ed7d$exports = $15421ca23a4ea5bb56764f657128ed7d$var$createReadableStreamAsyncIterator;
}

function $15421ca23a4ea5bb56764f657128ed7d$init() {
  if (!$15421ca23a4ea5bb56764f657128ed7d$executed) {
    $15421ca23a4ea5bb56764f657128ed7d$executed = true;
    $15421ca23a4ea5bb56764f657128ed7d$exec();
  }

  return $15421ca23a4ea5bb56764f657128ed7d$exports;
}

// ASSET: node_modules/readable-stream/lib/internal/streams/from-browser.js
var $7aa69d9834dd06b0759662331ec8a415$exports,
    $7aa69d9834dd06b0759662331ec8a415$executed = false;

function $7aa69d9834dd06b0759662331ec8a415$exec() {
  $7aa69d9834dd06b0759662331ec8a415$exports = {};

  $7aa69d9834dd06b0759662331ec8a415$exports = function () {
    throw new Error('Readable.from is not available in the browser');
  };
}

function $7aa69d9834dd06b0759662331ec8a415$init() {
  if (!$7aa69d9834dd06b0759662331ec8a415$executed) {
    $7aa69d9834dd06b0759662331ec8a415$executed = true;
    $7aa69d9834dd06b0759662331ec8a415$exec();
  }

  return $7aa69d9834dd06b0759662331ec8a415$exports;
}

// ASSET: node_modules/readable-stream/lib/_stream_readable.js
var $e4e1dbd0ad8e2f0fc748e7678eaf7991$exports,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EE,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EElistenerCount,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$OurUint8Array,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debugUtil,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$BufferList,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$destroyImpl,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$getHighWaterMark,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_INVALID_ARG_TYPE,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_PUSH_AFTER_EOF,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_METHOD_NOT_IMPLEMENTED,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$createReadableStreamAsyncIterator,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$from,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$kProxyEvents,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$MAX_HWM,
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$executed = false;

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_uint8ArrayToBuffer(chunk) {
  return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer.from(chunk);
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_isUint8Array(obj) {
  return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer.isBuffer(obj) || obj instanceof $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$OurUint8Array;
}
/*<replacement>*/


function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ReadableState(options, stream, isDuplex) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex || $709c29857bc9580aaf7a4e519b9362cf$init();
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  // has it been destroyed
  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!$e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder = $9902be2109033b88050ebe7f370f9452$init().StringDecoder;
    this.decoder = new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable(options) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex || $709c29857bc9580aaf7a4e519b9362cf$init();
  if (!(this instanceof $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable)) return new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Duplex;
  this._readableState = new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ReadableState(options, this, isDuplex); // legacy

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream.call(this);
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$chunkInvalid(state, chunk);

    if (er) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer.prototype) {
        chunk = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy(stream, new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy(stream, new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$addChunk(stream, state, chunk, false);else $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore(stream, state);
        } else {
          $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable(stream);
  }

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore(stream, state);
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$chunkInvalid(state, chunk) {
  var er;

  if (!$e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$computeNewHighWaterMark(n) {
  if (n >= $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$onEofChunk(stream, state) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable(stream) {
  var state = stream._readableState;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable_, stream);
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable_(stream) {
  var state = stream._readableState;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore_, stream, state);
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EElistenerCount(src, 'data')) {
      state.flowing = true;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$flow(src);
    }
  };
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$nReadingNextTick(self) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$resume_, stream, state);
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$resume_(stream, state) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$flow(stream) {
  var state = stream._readableState;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadable(stream) {
  var state = stream._readableState;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadableNT, state, stream);
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadableNT(state, stream) {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$exec() {
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$exports = {};
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$exports = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable;
  /*<replacement>*/

  /*</replacement>*/
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.ReadableState = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ReadableState;
  /*<replacement>*/

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EE = $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter;

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream = $bbc98a712e7b59e43db394c1c9638888$init();
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$OurUint8Array = $parcel$global.Uint8Array || function () {};

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debugUtil = {};

  if ($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debugUtil && $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debugUtil.debuglog) {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debugUtil.debuglog('stream');
  } else {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug = function debug() {};
  }
  /*</replacement>*/


  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$BufferList = $8b1e4502124440ec13f9215790905328$exports;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$destroyImpl = $5aa3e98abd1a522a9b1e072175fe86f5$init();
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require = $afaf2a5946bd26a0d4bfb0d521b5acad$init(), $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$getHighWaterMark = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require.getHighWaterMark;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes = $ce1e48c839fd190a908ad6f8f735675a$init().codes, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_INVALID_ARG_TYPE = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes.ERR_INVALID_ARG_TYPE, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_PUSH_AFTER_EOF = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes.ERR_STREAM_PUSH_AFTER_EOF, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_METHOD_NOT_IMPLEMENTED = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  $5e04eef67f3cc70b90141a363590b6ee$init()($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream);
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$destroyImpl.errorOrDestroy;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
  Object.defineProperty($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }

      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
    }
  });
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.destroy = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$destroyImpl.destroy;
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype._undestroy = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$destroyImpl.undestroy;

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype._destroy = function (err, cb) {
    cb(err);
  }; // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.


  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;

    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Buffer.from(chunk, encoding);
          encoding = '';
        }

        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }

    return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  }; // Unshift should *always* be something directly out of read()


  // Unshift should *always* be something directly out of read()
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.unshift = function (chunk) {
    return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$readableAddChunk(this, chunk, null, true, false);
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  }; // backwards compatibility.


  // backwards compatibility.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.setEncoding = function (enc) {
    if (!$e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder = $9902be2109033b88050ebe7f370f9452$init().StringDecoder;
    var decoder = new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';

    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }

    this._readableState.buffer.clear();

    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  }; // Don't raise the hwm > 1GB


  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$MAX_HWM = 0x40000000;

  // you can override either this method, or the async _read(n) below.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.read = function (n) {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadable(this);else $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable(this);
      return null;
    }

    n = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadable(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('reading or ended', doRead);
    } else if (doRead) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('do read');
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true; // call internal read method

      // call internal read method
      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);
    return ret;
  };

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype._read = function (n) {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy(this, new $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$ERR_METHOD_NOT_IMPLEMENTED('_read()'));
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.stdout && dest !== $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);

    function onunpipe(readable, unpipeInfo) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('onunpipe');

      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }

    function onend() {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('onend');
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;

    function cleanup() {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('cleanup'); // cleanup event handlers once the pipe is broken

      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    src.on('data', ondata);

    function ondata(chunk) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('ondata');
      var ret = dest.write(chunk);
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('dest.write', ret);

      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('false write response, pause', state.awaitDrain);
          state.awaitDrain++;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if ($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$EElistenerCount(dest, 'error') === 0) $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.


    // Make sure our error handler is attached before userland ones.
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }

    dest.once('close', onclose);

    function onfinish() {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }

    dest.once('finish', onfinish);

    function unpipe() {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('unpipe');
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    // tell the dest that it's being piped to
    dest.emit('pipe', src); // start the flow if it hasn't been started already.

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('pipe resume');
      src.resume();
    }

    return dest;
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    } // slow case. multiple pipe destinations.


    // slow case. multiple pipe destinations.
    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var i = 0; i < len; i++) {
        dests[i].emit('unpipe', this, {
          hasUnpiped: false
        });
      }

      return this;
    } // try to find the right one.


    // try to find the right one.
    var index = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.on = function (ev, fn) {
    var res = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;

    if (ev === 'data') {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

      // Try start flowing on next tick if stream isn't explicitly paused
      if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('on readable', state.length, state.reading);

        if (state.length) {
          $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$emitReadable(this);
        } else if (!state.reading) {
          $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$nReadingNextTick, this);
        }
      }
    }

    return res;
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.addListener = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.on;

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.removeListener = function (ev, fn) {
    var res = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === 'readable') {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$updateReadableListening, this);
    }

    return res;
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.removeAllListeners = function (ev) {
    var res = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === 'readable' || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$process.nextTick($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$updateReadableListening, this);
    }

    return res;
  };

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('resume'); // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()

      // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()
      state.flowing = !state.readableListening;
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$resume(this, state);
    }

    state.paused = false;
    return this;
  };

  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.pause = function () {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('call pause flowing=%j', this._readableState.flowing);

    if (this._readableState.flowing !== false) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }

    this._readableState.paused = true;
    return this;
  };

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype.wrap = function (stream) {
    var _this = this;

    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('wrapped end');

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }

      _this.push(null);
    });
    stream.on('data', function (chunk) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = _this.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    // proxy certain important events.
    for (var n = 0; n < $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$kProxyEvents.length; n++) {
      stream.on($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$kProxyEvents[n], this.emit.bind(this, $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.


    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function (n) {
      $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$debug('wrapped _read', n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return this;
  };

  if (typeof Symbol === 'function') {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype[Symbol.asyncIterator] = function () {
      if ($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$createReadableStreamAsyncIterator === undefined) {
        $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$createReadableStreamAsyncIterator = $15421ca23a4ea5bb56764f657128ed7d$init();
      }

      return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$createReadableStreamAsyncIterator(this);
    };
  }

  Object.defineProperty($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  }); // exposed for testing purposes only.

  // exposed for testing purposes only.
  $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable._fromList = $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$fromList;
  Object.defineProperty($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  }); // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  if (typeof Symbol === 'function') {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable.from = function (iterable, opts) {
      if ($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$from === undefined) {
        $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$from = $7aa69d9834dd06b0759662331ec8a415$init();
      }

      return $e4e1dbd0ad8e2f0fc748e7678eaf7991$var$from($e4e1dbd0ad8e2f0fc748e7678eaf7991$var$Readable, iterable, opts);
    };
  }
}

function $e4e1dbd0ad8e2f0fc748e7678eaf7991$init() {
  if (!$e4e1dbd0ad8e2f0fc748e7678eaf7991$executed) {
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$executed = true;
    $e4e1dbd0ad8e2f0fc748e7678eaf7991$exec();
  }

  return $e4e1dbd0ad8e2f0fc748e7678eaf7991$exports;
}

$77f1f3b73e58a1193c01fee8e7b8ba28$cjs_exports = $77f1f3b73e58a1193c01fee8e7b8ba28$exports = $e4e1dbd0ad8e2f0fc748e7678eaf7991$init();
var $77f1f3b73e58a1193c01fee8e7b8ba28$export$Stream = $77f1f3b73e58a1193c01fee8e7b8ba28$cjs_exports;
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.Stream = $77f1f3b73e58a1193c01fee8e7b8ba28$export$Stream;
var $77f1f3b73e58a1193c01fee8e7b8ba28$export$Readable = $77f1f3b73e58a1193c01fee8e7b8ba28$cjs_exports;
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable = $77f1f3b73e58a1193c01fee8e7b8ba28$export$Readable;
var $77f1f3b73e58a1193c01fee8e7b8ba28$export$Writable = $df00fcec4dc8b52161bed6287b75d28f$init();
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable = $77f1f3b73e58a1193c01fee8e7b8ba28$export$Writable;
var $77f1f3b73e58a1193c01fee8e7b8ba28$export$Duplex = $709c29857bc9580aaf7a4e519b9362cf$init();
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.Duplex = $77f1f3b73e58a1193c01fee8e7b8ba28$export$Duplex;
// ASSET: node_modules/readable-stream/lib/_stream_transform.js
var $9da82fd6af8be89c7f2f44d04f5ab20d$exports = {};
$9da82fd6af8be89c7f2f44d04f5ab20d$exports = $9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform;
var $9da82fd6af8be89c7f2f44d04f5ab20d$var$_require$codes = $ce1e48c839fd190a908ad6f8f735675a$init().codes,
    $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_METHOD_NOT_IMPLEMENTED = $9da82fd6af8be89c7f2f44d04f5ab20d$var$_require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_MULTIPLE_CALLBACK = $9da82fd6af8be89c7f2f44d04f5ab20d$var$_require$codes.ERR_MULTIPLE_CALLBACK,
    $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_TRANSFORM_ALREADY_TRANSFORMING = $9da82fd6af8be89c7f2f44d04f5ab20d$var$_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_TRANSFORM_WITH_LENGTH_0 = $9da82fd6af8be89c7f2f44d04f5ab20d$var$_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var $9da82fd6af8be89c7f2f44d04f5ab20d$var$Duplex = $709c29857bc9580aaf7a4e519b9362cf$init();
$5e04eef67f3cc70b90141a363590b6ee$init()($9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform, $9da82fd6af8be89c7f2f44d04f5ab20d$var$Duplex);

function $9da82fd6af8be89c7f2f44d04f5ab20d$var$afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function $9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform(options) {
  if (!(this instanceof $9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform)) return new $9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform(options);
  $9da82fd6af8be89c7f2f44d04f5ab20d$var$Duplex.call(this, options);
  this._transformState = {
    afterTransform: $9da82fd6af8be89c7f2f44d04f5ab20d$var$afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', $9da82fd6af8be89c7f2f44d04f5ab20d$var$prefinish);
}

function $9da82fd6af8be89c7f2f44d04f5ab20d$var$prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      $9da82fd6af8be89c7f2f44d04f5ab20d$var$done(_this, er, data);
    });
  } else {
    $9da82fd6af8be89c7f2f44d04f5ab20d$var$done(this, null, null);
  }
}

$9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return $9da82fd6af8be89c7f2f44d04f5ab20d$var$Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
$9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

$9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
$9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

$9da82fd6af8be89c7f2f44d04f5ab20d$var$Transform.prototype._destroy = function (err, cb) {
  $9da82fd6af8be89c7f2f44d04f5ab20d$var$Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function $9da82fd6af8be89c7f2f44d04f5ab20d$var$done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new $9da82fd6af8be89c7f2f44d04f5ab20d$var$ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

$77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform = $9da82fd6af8be89c7f2f44d04f5ab20d$exports;
// ASSET: node_modules/readable-stream/lib/_stream_passthrough.js
var $1458abb10c3146b546da213c20ff10ad$exports = {};
$1458abb10c3146b546da213c20ff10ad$exports = $1458abb10c3146b546da213c20ff10ad$var$PassThrough;
$5e04eef67f3cc70b90141a363590b6ee$init()($1458abb10c3146b546da213c20ff10ad$var$PassThrough, $9da82fd6af8be89c7f2f44d04f5ab20d$exports);

function $1458abb10c3146b546da213c20ff10ad$var$PassThrough(options) {
  if (!(this instanceof $1458abb10c3146b546da213c20ff10ad$var$PassThrough)) return new $1458abb10c3146b546da213c20ff10ad$var$PassThrough(options);
  $9da82fd6af8be89c7f2f44d04f5ab20d$exports.call(this, options);
}

$1458abb10c3146b546da213c20ff10ad$var$PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

$77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough = $1458abb10c3146b546da213c20ff10ad$exports;
var $77f1f3b73e58a1193c01fee8e7b8ba28$export$finished = $34df0867d9bc906fb1020697ef28b46c$init();
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.finished = $77f1f3b73e58a1193c01fee8e7b8ba28$export$finished;
// ASSET: node_modules/readable-stream/lib/internal/streams/pipeline.js
var $0874149cb3bab2afbf55aebb4bdbc6ae$exports = {};
var $0874149cb3bab2afbf55aebb4bdbc6ae$var$eos;

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var $0874149cb3bab2afbf55aebb4bdbc6ae$var$_require$codes = $ce1e48c839fd190a908ad6f8f735675a$init().codes,
    $0874149cb3bab2afbf55aebb4bdbc6ae$var$ERR_MISSING_ARGS = $0874149cb3bab2afbf55aebb4bdbc6ae$var$_require$codes.ERR_MISSING_ARGS,
    $0874149cb3bab2afbf55aebb4bdbc6ae$var$ERR_STREAM_DESTROYED = $0874149cb3bab2afbf55aebb4bdbc6ae$var$_require$codes.ERR_STREAM_DESTROYED;

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$destroyer(stream, reading, writing, callback) {
  callback = $0874149cb3bab2afbf55aebb4bdbc6ae$var$once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if ($0874149cb3bab2afbf55aebb4bdbc6ae$var$eos === undefined) $0874149cb3bab2afbf55aebb4bdbc6ae$var$eos = $34df0867d9bc906fb1020697ef28b46c$init();
  $0874149cb3bab2afbf55aebb4bdbc6ae$var$eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    // request.destroy just do .end - .abort is what we want
    if ($0874149cb3bab2afbf55aebb4bdbc6ae$var$isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new $0874149cb3bab2afbf55aebb4bdbc6ae$var$ERR_STREAM_DESTROYED('pipe'));
  };
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$call(fn) {
  fn();
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$pipe(from, to) {
  return from.pipe(to);
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$popCallback(streams) {
  if (!streams.length) return $0874149cb3bab2afbf55aebb4bdbc6ae$var$noop;
  if (typeof streams[streams.length - 1] !== 'function') return $0874149cb3bab2afbf55aebb4bdbc6ae$var$noop;
  return streams.pop();
}

function $0874149cb3bab2afbf55aebb4bdbc6ae$var$pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = $0874149cb3bab2afbf55aebb4bdbc6ae$var$popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new $0874149cb3bab2afbf55aebb4bdbc6ae$var$ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return $0874149cb3bab2afbf55aebb4bdbc6ae$var$destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach($0874149cb3bab2afbf55aebb4bdbc6ae$var$call);
      if (reading) return;
      destroys.forEach($0874149cb3bab2afbf55aebb4bdbc6ae$var$call);
      callback(error);
    });
  });
  return streams.reduce($0874149cb3bab2afbf55aebb4bdbc6ae$var$pipe);
}

$0874149cb3bab2afbf55aebb4bdbc6ae$exports = $0874149cb3bab2afbf55aebb4bdbc6ae$var$pipeline;
$77f1f3b73e58a1193c01fee8e7b8ba28$exports.pipeline = $0874149cb3bab2afbf55aebb4bdbc6ae$exports;
const $96dc529002d169e2098dfb4902acf701$var$util_1 = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/browserify-zlib/lib/index.js
var $5051c00e87739024f780cb19cb94c308$exports = {};
var $5051c00e87739024f780cb19cb94c308$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $5051c00e87739024f780cb19cb94c308$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $5051c00e87739024f780cb19cb94c308$var$Transform = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform;
// ASSET: node_modules/browserify-zlib/lib/binding.js
var $ac254f1082b0ce94146edfb9c2acdf2f$exports = {};
var $ac254f1082b0ce94146edfb9c2acdf2f$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $ac254f1082b0ce94146edfb9c2acdf2f$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// ASSET: node_modules/assert/build/internal/errors.js
var $451df81020daf200ba28865e982d3a0a$exports = {};

// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function $451df81020daf200ba28865e982d3a0a$var$_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    $451df81020daf200ba28865e982d3a0a$var$_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    $451df81020daf200ba28865e982d3a0a$var$_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return $451df81020daf200ba28865e982d3a0a$var$_typeof(obj);
}

function $451df81020daf200ba28865e982d3a0a$var$_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function $451df81020daf200ba28865e982d3a0a$var$_possibleConstructorReturn(self, call) {
  if (call && ($451df81020daf200ba28865e982d3a0a$var$_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return $451df81020daf200ba28865e982d3a0a$var$_assertThisInitialized(self);
}

function $451df81020daf200ba28865e982d3a0a$var$_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function $451df81020daf200ba28865e982d3a0a$var$_getPrototypeOf(o) {
  $451df81020daf200ba28865e982d3a0a$var$_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return $451df81020daf200ba28865e982d3a0a$var$_getPrototypeOf(o);
}

function $451df81020daf200ba28865e982d3a0a$var$_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) $451df81020daf200ba28865e982d3a0a$var$_setPrototypeOf(subClass, superClass);
}

function $451df81020daf200ba28865e982d3a0a$var$_setPrototypeOf(o, p) {
  $451df81020daf200ba28865e982d3a0a$var$_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return $451df81020daf200ba28865e982d3a0a$var$_setPrototypeOf(o, p);
}

var $451df81020daf200ba28865e982d3a0a$var$codes = {}; // Lazy loaded

// Lazy loaded
var $451df81020daf200ba28865e982d3a0a$var$assert;
var $451df81020daf200ba28865e982d3a0a$var$util;

function $451df81020daf200ba28865e982d3a0a$var$createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    $451df81020daf200ba28865e982d3a0a$var$_inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      $451df81020daf200ba28865e982d3a0a$var$_classCallCheck(this, NodeError);
      _this = $451df81020daf200ba28865e982d3a0a$var$_possibleConstructorReturn(this, $451df81020daf200ba28865e982d3a0a$var$_getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  $451df81020daf200ba28865e982d3a0a$var$codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function $451df81020daf200ba28865e982d3a0a$var$oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function $451df81020daf200ba28865e982d3a0a$var$startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function $451df81020daf200ba28865e982d3a0a$var$endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function $451df81020daf200ba28865e982d3a0a$var$includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

$451df81020daf200ba28865e982d3a0a$var$createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
$451df81020daf200ba28865e982d3a0a$var$createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if ($451df81020daf200ba28865e982d3a0a$var$assert === undefined) $451df81020daf200ba28865e982d3a0a$var$assert = $034bb26d820f8530f21df3dfc0306a11$init();
  $451df81020daf200ba28865e982d3a0a$var$assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && $451df81020daf200ba28865e982d3a0a$var$startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if ($451df81020daf200ba28865e982d3a0a$var$endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat($451df81020daf200ba28865e982d3a0a$var$oneOf(expected, 'type'));
  } else {
    var type = $451df81020daf200ba28865e982d3a0a$var$includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat($451df81020daf200ba28865e982d3a0a$var$oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat($451df81020daf200ba28865e982d3a0a$var$_typeof(actual));
  return msg;
}, TypeError);
$451df81020daf200ba28865e982d3a0a$var$createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if ($451df81020daf200ba28865e982d3a0a$var$util === undefined) $451df81020daf200ba28865e982d3a0a$var$util = $69678d3e0618202337016e1b4ed76965$init();
  var inspected = $451df81020daf200ba28865e982d3a0a$var$util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
$451df81020daf200ba28865e982d3a0a$var$createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat($451df81020daf200ba28865e982d3a0a$var$_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
$451df81020daf200ba28865e982d3a0a$var$createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if ($451df81020daf200ba28865e982d3a0a$var$assert === undefined) $451df81020daf200ba28865e982d3a0a$var$assert = $034bb26d820f8530f21df3dfc0306a11$init();
  $451df81020daf200ba28865e982d3a0a$var$assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
var $451df81020daf200ba28865e982d3a0a$export$codes = $451df81020daf200ba28865e982d3a0a$var$codes;
$451df81020daf200ba28865e982d3a0a$exports.codes = $451df81020daf200ba28865e982d3a0a$export$codes;
// ASSET: node_modules/assert/build/internal/assert/assertion_error.js
var $67cecab1d850108c9484923539bb3dd9$exports = {};
var $67cecab1d850108c9484923539bb3dd9$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

function $67cecab1d850108c9484923539bb3dd9$var$_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      $67cecab1d850108c9484923539bb3dd9$var$_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function $67cecab1d850108c9484923539bb3dd9$var$_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function $67cecab1d850108c9484923539bb3dd9$var$_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function $67cecab1d850108c9484923539bb3dd9$var$_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function $67cecab1d850108c9484923539bb3dd9$var$_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) $67cecab1d850108c9484923539bb3dd9$var$_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) $67cecab1d850108c9484923539bb3dd9$var$_defineProperties(Constructor, staticProps);
  return Constructor;
}

function $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(self, call) {
  if (call && ($67cecab1d850108c9484923539bb3dd9$var$_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return $67cecab1d850108c9484923539bb3dd9$var$_assertThisInitialized(self);
}

function $67cecab1d850108c9484923539bb3dd9$var$_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function $67cecab1d850108c9484923539bb3dd9$var$_inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf(subClass, superClass);
}

function $67cecab1d850108c9484923539bb3dd9$var$_wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  $67cecab1d850108c9484923539bb3dd9$var$_wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !$67cecab1d850108c9484923539bb3dd9$var$_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return $67cecab1d850108c9484923539bb3dd9$var$_construct(Class, arguments, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf(Wrapper, Class);
  };

  return $67cecab1d850108c9484923539bb3dd9$var$_wrapNativeSuper(Class);
}

function $67cecab1d850108c9484923539bb3dd9$var$isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function $67cecab1d850108c9484923539bb3dd9$var$_construct(Parent, args, Class) {
  if ($67cecab1d850108c9484923539bb3dd9$var$isNativeReflectConstruct()) {
    $67cecab1d850108c9484923539bb3dd9$var$_construct = Reflect.construct;
  } else {
    $67cecab1d850108c9484923539bb3dd9$var$_construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return $67cecab1d850108c9484923539bb3dd9$var$_construct.apply(null, arguments);
}

function $67cecab1d850108c9484923539bb3dd9$var$_isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf(o, p) {
  $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return $67cecab1d850108c9484923539bb3dd9$var$_setPrototypeOf(o, p);
}

function $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(o) {
  $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(o);
}

function $67cecab1d850108c9484923539bb3dd9$var$_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    $67cecab1d850108c9484923539bb3dd9$var$_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    $67cecab1d850108c9484923539bb3dd9$var$_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return $67cecab1d850108c9484923539bb3dd9$var$_typeof(obj);
}

var $67cecab1d850108c9484923539bb3dd9$var$_require = $69678d3e0618202337016e1b4ed76965$init(),
    $67cecab1d850108c9484923539bb3dd9$var$inspect = $67cecab1d850108c9484923539bb3dd9$var$_require.inspect;
var $67cecab1d850108c9484923539bb3dd9$var$ERR_INVALID_ARG_TYPE = $451df81020daf200ba28865e982d3a0a$export$codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function $67cecab1d850108c9484923539bb3dd9$var$endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function $67cecab1d850108c9484923539bb3dd9$var$repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var $67cecab1d850108c9484923539bb3dd9$var$blue = '';
var $67cecab1d850108c9484923539bb3dd9$var$green = '';
var $67cecab1d850108c9484923539bb3dd9$var$red = '';
var $67cecab1d850108c9484923539bb3dd9$var$white = '';
var $67cecab1d850108c9484923539bb3dd9$var$kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

// Comparing short primitives should just show === / !== instead of using the
// diff.
var $67cecab1d850108c9484923539bb3dd9$var$kMaxShortLength = 10;

function $67cecab1d850108c9484923539bb3dd9$var$copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function $67cecab1d850108c9484923539bb3dd9$var$inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return $67cecab1d850108c9484923539bb3dd9$var$inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function $67cecab1d850108c9484923539bb3dd9$var$createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = $67cecab1d850108c9484923539bb3dd9$var$inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = $67cecab1d850108c9484923539bb3dd9$var$inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && $67cecab1d850108c9484923539bb3dd9$var$_typeof(actual) === 'object' && $67cecab1d850108c9484923539bb3dd9$var$_typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= $67cecab1d850108c9484923539bb3dd9$var$kMaxShortLength) {
      if (($67cecab1d850108c9484923539bb3dd9$var$_typeof(actual) !== 'object' || actual === null) && ($67cecab1d850108c9484923539bb3dd9$var$_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat($67cecab1d850108c9484923539bb3dd9$var$kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = $67cecab1d850108c9484923539bb3dd9$var$process.stderr && $67cecab1d850108c9484923539bb3dd9$var$process.stderr.isTTY ? $67cecab1d850108c9484923539bb3dd9$var$process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat($67cecab1d850108c9484923539bb3dd9$var$repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat($67cecab1d850108c9484923539bb3dd9$var$kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = $67cecab1d850108c9484923539bb3dd9$var$kReadableOperator[operator] + "\n".concat($67cecab1d850108c9484923539bb3dd9$var$green, "+ actual").concat($67cecab1d850108c9484923539bb3dd9$var$white, " ").concat($67cecab1d850108c9484923539bb3dd9$var$red, "- expected").concat($67cecab1d850108c9484923539bb3dd9$var$white);
  var skippedMsg = " ".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      // Mark the current line as the last diverging one.
      lastPos = i; // Add the expected line to the cache.

      // Add the expected line to the cache.
      other += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$red, "-").concat($67cecab1d850108c9484923539bb3dd9$var$white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      // Mark the current line as the last diverging one.
      lastPos = i; // Add the actual line to the result.

      // Add the actual line to the result.
      res += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$green, "+").concat($67cecab1d850108c9484923539bb3dd9$var$white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!$67cecab1d850108c9484923539bb3dd9$var$endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && $67cecab1d850108c9484923539bb3dd9$var$endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        // Mark the current line as the last diverging one.
        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$green, "+").concat($67cecab1d850108c9484923539bb3dd9$var$white, " ").concat(actualLine);
        other += "\n".concat($67cecab1d850108c9484923539bb3dd9$var$red, "-").concat($67cecab1d850108c9484923539bb3dd9$var$white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white).concat(other, "\n") + "".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var $67cecab1d850108c9484923539bb3dd9$var$AssertionError = /*#__PURE__*/function (_Error) {
  $67cecab1d850108c9484923539bb3dd9$var$_inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    $67cecab1d850108c9484923539bb3dd9$var$_classCallCheck(this, AssertionError);

    if ($67cecab1d850108c9484923539bb3dd9$var$_typeof(options) !== 'object' || options === null) {
      throw new $67cecab1d850108c9484923539bb3dd9$var$ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(this, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if ($67cecab1d850108c9484923539bb3dd9$var$process.stderr && $67cecab1d850108c9484923539bb3dd9$var$process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if ($67cecab1d850108c9484923539bb3dd9$var$process.stderr && $67cecab1d850108c9484923539bb3dd9$var$process.stderr.getColorDepth && $67cecab1d850108c9484923539bb3dd9$var$process.stderr.getColorDepth() !== 1) {
          $67cecab1d850108c9484923539bb3dd9$var$blue = "\x1B[34m";
          $67cecab1d850108c9484923539bb3dd9$var$green = "\x1B[32m";
          $67cecab1d850108c9484923539bb3dd9$var$white = "\x1B[39m";
          $67cecab1d850108c9484923539bb3dd9$var$red = "\x1B[31m";
        } else {
          $67cecab1d850108c9484923539bb3dd9$var$blue = '';
          $67cecab1d850108c9484923539bb3dd9$var$green = '';
          $67cecab1d850108c9484923539bb3dd9$var$white = '';
          $67cecab1d850108c9484923539bb3dd9$var$red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if ($67cecab1d850108c9484923539bb3dd9$var$_typeof(actual) === 'object' && actual !== null && $67cecab1d850108c9484923539bb3dd9$var$_typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = $67cecab1d850108c9484923539bb3dd9$var$copyError(actual);
        expected = $67cecab1d850108c9484923539bb3dd9$var$copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(this, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(AssertionError).call(this, $67cecab1d850108c9484923539bb3dd9$var$createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = $67cecab1d850108c9484923539bb3dd9$var$kReadableOperator[operator];
        var res = $67cecab1d850108c9484923539bb3dd9$var$inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && $67cecab1d850108c9484923539bb3dd9$var$_typeof(actual) === 'object' && actual !== null) {
          base = $67cecab1d850108c9484923539bb3dd9$var$kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat($67cecab1d850108c9484923539bb3dd9$var$blue, "...").concat($67cecab1d850108c9484923539bb3dd9$var$white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        // Only print a single input.
        if (res.length === 1) {
          _this = $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(this, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(this, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = $67cecab1d850108c9484923539bb3dd9$var$inspectValue(actual);

        var other = '';
        var knownOperators = $67cecab1d850108c9484923539bb3dd9$var$kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat($67cecab1d850108c9484923539bb3dd9$var$kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat($67cecab1d850108c9484923539bb3dd9$var$inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(this, $67cecab1d850108c9484923539bb3dd9$var$_getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty($67cecab1d850108c9484923539bb3dd9$var$_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace($67cecab1d850108c9484923539bb3dd9$var$_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    // Create error message including the error code in the name.
    _this.stack; // Reset the name.

    // Reset the name.
    _this.name = 'AssertionError';
    return $67cecab1d850108c9484923539bb3dd9$var$_possibleConstructorReturn(_this);
  }

  $67cecab1d850108c9484923539bb3dd9$var$_createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: $67cecab1d850108c9484923539bb3dd9$var$inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return $67cecab1d850108c9484923539bb3dd9$var$inspect(this, $67cecab1d850108c9484923539bb3dd9$var$_objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}($67cecab1d850108c9484923539bb3dd9$var$_wrapNativeSuper(Error));

$67cecab1d850108c9484923539bb3dd9$exports = $67cecab1d850108c9484923539bb3dd9$var$AssertionError;
// ASSET: node_modules/es6-object-assign/index.js
var $51aafa8b2b27a6555d4006d168b8fcad$exports,
    $51aafa8b2b27a6555d4006d168b8fcad$executed = false;

function $51aafa8b2b27a6555d4006d168b8fcad$var$assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);

  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];

    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));

    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }

  return to;
}

function $51aafa8b2b27a6555d4006d168b8fcad$var$polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: $51aafa8b2b27a6555d4006d168b8fcad$var$assign
    });
  }
}

function $51aafa8b2b27a6555d4006d168b8fcad$exec() {
  $51aafa8b2b27a6555d4006d168b8fcad$exports = {};
  $51aafa8b2b27a6555d4006d168b8fcad$exports = {
    assign: $51aafa8b2b27a6555d4006d168b8fcad$var$assign,
    polyfill: $51aafa8b2b27a6555d4006d168b8fcad$var$polyfill
  };
}

function $51aafa8b2b27a6555d4006d168b8fcad$init() {
  if (!$51aafa8b2b27a6555d4006d168b8fcad$executed) {
    $51aafa8b2b27a6555d4006d168b8fcad$executed = true;
    $51aafa8b2b27a6555d4006d168b8fcad$exec();
  }

  return $51aafa8b2b27a6555d4006d168b8fcad$exports;
}

// ASSET: node_modules/object-keys/isArguments.js
var $9f180a2edd16831a9d21a0c6ffb7e7a5$exports,
    $9f180a2edd16831a9d21a0c6ffb7e7a5$var$toStr,
    $9f180a2edd16831a9d21a0c6ffb7e7a5$executed = false;

function $9f180a2edd16831a9d21a0c6ffb7e7a5$exec() {
  $9f180a2edd16831a9d21a0c6ffb7e7a5$exports = {};
  $9f180a2edd16831a9d21a0c6ffb7e7a5$var$toStr = Object.prototype.toString;

  $9f180a2edd16831a9d21a0c6ffb7e7a5$exports = function isArguments(value) {
    var str = $9f180a2edd16831a9d21a0c6ffb7e7a5$var$toStr.call(value);
    var isArgs = str === '[object Arguments]';

    if (!isArgs) {
      isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $9f180a2edd16831a9d21a0c6ffb7e7a5$var$toStr.call(value.callee) === '[object Function]';
    }

    return isArgs;
  };
}

function $9f180a2edd16831a9d21a0c6ffb7e7a5$init() {
  if (!$9f180a2edd16831a9d21a0c6ffb7e7a5$executed) {
    $9f180a2edd16831a9d21a0c6ffb7e7a5$executed = true;
    $9f180a2edd16831a9d21a0c6ffb7e7a5$exec();
  }

  return $9f180a2edd16831a9d21a0c6ffb7e7a5$exports;
}

// ASSET: node_modules/object-keys/implementation.js
var $422eaf0e1c992ea13110d7ca93588a57$exports,
    $422eaf0e1c992ea13110d7ca93588a57$var$keysShim,
    $422eaf0e1c992ea13110d7ca93588a57$var$has,
    $422eaf0e1c992ea13110d7ca93588a57$var$toStr,
    $422eaf0e1c992ea13110d7ca93588a57$var$isArgs,
    $422eaf0e1c992ea13110d7ca93588a57$var$isEnumerable,
    $422eaf0e1c992ea13110d7ca93588a57$var$hasDontEnumBug,
    $422eaf0e1c992ea13110d7ca93588a57$var$hasProtoEnumBug,
    $422eaf0e1c992ea13110d7ca93588a57$var$dontEnums,
    $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototype,
    $422eaf0e1c992ea13110d7ca93588a57$var$excludedKeys,
    $422eaf0e1c992ea13110d7ca93588a57$var$hasAutomationEqualityBug,
    $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototypeIfNotBuggy,
    $422eaf0e1c992ea13110d7ca93588a57$executed = false;

function $422eaf0e1c992ea13110d7ca93588a57$exec() {
  $422eaf0e1c992ea13110d7ca93588a57$exports = {};

  if (!Object.keys) {
    $422eaf0e1c992ea13110d7ca93588a57$var$has = Object.prototype.hasOwnProperty;
    $422eaf0e1c992ea13110d7ca93588a57$var$toStr = Object.prototype.toString;
    $422eaf0e1c992ea13110d7ca93588a57$var$isArgs = $9f180a2edd16831a9d21a0c6ffb7e7a5$init();
    $422eaf0e1c992ea13110d7ca93588a57$var$isEnumerable = Object.prototype.propertyIsEnumerable;
    $422eaf0e1c992ea13110d7ca93588a57$var$hasDontEnumBug = !$422eaf0e1c992ea13110d7ca93588a57$var$isEnumerable.call({
      toString: null
    }, 'toString');
    $422eaf0e1c992ea13110d7ca93588a57$var$hasProtoEnumBug = $422eaf0e1c992ea13110d7ca93588a57$var$isEnumerable.call(function () {}, 'prototype');
    $422eaf0e1c992ea13110d7ca93588a57$var$dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

    $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototype = function (o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };

    $422eaf0e1c992ea13110d7ca93588a57$var$excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };

    $422eaf0e1c992ea13110d7ca93588a57$var$hasAutomationEqualityBug = function () {
      /* global window */
      if (typeof window === 'undefined') {
        return false;
      }

      for (var k in window) {
        try {
          if (!$422eaf0e1c992ea13110d7ca93588a57$var$excludedKeys['$' + k] && $422eaf0e1c992ea13110d7ca93588a57$var$has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
            try {
              $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }

      return false;
    }();

    $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototypeIfNotBuggy = function (o) {
      /* global window */
      if (typeof window === 'undefined' || !$422eaf0e1c992ea13110d7ca93588a57$var$hasAutomationEqualityBug) {
        return $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototype(o);
      }

      try {
        return $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };

    $422eaf0e1c992ea13110d7ca93588a57$var$keysShim = function keys(object) {
      var isObject = object !== null && typeof object === 'object';
      var isFunction = $422eaf0e1c992ea13110d7ca93588a57$var$toStr.call(object) === '[object Function]';
      var isArguments = $422eaf0e1c992ea13110d7ca93588a57$var$isArgs(object);
      var isString = isObject && $422eaf0e1c992ea13110d7ca93588a57$var$toStr.call(object) === '[object String]';
      var theKeys = [];

      if (!isObject && !isFunction && !isArguments) {
        throw new TypeError('Object.keys called on a non-object');
      }

      var skipProto = $422eaf0e1c992ea13110d7ca93588a57$var$hasProtoEnumBug && isFunction;

      if (isString && object.length > 0 && !$422eaf0e1c992ea13110d7ca93588a57$var$has.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }

      if (isArguments && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === 'prototype') && $422eaf0e1c992ea13110d7ca93588a57$var$has.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }

      if ($422eaf0e1c992ea13110d7ca93588a57$var$hasDontEnumBug) {
        var skipConstructor = $422eaf0e1c992ea13110d7ca93588a57$var$equalsConstructorPrototypeIfNotBuggy(object);

        for (var k = 0; k < $422eaf0e1c992ea13110d7ca93588a57$var$dontEnums.length; ++k) {
          if (!(skipConstructor && $422eaf0e1c992ea13110d7ca93588a57$var$dontEnums[k] === 'constructor') && $422eaf0e1c992ea13110d7ca93588a57$var$has.call(object, $422eaf0e1c992ea13110d7ca93588a57$var$dontEnums[k])) {
            theKeys.push($422eaf0e1c992ea13110d7ca93588a57$var$dontEnums[k]);
          }
        }
      }

      return theKeys;
    };
  }

  $422eaf0e1c992ea13110d7ca93588a57$exports = $422eaf0e1c992ea13110d7ca93588a57$var$keysShim;
}

function $422eaf0e1c992ea13110d7ca93588a57$init() {
  if (!$422eaf0e1c992ea13110d7ca93588a57$executed) {
    $422eaf0e1c992ea13110d7ca93588a57$executed = true;
    $422eaf0e1c992ea13110d7ca93588a57$exec();
  }

  return $422eaf0e1c992ea13110d7ca93588a57$exports;
}

// ASSET: node_modules/object-keys/index.js
var $0aa4b941f25f045e94656cc08c047e0c$exports,
    $0aa4b941f25f045e94656cc08c047e0c$var$slice,
    $0aa4b941f25f045e94656cc08c047e0c$var$isArgs,
    $0aa4b941f25f045e94656cc08c047e0c$var$origKeys,
    $0aa4b941f25f045e94656cc08c047e0c$var$keysShim,
    $0aa4b941f25f045e94656cc08c047e0c$var$originalKeys,
    $0aa4b941f25f045e94656cc08c047e0c$executed = false;

function $0aa4b941f25f045e94656cc08c047e0c$exec() {
  $0aa4b941f25f045e94656cc08c047e0c$exports = {};
  $0aa4b941f25f045e94656cc08c047e0c$var$slice = Array.prototype.slice;
  $0aa4b941f25f045e94656cc08c047e0c$var$isArgs = $9f180a2edd16831a9d21a0c6ffb7e7a5$init();
  $0aa4b941f25f045e94656cc08c047e0c$var$origKeys = Object.keys;
  $0aa4b941f25f045e94656cc08c047e0c$var$keysShim = $0aa4b941f25f045e94656cc08c047e0c$var$origKeys ? function keys(o) {
    return $0aa4b941f25f045e94656cc08c047e0c$var$origKeys(o);
  } : $422eaf0e1c992ea13110d7ca93588a57$init();
  $0aa4b941f25f045e94656cc08c047e0c$var$originalKeys = Object.keys;

  $0aa4b941f25f045e94656cc08c047e0c$var$keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function () {
        // Safari 5.0 bug
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);

      if (!keysWorksWithArguments) {
        Object.keys = function keys(object) {
          // eslint-disable-line func-name-matching
          if ($0aa4b941f25f045e94656cc08c047e0c$var$isArgs(object)) {
            return $0aa4b941f25f045e94656cc08c047e0c$var$originalKeys($0aa4b941f25f045e94656cc08c047e0c$var$slice.call(object));
          }

          return $0aa4b941f25f045e94656cc08c047e0c$var$originalKeys(object);
        };
      }
    } else {
      Object.keys = $0aa4b941f25f045e94656cc08c047e0c$var$keysShim;
    }

    return Object.keys || $0aa4b941f25f045e94656cc08c047e0c$var$keysShim;
  };

  $0aa4b941f25f045e94656cc08c047e0c$exports = $0aa4b941f25f045e94656cc08c047e0c$var$keysShim;
}

function $0aa4b941f25f045e94656cc08c047e0c$init() {
  if (!$0aa4b941f25f045e94656cc08c047e0c$executed) {
    $0aa4b941f25f045e94656cc08c047e0c$executed = true;
    $0aa4b941f25f045e94656cc08c047e0c$exec();
  }

  return $0aa4b941f25f045e94656cc08c047e0c$exports;
}

// ASSET: node_modules/define-properties/index.js
var $e06e3530f395093eb01c9535e613982e$exports,
    $e06e3530f395093eb01c9535e613982e$var$keys,
    $e06e3530f395093eb01c9535e613982e$var$hasSymbols,
    $e06e3530f395093eb01c9535e613982e$var$toStr,
    $e06e3530f395093eb01c9535e613982e$var$concat,
    $e06e3530f395093eb01c9535e613982e$var$origDefineProperty,
    $e06e3530f395093eb01c9535e613982e$var$isFunction,
    $e06e3530f395093eb01c9535e613982e$var$arePropertyDescriptorsSupported,
    $e06e3530f395093eb01c9535e613982e$var$supportsDescriptors,
    $e06e3530f395093eb01c9535e613982e$var$defineProperty,
    $e06e3530f395093eb01c9535e613982e$var$defineProperties,
    $e06e3530f395093eb01c9535e613982e$executed = false;

function $e06e3530f395093eb01c9535e613982e$exec() {
  $e06e3530f395093eb01c9535e613982e$exports = {};
  $e06e3530f395093eb01c9535e613982e$var$keys = $0aa4b941f25f045e94656cc08c047e0c$init();
  $e06e3530f395093eb01c9535e613982e$var$hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
  $e06e3530f395093eb01c9535e613982e$var$toStr = Object.prototype.toString;
  $e06e3530f395093eb01c9535e613982e$var$concat = Array.prototype.concat;
  $e06e3530f395093eb01c9535e613982e$var$origDefineProperty = Object.defineProperty;

  $e06e3530f395093eb01c9535e613982e$var$isFunction = function (fn) {
    return typeof fn === 'function' && $e06e3530f395093eb01c9535e613982e$var$toStr.call(fn) === '[object Function]';
  };

  $e06e3530f395093eb01c9535e613982e$var$arePropertyDescriptorsSupported = function () {
    var obj = {};

    try {
      $e06e3530f395093eb01c9535e613982e$var$origDefineProperty(obj, 'x', {
        enumerable: false,
        value: obj
      }); // eslint-disable-next-line no-unused-vars, no-restricted-syntax

      // eslint-disable-next-line no-unused-vars, no-restricted-syntax
      for (var _ in obj) {
        // jscs:ignore disallowUnusedVariables
        return false;
      }

      return obj.x === obj;
    } catch (e) {
      /* this is IE 8. */
      return false;
    }
  };

  $e06e3530f395093eb01c9535e613982e$var$supportsDescriptors = $e06e3530f395093eb01c9535e613982e$var$origDefineProperty && $e06e3530f395093eb01c9535e613982e$var$arePropertyDescriptorsSupported();

  $e06e3530f395093eb01c9535e613982e$var$defineProperty = function (object, name, value, predicate) {
    if (name in object && (!$e06e3530f395093eb01c9535e613982e$var$isFunction(predicate) || !predicate())) {
      return;
    }

    if ($e06e3530f395093eb01c9535e613982e$var$supportsDescriptors) {
      $e06e3530f395093eb01c9535e613982e$var$origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
      });
    } else {
      object[name] = value;
    }
  };

  $e06e3530f395093eb01c9535e613982e$var$defineProperties = function (object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = $e06e3530f395093eb01c9535e613982e$var$keys(map);

    if ($e06e3530f395093eb01c9535e613982e$var$hasSymbols) {
      props = $e06e3530f395093eb01c9535e613982e$var$concat.call(props, Object.getOwnPropertySymbols(map));
    }

    for (var i = 0; i < props.length; i += 1) {
      $e06e3530f395093eb01c9535e613982e$var$defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    }
  };

  $e06e3530f395093eb01c9535e613982e$var$defineProperties.supportsDescriptors = !!$e06e3530f395093eb01c9535e613982e$var$supportsDescriptors;
  $e06e3530f395093eb01c9535e613982e$exports = $e06e3530f395093eb01c9535e613982e$var$defineProperties;
}

function $e06e3530f395093eb01c9535e613982e$init() {
  if (!$e06e3530f395093eb01c9535e613982e$executed) {
    $e06e3530f395093eb01c9535e613982e$executed = true;
    $e06e3530f395093eb01c9535e613982e$exec();
  }

  return $e06e3530f395093eb01c9535e613982e$exports;
}

// ASSET: node_modules/object-is/implementation.js
var $63b0d12d2ee69f5d76a9d18b3429049c$exports,
    $63b0d12d2ee69f5d76a9d18b3429049c$var$numberIsNaN,
    $63b0d12d2ee69f5d76a9d18b3429049c$executed = false;

function $63b0d12d2ee69f5d76a9d18b3429049c$exec() {
  $63b0d12d2ee69f5d76a9d18b3429049c$exports = {};

  $63b0d12d2ee69f5d76a9d18b3429049c$var$numberIsNaN = function (value) {
    return value !== value;
  };

  $63b0d12d2ee69f5d76a9d18b3429049c$exports = function is(a, b) {
    if (a === 0 && b === 0) {
      return 1 / a === 1 / b;
    }

    if (a === b) {
      return true;
    }

    if ($63b0d12d2ee69f5d76a9d18b3429049c$var$numberIsNaN(a) && $63b0d12d2ee69f5d76a9d18b3429049c$var$numberIsNaN(b)) {
      return true;
    }

    return false;
  };
}

function $63b0d12d2ee69f5d76a9d18b3429049c$init() {
  if (!$63b0d12d2ee69f5d76a9d18b3429049c$executed) {
    $63b0d12d2ee69f5d76a9d18b3429049c$executed = true;
    $63b0d12d2ee69f5d76a9d18b3429049c$exec();
  }

  return $63b0d12d2ee69f5d76a9d18b3429049c$exports;
}

// ASSET: node_modules/object-is/polyfill.js
var $bd876d2d3e5e98d6b87f600dbc07022e$exports,
    $bd876d2d3e5e98d6b87f600dbc07022e$var$implementation,
    $bd876d2d3e5e98d6b87f600dbc07022e$executed = false;

function $bd876d2d3e5e98d6b87f600dbc07022e$exec() {
  $bd876d2d3e5e98d6b87f600dbc07022e$exports = {};
  $bd876d2d3e5e98d6b87f600dbc07022e$var$implementation = $63b0d12d2ee69f5d76a9d18b3429049c$init();

  $bd876d2d3e5e98d6b87f600dbc07022e$exports = function getPolyfill() {
    return typeof Object.is === 'function' ? Object.is : $bd876d2d3e5e98d6b87f600dbc07022e$var$implementation;
  };
}

function $bd876d2d3e5e98d6b87f600dbc07022e$init() {
  if (!$bd876d2d3e5e98d6b87f600dbc07022e$executed) {
    $bd876d2d3e5e98d6b87f600dbc07022e$executed = true;
    $bd876d2d3e5e98d6b87f600dbc07022e$exec();
  }

  return $bd876d2d3e5e98d6b87f600dbc07022e$exports;
}

// ASSET: node_modules/object-is/shim.js
var $a13479d704644c8352416caacce07b01$exports,
    $a13479d704644c8352416caacce07b01$var$getPolyfill,
    $a13479d704644c8352416caacce07b01$var$define,
    $a13479d704644c8352416caacce07b01$executed = false;

function $a13479d704644c8352416caacce07b01$exec() {
  $a13479d704644c8352416caacce07b01$exports = {};
  $a13479d704644c8352416caacce07b01$var$getPolyfill = $bd876d2d3e5e98d6b87f600dbc07022e$init();
  $a13479d704644c8352416caacce07b01$var$define = $e06e3530f395093eb01c9535e613982e$init();

  $a13479d704644c8352416caacce07b01$exports = function shimObjectIs() {
    var polyfill = $a13479d704644c8352416caacce07b01$var$getPolyfill();
    $a13479d704644c8352416caacce07b01$var$define(Object, {
      is: polyfill
    }, {
      is: function testObjectIs() {
        return Object.is !== polyfill;
      }
    });
    return polyfill;
  };
}

function $a13479d704644c8352416caacce07b01$init() {
  if (!$a13479d704644c8352416caacce07b01$executed) {
    $a13479d704644c8352416caacce07b01$executed = true;
    $a13479d704644c8352416caacce07b01$exec();
  }

  return $a13479d704644c8352416caacce07b01$exports;
}

// ASSET: node_modules/object-is/index.js
var $b3907554cc0e775ba10fc1e92615cda9$exports,
    $b3907554cc0e775ba10fc1e92615cda9$var$define,
    $b3907554cc0e775ba10fc1e92615cda9$var$callBind,
    $b3907554cc0e775ba10fc1e92615cda9$var$implementation,
    $b3907554cc0e775ba10fc1e92615cda9$var$getPolyfill,
    $b3907554cc0e775ba10fc1e92615cda9$var$shim,
    $b3907554cc0e775ba10fc1e92615cda9$var$polyfill,
    $b3907554cc0e775ba10fc1e92615cda9$executed = false;

function $b3907554cc0e775ba10fc1e92615cda9$exec() {
  $b3907554cc0e775ba10fc1e92615cda9$exports = {};
  $b3907554cc0e775ba10fc1e92615cda9$var$define = $e06e3530f395093eb01c9535e613982e$init();
  $b3907554cc0e775ba10fc1e92615cda9$var$callBind = $b2fe57bdbeef015e6d17ecffaa00c5a0$init();
  $b3907554cc0e775ba10fc1e92615cda9$var$implementation = $63b0d12d2ee69f5d76a9d18b3429049c$init();
  $b3907554cc0e775ba10fc1e92615cda9$var$getPolyfill = $bd876d2d3e5e98d6b87f600dbc07022e$init();
  $b3907554cc0e775ba10fc1e92615cda9$var$shim = $a13479d704644c8352416caacce07b01$init();
  $b3907554cc0e775ba10fc1e92615cda9$var$polyfill = $b3907554cc0e775ba10fc1e92615cda9$var$callBind($b3907554cc0e775ba10fc1e92615cda9$var$getPolyfill(), Object);
  $b3907554cc0e775ba10fc1e92615cda9$var$define($b3907554cc0e775ba10fc1e92615cda9$var$polyfill, {
    getPolyfill: $b3907554cc0e775ba10fc1e92615cda9$var$getPolyfill,
    implementation: $b3907554cc0e775ba10fc1e92615cda9$var$implementation,
    shim: $b3907554cc0e775ba10fc1e92615cda9$var$shim
  });
  $b3907554cc0e775ba10fc1e92615cda9$exports = $b3907554cc0e775ba10fc1e92615cda9$var$polyfill;
}

function $b3907554cc0e775ba10fc1e92615cda9$init() {
  if (!$b3907554cc0e775ba10fc1e92615cda9$executed) {
    $b3907554cc0e775ba10fc1e92615cda9$executed = true;
    $b3907554cc0e775ba10fc1e92615cda9$exec();
  }

  return $b3907554cc0e775ba10fc1e92615cda9$exports;
}

// ASSET: node_modules/is-nan/implementation.js
var $a5da3310a4c189ceeb39ce26d8e2e3c0$exports,
    $a5da3310a4c189ceeb39ce26d8e2e3c0$executed = false;

function $a5da3310a4c189ceeb39ce26d8e2e3c0$exec() {
  $a5da3310a4c189ceeb39ce26d8e2e3c0$exports = {};

  /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */
  $a5da3310a4c189ceeb39ce26d8e2e3c0$exports = function isNaN(value) {
    return value !== value;
  };
}

function $a5da3310a4c189ceeb39ce26d8e2e3c0$init() {
  if (!$a5da3310a4c189ceeb39ce26d8e2e3c0$executed) {
    $a5da3310a4c189ceeb39ce26d8e2e3c0$executed = true;
    $a5da3310a4c189ceeb39ce26d8e2e3c0$exec();
  }

  return $a5da3310a4c189ceeb39ce26d8e2e3c0$exports;
}

// ASSET: node_modules/is-nan/polyfill.js
var $00d64843f41d664d7256ff7ddca61698$exports,
    $00d64843f41d664d7256ff7ddca61698$var$implementation,
    $00d64843f41d664d7256ff7ddca61698$executed = false;

function $00d64843f41d664d7256ff7ddca61698$exec() {
  $00d64843f41d664d7256ff7ddca61698$exports = {};
  $00d64843f41d664d7256ff7ddca61698$var$implementation = $a5da3310a4c189ceeb39ce26d8e2e3c0$init();

  $00d64843f41d664d7256ff7ddca61698$exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
      return Number.isNaN;
    }

    return $00d64843f41d664d7256ff7ddca61698$var$implementation;
  };
}

function $00d64843f41d664d7256ff7ddca61698$init() {
  if (!$00d64843f41d664d7256ff7ddca61698$executed) {
    $00d64843f41d664d7256ff7ddca61698$executed = true;
    $00d64843f41d664d7256ff7ddca61698$exec();
  }

  return $00d64843f41d664d7256ff7ddca61698$exports;
}

// ASSET: node_modules/is-nan/shim.js
var $6d282547b6aaa7250cacc00a73a79b47$exports,
    $6d282547b6aaa7250cacc00a73a79b47$var$define,
    $6d282547b6aaa7250cacc00a73a79b47$var$getPolyfill,
    $6d282547b6aaa7250cacc00a73a79b47$executed = false;

function $6d282547b6aaa7250cacc00a73a79b47$exec() {
  $6d282547b6aaa7250cacc00a73a79b47$exports = {};
  $6d282547b6aaa7250cacc00a73a79b47$var$define = $e06e3530f395093eb01c9535e613982e$init();
  $6d282547b6aaa7250cacc00a73a79b47$var$getPolyfill = $00d64843f41d664d7256ff7ddca61698$init();

  /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */
  $6d282547b6aaa7250cacc00a73a79b47$exports = function shimNumberIsNaN() {
    var polyfill = $6d282547b6aaa7250cacc00a73a79b47$var$getPolyfill();
    $6d282547b6aaa7250cacc00a73a79b47$var$define(Number, {
      isNaN: polyfill
    }, {
      isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill;
      }
    });
    return polyfill;
  };
}

function $6d282547b6aaa7250cacc00a73a79b47$init() {
  if (!$6d282547b6aaa7250cacc00a73a79b47$executed) {
    $6d282547b6aaa7250cacc00a73a79b47$executed = true;
    $6d282547b6aaa7250cacc00a73a79b47$exec();
  }

  return $6d282547b6aaa7250cacc00a73a79b47$exports;
}

// ASSET: node_modules/is-nan/index.js
var $cdc7e84320847a5b523771232c0ded15$exports,
    $cdc7e84320847a5b523771232c0ded15$var$define,
    $cdc7e84320847a5b523771232c0ded15$var$implementation,
    $cdc7e84320847a5b523771232c0ded15$var$getPolyfill,
    $cdc7e84320847a5b523771232c0ded15$var$shim,
    $cdc7e84320847a5b523771232c0ded15$var$polyfill,
    $cdc7e84320847a5b523771232c0ded15$executed = false;

function $cdc7e84320847a5b523771232c0ded15$exec() {
  $cdc7e84320847a5b523771232c0ded15$exports = {};
  $cdc7e84320847a5b523771232c0ded15$var$define = $e06e3530f395093eb01c9535e613982e$init();
  $cdc7e84320847a5b523771232c0ded15$var$implementation = $a5da3310a4c189ceeb39ce26d8e2e3c0$init();
  $cdc7e84320847a5b523771232c0ded15$var$getPolyfill = $00d64843f41d664d7256ff7ddca61698$init();
  $cdc7e84320847a5b523771232c0ded15$var$shim = $6d282547b6aaa7250cacc00a73a79b47$init();
  $cdc7e84320847a5b523771232c0ded15$var$polyfill = $cdc7e84320847a5b523771232c0ded15$var$getPolyfill();

  /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */
  $cdc7e84320847a5b523771232c0ded15$var$define($cdc7e84320847a5b523771232c0ded15$var$polyfill, {
    getPolyfill: $cdc7e84320847a5b523771232c0ded15$var$getPolyfill,
    implementation: $cdc7e84320847a5b523771232c0ded15$var$implementation,
    shim: $cdc7e84320847a5b523771232c0ded15$var$shim
  });
  $cdc7e84320847a5b523771232c0ded15$exports = $cdc7e84320847a5b523771232c0ded15$var$polyfill;
}

function $cdc7e84320847a5b523771232c0ded15$init() {
  if (!$cdc7e84320847a5b523771232c0ded15$executed) {
    $cdc7e84320847a5b523771232c0ded15$executed = true;
    $cdc7e84320847a5b523771232c0ded15$exec();
  }

  return $cdc7e84320847a5b523771232c0ded15$exports;
}

// ASSET: node_modules/assert/build/internal/util/comparisons.js
var $299b35bf4e054a5a6b58d95129252536$exports,
    $299b35bf4e054a5a6b58d95129252536$var$regexFlagsSupported,
    $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet,
    $299b35bf4e054a5a6b58d95129252536$var$arrayFromMap,
    $299b35bf4e054a5a6b58d95129252536$var$objectIs,
    $299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols,
    $299b35bf4e054a5a6b58d95129252536$var$numberIsNaN,
    $299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty,
    $299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable,
    $299b35bf4e054a5a6b58d95129252536$var$objectToString,
    $299b35bf4e054a5a6b58d95129252536$var$_require$types,
    $299b35bf4e054a5a6b58d95129252536$var$isAnyArrayBuffer,
    $299b35bf4e054a5a6b58d95129252536$var$isArrayBufferView,
    $299b35bf4e054a5a6b58d95129252536$var$isDate,
    $299b35bf4e054a5a6b58d95129252536$var$isMap,
    $299b35bf4e054a5a6b58d95129252536$var$isRegExp,
    $299b35bf4e054a5a6b58d95129252536$var$isSet,
    $299b35bf4e054a5a6b58d95129252536$var$isNativeError,
    $299b35bf4e054a5a6b58d95129252536$var$isBoxedPrimitive,
    $299b35bf4e054a5a6b58d95129252536$var$isNumberObject,
    $299b35bf4e054a5a6b58d95129252536$var$isStringObject,
    $299b35bf4e054a5a6b58d95129252536$var$isBooleanObject,
    $299b35bf4e054a5a6b58d95129252536$var$isBigIntObject,
    $299b35bf4e054a5a6b58d95129252536$var$isSymbolObject,
    $299b35bf4e054a5a6b58d95129252536$var$isFloat32Array,
    $299b35bf4e054a5a6b58d95129252536$var$isFloat64Array,
    $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE,
    $299b35bf4e054a5a6b58d95129252536$var$kStrict,
    $299b35bf4e054a5a6b58d95129252536$var$kLoose,
    $299b35bf4e054a5a6b58d95129252536$var$kNoIterator,
    $299b35bf4e054a5a6b58d95129252536$var$kIsArray,
    $299b35bf4e054a5a6b58d95129252536$var$kIsSet,
    $299b35bf4e054a5a6b58d95129252536$var$kIsMap,
    $299b35bf4e054a5a6b58d95129252536$executed = false;

function $299b35bf4e054a5a6b58d95129252536$var$_slicedToArray(arr, i) {
  return $299b35bf4e054a5a6b58d95129252536$var$_arrayWithHoles(arr) || $299b35bf4e054a5a6b58d95129252536$var$_iterableToArrayLimit(arr, i) || $299b35bf4e054a5a6b58d95129252536$var$_nonIterableRest();
}

function $299b35bf4e054a5a6b58d95129252536$var$_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function $299b35bf4e054a5a6b58d95129252536$var$_iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function $299b35bf4e054a5a6b58d95129252536$var$_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function $299b35bf4e054a5a6b58d95129252536$var$_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    $299b35bf4e054a5a6b58d95129252536$var$_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    $299b35bf4e054a5a6b58d95129252536$var$_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return $299b35bf4e054a5a6b58d95129252536$var$_typeof(obj);
}

function $299b35bf4e054a5a6b58d95129252536$var$uncurryThis(f) {
  return f.call.bind(f);
}

function $299b35bf4e054a5a6b58d95129252536$var$isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}

function $299b35bf4e054a5a6b58d95129252536$var$getOwnNonIndexProperties(value) {
  return Object.keys(value).filter($299b35bf4e054a5a6b58d95129252536$var$isNonIndex).concat($299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function $299b35bf4e054a5a6b58d95129252536$var$compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

// Check if they have the same source and flags
function $299b35bf4e054a5a6b58d95129252536$var$areSimilarRegExps(a, b) {
  return $299b35bf4e054a5a6b58d95129252536$var$regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function $299b35bf4e054a5a6b58d95129252536$var$areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function $299b35bf4e054a5a6b58d95129252536$var$areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return $299b35bf4e054a5a6b58d95129252536$var$compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function $299b35bf4e054a5a6b58d95129252536$var$areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && $299b35bf4e054a5a6b58d95129252536$var$compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function $299b35bf4e054a5a6b58d95129252536$var$isEqualBoxedPrimitive(val1, val2) {
  if ($299b35bf4e054a5a6b58d95129252536$var$isNumberObject(val1)) {
    return $299b35bf4e054a5a6b58d95129252536$var$isNumberObject(val2) && $299b35bf4e054a5a6b58d95129252536$var$objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if ($299b35bf4e054a5a6b58d95129252536$var$isStringObject(val1)) {
    return $299b35bf4e054a5a6b58d95129252536$var$isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if ($299b35bf4e054a5a6b58d95129252536$var$isBooleanObject(val1)) {
    return $299b35bf4e054a5a6b58d95129252536$var$isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if ($299b35bf4e054a5a6b58d95129252536$var$isBigIntObject(val1)) {
    return $299b35bf4e054a5a6b58d95129252536$var$isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return $299b35bf4e054a5a6b58d95129252536$var$isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.
function $299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? $299b35bf4e054a5a6b58d95129252536$var$objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && $299b35bf4e054a5a6b58d95129252536$var$numberIsNaN(val1) && $299b35bf4e054a5a6b58d95129252536$var$numberIsNaN(val2);
    }

    if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || $299b35bf4e054a5a6b58d95129252536$var$_typeof(val1) !== 'object') {
      if (val2 === null || $299b35bf4e054a5a6b58d95129252536$var$_typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || $299b35bf4e054a5a6b58d95129252536$var$_typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = $299b35bf4e054a5a6b58d95129252536$var$objectToString(val1);
  var val2Tag = $299b35bf4e054a5a6b58d95129252536$var$objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = $299b35bf4e054a5a6b58d95129252536$var$getOwnNonIndexProperties(val1, $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE);
    var keys2 = $299b35bf4e054a5a6b58d95129252536$var$getOwnNonIndexProperties(val2, $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, $299b35bf4e054a5a6b58d95129252536$var$kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!$299b35bf4e054a5a6b58d95129252536$var$isMap(val1) && $299b35bf4e054a5a6b58d95129252536$var$isMap(val2) || !$299b35bf4e054a5a6b58d95129252536$var$isSet(val1) && $299b35bf4e054a5a6b58d95129252536$var$isSet(val2)) {
      return false;
    }
  }

  if ($299b35bf4e054a5a6b58d95129252536$var$isDate(val1)) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isRegExp(val1)) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$isRegExp(val2) || !$299b35bf4e054a5a6b58d95129252536$var$areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isArrayBufferView(val1)) {
    if (!strict && ($299b35bf4e054a5a6b58d95129252536$var$isFloat32Array(val1) || $299b35bf4e054a5a6b58d95129252536$var$isFloat64Array(val1))) {
      if (!$299b35bf4e054a5a6b58d95129252536$var$areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!$299b35bf4e054a5a6b58d95129252536$var$areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = $299b35bf4e054a5a6b58d95129252536$var$getOwnNonIndexProperties(val1, $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE);

    var _keys2 = $299b35bf4e054a5a6b58d95129252536$var$getOwnNonIndexProperties(val2, $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, $299b35bf4e054a5a6b58d95129252536$var$kNoIterator, _keys);
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isSet(val1)) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, $299b35bf4e054a5a6b58d95129252536$var$kIsSet);
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isMap(val1)) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, $299b35bf4e054a5a6b58d95129252536$var$kIsMap);
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isAnyArrayBuffer(val1)) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if ($299b35bf4e054a5a6b58d95129252536$var$isBoxedPrimitive(val1) && !$299b35bf4e054a5a6b58d95129252536$var$isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, $299b35bf4e054a5a6b58d95129252536$var$kNoIterator);
}

function $299b35bf4e054a5a6b58d95129252536$var$getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return $299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable(val, k);
  });
}

function $299b35bf4e054a5a6b58d95129252536$var$keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  // Cheap key test
  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = $299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if ($299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable(val1, key)) {
          if (!$299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if ($299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = $299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && $299b35bf4e054a5a6b58d95129252536$var$getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = $299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && $299b35bf4e054a5a6b58d95129252536$var$getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === $299b35bf4e054a5a6b58d95129252536$var$kNoIterator || iterationType === $299b35bf4e054a5a6b58d95129252536$var$kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = $299b35bf4e054a5a6b58d95129252536$var$objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function $299b35bf4e054a5a6b58d95129252536$var$setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if ($299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function $299b35bf4e054a5a6b58d95129252536$var$findLooseMatchingPrimitives(prim) {
  switch ($299b35bf4e054a5a6b58d95129252536$var$_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if ($299b35bf4e054a5a6b58d95129252536$var$numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function $299b35bf4e054a5a6b58d95129252536$var$setMightHaveLoosePrim(a, b, prim) {
  var altValue = $299b35bf4e054a5a6b58d95129252536$var$findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function $299b35bf4e054a5a6b58d95129252536$var$mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = $299b35bf4e054a5a6b58d95129252536$var$findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && $299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(item, curB, false, memo);
}

function $299b35bf4e054a5a6b58d95129252536$var$setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!$299b35bf4e054a5a6b58d95129252536$var$setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(_val) === 'object' && _val !== null) {
        if (!$299b35bf4e054a5a6b58d95129252536$var$setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !$299b35bf4e054a5a6b58d95129252536$var$setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function $299b35bf4e054a5a6b58d95129252536$var$mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if ($299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(key1, key2, strict, memo) && $299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function $299b35bf4e054a5a6b58d95129252536$var$mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = $299b35bf4e054a5a6b58d95129252536$var$arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = $299b35bf4e054a5a6b58d95129252536$var$_slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!$299b35bf4e054a5a6b58d95129252536$var$mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = $299b35bf4e054a5a6b58d95129252536$var$arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = $299b35bf4e054a5a6b58d95129252536$var$_slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if ($299b35bf4e054a5a6b58d95129252536$var$_typeof(key) === 'object' && key !== null) {
        if (!$299b35bf4e054a5a6b58d95129252536$var$mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(a.get(key), item, false, memo)) && !$299b35bf4e054a5a6b58d95129252536$var$mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function $299b35bf4e054a5a6b58d95129252536$var$objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === $299b35bf4e054a5a6b58d95129252536$var$kIsSet) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === $299b35bf4e054a5a6b58d95129252536$var$kIsMap) {
    if (!$299b35bf4e054a5a6b58d95129252536$var$mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === $299b35bf4e054a5a6b58d95129252536$var$kIsArray) {
    for (; i < a.length; i++) {
      if ($299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty(a, i)) {
        if (!$299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty(b, i) || !$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if ($299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!$299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty(b, key) || !$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!$299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function $299b35bf4e054a5a6b58d95129252536$var$isDeepEqual(val1, val2) {
  return $299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(val1, val2, $299b35bf4e054a5a6b58d95129252536$var$kLoose);
}

function $299b35bf4e054a5a6b58d95129252536$var$isDeepStrictEqual(val1, val2) {
  return $299b35bf4e054a5a6b58d95129252536$var$innerDeepEqual(val1, val2, $299b35bf4e054a5a6b58d95129252536$var$kStrict);
}

function $299b35bf4e054a5a6b58d95129252536$exec() {
  $299b35bf4e054a5a6b58d95129252536$exports = {};
  $299b35bf4e054a5a6b58d95129252536$var$regexFlagsSupported = /a/g.flags !== undefined;

  $299b35bf4e054a5a6b58d95129252536$var$arrayFromSet = function arrayFromSet(set) {
    var array = [];
    set.forEach(function (value) {
      return array.push(value);
    });
    return array;
  };

  $299b35bf4e054a5a6b58d95129252536$var$arrayFromMap = function arrayFromMap(map) {
    var array = [];
    map.forEach(function (value, key) {
      return array.push([key, value]);
    });
    return array;
  };

  $299b35bf4e054a5a6b58d95129252536$var$objectIs = Object.is ? Object.is : $b3907554cc0e775ba10fc1e92615cda9$init();
  $299b35bf4e054a5a6b58d95129252536$var$objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
    return [];
  };
  $299b35bf4e054a5a6b58d95129252536$var$numberIsNaN = Number.isNaN ? Number.isNaN : $cdc7e84320847a5b523771232c0ded15$init();
  $299b35bf4e054a5a6b58d95129252536$var$hasOwnProperty = $299b35bf4e054a5a6b58d95129252536$var$uncurryThis(Object.prototype.hasOwnProperty);
  $299b35bf4e054a5a6b58d95129252536$var$propertyIsEnumerable = $299b35bf4e054a5a6b58d95129252536$var$uncurryThis(Object.prototype.propertyIsEnumerable);
  $299b35bf4e054a5a6b58d95129252536$var$objectToString = $299b35bf4e054a5a6b58d95129252536$var$uncurryThis(Object.prototype.toString);
  $299b35bf4e054a5a6b58d95129252536$var$_require$types = $69678d3e0618202337016e1b4ed76965$init().types, $299b35bf4e054a5a6b58d95129252536$var$isAnyArrayBuffer = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isAnyArrayBuffer, $299b35bf4e054a5a6b58d95129252536$var$isArrayBufferView = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isArrayBufferView, $299b35bf4e054a5a6b58d95129252536$var$isDate = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isDate, $299b35bf4e054a5a6b58d95129252536$var$isMap = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isMap, $299b35bf4e054a5a6b58d95129252536$var$isRegExp = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isRegExp, $299b35bf4e054a5a6b58d95129252536$var$isSet = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isSet, $299b35bf4e054a5a6b58d95129252536$var$isNativeError = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isNativeError, $299b35bf4e054a5a6b58d95129252536$var$isBoxedPrimitive = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isBoxedPrimitive, $299b35bf4e054a5a6b58d95129252536$var$isNumberObject = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isNumberObject, $299b35bf4e054a5a6b58d95129252536$var$isStringObject = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isStringObject, $299b35bf4e054a5a6b58d95129252536$var$isBooleanObject = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isBooleanObject, $299b35bf4e054a5a6b58d95129252536$var$isBigIntObject = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isBigIntObject, $299b35bf4e054a5a6b58d95129252536$var$isSymbolObject = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isSymbolObject, $299b35bf4e054a5a6b58d95129252536$var$isFloat32Array = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isFloat32Array, $299b35bf4e054a5a6b58d95129252536$var$isFloat64Array = $299b35bf4e054a5a6b58d95129252536$var$_require$types.isFloat64Array;
  $299b35bf4e054a5a6b58d95129252536$var$ONLY_ENUMERABLE = undefined;
  $299b35bf4e054a5a6b58d95129252536$var$kStrict = true;
  $299b35bf4e054a5a6b58d95129252536$var$kLoose = false;
  $299b35bf4e054a5a6b58d95129252536$var$kNoIterator = 0;
  $299b35bf4e054a5a6b58d95129252536$var$kIsArray = 1;
  $299b35bf4e054a5a6b58d95129252536$var$kIsSet = 2;
  $299b35bf4e054a5a6b58d95129252536$var$kIsMap = 3;
  $299b35bf4e054a5a6b58d95129252536$exports = {
    isDeepEqual: $299b35bf4e054a5a6b58d95129252536$var$isDeepEqual,
    isDeepStrictEqual: $299b35bf4e054a5a6b58d95129252536$var$isDeepStrictEqual
  };
}

function $299b35bf4e054a5a6b58d95129252536$init() {
  if (!$299b35bf4e054a5a6b58d95129252536$executed) {
    $299b35bf4e054a5a6b58d95129252536$executed = true;
    $299b35bf4e054a5a6b58d95129252536$exec();
  }

  return $299b35bf4e054a5a6b58d95129252536$exports;
}

// ASSET: node_modules/assert/build/assert.js
var $034bb26d820f8530f21df3dfc0306a11$exports,
    $034bb26d820f8530f21df3dfc0306a11$var$process,
    $034bb26d820f8530f21df3dfc0306a11$var$_require,
    $034bb26d820f8530f21df3dfc0306a11$var$_require$codes,
    $034bb26d820f8530f21df3dfc0306a11$var$ERR_AMBIGUOUS_ARGUMENT,
    $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE,
    $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_VALUE,
    $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_RETURN_VALUE,
    $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS,
    $034bb26d820f8530f21df3dfc0306a11$var$AssertionError,
    $034bb26d820f8530f21df3dfc0306a11$var$_require2,
    $034bb26d820f8530f21df3dfc0306a11$var$inspect,
    $034bb26d820f8530f21df3dfc0306a11$var$_require$types,
    $034bb26d820f8530f21df3dfc0306a11$var$isPromise,
    $034bb26d820f8530f21df3dfc0306a11$var$isRegExp,
    $034bb26d820f8530f21df3dfc0306a11$var$objectAssign,
    $034bb26d820f8530f21df3dfc0306a11$var$objectIs,
    $034bb26d820f8530f21df3dfc0306a11$var$errorCache,
    $034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual,
    $034bb26d820f8530f21df3dfc0306a11$var$isDeepStrictEqual,
    $034bb26d820f8530f21df3dfc0306a11$var$parseExpressionAt,
    $034bb26d820f8530f21df3dfc0306a11$var$findNodeAround,
    $034bb26d820f8530f21df3dfc0306a11$var$decoder,
    $034bb26d820f8530f21df3dfc0306a11$var$escapeSequencesRegExp,
    $034bb26d820f8530f21df3dfc0306a11$var$meta,
    $034bb26d820f8530f21df3dfc0306a11$var$escapeFn,
    $034bb26d820f8530f21df3dfc0306a11$var$warned,
    $034bb26d820f8530f21df3dfc0306a11$var$assert,
    $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL,
    $034bb26d820f8530f21df3dfc0306a11$var$Comparison,
    $034bb26d820f8530f21df3dfc0306a11$executed = false;

function $034bb26d820f8530f21df3dfc0306a11$var$_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    $034bb26d820f8530f21df3dfc0306a11$var$_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    $034bb26d820f8530f21df3dfc0306a11$var$_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return $034bb26d820f8530f21df3dfc0306a11$var$_typeof(obj);
}

function $034bb26d820f8530f21df3dfc0306a11$var$_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison() {
  var comparison = $299b35bf4e054a5a6b58d95129252536$init();
  $034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual = comparison.isDeepEqual;
  $034bb26d820f8530f21df3dfc0306a11$var$isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function $034bb26d820f8530f21df3dfc0306a11$var$innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError(obj);
}

function $034bb26d820f8530f21df3dfc0306a11$var$fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if ($034bb26d820f8530f21df3dfc0306a11$var$warned === false) {
      $034bb26d820f8530f21df3dfc0306a11$var$warned = true;
      var warn = $034bb26d820f8530f21df3dfc0306a11$var$process.emitWarning ? $034bb26d820f8530f21df3dfc0306a11$var$process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || $034bb26d820f8530f21df3dfc0306a11$var$fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

function $034bb26d820f8530f21df3dfc0306a11$var$innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function $034bb26d820f8530f21df3dfc0306a11$var$ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  $034bb26d820f8530f21df3dfc0306a11$var$innerOk.apply(void 0, [$034bb26d820f8530f21df3dfc0306a11$var$ok, args.length].concat(args));
}

function $034bb26d820f8530f21df3dfc0306a11$var$notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
  }

  if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual === undefined) $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison();

  if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepStrictEqual(actual, expected)) {
    $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: $034bb26d820f8530f21df3dfc0306a11$var$notDeepStrictEqual
    });
  }
}

function $034bb26d820f8530f21df3dfc0306a11$var$compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !$034bb26d820f8530f21df3dfc0306a11$var$isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new $034bb26d820f8530f21df3dfc0306a11$var$Comparison(actual, keys);
      var b = new $034bb26d820f8530f21df3dfc0306a11$var$Comparison(expected, keys, actual);
      var err = new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function $034bb26d820f8530f21df3dfc0306a11$var$expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if ($034bb26d820f8530f21df3dfc0306a11$var$isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    // Handle primitives properly.
    if ($034bb26d820f8530f21df3dfc0306a11$var$_typeof(actual) !== 'object' || actual === null) {
      var err = new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual === undefined) $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && $034bb26d820f8530f21df3dfc0306a11$var$isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      $034bb26d820f8530f21df3dfc0306a11$var$compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function $034bb26d820f8530f21df3dfc0306a11$var$getActual(fn) {
  if (typeof fn !== 'function') {
    throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL;
}

function $034bb26d820f8530f21df3dfc0306a11$var$checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return $034bb26d820f8530f21df3dfc0306a11$var$isPromise(obj) || obj !== null && $034bb26d820f8530f21df3dfc0306a11$var$_typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function $034bb26d820f8530f21df3dfc0306a11$var$waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      // Fail in case no promise is returned.
      if (!$034bb26d820f8530f21df3dfc0306a11$var$checkIsPromise(resultPromise)) {
        throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if ($034bb26d820f8530f21df3dfc0306a11$var$checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function $034bb26d820f8530f21df3dfc0306a11$var$expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && $034bb26d820f8530f21df3dfc0306a11$var$_typeof(error) !== 'object' && typeof error !== 'function') {
    throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !$034bb26d820f8530f21df3dfc0306a11$var$expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function $034bb26d820f8530f21df3dfc0306a11$var$expectsNoError(stackStartFn, actual, error, message) {
  if (actual === $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || $034bb26d820f8530f21df3dfc0306a11$var$expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

// Expose a strict only variant of assert
function $034bb26d820f8530f21df3dfc0306a11$var$strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  $034bb26d820f8530f21df3dfc0306a11$var$innerOk.apply(void 0, [$034bb26d820f8530f21df3dfc0306a11$var$strict, args.length].concat(args));
}

function $034bb26d820f8530f21df3dfc0306a11$exec() {
  $034bb26d820f8530f21df3dfc0306a11$exports = {};
  $034bb26d820f8530f21df3dfc0306a11$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $034bb26d820f8530f21df3dfc0306a11$var$_require = $451df81020daf200ba28865e982d3a0a$exports, $034bb26d820f8530f21df3dfc0306a11$var$_require$codes = $034bb26d820f8530f21df3dfc0306a11$var$_require.codes, $034bb26d820f8530f21df3dfc0306a11$var$ERR_AMBIGUOUS_ARGUMENT = $034bb26d820f8530f21df3dfc0306a11$var$_require$codes.ERR_AMBIGUOUS_ARGUMENT, $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_TYPE = $034bb26d820f8530f21df3dfc0306a11$var$_require$codes.ERR_INVALID_ARG_TYPE, $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_ARG_VALUE = $034bb26d820f8530f21df3dfc0306a11$var$_require$codes.ERR_INVALID_ARG_VALUE, $034bb26d820f8530f21df3dfc0306a11$var$ERR_INVALID_RETURN_VALUE = $034bb26d820f8530f21df3dfc0306a11$var$_require$codes.ERR_INVALID_RETURN_VALUE, $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS = $034bb26d820f8530f21df3dfc0306a11$var$_require$codes.ERR_MISSING_ARGS;
  $034bb26d820f8530f21df3dfc0306a11$var$AssertionError = $67cecab1d850108c9484923539bb3dd9$exports;
  $034bb26d820f8530f21df3dfc0306a11$var$_require2 = $69678d3e0618202337016e1b4ed76965$init(), $034bb26d820f8530f21df3dfc0306a11$var$inspect = $034bb26d820f8530f21df3dfc0306a11$var$_require2.inspect;
  $034bb26d820f8530f21df3dfc0306a11$var$_require$types = $69678d3e0618202337016e1b4ed76965$init().types, $034bb26d820f8530f21df3dfc0306a11$var$isPromise = $034bb26d820f8530f21df3dfc0306a11$var$_require$types.isPromise, $034bb26d820f8530f21df3dfc0306a11$var$isRegExp = $034bb26d820f8530f21df3dfc0306a11$var$_require$types.isRegExp;
  $034bb26d820f8530f21df3dfc0306a11$var$objectAssign = Object.assign ? Object.assign : $51aafa8b2b27a6555d4006d168b8fcad$init().assign;
  $034bb26d820f8530f21df3dfc0306a11$var$objectIs = Object.is ? Object.is : $b3907554cc0e775ba10fc1e92615cda9$init();
  $034bb26d820f8530f21df3dfc0306a11$var$errorCache = new Map();
  $034bb26d820f8530f21df3dfc0306a11$var$escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
  $034bb26d820f8530f21df3dfc0306a11$var$meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

  $034bb26d820f8530f21df3dfc0306a11$var$escapeFn = function escapeFn(str) {
    return $034bb26d820f8530f21df3dfc0306a11$var$meta[str.charCodeAt(0)];
  };

  $034bb26d820f8530f21df3dfc0306a11$var$warned = false;
  $034bb26d820f8530f21df3dfc0306a11$var$assert = $034bb26d820f8530f21df3dfc0306a11$exports = $034bb26d820f8530f21df3dfc0306a11$var$ok;
  $034bb26d820f8530f21df3dfc0306a11$var$NO_EXCEPTION_SENTINEL = {};
  $034bb26d820f8530f21df3dfc0306a11$var$assert.fail = $034bb26d820f8530f21df3dfc0306a11$var$fail; // The AssertionError is defined in internal/error.

  // The AssertionError is defined in internal/error.
  $034bb26d820f8530f21df3dfc0306a11$var$assert.AssertionError = $034bb26d820f8530f21df3dfc0306a11$var$AssertionError;
  $034bb26d820f8530f21df3dfc0306a11$var$assert.ok = $034bb26d820f8530f21df3dfc0306a11$var$ok; // The equality assertion tests shallow, coercive equality with ==.

  /* eslint-disable no-restricted-properties */

  // The equality assertion tests shallow, coercive equality with ==.

  /* eslint-disable no-restricted-properties */
  $034bb26d820f8530f21df3dfc0306a11$var$assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    } // eslint-disable-next-line eqeqeq


    // eslint-disable-next-line eqeqeq
    if (actual != expected) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '==',
        stackStartFn: equal
      });
    }
  }; // The non-equality assertion tests for whether two objects are not
  // equal with !=.


  // The non-equality assertion tests for whether two objects are not
  // equal with !=.
  $034bb26d820f8530f21df3dfc0306a11$var$assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    } // eslint-disable-next-line eqeqeq


    // eslint-disable-next-line eqeqeq
    if (actual == expected) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '!=',
        stackStartFn: notEqual
      });
    }
  }; // The equivalence assertion tests a deep equality relation.


  // The equivalence assertion tests a deep equality relation.
  $034bb26d820f8530f21df3dfc0306a11$var$assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual === undefined) $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison();

    if (!$034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual(actual, expected)) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepEqual',
        stackStartFn: deepEqual
      });
    }
  }; // The non-equivalence assertion tests for any deep inequality.


  // The non-equivalence assertion tests for any deep inequality.
  $034bb26d820f8530f21df3dfc0306a11$var$assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual === undefined) $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison();

    if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual(actual, expected)) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notDeepEqual',
        stackStartFn: notDeepEqual
      });
    }
  };
  /* eslint-enable */


  /* eslint-enable */
  $034bb26d820f8530f21df3dfc0306a11$var$assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$isDeepEqual === undefined) $034bb26d820f8530f21df3dfc0306a11$var$lazyLoadComparison();

    if (!$034bb26d820f8530f21df3dfc0306a11$var$isDeepStrictEqual(actual, expected)) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepStrictEqual',
        stackStartFn: deepStrictEqual
      });
    }
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.notDeepStrictEqual = $034bb26d820f8530f21df3dfc0306a11$var$notDeepStrictEqual;

  $034bb26d820f8530f21df3dfc0306a11$var$assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    }

    if (!$034bb26d820f8530f21df3dfc0306a11$var$objectIs(actual, expected)) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'strictEqual',
        stackStartFn: strictEqual
      });
    }
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new $034bb26d820f8530f21df3dfc0306a11$var$ERR_MISSING_ARGS('actual', 'expected');
    }

    if ($034bb26d820f8530f21df3dfc0306a11$var$objectIs(actual, expected)) {
      $034bb26d820f8530f21df3dfc0306a11$var$innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notStrictEqual',
        stackStartFn: notStrictEqual
      });
    }
  };

  $034bb26d820f8530f21df3dfc0306a11$var$Comparison = function Comparison(obj, keys, actual) {
    var _this = this;

    $034bb26d820f8530f21df3dfc0306a11$var$_classCallCheck(this, Comparison);
    keys.forEach(function (key) {
      if (key in obj) {
        if (actual !== undefined && typeof actual[key] === 'string' && $034bb26d820f8530f21df3dfc0306a11$var$isRegExp(obj[key]) && obj[key].test(actual[key])) {
          _this[key] = actual[key];
        } else {
          _this[key] = obj[key];
        }
      }
    });
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.throws = function throws(promiseFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    $034bb26d820f8530f21df3dfc0306a11$var$expectsError.apply(void 0, [throws, $034bb26d820f8530f21df3dfc0306a11$var$getActual(promiseFn)].concat(args));
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.rejects = function rejects(promiseFn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return $034bb26d820f8530f21df3dfc0306a11$var$waitForActual(promiseFn).then(function (result) {
      return $034bb26d820f8530f21df3dfc0306a11$var$expectsError.apply(void 0, [rejects, result].concat(args));
    });
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.doesNotThrow = function doesNotThrow(fn) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    $034bb26d820f8530f21df3dfc0306a11$var$expectsNoError.apply(void 0, [doesNotThrow, $034bb26d820f8530f21df3dfc0306a11$var$getActual(fn)].concat(args));
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.doesNotReject = function doesNotReject(fn) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }

    return $034bb26d820f8530f21df3dfc0306a11$var$waitForActual(fn).then(function (result) {
      return $034bb26d820f8530f21df3dfc0306a11$var$expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
    });
  };

  $034bb26d820f8530f21df3dfc0306a11$var$assert.ifError = function ifError(err) {
    if (err !== null && err !== undefined) {
      var message = 'ifError got unwanted exception: ';

      if ($034bb26d820f8530f21df3dfc0306a11$var$_typeof(err) === 'object' && typeof err.message === 'string') {
        if (err.message.length === 0 && err.constructor) {
          message += err.constructor.name;
        } else {
          message += err.message;
        }
      } else {
        message += $034bb26d820f8530f21df3dfc0306a11$var$inspect(err);
      }

      var newErr = new $034bb26d820f8530f21df3dfc0306a11$var$AssertionError({
        actual: err,
        expected: null,
        operator: 'ifError',
        message: message,
        stackStartFn: ifError
      }); // Make sure we actually have a stack trace!

      // Make sure we actually have a stack trace!
      var origStack = err.stack;

      if (typeof origStack === 'string') {
        // This will remove any duplicated frames from the error frames taken
        // from within `ifError` and add the original error frames to the newly
        // created ones.
        var tmp2 = origStack.split('\n');
        tmp2.shift(); // Filter all frames existing in err.stack.

        // Filter all frames existing in err.stack.
        var tmp1 = newErr.stack.split('\n');

        for (var i = 0; i < tmp2.length; i++) {
          // Find the first occurrence of the frame.
          var pos = tmp1.indexOf(tmp2[i]);

          if (pos !== -1) {
            // Only keep new frames.
            tmp1 = tmp1.slice(0, pos);
            break;
          }
        }

        newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
      }

      throw newErr;
    }
  }; // Expose a strict only variant of assert


  $034bb26d820f8530f21df3dfc0306a11$var$assert.strict = $034bb26d820f8530f21df3dfc0306a11$var$objectAssign($034bb26d820f8530f21df3dfc0306a11$var$strict, $034bb26d820f8530f21df3dfc0306a11$var$assert, {
    equal: $034bb26d820f8530f21df3dfc0306a11$var$assert.strictEqual,
    deepEqual: $034bb26d820f8530f21df3dfc0306a11$var$assert.deepStrictEqual,
    notEqual: $034bb26d820f8530f21df3dfc0306a11$var$assert.notStrictEqual,
    notDeepEqual: $034bb26d820f8530f21df3dfc0306a11$var$assert.notDeepStrictEqual
  });
  $034bb26d820f8530f21df3dfc0306a11$var$assert.strict.strict = $034bb26d820f8530f21df3dfc0306a11$var$assert.strict;
}

function $034bb26d820f8530f21df3dfc0306a11$init() {
  if (!$034bb26d820f8530f21df3dfc0306a11$executed) {
    $034bb26d820f8530f21df3dfc0306a11$executed = true;
    $034bb26d820f8530f21df3dfc0306a11$exec();
  }

  return $034bb26d820f8530f21df3dfc0306a11$exports;
}

/* eslint camelcase: "off" */
var $ac254f1082b0ce94146edfb9c2acdf2f$var$assert = $034bb26d820f8530f21df3dfc0306a11$init();
// ASSET: node_modules/pako/lib/zlib/zstream.js
var $96705731572b187214e5f1c7e22db483$exports = {};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function $96705731572b187214e5f1c7e22db483$var$ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */

  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */

  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */

  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers

  // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */

  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */

  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */

  /* last error message, NULL if no error */
  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */

  /* best guess about the data type: binary or text */
  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

$96705731572b187214e5f1c7e22db483$exports = $96705731572b187214e5f1c7e22db483$var$ZStream;
// ASSET: node_modules/pako/lib/utils/common.js
var $8a14024ea7aaaa468f79728228f23324$export$Buf8,
    $8a14024ea7aaaa468f79728228f23324$export$Buf16,
    $8a14024ea7aaaa468f79728228f23324$export$Buf32,
    $8a14024ea7aaaa468f79728228f23324$exports = {};
var $8a14024ea7aaaa468f79728228f23324$var$TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function $8a14024ea7aaaa468f79728228f23324$var$_has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

var $8a14024ea7aaaa468f79728228f23324$export$assign = function (obj
/*from1, from2, from3, ...*/
)
/*from1, from2, from3, ...*/
{
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if ($8a14024ea7aaaa468f79728228f23324$var$_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

$8a14024ea7aaaa468f79728228f23324$exports.assign = $8a14024ea7aaaa468f79728228f23324$export$assign; // reduce buffer size, avoiding mem copy

var $8a14024ea7aaaa468f79728228f23324$export$shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

// reduce buffer size, avoiding mem copy
$8a14024ea7aaaa468f79728228f23324$exports.shrinkBuf = $8a14024ea7aaaa468f79728228f23324$export$shrinkBuf;
var $8a14024ea7aaaa468f79728228f23324$var$fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    // calculate data length
    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    // join chunks
    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var $8a14024ea7aaaa468f79728228f23324$var$fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

var $8a14024ea7aaaa468f79728228f23324$export$setTyped = function (on) {
  if (on) {
    $8a14024ea7aaaa468f79728228f23324$export$Buf8 = Uint8Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf8 = $8a14024ea7aaaa468f79728228f23324$export$Buf8;
    $8a14024ea7aaaa468f79728228f23324$export$Buf16 = Uint16Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf16 = $8a14024ea7aaaa468f79728228f23324$export$Buf16;
    $8a14024ea7aaaa468f79728228f23324$export$Buf32 = Int32Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf32 = $8a14024ea7aaaa468f79728228f23324$export$Buf32;
    $8a14024ea7aaaa468f79728228f23324$exports.assign($8a14024ea7aaaa468f79728228f23324$exports, $8a14024ea7aaaa468f79728228f23324$var$fnTyped);
  } else {
    $8a14024ea7aaaa468f79728228f23324$export$Buf8 = Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf8 = $8a14024ea7aaaa468f79728228f23324$export$Buf8;
    $8a14024ea7aaaa468f79728228f23324$export$Buf16 = Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf16 = $8a14024ea7aaaa468f79728228f23324$export$Buf16;
    $8a14024ea7aaaa468f79728228f23324$export$Buf32 = Array;
    $8a14024ea7aaaa468f79728228f23324$exports.Buf32 = $8a14024ea7aaaa468f79728228f23324$export$Buf32;
    $8a14024ea7aaaa468f79728228f23324$exports.assign($8a14024ea7aaaa468f79728228f23324$exports, $8a14024ea7aaaa468f79728228f23324$var$fnUntyped);
  }
};

// Enable/Disable typed arrays use, for testing
//
$8a14024ea7aaaa468f79728228f23324$exports.setTyped = $8a14024ea7aaaa468f79728228f23324$export$setTyped;
$8a14024ea7aaaa468f79728228f23324$exports.setTyped($8a14024ea7aaaa468f79728228f23324$var$TYPED_OK);

/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var $48871d5c23eeea8ca519be31f99a83f4$var$Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var $48871d5c23eeea8ca519be31f99a83f4$var$Z_BINARY = 0;
var $48871d5c23eeea8ca519be31f99a83f4$var$Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

//var Z_ASCII             = 1; // = Z_TEXT
var $48871d5c23eeea8ca519be31f99a83f4$var$Z_UNKNOWN = 2;
/*============================================================================*/

/*============================================================================*/
function $48871d5c23eeea8ca519be31f99a83f4$var$zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


// From zutil.h
var $48871d5c23eeea8ca519be31f99a83f4$var$STORED_BLOCK = 0;
var $48871d5c23eeea8ca519be31f99a83f4$var$STATIC_TREES = 1;
var $48871d5c23eeea8ca519be31f99a83f4$var$DYN_TREES = 2;
/* The three kinds of block type */

/* The three kinds of block type */
var $48871d5c23eeea8ca519be31f99a83f4$var$MIN_MATCH = 3;
var $48871d5c23eeea8ca519be31f99a83f4$var$MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */
var $48871d5c23eeea8ca519be31f99a83f4$var$LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

/* number of length codes, not counting the special END_BLOCK code */
var $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS = 256;
/* number of literal bytes 0..255 */

/* number of literal bytes 0..255 */
var $48871d5c23eeea8ca519be31f99a83f4$var$L_CODES = $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS + 1 + $48871d5c23eeea8ca519be31f99a83f4$var$LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

/* number of Literal or Length codes, including the END_BLOCK code */
var $48871d5c23eeea8ca519be31f99a83f4$var$D_CODES = 30;
/* number of distance codes */

/* number of distance codes */
var $48871d5c23eeea8ca519be31f99a83f4$var$BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

/* number of codes used to transfer the bit lengths */
var $48871d5c23eeea8ca519be31f99a83f4$var$HEAP_SIZE = 2 * $48871d5c23eeea8ca519be31f99a83f4$var$L_CODES + 1;
/* maximum heap size */

/* maximum heap size */
var $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

/* All codes must not exceed MAX_BITS bits */
var $48871d5c23eeea8ca519be31f99a83f4$var$Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */
var $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

/* Bit length codes must not exceed MAX_BL_BITS bits */
var $48871d5c23eeea8ca519be31f99a83f4$var$END_BLOCK = 256;
/* end of block literal code */

/* end of block literal code */
var $48871d5c23eeea8ca519be31f99a83f4$var$REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

/* repeat previous bit length 3-6 times (2 bits of repeat count) */
var $48871d5c23eeea8ca519be31f99a83f4$var$REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

/* repeat a zero length 3-10 times  (3 bits of repeat count) */
var $48871d5c23eeea8ca519be31f99a83f4$var$REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var $48871d5c23eeea8ca519be31f99a83f4$var$extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var $48871d5c23eeea8ca519be31f99a83f4$var$extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var $48871d5c23eeea8ca519be31f99a83f4$var$extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var $48871d5c23eeea8ca519be31f99a83f4$var$bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps
var $48871d5c23eeea8ca519be31f99a83f4$var$DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree = new Array(($48871d5c23eeea8ca519be31f99a83f4$var$L_CODES + 2) * 2);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */
var $48871d5c23eeea8ca519be31f99a83f4$var$static_dtree = new Array($48871d5c23eeea8ca519be31f99a83f4$var$D_CODES * 2);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */
var $48871d5c23eeea8ca519be31f99a83f4$var$_dist_code = new Array($48871d5c23eeea8ca519be31f99a83f4$var$DIST_CODE_LEN);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */
var $48871d5c23eeea8ca519be31f99a83f4$var$_length_code = new Array($48871d5c23eeea8ca519be31f99a83f4$var$MAX_MATCH - $48871d5c23eeea8ca519be31f99a83f4$var$MIN_MATCH + 1);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

/* length code for each normalized match length (0 == MIN_MATCH) */
var $48871d5c23eeea8ca519be31f99a83f4$var$base_length = new Array($48871d5c23eeea8ca519be31f99a83f4$var$LENGTH_CODES);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

/* First normalized length for each code (0 = MIN_MATCH) */
var $48871d5c23eeea8ca519be31f99a83f4$var$base_dist = new Array($48871d5c23eeea8ca519be31f99a83f4$var$D_CODES);
$48871d5c23eeea8ca519be31f99a83f4$var$zero($48871d5c23eeea8ca519be31f99a83f4$var$base_dist);
/* First normalized distance for each code (0 = distance of 1) */

/* First normalized distance for each code (0 = distance of 1) */
function $48871d5c23eeea8ca519be31f99a83f4$var$StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  /* static tree or NULL */
  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  /* extra bits for each code or NULL */
  this.extra_base = extra_base;
  /* base index for extra_bits */

  /* base index for extra_bits */
  this.elems = elems;
  /* max number of elements in the tree */

  /* max number of elements in the tree */
  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var $48871d5c23eeea8ca519be31f99a83f4$var$static_l_desc;
var $48871d5c23eeea8ca519be31f99a83f4$var$static_d_desc;
var $48871d5c23eeea8ca519be31f99a83f4$var$static_bl_desc;

function $48871d5c23eeea8ca519be31f99a83f4$var$TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  /* the dynamic tree */
  this.max_code = 0;
  /* largest code with non zero frequency */

  /* largest code with non zero frequency */
  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function $48871d5c23eeea8ca519be31f99a83f4$var$d_code(dist) {
  return dist < 256 ? $48871d5c23eeea8ca519be31f99a83f4$var$_dist_code[dist] : $48871d5c23eeea8ca519be31f99a83f4$var$_dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, value, length) {
  if (s.bi_valid > $48871d5c23eeea8ca519be31f99a83f4$var$Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, s.bi_buf);
    s.bi_buf = value >> $48871d5c23eeea8ca519be31f99a83f4$var$Buf_size - s.bi_valid;
    s.bi_valid += length - $48871d5c23eeea8ca519be31f99a83f4$var$Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, c, tree) {
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, tree[c * 2]
  /*.Code*/
  ,
  /*.Code*/
  tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$bi_flush(s) {
  if (s.bi_valid === 16) {
    $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  /* heap index */
  var n, m;
  /* iterate over the tree elements */

  /* iterate over the tree elements */
  var bits;
  /* bit length */

  /* bit length */
  var xbits;
  /* extra bits */

  /* extra bits */
  var f;
  /* frequency */

  /* frequency */
  var overflow = 0;
  /* number of elements with bit length too large */

  /* number of elements with bit length too large */
  for (bits = 0; bits <= $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  =
  /*.Len*/
  0;
  /* root of the heap */

  /* root of the heap */
  for (h = s.heap_max + 1; h < $48871d5c23eeea8ca519be31f99a83f4$var$HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    *
    /*.Dad*/
    2 + 1]
    /*.Len*/
    +
    /*.Len*/
    1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    /* We overwrite tree[n].Dad which is no longer needed */
    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    /* not a leaf node */
    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      +
      /*.Len*/
      xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !==
      /*.Len*/
      bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) *
        /*.Len*/
        tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        =
        /*.Len*/
        bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array($48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS + 1);
  /* next code value for each bit length */

  /* next code value for each bit length */
  var code = 0;
  /* running code value */

  /* running code value */
  var bits;
  /* bit index */

  /* bit index */
  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    /* Now reverse the bits */
    tree[n * 2]
    /*.Code*/
    =
    /*.Code*/
    $48871d5c23eeea8ca519be31f99a83f4$var$bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$tr_static_init() {
  var n;
  /* iterates over tree elements */

  /* iterates over tree elements */
  var bits;
  /* bit counter */

  /* bit counter */
  var length;
  /* length value */

  /* length value */
  var code;
  /* code value */

  /* code value */
  var dist;
  /* distance index */

  /* distance index */
  var bl_count = new Array($48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;

  for (code = 0; code < $48871d5c23eeea8ca519be31f99a83f4$var$LENGTH_CODES - 1; code++) {
    $48871d5c23eeea8ca519be31f99a83f4$var$base_length[code] = length;

    for (n = 0; n < 1 << $48871d5c23eeea8ca519be31f99a83f4$var$extra_lbits[code]; n++) {
      $48871d5c23eeea8ca519be31f99a83f4$var$_length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  $48871d5c23eeea8ca519be31f99a83f4$var$_length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;

  for (code = 0; code < 16; code++) {
    $48871d5c23eeea8ca519be31f99a83f4$var$base_dist[code] = dist;

    for (n = 0; n < 1 << $48871d5c23eeea8ca519be31f99a83f4$var$extra_dbits[code]; n++) {
      $48871d5c23eeea8ca519be31f99a83f4$var$_dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  /* from now on, all distances are divided by 128 */
  for (; code < $48871d5c23eeea8ca519be31f99a83f4$var$D_CODES; code++) {
    $48871d5c23eeea8ca519be31f99a83f4$var$base_dist[code] = dist << 7;

    for (n = 0; n < 1 << $48871d5c23eeea8ca519be31f99a83f4$var$extra_dbits[code] - 7; n++) {
      $48871d5c23eeea8ca519be31f99a83f4$var$_dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  $48871d5c23eeea8ca519be31f99a83f4$var$gen_codes($48871d5c23eeea8ca519be31f99a83f4$var$static_ltree, $48871d5c23eeea8ca519be31f99a83f4$var$L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  /* The static distance tree is trivial: */
  for (n = 0; n < $48871d5c23eeea8ca519be31f99a83f4$var$D_CODES; n++) {
    $48871d5c23eeea8ca519be31f99a83f4$var$static_dtree[n * 2 + 1]
    /*.Len*/
    =
    /*.Len*/
    5;
    $48871d5c23eeea8ca519be31f99a83f4$var$static_dtree[n * 2]
    /*.Code*/
    =
    /*.Code*/
    $48871d5c23eeea8ca519be31f99a83f4$var$bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  // Now data ready and we can init static trees
  $48871d5c23eeea8ca519be31f99a83f4$var$static_l_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$StaticTreeDesc($48871d5c23eeea8ca519be31f99a83f4$var$static_ltree, $48871d5c23eeea8ca519be31f99a83f4$var$extra_lbits, $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS + 1, $48871d5c23eeea8ca519be31f99a83f4$var$L_CODES, $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS);
  $48871d5c23eeea8ca519be31f99a83f4$var$static_d_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$StaticTreeDesc($48871d5c23eeea8ca519be31f99a83f4$var$static_dtree, $48871d5c23eeea8ca519be31f99a83f4$var$extra_dbits, 0, $48871d5c23eeea8ca519be31f99a83f4$var$D_CODES, $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BITS);
  $48871d5c23eeea8ca519be31f99a83f4$var$static_bl_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$StaticTreeDesc(new Array(0), $48871d5c23eeea8ca519be31f99a83f4$var$extra_blbits, 0, $48871d5c23eeea8ca519be31f99a83f4$var$BL_CODES, $48871d5c23eeea8ca519be31f99a83f4$var$MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


/* ===========================================================================
 * Initialize a new block.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < $48871d5c23eeea8ca519be31f99a83f4$var$L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    =
    /*.Freq*/
    0;
  }

  for (n = 0; n < $48871d5c23eeea8ca519be31f99a83f4$var$D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    =
    /*.Freq*/
    0;
  }

  for (n = 0; n < $48871d5c23eeea8ca519be31f99a83f4$var$BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    =
    /*.Freq*/
    0;
  }

  s.dyn_ltree[$48871d5c23eeea8ca519be31f99a83f4$var$END_BLOCK * 2]
  /*.Freq*/
  =
  /*.Freq*/
  1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$bi_windup(s) {
  if (s.bi_valid > 8) {
    $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  $48871d5c23eeea8ca519be31f99a83f4$var$bi_windup(s);
  /* align on byte boundary */

  /* align on byte boundary */
  if (header) {
    $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, len);
    $48871d5c23eeea8ca519be31f99a83f4$var$put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  $8a14024ea7aaaa468f79728228f23324$exports.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  <
  /*.Freq*/
  tree[_m2]
  /*.Freq*/
  ||
  /*.Freq*/
  tree[_n2]
  /*.Freq*/
  ===
  /*.Freq*/
  tree[_m2]
  /*.Freq*/
  &&
  /*.Freq*/
  depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && $48871d5c23eeea8ca519be31f99a83f4$var$smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    /* Exit if v is smaller than both sons */
    if ($48871d5c23eeea8ca519be31f99a83f4$var$smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  /* distance of matched string */
  var lc;
  /* match length or unmatched char (if dist == 0) */

  /* match length or unmatched char (if dist == 0) */
  var lx = 0;
  /* running index in l_buf */

  /* running index in l_buf */
  var code;
  /* the code to send */

  /* the code to send */
  var extra;
  /* number of extra bits to send */

  /* number of extra bits to send */
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = $48871d5c23eeea8ca519be31f99a83f4$var$_length_code[lc];
        $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, code + $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS + 1, ltree);
        /* send the length code */

        /* send the length code */
        extra = $48871d5c23eeea8ca519be31f99a83f4$var$extra_lbits[code];

        if (extra !== 0) {
          lc -= $48871d5c23eeea8ca519be31f99a83f4$var$base_length[code];
          $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        /* dist is now the match distance - 1 */
        code = $48871d5c23eeea8ca519be31f99a83f4$var$d_code(dist); //Assert (code < D_CODES, "bad d_code");

        //Assert (code < D_CODES, "bad d_code");
        $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, code, dtree);
        /* send the distance code */

        /* send the distance code */
        extra = $48871d5c23eeea8ca519be31f99a83f4$var$extra_dbits[code];

        if (extra !== 0) {
          dist -= $48871d5c23eeea8ca519be31f99a83f4$var$base_dist[code];
          $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, $48871d5c23eeea8ca519be31f99a83f4$var$END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  /* iterate over heap elements */
  var max_code = -1;
  /* largest code with non zero frequency */

  /* largest code with non zero frequency */
  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = $48871d5c23eeea8ca519be31f99a83f4$var$HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !==
    /*.Freq*/
    0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      =
      /*.Len*/
      0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    =
    /*.Freq*/
    1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    $48871d5c23eeea8ca519be31f99a83f4$var$pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;
  /* next internal node of the tree */

  /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    $48871d5c23eeea8ca519be31f99a83f4$var$pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    /***/
    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    /* m = node of next least frequency */
    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    /* Create a new node father of n and m */
    tree[node * 2]
    /*.Freq*/
    =
    /*.Freq*/
    tree[n * 2]
    /*.Freq*/
    +
    /*.Freq*/
    tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    =
    /*.Dad*/
    tree[m * 2 + 1]
    /*.Dad*/
    =
    /*.Dad*/
    node;
    /* and insert the new node in the heap */

    /* and insert the new node in the heap */
    s.heap[1
    /*SMALLEST*/
    ] = node++;
    $48871d5c23eeea8ca519be31f99a83f4$var$pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  $48871d5c23eeea8ca519be31f99a83f4$var$gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  /* The field len is now set, we can generate the bit codes */
  $48871d5c23eeea8ca519be31f99a83f4$var$gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  /* iterates over all tree elements */
  var prevlen = -1;
  /* last emitted length */

  /* last emitted length */
  var curlen;
  /* length of current code */

  /* length of current code */
  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  /* length of next code */
  var count = 0;
  /* repeat count of the current code */

  /* repeat count of the current code */
  var max_count = 7;
  /* max repeat count */

  /* max repeat count */
  var min_count = 4;
  /* min repeat count */

  /* min repeat count */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  =
  /*.Len*/
  0xffff;
  /* guard */

  /* guard */
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      +=
      /*.Freq*/
      count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[$48871d5c23eeea8ca519be31f99a83f4$var$REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[$48871d5c23eeea8ca519be31f99a83f4$var$REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[$48871d5c23eeea8ca519be31f99a83f4$var$REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  /* iterates over all tree elements */
  var prevlen = -1;
  /* last emitted length */

  /* last emitted length */
  var curlen;
  /* length of current code */

  /* length of current code */
  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  /* length of next code */
  var count = 0;
  /* repeat count of the current code */

  /* repeat count of the current code */
  var max_count = 7;
  /* max repeat count */

  /* max repeat count */
  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      //Assert(count >= 3 && count <= 6, " 3_6?");
      $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, $48871d5c23eeea8ca519be31f99a83f4$var$REP_3_6, s.bl_tree);
      $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, $48871d5c23eeea8ca519be31f99a83f4$var$REPZ_3_10, s.bl_tree);
      $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, count - 3, 3);
    } else {
      $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, $48871d5c23eeea8ca519be31f99a83f4$var$REPZ_11_138, s.bl_tree);
      $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  $48871d5c23eeea8ca519be31f99a83f4$var$scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  $48871d5c23eeea8ca519be31f99a83f4$var$scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  /* Build the bit length tree: */
  $48871d5c23eeea8ca519be31f99a83f4$var$build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = $48871d5c23eeea8ca519be31f99a83f4$var$BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[$48871d5c23eeea8ca519be31f99a83f4$var$bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !==
    /*.Len*/
    0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));
  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  /* not +255 as stated in appnote.txt */
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, dcodes - 1, 5);
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, s.bl_tree[$48871d5c23eeea8ca519be31f99a83f4$var$bl_order[rank] * 2 + 1]
    /*.Len*/
    ,
    /*.Len*/
    3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
  $48871d5c23eeea8ca519be31f99a83f4$var$send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
  $48871d5c23eeea8ca519be31f99a83f4$var$send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !==
    /*.Freq*/
    0) {
      return $48871d5c23eeea8ca519be31f99a83f4$var$Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !==
  /*.Freq*/
  0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !==
  /*.Freq*/
  0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !==
  /*.Freq*/
  0) {
    return $48871d5c23eeea8ca519be31f99a83f4$var$Z_TEXT;
  }

  for (n = 32; n < $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !==
    /*.Freq*/
    0) {
      return $48871d5c23eeea8ca519be31f99a83f4$var$Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return $48871d5c23eeea8ca519be31f99a83f4$var$Z_BINARY;
}

var $48871d5c23eeea8ca519be31f99a83f4$var$static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$_tr_init(s) {
  if (!$48871d5c23eeea8ca519be31f99a83f4$var$static_init_done) {
    $48871d5c23eeea8ca519be31f99a83f4$var$tr_static_init();
    $48871d5c23eeea8ca519be31f99a83f4$var$static_init_done = true;
  }

  s.l_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$TreeDesc(s.dyn_ltree, $48871d5c23eeea8ca519be31f99a83f4$var$static_l_desc);
  s.d_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$TreeDesc(s.dyn_dtree, $48871d5c23eeea8ca519be31f99a83f4$var$static_d_desc);
  s.bl_desc = new $48871d5c23eeea8ca519be31f99a83f4$var$TreeDesc(s.bl_tree, $48871d5c23eeea8ca519be31f99a83f4$var$static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  /* Initialize the first block of the first file: */
  $48871d5c23eeea8ca519be31f99a83f4$var$init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


/* ===========================================================================
 * Send a stored block
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$_tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, ($48871d5c23eeea8ca519be31f99a83f4$var$STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  /* send block type */
  $48871d5c23eeea8ca519be31f99a83f4$var$copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$_tr_align(s) {
  $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, $48871d5c23eeea8ca519be31f99a83f4$var$STATIC_TREES << 1, 3);
  $48871d5c23eeea8ca519be31f99a83f4$var$send_code(s, $48871d5c23eeea8ca519be31f99a83f4$var$END_BLOCK, $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree);
  $48871d5c23eeea8ca519be31f99a83f4$var$bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$_tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  /* opt_len and static_len in bytes */
  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === $48871d5c23eeea8ca519be31f99a83f4$var$Z_UNKNOWN) {
      s.strm.data_type = $48871d5c23eeea8ca519be31f99a83f4$var$detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    /* Construct the literal and distance trees */
    $48871d5c23eeea8ca519be31f99a83f4$var$build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    $48871d5c23eeea8ca519be31f99a83f4$var$build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = $48871d5c23eeea8ca519be31f99a83f4$var$build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    $48871d5c23eeea8ca519be31f99a83f4$var$_tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === $48871d5c23eeea8ca519be31f99a83f4$var$Z_FIXED || static_lenb === opt_lenb) {
    $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, ($48871d5c23eeea8ca519be31f99a83f4$var$STATIC_TREES << 1) + (last ? 1 : 0), 3);
    $48871d5c23eeea8ca519be31f99a83f4$var$compress_block(s, $48871d5c23eeea8ca519be31f99a83f4$var$static_ltree, $48871d5c23eeea8ca519be31f99a83f4$var$static_dtree);
  } else {
    $48871d5c23eeea8ca519be31f99a83f4$var$send_bits(s, ($48871d5c23eeea8ca519be31f99a83f4$var$DYN_TREES << 1) + (last ? 1 : 0), 3);
    $48871d5c23eeea8ca519be31f99a83f4$var$send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    $48871d5c23eeea8ca519be31f99a83f4$var$compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  $48871d5c23eeea8ca519be31f99a83f4$var$init_block(s);

  if (last) {
    $48871d5c23eeea8ca519be31f99a83f4$var$bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function $48871d5c23eeea8ca519be31f99a83f4$var$_tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    /* Here, lc is the match length - MIN_MATCH */
    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
    s.dyn_ltree[($48871d5c23eeea8ca519be31f99a83f4$var$_length_code[lc] + $48871d5c23eeea8ca519be31f99a83f4$var$LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[$48871d5c23eeea8ca519be31f99a83f4$var$d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif
  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

var $48871d5c23eeea8ca519be31f99a83f4$export$_tr_init = $48871d5c23eeea8ca519be31f99a83f4$var$_tr_init;
var $48871d5c23eeea8ca519be31f99a83f4$export$_tr_stored_block = $48871d5c23eeea8ca519be31f99a83f4$var$_tr_stored_block;
var $48871d5c23eeea8ca519be31f99a83f4$export$_tr_flush_block = $48871d5c23eeea8ca519be31f99a83f4$var$_tr_flush_block;
var $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally = $48871d5c23eeea8ca519be31f99a83f4$var$_tr_tally;
var $48871d5c23eeea8ca519be31f99a83f4$export$_tr_align = $48871d5c23eeea8ca519be31f99a83f4$var$_tr_align;
// ASSET: node_modules/pako/lib/zlib/adler32.js
var $f5e3420f0ba52555cac23cb3e641886f$exports = {};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function $f5e3420f0ba52555cac23cb3e641886f$var$adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

$f5e3420f0ba52555cac23cb3e641886f$exports = $f5e3420f0ba52555cac23cb3e641886f$var$adler32;
// ASSET: node_modules/pako/lib/zlib/crc32.js
var $ef4d58971db61b7aa82dc64394c5ee16$exports = {};

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here
function $ef4d58971db61b7aa82dc64394c5ee16$var$makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


// Create table on load. Just 255 signed longs. Not a problem.
var $ef4d58971db61b7aa82dc64394c5ee16$var$crcTable = $ef4d58971db61b7aa82dc64394c5ee16$var$makeTable();

function $ef4d58971db61b7aa82dc64394c5ee16$var$crc32(crc, buf, len, pos) {
  var t = $ef4d58971db61b7aa82dc64394c5ee16$var$crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

$ef4d58971db61b7aa82dc64394c5ee16$exports = $ef4d58971db61b7aa82dc64394c5ee16$var$crc32;
// ASSET: node_modules/pako/lib/zlib/messages.js
var $c93cb163d8226a786a6d26732499d741$exports = {};
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
$c93cb163d8226a786a6d26732499d741$exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH = 0;
var $af68a4e46963dbc6080b158c600e7210$var$Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

//var Z_SYNC_FLUSH    = 2;
var $af68a4e46963dbc6080b158c600e7210$var$Z_FULL_FLUSH = 3;
var $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH = 4;
var $af68a4e46963dbc6080b158c600e7210$var$Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

//var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var $af68a4e46963dbc6080b158c600e7210$var$Z_OK = 0;
var $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR = -2;
var $af68a4e46963dbc6080b158c600e7210$var$Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

//var Z_MEM_ERROR     = -4;
var $af68a4e46963dbc6080b158c600e7210$var$Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

//var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var $af68a4e46963dbc6080b158c600e7210$var$Z_DEFAULT_COMPRESSION = -1;
var $af68a4e46963dbc6080b158c600e7210$var$Z_FILTERED = 1;
var $af68a4e46963dbc6080b158c600e7210$var$Z_HUFFMAN_ONLY = 2;
var $af68a4e46963dbc6080b158c600e7210$var$Z_RLE = 3;
var $af68a4e46963dbc6080b158c600e7210$var$Z_FIXED = 4;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var $af68a4e46963dbc6080b158c600e7210$var$Z_UNKNOWN = 2;
/* The deflate compression method */

/* The deflate compression method */
var $af68a4e46963dbc6080b158c600e7210$var$Z_DEFLATED = 8;
/*============================================================================*/

/*============================================================================*/
var $af68a4e46963dbc6080b158c600e7210$var$MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var $af68a4e46963dbc6080b158c600e7210$var$LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

/* number of length codes, not counting the special END_BLOCK code */
var $af68a4e46963dbc6080b158c600e7210$var$LITERALS = 256;
/* number of literal bytes 0..255 */

/* number of literal bytes 0..255 */
var $af68a4e46963dbc6080b158c600e7210$var$L_CODES = $af68a4e46963dbc6080b158c600e7210$var$LITERALS + 1 + $af68a4e46963dbc6080b158c600e7210$var$LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

/* number of Literal or Length codes, including the END_BLOCK code */
var $af68a4e46963dbc6080b158c600e7210$var$D_CODES = 30;
/* number of distance codes */

/* number of distance codes */
var $af68a4e46963dbc6080b158c600e7210$var$BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

/* number of codes used to transfer the bit lengths */
var $af68a4e46963dbc6080b158c600e7210$var$HEAP_SIZE = 2 * $af68a4e46963dbc6080b158c600e7210$var$L_CODES + 1;
/* maximum heap size */

/* maximum heap size */
var $af68a4e46963dbc6080b158c600e7210$var$MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

/* All codes must not exceed MAX_BITS bits */
var $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH = 3;
var $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH = 258;
var $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD = $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH + 1;
var $af68a4e46963dbc6080b158c600e7210$var$PRESET_DICT = 0x20;
var $af68a4e46963dbc6080b158c600e7210$var$INIT_STATE = 42;
var $af68a4e46963dbc6080b158c600e7210$var$EXTRA_STATE = 69;
var $af68a4e46963dbc6080b158c600e7210$var$NAME_STATE = 73;
var $af68a4e46963dbc6080b158c600e7210$var$COMMENT_STATE = 91;
var $af68a4e46963dbc6080b158c600e7210$var$HCRC_STATE = 103;
var $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE = 113;
var $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE = 666;
var $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

/* block not completed, need more input or more output */
var $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE = 2;
/* block flush performed */

/* block flush performed */
var $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

/* finish started, need only more output at next deflate */
var $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

/* finish done, accept no more input or output */
var $af68a4e46963dbc6080b158c600e7210$var$OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

// Unix :) . Don't detect, use this default.
function $af68a4e46963dbc6080b158c600e7210$var$err(strm, errorCode) {
  strm.msg = $c93cb163d8226a786a6d26732499d741$exports[errorCode];
  return errorCode;
}

function $af68a4e46963dbc6080b158c600e7210$var$rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function $af68a4e46963dbc6080b158c600e7210$var$zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  //_tr_flush_bits(s);
  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  $8a14024ea7aaaa468f79728228f23324$exports.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, last) {
  $48871d5c23eeea8ca519be31f99a83f4$export$_tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  $af68a4e46963dbc6080b158c600e7210$var$flush_pending(s.strm);
}

function $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function $af68a4e46963dbc6080b158c600e7210$var$read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  // zmemcpy(buf, strm->next_in, len);
  $8a14024ea7aaaa468f79728228f23324$exports.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = $f5e3420f0ba52555cac23cb3e641886f$exports(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function $af68a4e46963dbc6080b158c600e7210$var$longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  /* max hash chain length */
  var scan = s.strstart;
  /* current string */

  /* current string */
  var match;
  /* matched string */

  /* matched string */
  var len;
  /* length of current match */

  /* length of current match */
  var best_len = s.prev_length;
  /* best match length so far */

  /* best match length so far */
  var nice_match = s.nice_match;
  /* stop if match long enough */

  /* stop if match long enough */
  var limit = s.strstart > s.w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD ? s.strstart - (s.w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  // shortcut
  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */
  var strend = s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
    len = $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH - (strend - scan);
    scan = strend - $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function $af68a4e46963dbc6080b158c600e7210$var$fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD)) {
      $8a14024ea7aaaa468f79728228f23324$exports.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */
      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = $af68a4e46963dbc6080b158c600e7210$var$read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

      if (s.lookahead === 0 && flush === $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");
    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      /*** FLUSH_BLOCK(s, 0); ***/
      $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED;
    }
    /***/


    /***/
    return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
    }
    /***/

  }

  return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  /* head of the hash chain */
  var bflush;
  /* set if current block must be flushed */

  /* set if current block must be flushed */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD) {
      $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

      if (s.lookahead < $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD && flush === $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0
    /*NIL*/
    &&
    /*NIL*/
    s.strstart - hash_head <= s.w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = $af68a4e46963dbc6080b158c600e7210$var$longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, s.strstart - s.match_start, s.match_length - $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      &&
      /*max_insert_length*/
      s.lookahead >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1 ? s.strstart : $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;

  if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED;
    }
    /***/


    /***/
    return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
    }
    /***/

  }

  return $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  /* head of hash chain */
  var bflush;
  /* set if current block must be flushed */

  /* set if current block must be flushed */
  var max_insert;
  /* Process the input block. */

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD) {
      $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

      if (s.lookahead < $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD && flush === $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    &&
    /*NIL*/
    s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - $af68a4e46963dbc6080b158c600e7210$var$MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    )
      /*MAX_DIST(s)*/
      {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = $af68a4e46963dbc6080b158c600e7210$var$longest_match(s, hash_head);
        /* longest_match() sets match_start */

        /* longest_match() sets match_start */
        if (s.match_length <= 5 && (s.strategy === $af68a4e46963dbc6080b158c600e7210$var$Z_FILTERED || s.match_length === $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1 ? s.strstart : $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;

  if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED;
    }
    /***/


    /***/
    return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
    }
    /***/

  }

  return $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  /* set if current block must be flushed */
  var prev;
  /* byte at distance one to match */

  /* byte at distance one to match */
  var scan, strend;
  /* scan goes up to strend for length of run */

  /* scan goes up to strend for length of run */
  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH) {
      $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

      if (s.lookahead <= $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH && flush === $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    /* See how many times the previous byte repeats */
    s.match_length = 0;

    if (s.lookahead >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = $af68a4e46963dbc6080b158c600e7210$var$MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 1, s.match_length - $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED;
    }
    /***/


    /***/
    return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
    }
    /***/

  }

  return $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  /* set if current block must be flushed */
  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

      if (s.lookahead === 0) {
        if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH) {
          return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    /* Output a literal byte */
    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = $48871d5c23eeea8ca519be31f99a83f4$export$_tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED;
    }
    /***/


    /***/
    return $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    $af68a4e46963dbc6080b158c600e7210$var$flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE;
    }
    /***/

  }

  return $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function $af68a4e46963dbc6080b158c600e7210$var$Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var $af68a4e46963dbc6080b158c600e7210$var$configuration_table;
$af68a4e46963dbc6080b158c600e7210$var$configuration_table = [
/*      good lazy nice chain */
new $af68a4e46963dbc6080b158c600e7210$var$Config(0, 0, 0, 0, $af68a4e46963dbc6080b158c600e7210$var$deflate_stored),
/* 0 store only */
new $af68a4e46963dbc6080b158c600e7210$var$Config(4, 4, 8, 4, $af68a4e46963dbc6080b158c600e7210$var$deflate_fast),
/* 1 max speed, no lazy matches */
new $af68a4e46963dbc6080b158c600e7210$var$Config(4, 5, 16, 8, $af68a4e46963dbc6080b158c600e7210$var$deflate_fast),
/* 2 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(4, 6, 32, 32, $af68a4e46963dbc6080b158c600e7210$var$deflate_fast),
/* 3 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(4, 4, 16, 16, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow),
/* 4 lazy matches */
new $af68a4e46963dbc6080b158c600e7210$var$Config(8, 16, 32, 32, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow),
/* 5 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(8, 16, 128, 128, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow),
/* 6 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(8, 32, 128, 256, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow),
/* 7 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(32, 128, 258, 1024, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow),
/* 8 */
new $af68a4e46963dbc6080b158c600e7210$var$Config(32, 258, 258, 4096, $af68a4e46963dbc6080b158c600e7210$var$deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function $af68a4e46963dbc6080b158c600e7210$var$lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  /*** CLEAR_HASH(s); ***/
  $af68a4e46963dbc6080b158c600e7210$var$zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = $af68a4e46963dbc6080b158c600e7210$var$configuration_table[s.level].max_lazy;
  s.good_match = $af68a4e46963dbc6080b158c600e7210$var$configuration_table[s.level].good_length;
  s.nice_match = $af68a4e46963dbc6080b158c600e7210$var$configuration_table[s.level].nice_length;
  s.max_chain_length = $af68a4e46963dbc6080b158c600e7210$var$configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function $af68a4e46963dbc6080b158c600e7210$var$DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  /* pointer back to this zlib stream */
  this.status = 0;
  /* as the name implies */

  /* as the name implies */
  this.pending_buf = null;
  /* output still pending */

  /* output still pending */
  this.pending_buf_size = 0;
  /* size of pending_buf */

  /* size of pending_buf */
  this.pending_out = 0;
  /* next pending byte to output to the stream */

  /* next pending byte to output to the stream */
  this.pending = 0;
  /* nb of bytes in the pending buffer */

  /* nb of bytes in the pending buffer */
  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;
  /* gzip header information to write */

  /* gzip header information to write */
  this.gzindex = 0;
  /* where in extra, name, or comment */

  /* where in extra, name, or comment */
  this.method = $af68a4e46963dbc6080b158c600e7210$var$Z_DEFLATED;
  /* can only be DEFLATED */

  /* can only be DEFLATED */
  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  /* value of flush param for previous deflate call */
  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  /* LZ77 window size (32K by default) */
  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  /* log2(w_size)  (8..16) */
  this.w_mask = 0;
  /* w_size - 1 */

  /* w_size - 1 */
  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */
  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */
  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */
  this.head = null;
  /* Heads of the hash chains or NIL. */

  /* Heads of the hash chains or NIL. */
  this.ins_h = 0;
  /* hash index of string to be inserted */

  /* hash index of string to be inserted */
  this.hash_size = 0;
  /* number of elements in hash table */

  /* number of elements in hash table */
  this.hash_bits = 0;
  /* log2(hash_size) */

  /* log2(hash_size) */
  this.hash_mask = 0;
  /* hash_size-1 */

  /* hash_size-1 */
  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */
  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */
  this.match_length = 0;
  /* length of best match */

  /* length of best match */
  this.prev_match = 0;
  /* previous match */

  /* previous match */
  this.match_available = 0;
  /* set if previous match exists */

  /* set if previous match exists */
  this.strstart = 0;
  /* start of string to insert */

  /* start of string to insert */
  this.match_start = 0;
  /* start of matching string */

  /* start of matching string */
  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  /* number of valid bytes ahead in window */
  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */
  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */
  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */
  this.level = 0;
  /* compression level (1..9) */

  /* compression level (1..9) */
  this.strategy = 0;
  /* favor or force Huffman coding*/

  /* favor or force Huffman coding*/
  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  /* Use a faster search when the previous match is longer than this */
  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16($af68a4e46963dbc6080b158c600e7210$var$HEAP_SIZE * 2);
  this.dyn_dtree = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16((2 * $af68a4e46963dbc6080b158c600e7210$var$D_CODES + 1) * 2);
  this.bl_tree = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16((2 * $af68a4e46963dbc6080b158c600e7210$var$BL_CODES + 1) * 2);
  $af68a4e46963dbc6080b158c600e7210$var$zero(this.dyn_ltree);
  $af68a4e46963dbc6080b158c600e7210$var$zero(this.dyn_dtree);
  $af68a4e46963dbc6080b158c600e7210$var$zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  /* desc. for literal tree */
  this.d_desc = null;
  /* desc. for distance tree */

  /* desc. for distance tree */
  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];
  this.bl_count = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16($af68a4e46963dbc6080b158c600e7210$var$MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(2 * $af68a4e46963dbc6080b158c600e7210$var$L_CODES + 1);
  /* heap used to build the Huffman trees */

  /* heap used to build the Huffman trees */
  $af68a4e46963dbc6080b158c600e7210$var$zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  /* number of elements in the heap */
  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */
  this.depth = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(2 * $af68a4e46963dbc6080b158c600e7210$var$L_CODES + 1); //uch depth[2*L_CODES+1];

  //uch depth[2*L_CODES+1];
  $af68a4e46963dbc6080b158c600e7210$var$zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */
  this.l_buf = 0;
  /* buffer index for literals or lengths */

  /* buffer index for literals or lengths */
  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */
  this.last_lit = 0;
  /* running index in l_buf */

  /* running index in l_buf */
  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */
  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  /* bit length of current block with optimal trees */
  this.static_len = 0;
  /* bit length of current block with static trees */

  /* bit length of current block with static trees */
  this.matches = 0;
  /* number of string matches in current block */

  /* number of string matches in current block */
  this.insert = 0;
  /* bytes at end of window left to insert */

  /* bytes at end of window left to insert */
  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function $af68a4e46963dbc6080b158c600e7210$var$deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = $af68a4e46963dbc6080b158c600e7210$var$Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? $af68a4e46963dbc6080b158c600e7210$var$INIT_STATE : $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : // crc32(0, Z_NULL, 0)
  1; // adler32(0, Z_NULL, 0)

  // adler32(0, Z_NULL, 0)
  s.last_flush = $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH;
  $48871d5c23eeea8ca519be31f99a83f4$export$_tr_init(s);
  return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
}

function $af68a4e46963dbc6080b158c600e7210$var$deflateReset(strm) {
  var ret = $af68a4e46963dbc6080b158c600e7210$var$deflateResetKeep(strm);

  if (ret === $af68a4e46963dbc6080b158c600e7210$var$Z_OK) {
    $af68a4e46963dbc6080b158c600e7210$var$lm_init(strm.state);
  }

  return ret;
}

function $af68a4e46963dbc6080b158c600e7210$var$deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === $af68a4e46963dbc6080b158c600e7210$var$Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > $af68a4e46963dbc6080b158c600e7210$var$MAX_MEM_LEVEL || method !== $af68a4e46963dbc6080b158c600e7210$var$Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > $af68a4e46963dbc6080b158c600e7210$var$Z_FIXED) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  /* until 256-byte window bug fixed */
  var s = new $af68a4e46963dbc6080b158c600e7210$var$DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1) / $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH);
  s.window = new $8a14024ea7aaaa468f79728228f23324$exports.Buf8(s.w_size * 2);
  s.head = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(s.hash_size);
  s.prev = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */
  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  /* 16K elements by default */
  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new $8a14024ea7aaaa468f79728228f23324$exports.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return $af68a4e46963dbc6080b158c600e7210$var$deflateReset(strm);
}

function $af68a4e46963dbc6080b158c600e7210$var$deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  // for gzip header write only
  if (!strm || !strm.state || flush > $af68a4e46963dbc6080b158c600e7210$var$Z_BLOCK || flush < 0) {
    return strm ? $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR) : $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE && flush !== $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, strm.avail_out === 0 ? $af68a4e46963dbc6080b158c600e7210$var$Z_BUF_ERROR : $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  /* Write the header */
  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      //crc32(0L, Z_NULL, 0);
      $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 31);
      $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 139);
      $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.level === 9 ? 2 : s.strategy >= $af68a4e46963dbc6080b158c600e7210$var$Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, $af68a4e46963dbc6080b158c600e7210$var$OS_CODE);
        s.status = $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE;
      } else {
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.time & 0xff);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.time >> 8 & 0xff);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.time >> 16 & 0xff);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.time >> 24 & 0xff);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.level === 9 ? 2 : s.strategy >= $af68a4e46963dbc6080b158c600e7210$var$Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.extra.length & 0xff);
          $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = $af68a4e46963dbc6080b158c600e7210$var$EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = $af68a4e46963dbc6080b158c600e7210$var$Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= $af68a4e46963dbc6080b158c600e7210$var$Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= $af68a4e46963dbc6080b158c600e7210$var$PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE;
        $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, strm.adler >>> 16);
          $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  //#ifdef GZIP
  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    )
      /* != Z_NULL*/
      {
        beg = s.pending;
        /* start of bytes to update crc */

        /* start of bytes to update crc */
        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = $af68a4e46963dbc6080b158c600e7210$var$NAME_STATE;
        }
      } else {
      s.status = $af68a4e46963dbc6080b158c600e7210$var$NAME_STATE;
    }
  }

  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    )
      /* != Z_NULL*/
      {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        /* start of bytes to update crc */
        //int val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = $af68a4e46963dbc6080b158c600e7210$var$COMMENT_STATE;
        }
      } else {
      s.status = $af68a4e46963dbc6080b158c600e7210$var$COMMENT_STATE;
    }
  }

  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    )
      /* != Z_NULL*/
      {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        /* start of bytes to update crc */
        //int val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = $ef4d58971db61b7aa82dc64394c5ee16$exports(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = $af68a4e46963dbc6080b158c600e7210$var$HCRC_STATE;
        }
      } else {
      s.status = $af68a4e46963dbc6080b158c600e7210$var$HCRC_STATE;
    }
  }

  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler & 0xff);
        $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        //crc32(0L, Z_NULL, 0);
        s.status = $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE;
      }
    } else {
      s.status = $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && $af68a4e46963dbc6080b158c600e7210$var$rank(flush) <= $af68a4e46963dbc6080b158c600e7210$var$rank(old_flush) && flush !== $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  /* User must not provide more input after the first FINISH: */
  if (s.status === $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE && strm.avail_in !== 0) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== $af68a4e46963dbc6080b158c600e7210$var$Z_NO_FLUSH && s.status !== $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE) {
    var bstate = s.strategy === $af68a4e46963dbc6080b158c600e7210$var$Z_HUFFMAN_ONLY ? $af68a4e46963dbc6080b158c600e7210$var$deflate_huff(s, flush) : s.strategy === $af68a4e46963dbc6080b158c600e7210$var$Z_RLE ? $af68a4e46963dbc6080b158c600e7210$var$deflate_rle(s, flush) : $af68a4e46963dbc6080b158c600e7210$var$configuration_table[s.level].func(s, flush);

    if (bstate === $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED || bstate === $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_DONE) {
      s.status = $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE;
    }

    if (bstate === $af68a4e46963dbc6080b158c600e7210$var$BS_NEED_MORE || bstate === $af68a4e46963dbc6080b158c600e7210$var$BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === $af68a4e46963dbc6080b158c600e7210$var$BS_BLOCK_DONE) {
      if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_PARTIAL_FLUSH) {
        $48871d5c23eeea8ca519be31f99a83f4$export$_tr_align(s);
      } else if (flush !== $af68a4e46963dbc6080b158c600e7210$var$Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        $48871d5c23eeea8ca519be31f99a83f4$export$_tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */

        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === $af68a4e46963dbc6080b158c600e7210$var$Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          $af68a4e46963dbc6080b158c600e7210$var$zero(s.head); // Fill with NIL (= 0);

          // Fill with NIL (= 0);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        /* avoid BUF_ERROR at next call, see above */
        return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}
  if (flush !== $af68a4e46963dbc6080b158c600e7210$var$Z_FINISH) {
    return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
  }

  if (s.wrap <= 0) {
    return $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_END;
  }
  /* Write the trailer */


  /* Write the trailer */
  if (s.wrap === 2) {
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler >> 8 & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler >> 16 & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.adler >> 24 & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.total_in & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.total_in >> 8 & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.total_in >> 16 & 0xff);
    $af68a4e46963dbc6080b158c600e7210$var$put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, strm.adler >>> 16);
    $af68a4e46963dbc6080b158c600e7210$var$putShortMSB(s, strm.adler & 0xffff);
  }

  $af68a4e46963dbc6080b158c600e7210$var$flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  /* write the trailer only once! */
  return s.pending !== 0 ? $af68a4e46963dbc6080b158c600e7210$var$Z_OK : $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_END;
}

function $af68a4e46963dbc6080b158c600e7210$var$deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  ||
  /*== Z_NULL*/
  !strm.state
  /*== Z_NULL*/
  )
    /*== Z_NULL*/
    {
      return $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== $af68a4e46963dbc6080b158c600e7210$var$INIT_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$EXTRA_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$NAME_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$COMMENT_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$HCRC_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE && status !== $af68a4e46963dbc6080b158c600e7210$var$FINISH_STATE) {
    return $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === $af68a4e46963dbc6080b158c600e7210$var$BUSY_STATE ? $af68a4e46963dbc6080b158c600e7210$var$err(strm, $af68a4e46963dbc6080b158c600e7210$var$Z_DATA_ERROR) : $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function $af68a4e46963dbc6080b158c600e7210$var$deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  ||
  /*== Z_NULL*/
  !strm.state
  /*== Z_NULL*/
  )
    /*== Z_NULL*/
    {
      return $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== $af68a4e46963dbc6080b158c600e7210$var$INIT_STATE || s.lookahead) {
    return $af68a4e46963dbc6080b158c600e7210$var$Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = $f5e3420f0ba52555cac23cb3e641886f$exports(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      $af68a4e46963dbc6080b158c600e7210$var$zero(s.head); // Fill with NIL (= 0);

      // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new $8a14024ea7aaaa468f79728228f23324$exports.Buf8(s.w_size);
    $8a14024ea7aaaa468f79728228f23324$exports.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);

  while (s.lookahead >= $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - ($af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;
    $af68a4e46963dbc6080b158c600e7210$var$fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = $af68a4e46963dbc6080b158c600e7210$var$MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return $af68a4e46963dbc6080b158c600e7210$var$Z_OK;
}

var $af68a4e46963dbc6080b158c600e7210$export$deflateInit2 = $af68a4e46963dbc6080b158c600e7210$var$deflateInit2;
var $af68a4e46963dbc6080b158c600e7210$export$deflateReset = $af68a4e46963dbc6080b158c600e7210$var$deflateReset;
var $af68a4e46963dbc6080b158c600e7210$export$deflate = $af68a4e46963dbc6080b158c600e7210$var$deflate;
var $af68a4e46963dbc6080b158c600e7210$export$deflateEnd = $af68a4e46963dbc6080b158c600e7210$var$deflateEnd;
var $af68a4e46963dbc6080b158c600e7210$export$deflateSetDictionary = $af68a4e46963dbc6080b158c600e7210$var$deflateSetDictionary;
// ASSET: node_modules/pako/lib/zlib/inffast.js
var $92a7ecebd036f0f232453e943b8f8f35$exports = {};
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js
var $92a7ecebd036f0f232453e943b8f8f35$var$BAD = 30;
/* got a data error -- remain here until reset */

/* got a data error -- remain here until reset */
var $92a7ecebd036f0f232453e943b8f8f35$var$TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
$92a7ecebd036f0f232453e943b8f8f35$exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  /* local strm.input */
  var last;
  /* have enough input while in < last */

  /* have enough input while in < last */
  var _out;
  /* local strm.output */


  /* local strm.output */
  var beg;
  /* inflate()'s initial strm.output */

  /* inflate()'s initial strm.output */
  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax;
  /* maximum distance from zlib header */
  //#endif

  /* maximum distance from zlib header */
  //#endif
  var wsize;
  /* window size or zero if not using window */

  /* window size or zero if not using window */
  var whave;
  /* valid bytes in the window */

  /* valid bytes in the window */
  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;
  /* allocated sliding window, if wsize != 0 */

  /* allocated sliding window, if wsize != 0 */
  var hold;
  /* local strm.hold */

  /* local strm.hold */
  var bits;
  /* local strm.bits */

  /* local strm.bits */
  var lcode;
  /* local strm.lencode */

  /* local strm.lencode */
  var dcode;
  /* local strm.distcode */

  /* local strm.distcode */
  var lmask;
  /* mask for first level of length codes */

  /* mask for first level of length codes */
  var dmask;
  /* mask for first level of distance codes */

  /* mask for first level of distance codes */
  var here;
  /* retrieved table entry */

  /* retrieved table entry */
  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */
  var len;
  /* match length, unused bytes */

  /* match length, unused bytes */
  var dist;
  /* match distance */

  /* match distance */
  var from;
  /* where to copy match from */

  /* where to copy match from */
  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state; //here = state.here;

  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  //#ifdef INFLATE_STRICT
  dmax = state.dmax; //#endif

  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = $92a7ecebd036f0f232453e943b8f8f35$var$BAD;
              break top;
            } //#endif


            //#endif
            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;
            /* max distance in output */

            /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = $92a7ecebd036f0f232453e943b8f8f35$var$BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              // window index
              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  /* rest from output */
                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = $92a7ecebd036f0f232453e943b8f8f35$var$BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = $92a7ecebd036f0f232453e943b8f8f35$var$TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = $92a7ecebd036f0f232453e943b8f8f35$var$BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

// ASSET: node_modules/pako/lib/zlib/inftrees.js
var $987b95d2fe6ae980b698f09b63be7c33$exports = {};
var $987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS = 15;
var $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_LENS = 852;
var $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
var $987b95d2fe6ae980b698f09b63be7c33$var$CODES = 0;
var $987b95d2fe6ae980b698f09b63be7c33$var$LENS = 1;
var $987b95d2fe6ae980b698f09b63be7c33$var$DISTS = 2;
var $987b95d2fe6ae980b698f09b63be7c33$var$lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var $987b95d2fe6ae980b698f09b63be7c33$var$lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var $987b95d2fe6ae980b698f09b63be7c33$var$dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var $987b95d2fe6ae980b698f09b63be7c33$var$dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

$987b95d2fe6ae980b698f09b63be7c33$exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  //here = opts.here; /* table entry for duplication */
  var len = 0;
  /* a code's length in bits */

  /* a code's length in bits */
  var sym = 0;
  /* index of code symbols */

  /* index of code symbols */
  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  /* minimum and maximum code lengths */
  var root = 0;
  /* number of index bits for root table */

  /* number of index bits for root table */
  var curr = 0;
  /* number of index bits for current table */

  /* number of index bits for current table */
  var drop = 0;
  /* code bits to drop for sub-table */

  /* code bits to drop for sub-table */
  var left = 0;
  /* number of prefix codes available */

  /* number of prefix codes available */
  var used = 0;
  /* code entries in table used */

  /* code entries in table used */
  var huff = 0;
  /* Huffman code */

  /* Huffman code */
  var incr;
  /* for incrementing code, index */

  /* for incrementing code, index */
  var fill;
  /* index for replicating entries */

  /* index for replicating entries */
  var low;
  /* low bits for current root entry */

  /* low bits for current root entry */
  var mask;
  /* mask for low root bits */

  /* mask for low root bits */
  var next;
  /* next available space in table */

  /* next available space in table */
  var base = null;
  /* base value table to use */

  /* base value table to use */
  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  //  var shoextra;    /* extra bits table to use */
  var end;
  /* use base and extra for symbol > end */

  /* use base and extra for symbol > end */
  var count = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16($987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  //[MAXBITS+1];    /* number of codes of each length */
  var offs = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16($987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= $987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  /* bound code lengths, force root to be within code lengths */
  root = bits;

  for (max = $987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;

  for (len = 1; len <= $987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === $987b95d2fe6ae980b698f09b63be7c33$var$CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;

  for (len = 1; len < $987b95d2fe6ae980b698f09b63be7c33$var$MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === $987b95d2fe6ae980b698f09b63be7c33$var$CODES) {
    base = extra = work;
    /* dummy value--not used */

    /* dummy value--not used */
    end = 19;
  } else if (type === $987b95d2fe6ae980b698f09b63be7c33$var$LENS) {
    base = $987b95d2fe6ae980b698f09b63be7c33$var$lbase;
    base_index -= 257;
    extra = $987b95d2fe6ae980b698f09b63be7c33$var$lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = $987b95d2fe6ae980b698f09b63be7c33$var$dbase;
    extra = $987b95d2fe6ae980b698f09b63be7c33$var$dext;
    end = -1;
  }
  /* initialize opts for loop */


  /* initialize opts for loop */
  huff = 0;
  /* starting code */

  /* starting code */
  sym = 0;
  /* starting code symbol */

  /* starting code symbol */
  len = min;
  /* starting code length */

  /* starting code length */
  next = table_index;
  /* current table to fill in */

  /* current table to fill in */
  curr = root;
  /* current table index bits */

  /* current table index bits */
  drop = 0;
  /* current bits to drop from code for index */

  /* current bits to drop from code for index */
  low = -1;
  /* trigger new sub-table when len > root */

  /* trigger new sub-table when len > root */
  used = 1 << root;
  /* use root table entries */

  /* use root table entries */
  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  /* mask for comparing low */

  /* check available table space */
  if (type === $987b95d2fe6ae980b698f09b63be7c33$var$LENS && used > $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_LENS || type === $987b95d2fe6ae980b698f09b63be7c33$var$DISTS && used > $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      /* end of block */
      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    /* go to next symbol, update count, len */
    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      /* increment past last table */
      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      /* check for enough space */
      used += 1 << curr;

      if (type === $987b95d2fe6ae980b698f09b63be7c33$var$LENS && used > $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_LENS || type === $987b95d2fe6ae980b698f09b63be7c33$var$DISTS && used > $987b95d2fe6ae980b698f09b63be7c33$var$ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

var $84d49246177a6911a2519f7712dfd592$var$CODES = 0;
var $84d49246177a6911a2519f7712dfd592$var$LENS = 1;
var $84d49246177a6911a2519f7712dfd592$var$DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var $84d49246177a6911a2519f7712dfd592$var$Z_FINISH = 4;
var $84d49246177a6911a2519f7712dfd592$var$Z_BLOCK = 5;
var $84d49246177a6911a2519f7712dfd592$var$Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var $84d49246177a6911a2519f7712dfd592$var$Z_OK = 0;
var $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_END = 1;
var $84d49246177a6911a2519f7712dfd592$var$Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

//var Z_ERRNO         = -1;
var $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR = -2;
var $84d49246177a6911a2519f7712dfd592$var$Z_DATA_ERROR = -3;
var $84d49246177a6911a2519f7712dfd592$var$Z_MEM_ERROR = -4;
var $84d49246177a6911a2519f7712dfd592$var$Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var $84d49246177a6911a2519f7712dfd592$var$Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

/* STATES ====================================================================*/

/* ===========================================================================*/
var $84d49246177a6911a2519f7712dfd592$var$HEAD = 1;
/* i: waiting for magic header */

/* i: waiting for magic header */
var $84d49246177a6911a2519f7712dfd592$var$FLAGS = 2;
/* i: waiting for method and flags (gzip) */

/* i: waiting for method and flags (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$TIME = 3;
/* i: waiting for modification time (gzip) */

/* i: waiting for modification time (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

/* i: waiting for extra flags and operating system (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$EXLEN = 5;
/* i: waiting for extra length (gzip) */

/* i: waiting for extra length (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

/* i: waiting for extra bytes (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$NAME = 7;
/* i: waiting for end of file name (gzip) */

/* i: waiting for end of file name (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$COMMENT = 8;
/* i: waiting for end of comment (gzip) */

/* i: waiting for end of comment (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$HCRC = 9;
/* i: waiting for header crc (gzip) */

/* i: waiting for header crc (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$DICTID = 10;
/* i: waiting for dictionary check value */

/* i: waiting for dictionary check value */
var $84d49246177a6911a2519f7712dfd592$var$DICT = 11;
/* waiting for inflateSetDictionary() call */

/* waiting for inflateSetDictionary() call */
var $84d49246177a6911a2519f7712dfd592$var$TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/* i: waiting for type bits, including last-flag bit */
var $84d49246177a6911a2519f7712dfd592$var$TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

/* i: same, but skip check to exit inflate on new block */
var $84d49246177a6911a2519f7712dfd592$var$STORED = 14;
/* i: waiting for stored size (length and complement) */

/* i: waiting for stored size (length and complement) */
var $84d49246177a6911a2519f7712dfd592$var$COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

/* i/o: same as COPY below, but only first time in */
var $84d49246177a6911a2519f7712dfd592$var$COPY = 16;
/* i/o: waiting for input or output to copy stored block */

/* i/o: waiting for input or output to copy stored block */
var $84d49246177a6911a2519f7712dfd592$var$TABLE = 17;
/* i: waiting for dynamic block table lengths */

/* i: waiting for dynamic block table lengths */
var $84d49246177a6911a2519f7712dfd592$var$LENLENS = 18;
/* i: waiting for code length code lengths */

/* i: waiting for code length code lengths */
var $84d49246177a6911a2519f7712dfd592$var$CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

/* i: waiting for length/lit and distance code lengths */
var $84d49246177a6911a2519f7712dfd592$var$LEN_ = 20;
/* i: same as LEN below, but only first time in */

/* i: same as LEN below, but only first time in */
var $84d49246177a6911a2519f7712dfd592$var$LEN = 21;
/* i: waiting for length/lit/eob code */

/* i: waiting for length/lit/eob code */
var $84d49246177a6911a2519f7712dfd592$var$LENEXT = 22;
/* i: waiting for length extra bits */

/* i: waiting for length extra bits */
var $84d49246177a6911a2519f7712dfd592$var$DIST = 23;
/* i: waiting for distance code */

/* i: waiting for distance code */
var $84d49246177a6911a2519f7712dfd592$var$DISTEXT = 24;
/* i: waiting for distance extra bits */

/* i: waiting for distance extra bits */
var $84d49246177a6911a2519f7712dfd592$var$MATCH = 25;
/* o: waiting for output space to copy string */

/* o: waiting for output space to copy string */
var $84d49246177a6911a2519f7712dfd592$var$LIT = 26;
/* o: waiting for output space to write literal */

/* o: waiting for output space to write literal */
var $84d49246177a6911a2519f7712dfd592$var$CHECK = 27;
/* i: waiting for 32-bit check value */

/* i: waiting for 32-bit check value */
var $84d49246177a6911a2519f7712dfd592$var$LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

/* i: waiting for 32-bit length (gzip) */
var $84d49246177a6911a2519f7712dfd592$var$DONE = 29;
/* finished check, done -- remain here until reset */

/* finished check, done -- remain here until reset */
var $84d49246177a6911a2519f7712dfd592$var$BAD = 30;
/* got a data error -- remain here until reset */

/* got a data error -- remain here until reset */
var $84d49246177a6911a2519f7712dfd592$var$MEM = 31;
/* got an inflate() memory error -- remain here until reset */

/* got an inflate() memory error -- remain here until reset */
var $84d49246177a6911a2519f7712dfd592$var$SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/
var $84d49246177a6911a2519f7712dfd592$var$ENOUGH_LENS = 852;
var $84d49246177a6911a2519f7712dfd592$var$ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

function $84d49246177a6911a2519f7712dfd592$var$zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function $84d49246177a6911a2519f7712dfd592$var$InflateState() {
  this.mode = 0;
  /* current inflate mode */

  /* current inflate mode */
  this.last = false;
  /* true if processing last block */

  /* true if processing last block */
  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;
  /* true if dictionary provided */

  /* true if dictionary provided */
  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;
  /* protected copy of check value */

  /* protected copy of check value */
  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  /* protected copy of output count */
  // TODO: may be {}
  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;
  /* log base 2 of requested window size */

  /* log base 2 of requested window size */
  this.wsize = 0;
  /* window size or zero if not using window */

  /* window size or zero if not using window */
  this.whave = 0;
  /* valid bytes in the window */

  /* valid bytes in the window */
  this.wnext = 0;
  /* window write index */

  /* window write index */
  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;
  /* input bit accumulator */

  /* input bit accumulator */
  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;
  /* literal or length of data to copy */

  /* literal or length of data to copy */
  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;
  /* starting table for length/literal codes */

  /* starting table for length/literal codes */
  this.distcode = null;
  /* starting table for distance codes */

  /* starting table for distance codes */
  this.lenbits = 0;
  /* index bits for lencode */

  /* index bits for lencode */
  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;
  /* number of code length code lengths */

  /* number of code length code lengths */
  this.nlen = 0;
  /* number of length code lengths */

  /* number of length code lengths */
  this.ndist = 0;
  /* number of distance code lengths */

  /* number of distance code lengths */
  this.have = 0;
  /* number of code lengths in lens[] */

  /* number of code lengths in lens[] */
  this.next = null;
  /* next available space in codes[] */

  /* next available space in codes[] */
  this.lens = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(320);
  /* temporary storage for code lengths */

  /* temporary storage for code lengths */
  this.work = new $8a14024ea7aaaa468f79728228f23324$exports.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  /* dynamic table for distance codes (JS specific) */
  this.sane = 0;
  /* if false, allow invalid distance too far */

  /* if false, allow invalid distance too far */
  this.back = 0;
  /* bits back of last unprocessed length/lit */

  /* bits back of last unprocessed length/lit */
  this.was = 0;
  /* initial length of match */
}

function $84d49246177a6911a2519f7712dfd592$var$inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = $84d49246177a6911a2519f7712dfd592$var$HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new $8a14024ea7aaaa468f79728228f23324$exports.Buf32($84d49246177a6911a2519f7712dfd592$var$ENOUGH_LENS);
  state.distcode = state.distdyn = new $8a14024ea7aaaa468f79728228f23324$exports.Buf32($84d49246177a6911a2519f7712dfd592$var$ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  //Tracev((stderr, "inflate: reset\n"));
  return $84d49246177a6911a2519f7712dfd592$var$Z_OK;
}

function $84d49246177a6911a2519f7712dfd592$var$inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return $84d49246177a6911a2519f7712dfd592$var$inflateResetKeep(strm);
}

function $84d49246177a6911a2519f7712dfd592$var$inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  /* get the state */
  if (!strm || !strm.state) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return $84d49246177a6911a2519f7712dfd592$var$inflateReset(strm);
}

function $84d49246177a6911a2519f7712dfd592$var$inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  //strm.msg = Z_NULL;                 /* in case we return an error */
  state = new $84d49246177a6911a2519f7712dfd592$var$InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = $84d49246177a6911a2519f7712dfd592$var$inflateReset2(strm, windowBits);

  if (ret !== $84d49246177a6911a2519f7712dfd592$var$Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var $84d49246177a6911a2519f7712dfd592$var$virgin = true;
var $84d49246177a6911a2519f7712dfd592$var$lenfix, $84d49246177a6911a2519f7712dfd592$var$distfix; // We have no pointers in JS, so keep tables separate

// We have no pointers in JS, so keep tables separate
function $84d49246177a6911a2519f7712dfd592$var$fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if ($84d49246177a6911a2519f7712dfd592$var$virgin) {
    var sym;
    $84d49246177a6911a2519f7712dfd592$var$lenfix = new $8a14024ea7aaaa468f79728228f23324$exports.Buf32(512);
    $84d49246177a6911a2519f7712dfd592$var$distfix = new $8a14024ea7aaaa468f79728228f23324$exports.Buf32(32);
    /* literal/length table */

    /* literal/length table */
    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    $987b95d2fe6ae980b698f09b63be7c33$exports($84d49246177a6911a2519f7712dfd592$var$LENS, state.lens, 0, 288, $84d49246177a6911a2519f7712dfd592$var$lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    /* distance table */
    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    $987b95d2fe6ae980b698f09b63be7c33$exports($84d49246177a6911a2519f7712dfd592$var$DISTS, state.lens, 0, 32, $84d49246177a6911a2519f7712dfd592$var$distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    /* do this just once */
    $84d49246177a6911a2519f7712dfd592$var$virgin = false;
  }

  state.lencode = $84d49246177a6911a2519f7712dfd592$var$lenfix;
  state.lenbits = 9;
  state.distcode = $84d49246177a6911a2519f7712dfd592$var$distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function $84d49246177a6911a2519f7712dfd592$var$updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new $8a14024ea7aaaa468f79728228f23324$exports.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    $8a14024ea7aaaa468f79728228f23324$exports.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    //zmemcpy(state->window + state->wnext, end - copy, dist);
    $8a14024ea7aaaa468f79728228f23324$exports.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      $8a14024ea7aaaa468f79728228f23324$exports.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function $84d49246177a6911a2519f7712dfd592$var$inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  // input/output buffers
  var next;
  /* next input INDEX */

  /* next input INDEX */
  var put;
  /* next output INDEX */

  /* next output INDEX */
  var have, left;
  /* available input and output */

  /* available input and output */
  var hold;
  /* bit buffer */

  /* bit buffer */
  var bits;
  /* bits in bit buffer */

  /* bits in bit buffer */
  var _in, _out;
  /* save starting available input and output */


  /* save starting available input and output */
  var copy;
  /* number of stored or match bytes to copy */

  /* number of stored or match bytes to copy */
  var from;
  /* where to copy match bytes from */

  /* where to copy match bytes from */
  var from_source;
  var here = 0;
  /* current decoding table entry */

  /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  // paked "last" denormalized (JS specific)
  var len;
  /* length to copy for repeats, bits to drop */

  /* length to copy for repeats, bits to drop */
  var ret;
  /* return code */

  /* return code */
  var hbuf = new $8a14024ea7aaaa468f79728228f23324$exports.Buf8(4);
  /* buffer for gzip header crc calculation */

  /* buffer for gzip header crc calculation */
  var opts;
  var n; // temporary var for NEED_BITS

  // temporary var for NEED_BITS
  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === $84d49246177a6911a2519f7712dfd592$var$TYPE) {
    state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  /* skip check */
  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  //---
  _in = have;
  _out = left;
  ret = $84d49246177a6911a2519f7712dfd592$var$Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case $84d49246177a6911a2519f7712dfd592$var$HEAD:
        if (state.wrap === 0) {
          state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPEDO;
          break;
        } //=== NEEDBITS(16);


        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          //===//
          //=== INITBITS();
          hold = 0;
          bits = 0; //===//

          //===//
          state.mode = $84d49246177a6911a2519f7712dfd592$var$FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        $84d49246177a6911a2519f7712dfd592$var$Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        } //--- DROPBITS(4) ---//


        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4; //---//

        //---//
        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? $84d49246177a6911a2519f7712dfd592$var$DICTID : $84d49246177a6911a2519f7712dfd592$var$TYPE; //=== INITBITS();

        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        break;

      case $84d49246177a6911a2519f7712dfd592$var$FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        state.flags = hold;

        if ((state.flags & 0xff) !== $84d49246177a6911a2519f7712dfd592$var$Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        state.mode = $84d49246177a6911a2519f7712dfd592$var$TIME;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        state.mode = $84d49246177a6911a2519f7712dfd592$var$OS;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        state.mode = $84d49246177a6911a2519f7712dfd592$var$EXLEN;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          //=== INITBITS();
          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = $84d49246177a6911a2519f7712dfd592$var$EXTRA;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              $8a14024ea7aaaa468f79728228f23324$exports.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$NAME;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$COMMENT;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = $84d49246177a6911a2519f7712dfd592$var$HCRC;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
            break;
          } //=== INITBITS();


          //=== INITBITS();
          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPE;
        break;

      case $84d49246177a6911a2519f7712dfd592$var$DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        strm.adler = state.check = $84d49246177a6911a2519f7712dfd592$var$zswap32(hold); //=== INITBITS();

        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        state.mode = $84d49246177a6911a2519f7712dfd592$var$DICT;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          //---
          return $84d49246177a6911a2519f7712dfd592$var$Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPE;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$TYPE:
        if (flush === $84d49246177a6911a2519f7712dfd592$var$Z_BLOCK || flush === $84d49246177a6911a2519f7712dfd592$var$Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          //---//
          state.mode = $84d49246177a6911a2519f7712dfd592$var$CHECK;
          break;
        } //=== NEEDBITS(3); */


        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1; //---//

        //---//
        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = $84d49246177a6911a2519f7712dfd592$var$STORED;
            break;

          case 1:
            /* fixed block */
            $84d49246177a6911a2519f7712dfd592$var$fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = $84d49246177a6911a2519f7712dfd592$var$LEN_;
            /* decode codes */

            /* decode codes */
            if (flush === $84d49246177a6911a2519f7712dfd592$var$Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              //---//
              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = $84d49246177a6911a2519f7712dfd592$var$TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
        } //--- DROPBITS(2) ---//


        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2; //---//

        //---//
        break;

      case $84d49246177a6911a2519f7712dfd592$var$STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0; //===//

        //===//
        state.mode = $84d49246177a6911a2519f7712dfd592$var$COPY_;

        if (flush === $84d49246177a6911a2519f7712dfd592$var$Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$COPY_:
        state.mode = $84d49246177a6911a2519f7712dfd592$var$COPY;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          //--- zmemcpy(put, next, copy); ---
          $8a14024ea7aaaa468f79728228f23324$exports.arraySet(output, input, next, copy, put); //---//

          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPE;
        break;

      case $84d49246177a6911a2519f7712dfd592$var$TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        //===//
        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5; //---//

        //---//
        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5; //---//

        //---//
        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$LENLENS;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = $987b95d2fe6ae980b698f09b63be7c33$exports($84d49246177a6911a2519f7712dfd592$var$CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$CODELENS;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits; //---//

              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits; //---//

              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits; //---//

              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        /* handle error breaks in while */
        if (state.mode === $84d49246177a6911a2519f7712dfd592$var$BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = $987b95d2fe6ae980b698f09b63be7c33$exports($84d49246177a6911a2519f7712dfd592$var$LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits; // state.lencode = state.next;

        // state.lencode = state.next;
        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = $987b95d2fe6ae980b698f09b63be7c33$exports($84d49246177a6911a2519f7712dfd592$var$DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits; // state.distcode = state.next;

        // state.distcode = state.next;
        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = $84d49246177a6911a2519f7712dfd592$var$LEN_;

        if (flush === $84d49246177a6911a2519f7712dfd592$var$Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$LEN_:
        state.mode = $84d49246177a6911a2519f7712dfd592$var$LEN;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          //---
          $92a7ecebd036f0f232453e943b8f8f35$exports(strm, _out); //--- LOAD() ---

          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          //---
          if (state.mode === $84d49246177a6911a2519f7712dfd592$var$TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits; //---//

          //---//
          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits; //---//

        //---//
        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = $84d49246177a6911a2519f7712dfd592$var$LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = $84d49246177a6911a2519f7712dfd592$var$TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$LENEXT;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra; //---//

          //---//
          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$DIST;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits; //---//

          //---//
          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits; //---//

        //---//
        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$DISTEXT;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra; //---//

          //---//
          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = $84d49246177a6911a2519f7712dfd592$var$MATCH;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = $84d49246177a6911a2519f7712dfd592$var$LEN;
        }

        break;

      case $84d49246177a6911a2519f7712dfd592$var$LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = $84d49246177a6911a2519f7712dfd592$var$LEN;
        break;

      case $84d49246177a6911a2519f7712dfd592$var$CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, output, _out, put - _out) : $f5e3420f0ba52555cac23cb3e641886f$exports(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : $84d49246177a6911a2519f7712dfd592$var$zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
            break;
          } //=== INITBITS();


          //=== INITBITS();
          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = $84d49246177a6911a2519f7712dfd592$var$LENGTH;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = $84d49246177a6911a2519f7712dfd592$var$BAD;
            break;
          } //=== INITBITS();


          //=== INITBITS();
          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = $84d49246177a6911a2519f7712dfd592$var$DONE;

      /* falls through */

      /* falls through */
      case $84d49246177a6911a2519f7712dfd592$var$DONE:
        ret = $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_END;
        break inf_leave;

      case $84d49246177a6911a2519f7712dfd592$var$BAD:
        ret = $84d49246177a6911a2519f7712dfd592$var$Z_DATA_ERROR;
        break inf_leave;

      case $84d49246177a6911a2519f7712dfd592$var$MEM:
        return $84d49246177a6911a2519f7712dfd592$var$Z_MEM_ERROR;

      case $84d49246177a6911a2519f7712dfd592$var$SYNC:
      /* falls through */

      /* falls through */
      default:
        return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  //---
  if (state.wsize || _out !== strm.avail_out && state.mode < $84d49246177a6911a2519f7712dfd592$var$BAD && (state.mode < $84d49246177a6911a2519f7712dfd592$var$CHECK || flush !== $84d49246177a6911a2519f7712dfd592$var$Z_FINISH)) {
    if ($84d49246177a6911a2519f7712dfd592$var$updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = $84d49246177a6911a2519f7712dfd592$var$MEM;
      return $84d49246177a6911a2519f7712dfd592$var$Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? $ef4d58971db61b7aa82dc64394c5ee16$exports(state.check, output, _out, strm.next_out - _out) : $f5e3420f0ba52555cac23cb3e641886f$exports(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === $84d49246177a6911a2519f7712dfd592$var$TYPE ? 128 : 0) + (state.mode === $84d49246177a6911a2519f7712dfd592$var$LEN_ || state.mode === $84d49246177a6911a2519f7712dfd592$var$COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === $84d49246177a6911a2519f7712dfd592$var$Z_FINISH) && ret === $84d49246177a6911a2519f7712dfd592$var$Z_OK) {
    ret = $84d49246177a6911a2519f7712dfd592$var$Z_BUF_ERROR;
  }

  return ret;
}

function $84d49246177a6911a2519f7712dfd592$var$inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  )
    /*|| strm->zfree == (free_func)0*/
    {
      return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return $84d49246177a6911a2519f7712dfd592$var$Z_OK;
}

function $84d49246177a6911a2519f7712dfd592$var$inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  /* check state */
  if (!strm
  /* == Z_NULL */
  ||
  /* == Z_NULL */
  !strm.state
  /* == Z_NULL */
  )
    /* == Z_NULL */
    {
      return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== $84d49246177a6911a2519f7712dfd592$var$DICT) {
    return $84d49246177a6911a2519f7712dfd592$var$Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  /* check for correct dictionary identifier */
  if (state.mode === $84d49246177a6911a2519f7712dfd592$var$DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = $f5e3420f0ba52555cac23cb3e641886f$exports(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return $84d49246177a6911a2519f7712dfd592$var$Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = $84d49246177a6911a2519f7712dfd592$var$updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = $84d49246177a6911a2519f7712dfd592$var$MEM;
    return $84d49246177a6911a2519f7712dfd592$var$Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  // Tracev((stderr, "inflate:   dictionary set\n"));
  return $84d49246177a6911a2519f7712dfd592$var$Z_OK;
}

var $84d49246177a6911a2519f7712dfd592$export$inflateReset = $84d49246177a6911a2519f7712dfd592$var$inflateReset;
var $84d49246177a6911a2519f7712dfd592$export$inflateInit2 = $84d49246177a6911a2519f7712dfd592$var$inflateInit2;
var $84d49246177a6911a2519f7712dfd592$export$inflate = $84d49246177a6911a2519f7712dfd592$var$inflate;
var $84d49246177a6911a2519f7712dfd592$export$inflateEnd = $84d49246177a6911a2519f7712dfd592$var$inflateEnd;
var $84d49246177a6911a2519f7712dfd592$export$inflateSetDictionary = $84d49246177a6911a2519f7712dfd592$var$inflateSetDictionary;
// ASSET: node_modules/pako/lib/zlib/constants.js
var $2c0984bcb3a6a7cae943b823129856ed$exports = {};
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
$2c0984bcb3a6a7cae943b823129856ed$exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

for (var $ac254f1082b0ce94146edfb9c2acdf2f$var$key in $2c0984bcb3a6a7cae943b823129856ed$exports) {
  $ac254f1082b0ce94146edfb9c2acdf2f$exports[$ac254f1082b0ce94146edfb9c2acdf2f$var$key] = $2c0984bcb3a6a7cae943b823129856ed$exports[$ac254f1082b0ce94146edfb9c2acdf2f$var$key];
} // zlib modes


var $ac254f1082b0ce94146edfb9c2acdf2f$export$NONE = 0;
// zlib modes
$ac254f1082b0ce94146edfb9c2acdf2f$exports.NONE = $ac254f1082b0ce94146edfb9c2acdf2f$export$NONE;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$DEFLATE = 1;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE = $ac254f1082b0ce94146edfb9c2acdf2f$export$DEFLATE;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$INFLATE = 2;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE = $ac254f1082b0ce94146edfb9c2acdf2f$export$INFLATE;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$GZIP = 3;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP = $ac254f1082b0ce94146edfb9c2acdf2f$export$GZIP;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$GUNZIP = 4;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP = $ac254f1082b0ce94146edfb9c2acdf2f$export$GUNZIP;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$DEFLATERAW = 5;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW = $ac254f1082b0ce94146edfb9c2acdf2f$export$DEFLATERAW;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$INFLATERAW = 6;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW = $ac254f1082b0ce94146edfb9c2acdf2f$export$INFLATERAW;
var $ac254f1082b0ce94146edfb9c2acdf2f$export$UNZIP = 7;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP = $ac254f1082b0ce94146edfb9c2acdf2f$export$UNZIP;
var $ac254f1082b0ce94146edfb9c2acdf2f$var$GZIP_HEADER_ID1 = 0x1f;
var $ac254f1082b0ce94146edfb9c2acdf2f$var$GZIP_HEADER_ID2 = 0x8b;
/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function $ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib(mode) {
  if (typeof mode !== 'number' || mode < $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE || mode > $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(this.init_done, 'close before init');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(this.mode <= $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP);

  if (this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW) {
    $af68a4e46963dbc6080b158c600e7210$export$deflateEnd(this.strm);
  } else if (this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP) {
    $84d49246177a6911a2519f7712dfd592$export$inflateEnd(this.strm);
  }

  this.mode = $ac254f1082b0ce94146edfb9c2acdf2f$exports.NONE;
  this.dictionary = null;
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert.equal(arguments.length, 8);
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(this.init_done, 'write before init');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(this.mode !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.NONE, 'already finalized');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert.equal(false, this.write_in_progress, 'write already in progress');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert.equal(false, this.pending_close, 'close is pending');
  this.write_in_progress = true;
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert.equal(false, flush === undefined, 'must provide flush value');
  this.write_in_progress = true;

  if (flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NO_FLUSH && flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_PARTIAL_FLUSH && flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_SYNC_FLUSH && flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FULL_FLUSH && flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FINISH && flush !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = $ac254f1082b0ce94146edfb9c2acdf2f$var$Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }

    return;
  } // async version


  // async version
  var self = this;
  $ac254f1082b0ce94146edfb9c2acdf2f$var$process.nextTick(function () {
    self._process();

    self._after();
  });
  return this;
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false;
  return [avail_in, avail_out];
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._process = function () {
  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (this.mode) {
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW:
      this.err = $af68a4e46963dbc6080b158c600e7210$export$deflate(this.strm, this.flush);
      break;

    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === $ac254f1082b0ce94146edfb9c2acdf2f$var$GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE;
            break;
          }

        // fallthrough

        // fallthrough
        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === $ac254f1082b0ce94146edfb9c2acdf2f$var$GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE;
          }

          break;

        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough

    // fallthrough
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW:
      this.err = $84d49246177a6911a2519f7712dfd592$export$inflate(this.strm, this.flush // If data was encoded with dictionary
      );

      if (this.err === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = $84d49246177a6911a2519f7712dfd592$export$inflateSetDictionary(this.strm, this.dictionary);

        if (this.err === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK) {
          // And try to decode again
          this.err = $84d49246177a6911a2519f7712dfd592$export$inflate(this.strm, this.flush);
        } else if (this.err === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NEED_DICT;
        }
      }

      while (this.strm.avail_in > 0 && this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP && this.err === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.
        this.reset();
        this.err = $84d49246177a6911a2519f7712dfd592$export$inflate(this.strm, this.flush);
      }

      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FINISH) {
        this._error('unexpected end of file');

        return false;
      }

      break;

    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;

    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }

      return false;

    default:
      // something else.
      this._error('Zlib error');

      return false;
  }

  return true;
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false; // call the write() cb

  // call the write() cb
  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }

  this.onerror(message, this.err // no hope of rescue.
  );
  this.write_in_progress = false;

  if (this.pending_close) {
    this.close();
  }
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(level >= -1 && level <= 9, 'invalid compression level');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');
  $ac254f1082b0ce94146edfb9c2acdf2f$var$assert(strategy === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FILTERED || strategy === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_HUFFMAN_ONLY || strategy === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_RLE || strategy === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FIXED || strategy === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);

  this._setDictionary();
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype.reset = function () {
  this._reset();

  this._setDictionary();
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;
  this.flush = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NO_FLUSH;
  this.err = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK;

  if (this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW || this.mode === $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new $96705731572b187214e5f1c7e22db483$exports();

  switch (this.mode) {
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW:
      this.err = $af68a4e46963dbc6080b158c600e7210$export$deflateInit2(this.strm, this.level, $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;

    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP:
      this.err = $84d49246177a6911a2519f7712dfd592$export$inflateInit2(this.strm, this.windowBits);
      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;
  this.write_in_progress = false;
  this.init_done = true;
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK;

  switch (this.mode) {
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW:
      this.err = $af68a4e46963dbc6080b158c600e7210$export$deflateSetDictionary(this.strm, this.dictionary);
      break;

    default:
      break;
  }

  if (this.err !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

$ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib.prototype._reset = function () {
  this.err = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK;

  switch (this.mode) {
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP:
      this.err = $af68a4e46963dbc6080b158c600e7210$export$deflateReset(this.strm);
      break;

    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW:
    case $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP:
      this.err = $84d49246177a6911a2519f7712dfd592$export$inflateReset(this.strm);
      break;

    default:
      break;
  }

  if (this.err !== $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

var $ac254f1082b0ce94146edfb9c2acdf2f$export$Zlib = $ac254f1082b0ce94146edfb9c2acdf2f$var$Zlib;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Zlib = $ac254f1082b0ce94146edfb9c2acdf2f$export$Zlib;
var $5051c00e87739024f780cb19cb94c308$var$util = $69678d3e0618202337016e1b4ed76965$init();
var $5051c00e87739024f780cb19cb94c308$var$assert = $034bb26d820f8530f21df3dfc0306a11$init().ok;
var $5051c00e87739024f780cb19cb94c308$var$kMaxLength = $4bb8553ea3f2a3c18bc67044f716b1cc$init().kMaxLength;
var $5051c00e87739024f780cb19cb94c308$var$kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + $5051c00e87739024f780cb19cb94c308$var$kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MIN_WINDOWBITS = 8;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MAX_WINDOWBITS = 15;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MIN_CHUNK = 64;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MAX_CHUNK = Infinity;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_CHUNK = 16 * 1024;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MIN_MEMLEVEL = 1;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MAX_MEMLEVEL = 9;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_MEMLEVEL = 8;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MIN_LEVEL = -1;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MAX_LEVEL = 9;
$ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_LEVEL = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DEFAULT_COMPRESSION; // expose all the zlib constants

// expose all the zlib constants
var $5051c00e87739024f780cb19cb94c308$var$bkeys = Object.keys($ac254f1082b0ce94146edfb9c2acdf2f$exports);

for (var $5051c00e87739024f780cb19cb94c308$var$bk = 0; $5051c00e87739024f780cb19cb94c308$var$bk < $5051c00e87739024f780cb19cb94c308$var$bkeys.length; $5051c00e87739024f780cb19cb94c308$var$bk++) {
  var $5051c00e87739024f780cb19cb94c308$var$bkey = $5051c00e87739024f780cb19cb94c308$var$bkeys[$5051c00e87739024f780cb19cb94c308$var$bk];

  if ($5051c00e87739024f780cb19cb94c308$var$bkey.match(/^Z/)) {
    Object.defineProperty($5051c00e87739024f780cb19cb94c308$exports, $5051c00e87739024f780cb19cb94c308$var$bkey, {
      enumerable: true,
      value: $ac254f1082b0ce94146edfb9c2acdf2f$exports[$5051c00e87739024f780cb19cb94c308$var$bkey],
      writable: false
    });
  }
} // translation table for return codes.


// translation table for return codes.
var $5051c00e87739024f780cb19cb94c308$var$codes = {
  Z_OK: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_OK,
  Z_STREAM_END: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_STREAM_END,
  Z_NEED_DICT: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NEED_DICT,
  Z_ERRNO: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_ERRNO,
  Z_STREAM_ERROR: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_STREAM_ERROR,
  Z_DATA_ERROR: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_DATA_ERROR,
  Z_MEM_ERROR: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_MEM_ERROR,
  Z_BUF_ERROR: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_BUF_ERROR,
  Z_VERSION_ERROR: $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_VERSION_ERROR
};
var $5051c00e87739024f780cb19cb94c308$var$ckeys = Object.keys($5051c00e87739024f780cb19cb94c308$var$codes);

for (var $5051c00e87739024f780cb19cb94c308$var$ck = 0; $5051c00e87739024f780cb19cb94c308$var$ck < $5051c00e87739024f780cb19cb94c308$var$ckeys.length; $5051c00e87739024f780cb19cb94c308$var$ck++) {
  var $5051c00e87739024f780cb19cb94c308$var$ckey = $5051c00e87739024f780cb19cb94c308$var$ckeys[$5051c00e87739024f780cb19cb94c308$var$ck];
  $5051c00e87739024f780cb19cb94c308$var$codes[$5051c00e87739024f780cb19cb94c308$var$codes[$5051c00e87739024f780cb19cb94c308$var$ckey]] = $5051c00e87739024f780cb19cb94c308$var$ckey;
}

Object.defineProperty($5051c00e87739024f780cb19cb94c308$exports, 'codes', {
  enumerable: true,
  value: Object.freeze($5051c00e87739024f780cb19cb94c308$var$codes),
  writable: false
});
var $5051c00e87739024f780cb19cb94c308$export$Deflate = $5051c00e87739024f780cb19cb94c308$var$Deflate;
$5051c00e87739024f780cb19cb94c308$exports.Deflate = $5051c00e87739024f780cb19cb94c308$export$Deflate;
var $5051c00e87739024f780cb19cb94c308$export$Inflate = $5051c00e87739024f780cb19cb94c308$var$Inflate;
$5051c00e87739024f780cb19cb94c308$exports.Inflate = $5051c00e87739024f780cb19cb94c308$export$Inflate;
var $5051c00e87739024f780cb19cb94c308$export$Gzip = $5051c00e87739024f780cb19cb94c308$var$Gzip;
$5051c00e87739024f780cb19cb94c308$exports.Gzip = $5051c00e87739024f780cb19cb94c308$export$Gzip;
var $5051c00e87739024f780cb19cb94c308$export$Gunzip = $5051c00e87739024f780cb19cb94c308$var$Gunzip;
$5051c00e87739024f780cb19cb94c308$exports.Gunzip = $5051c00e87739024f780cb19cb94c308$export$Gunzip;
var $5051c00e87739024f780cb19cb94c308$export$DeflateRaw = $5051c00e87739024f780cb19cb94c308$var$DeflateRaw;
$5051c00e87739024f780cb19cb94c308$exports.DeflateRaw = $5051c00e87739024f780cb19cb94c308$export$DeflateRaw;
var $5051c00e87739024f780cb19cb94c308$export$InflateRaw = $5051c00e87739024f780cb19cb94c308$var$InflateRaw;
$5051c00e87739024f780cb19cb94c308$exports.InflateRaw = $5051c00e87739024f780cb19cb94c308$export$InflateRaw;
var $5051c00e87739024f780cb19cb94c308$export$Unzip = $5051c00e87739024f780cb19cb94c308$var$Unzip;
$5051c00e87739024f780cb19cb94c308$exports.Unzip = $5051c00e87739024f780cb19cb94c308$export$Unzip;

var $5051c00e87739024f780cb19cb94c308$export$createDeflate = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$Deflate(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createDeflate = $5051c00e87739024f780cb19cb94c308$export$createDeflate;

var $5051c00e87739024f780cb19cb94c308$export$createInflate = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$Inflate(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createInflate = $5051c00e87739024f780cb19cb94c308$export$createInflate;

var $5051c00e87739024f780cb19cb94c308$export$createDeflateRaw = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$DeflateRaw(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createDeflateRaw = $5051c00e87739024f780cb19cb94c308$export$createDeflateRaw;

var $5051c00e87739024f780cb19cb94c308$export$createInflateRaw = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$InflateRaw(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createInflateRaw = $5051c00e87739024f780cb19cb94c308$export$createInflateRaw;

var $5051c00e87739024f780cb19cb94c308$export$createGzip = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$Gzip(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createGzip = $5051c00e87739024f780cb19cb94c308$export$createGzip;

var $5051c00e87739024f780cb19cb94c308$export$createGunzip = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$Gunzip(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createGunzip = $5051c00e87739024f780cb19cb94c308$export$createGunzip;

var $5051c00e87739024f780cb19cb94c308$export$createUnzip = function (o) {
  return new $5051c00e87739024f780cb19cb94c308$var$Unzip(o);
};

$5051c00e87739024f780cb19cb94c308$exports.createUnzip = $5051c00e87739024f780cb19cb94c308$export$createUnzip; // Convenience methods.
// compress/decompress a string or buffer in one step.

var $5051c00e87739024f780cb19cb94c308$export$deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$Deflate(opts), buffer, callback);
};

// Convenience methods.
// compress/decompress a string or buffer in one step.
$5051c00e87739024f780cb19cb94c308$exports.deflate = $5051c00e87739024f780cb19cb94c308$export$deflate;

var $5051c00e87739024f780cb19cb94c308$export$deflateSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$Deflate(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.deflateSync = $5051c00e87739024f780cb19cb94c308$export$deflateSync;

var $5051c00e87739024f780cb19cb94c308$export$gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$Gzip(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.gzip = $5051c00e87739024f780cb19cb94c308$export$gzip;

var $5051c00e87739024f780cb19cb94c308$export$gzipSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$Gzip(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.gzipSync = $5051c00e87739024f780cb19cb94c308$export$gzipSync;

var $5051c00e87739024f780cb19cb94c308$export$deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$DeflateRaw(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.deflateRaw = $5051c00e87739024f780cb19cb94c308$export$deflateRaw;

var $5051c00e87739024f780cb19cb94c308$export$deflateRawSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$DeflateRaw(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.deflateRawSync = $5051c00e87739024f780cb19cb94c308$export$deflateRawSync;

var $5051c00e87739024f780cb19cb94c308$export$unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$Unzip(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.unzip = $5051c00e87739024f780cb19cb94c308$export$unzip;

var $5051c00e87739024f780cb19cb94c308$export$unzipSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$Unzip(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.unzipSync = $5051c00e87739024f780cb19cb94c308$export$unzipSync;

var $5051c00e87739024f780cb19cb94c308$export$inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$Inflate(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.inflate = $5051c00e87739024f780cb19cb94c308$export$inflate;

var $5051c00e87739024f780cb19cb94c308$export$inflateSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$Inflate(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.inflateSync = $5051c00e87739024f780cb19cb94c308$export$inflateSync;

var $5051c00e87739024f780cb19cb94c308$export$gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$Gunzip(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.gunzip = $5051c00e87739024f780cb19cb94c308$export$gunzip;

var $5051c00e87739024f780cb19cb94c308$export$gunzipSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$Gunzip(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.gunzipSync = $5051c00e87739024f780cb19cb94c308$export$gunzipSync;

var $5051c00e87739024f780cb19cb94c308$export$inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(new $5051c00e87739024f780cb19cb94c308$var$InflateRaw(opts), buffer, callback);
};

$5051c00e87739024f780cb19cb94c308$exports.inflateRaw = $5051c00e87739024f780cb19cb94c308$export$inflateRaw;

var $5051c00e87739024f780cb19cb94c308$export$inflateRawSync = function (buffer, opts) {
  return $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(new $5051c00e87739024f780cb19cb94c308$var$InflateRaw(opts), buffer);
};

$5051c00e87739024f780cb19cb94c308$exports.inflateRawSync = $5051c00e87739024f780cb19cb94c308$export$inflateRawSync;

function $5051c00e87739024f780cb19cb94c308$var$zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();

  function flow() {
    var chunk;

    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }

    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= $5051c00e87739024f780cb19cb94c308$var$kMaxLength) {
      err = new RangeError($5051c00e87739024f780cb19cb94c308$var$kRangeErrorMessage);
    } else {
      buf = $5051c00e87739024f780cb19cb94c308$var$Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function $5051c00e87739024f780cb19cb94c308$var$zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = $5051c00e87739024f780cb19cb94c308$var$Buffer.from(buffer);
  if (!$5051c00e87739024f780cb19cb94c308$var$Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
  var flushFlag = engine._finishFlushFlag;
  return engine._processChunk(buffer, flushFlag);
} // generic zlib
// minimal 2-byte header


// generic zlib
// minimal 2-byte header
function $5051c00e87739024f780cb19cb94c308$var$Deflate(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$Deflate)) return new $5051c00e87739024f780cb19cb94c308$var$Deflate(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATE);
}

function $5051c00e87739024f780cb19cb94c308$var$Inflate(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$Inflate)) return new $5051c00e87739024f780cb19cb94c308$var$Inflate(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATE);
} // gzip - bigger header, same deflate compression


// gzip - bigger header, same deflate compression
function $5051c00e87739024f780cb19cb94c308$var$Gzip(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$Gzip)) return new $5051c00e87739024f780cb19cb94c308$var$Gzip(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.GZIP);
}

function $5051c00e87739024f780cb19cb94c308$var$Gunzip(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$Gunzip)) return new $5051c00e87739024f780cb19cb94c308$var$Gunzip(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.GUNZIP);
} // raw - no header


// raw - no header
function $5051c00e87739024f780cb19cb94c308$var$DeflateRaw(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$DeflateRaw)) return new $5051c00e87739024f780cb19cb94c308$var$DeflateRaw(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.DEFLATERAW);
}

function $5051c00e87739024f780cb19cb94c308$var$InflateRaw(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$InflateRaw)) return new $5051c00e87739024f780cb19cb94c308$var$InflateRaw(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.INFLATERAW);
} // auto-detect header.


// auto-detect header.
function $5051c00e87739024f780cb19cb94c308$var$Unzip(opts) {
  if (!(this instanceof $5051c00e87739024f780cb19cb94c308$var$Unzip)) return new $5051c00e87739024f780cb19cb94c308$var$Unzip(opts);
  $5051c00e87739024f780cb19cb94c308$var$Zlib.call(this, opts, $ac254f1082b0ce94146edfb9c2acdf2f$exports.UNZIP);
}

function $5051c00e87739024f780cb19cb94c308$var$isValidFlushFlag(flag) {
  return flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NO_FLUSH || flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_PARTIAL_FLUSH || flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_SYNC_FLUSH || flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FULL_FLUSH || flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FINISH || flag === $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_BLOCK;
} // the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
function $5051c00e87739024f780cb19cb94c308$var$Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_CHUNK;
  $5051c00e87739024f780cb19cb94c308$var$Transform.call(this, opts);

  if (opts.flush && !$5051c00e87739024f780cb19cb94c308$var$isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }

  if (opts.finishFlush && !$5051c00e87739024f780cb19cb94c308$var$isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < $5051c00e87739024f780cb19cb94c308$exports.Z_MIN_CHUNK || opts.chunkSize > $5051c00e87739024f780cb19cb94c308$exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < $5051c00e87739024f780cb19cb94c308$exports.Z_MIN_WINDOWBITS || opts.windowBits > $5051c00e87739024f780cb19cb94c308$exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < $5051c00e87739024f780cb19cb94c308$exports.Z_MIN_LEVEL || opts.level > $5051c00e87739024f780cb19cb94c308$exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < $5051c00e87739024f780cb19cb94c308$exports.Z_MIN_MEMLEVEL || opts.memLevel > $5051c00e87739024f780cb19cb94c308$exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_FILTERED && opts.strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_HUFFMAN_ONLY && opts.strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_RLE && opts.strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_FIXED && opts.strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!$5051c00e87739024f780cb19cb94c308$var$Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new $ac254f1082b0ce94146edfb9c2acdf2f$exports.Zlib(mode);
  var self = this;
  this._hadError = false;

  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    $5051c00e87739024f780cb19cb94c308$var$_close(self);
    self._hadError = true;
    var error = new Error(message);
    error.errno = errno;
    error.code = $5051c00e87739024f780cb19cb94c308$exports.codes[errno];
    self.emit('error', error);
  };

  var level = $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;
  var strategy = $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = $5051c00e87739024f780cb19cb94c308$var$Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;
  this.once('end', this.close);
  Object.defineProperty(this, '_closed', {
    get: function () {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Zlib, $5051c00e87739024f780cb19cb94c308$var$Transform);

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype.params = function (level, strategy, callback) {
  if (level < $5051c00e87739024f780cb19cb94c308$exports.Z_MIN_LEVEL || level > $5051c00e87739024f780cb19cb94c308$exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }

  if (strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_FILTERED && strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_HUFFMAN_ONLY && strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_RLE && strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_FIXED && strategy != $5051c00e87739024f780cb19cb94c308$exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush($ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_SYNC_FLUSH, function () {
      $5051c00e87739024f780cb19cb94c308$var$assert(self._handle, 'zlib binding closed');

      self._handle.params(level, strategy);

      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    $5051c00e87739024f780cb19cb94c308$var$process.nextTick(callback);
  }
};

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype.reset = function () {
  $5051c00e87739024f780cb19cb94c308$var$assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
}; // This is the _flush function called by the transform class,
// internally, when the last chunk has been written.


// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype._flush = function (callback) {
  this._transform($5051c00e87739024f780cb19cb94c308$var$Buffer.alloc(0), '', callback);
};

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) $5051c00e87739024f780cb19cb94c308$var$process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write($5051c00e87739024f780cb19cb94c308$var$Buffer.alloc(0), '', callback);
  }
};

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype.close = function (callback) {
  $5051c00e87739024f780cb19cb94c308$var$_close(this, callback);
  $5051c00e87739024f780cb19cb94c308$var$process.nextTick($5051c00e87739024f780cb19cb94c308$var$emitCloseNT, this);
};

function $5051c00e87739024f780cb19cb94c308$var$_close(engine, callback) {
  if (callback) $5051c00e87739024f780cb19cb94c308$var$process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) return;

  engine._handle.close();

  engine._handle = null;
}

function $5051c00e87739024f780cb19cb94c308$var$emitCloseNT(self) {
  self.emit('close');
}

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);
  if (chunk !== null && !$5051c00e87739024f780cb19cb94c308$var$Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));
  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.

    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || $ac254f1082b0ce94146edfb9c2acdf2f$exports.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

$5051c00e87739024f780cb19cb94c308$var$Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;
  var self = this;
  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;
    var error;
    this.on('error', function (er) {
      error = er;
    });
    $5051c00e87739024f780cb19cb94c308$var$assert(this._handle, 'zlib binding closed');

    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len

    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= $5051c00e87739024f780cb19cb94c308$var$kMaxLength) {
      $5051c00e87739024f780cb19cb94c308$var$_close(this);
      throw new RangeError($5051c00e87739024f780cb19cb94c308$var$kRangeErrorMessage);
    }

    var buf = $5051c00e87739024f780cb19cb94c308$var$Buffer.concat(buffers, nread);
    $5051c00e87739024f780cb19cb94c308$var$_close(this);
    return buf;
  }

  $5051c00e87739024f780cb19cb94c308$var$assert(this._handle, 'zlib binding closed');

  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len


  // out_len
  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;
    var have = availOutBefore - availOutAfter;
    $5051c00e87739024f780cb19cb94c308$var$assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);

      self._offset += have; // serve some output to the consumer.

      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    } // exhausted the output buffer, or used all the input create a new one.


    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = $5051c00e87739024f780cb19cb94c308$var$Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;
      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);

      newReq.callback = callback; // this same function

      // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async) return false; // finished with the chunk.

    // finished with the chunk.
    cb();
  }
};

$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Deflate, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Inflate, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Gzip, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Gunzip, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$DeflateRaw, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$InflateRaw, $5051c00e87739024f780cb19cb94c308$var$Zlib);
$5051c00e87739024f780cb19cb94c308$var$util.inherits($5051c00e87739024f780cb19cb94c308$var$Unzip, $5051c00e87739024f780cb19cb94c308$var$Zlib);
const $96dc529002d169e2098dfb4902acf701$var$zlib_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($5051c00e87739024f780cb19cb94c308$exports);
// ASSET: node_modules/@yarnpkg/fslib/lib/algorithms/watchFile.js
var $75399b2ee6b8925a853aad4408c7e400$exports = {};
Object.defineProperty($75399b2ee6b8925a853aad4408c7e400$exports, "__esModule", {
  value: true
});
var $75399b2ee6b8925a853aad4408c7e400$export$unwatchAllFiles = ($75399b2ee6b8925a853aad4408c7e400$export$unwatchFile = ($75399b2ee6b8925a853aad4408c7e400$export$watchFile = void 0, $75399b2ee6b8925a853aad4408c7e400$exports.watchFile = $75399b2ee6b8925a853aad4408c7e400$export$watchFile), $75399b2ee6b8925a853aad4408c7e400$exports.unwatchFile = $75399b2ee6b8925a853aad4408c7e400$export$unwatchFile);
$75399b2ee6b8925a853aad4408c7e400$exports.unwatchAllFiles = $75399b2ee6b8925a853aad4408c7e400$export$unwatchAllFiles;
// ASSET: node_modules/@yarnpkg/fslib/lib/algorithms/watchFile/CustomStatWatcher.js
var $9aad6e7feda16c1c965cc1338532a368$export$Event,
    $9aad6e7feda16c1c965cc1338532a368$export$Status,
    $9aad6e7feda16c1c965cc1338532a368$exports = {};
Object.defineProperty($9aad6e7feda16c1c965cc1338532a368$exports, "__esModule", {
  value: true
});
var $9aad6e7feda16c1c965cc1338532a368$export$CustomStatWatcher = ($9aad6e7feda16c1c965cc1338532a368$export$assertStatus = ($9aad6e7feda16c1c965cc1338532a368$export$Status = ($9aad6e7feda16c1c965cc1338532a368$export$Event = void 0, $9aad6e7feda16c1c965cc1338532a368$exports.Event = $9aad6e7feda16c1c965cc1338532a368$export$Event), $9aad6e7feda16c1c965cc1338532a368$exports.Status = $9aad6e7feda16c1c965cc1338532a368$export$Status), $9aad6e7feda16c1c965cc1338532a368$exports.assertStatus = $9aad6e7feda16c1c965cc1338532a368$export$assertStatus);
$9aad6e7feda16c1c965cc1338532a368$exports.CustomStatWatcher = $9aad6e7feda16c1c965cc1338532a368$export$CustomStatWatcher;
const $9aad6e7feda16c1c965cc1338532a368$var$statUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($0be3cf17f95cc3f98aedc294fb6f7f45$exports);
var $9aad6e7feda16c1c965cc1338532a368$var$Event;

(function (Event) {
  Event["Change"] = "change";
  Event["Stop"] = "stop";
})($9aad6e7feda16c1c965cc1338532a368$var$Event = $9aad6e7feda16c1c965cc1338532a368$exports.Event || ($9aad6e7feda16c1c965cc1338532a368$export$Event = {}, $9aad6e7feda16c1c965cc1338532a368$exports.Event = $9aad6e7feda16c1c965cc1338532a368$export$Event));

var $9aad6e7feda16c1c965cc1338532a368$var$Status;

(function (Status) {
  Status["Ready"] = "ready";
  Status["Running"] = "running";
  Status["Stopped"] = "stopped";
})($9aad6e7feda16c1c965cc1338532a368$var$Status = $9aad6e7feda16c1c965cc1338532a368$exports.Status || ($9aad6e7feda16c1c965cc1338532a368$export$Status = {}, $9aad6e7feda16c1c965cc1338532a368$exports.Status = $9aad6e7feda16c1c965cc1338532a368$export$Status));

function $9aad6e7feda16c1c965cc1338532a368$var$assertStatus(current, expected) {
  if (current !== expected) {
    throw new Error(`Invalid StatWatcher status: expected '${expected}', got '${current}'`);
  }
}

var $9aad6e7feda16c1c965cc1338532a368$export$assertStatus = $9aad6e7feda16c1c965cc1338532a368$var$assertStatus;
$9aad6e7feda16c1c965cc1338532a368$exports.assertStatus = $9aad6e7feda16c1c965cc1338532a368$export$assertStatus;

class $9aad6e7feda16c1c965cc1338532a368$var$CustomStatWatcher extends $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter {
  constructor(fakeFs, path, {
    bigint = false
  } = {}) {
    super();
    this.status = $9aad6e7feda16c1c965cc1338532a368$var$Status.Ready;
    this.changeListeners = new Map();
    this.startTimeout = null;
    this.fakeFs = fakeFs;
    this.path = path;
    this.bigint = bigint;
    this.lastStats = this.stat();
  }

  static create(fakeFs, path, opts) {
    const statWatcher = new $9aad6e7feda16c1c965cc1338532a368$var$CustomStatWatcher(fakeFs, path, opts);
    statWatcher.start();
    return statWatcher;
  }

  start() {
    $9aad6e7feda16c1c965cc1338532a368$var$assertStatus(this.status, $9aad6e7feda16c1c965cc1338532a368$var$Status.Ready);
    this.status = $9aad6e7feda16c1c965cc1338532a368$var$Status.Running; // Node allows other listeners to be registered up to 3 milliseconds
    // after the watcher has been started, so that's what we're doing too

    // Node allows other listeners to be registered up to 3 milliseconds
    // after the watcher has been started, so that's what we're doing too
    this.startTimeout = setTimeout(() => {
      this.startTimeout = null; // Per the Node FS docs:
      // "When an fs.watchFile operation results in an ENOENT error,
      // it will invoke the listener once, with all the fields zeroed
      // (or, for dates, the Unix Epoch)."

      // Per the Node FS docs:
      // "When an fs.watchFile operation results in an ENOENT error,
      // it will invoke the listener once, with all the fields zeroed
      // (or, for dates, the Unix Epoch)."
      if (!this.fakeFs.existsSync(this.path)) {
        this.emit($9aad6e7feda16c1c965cc1338532a368$var$Event.Change, this.lastStats, this.lastStats);
      }
    }, 3);
  }

  stop() {
    $9aad6e7feda16c1c965cc1338532a368$var$assertStatus(this.status, $9aad6e7feda16c1c965cc1338532a368$var$Status.Running);
    this.status = $9aad6e7feda16c1c965cc1338532a368$var$Status.Stopped;

    if (this.startTimeout !== null) {
      clearTimeout(this.startTimeout);
      this.startTimeout = null;
    }

    this.emit($9aad6e7feda16c1c965cc1338532a368$var$Event.Stop);
  }

  stat() {
    try {
      return this.fakeFs.statSync(this.path);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return $9aad6e7feda16c1c965cc1338532a368$var$statUtils.makeEmptyStats();
      } else {
        throw error;
      }
    }
  }
  /**
   * Creates an interval whose callback compares the current stats with the previous stats and notifies all listeners in case of changes.
   *
   * @param opts.persistent Decides whether the interval should be immediately unref-ed.
   */


  /**
   * Creates an interval whose callback compares the current stats with the previous stats and notifies all listeners in case of changes.
   *
   * @param opts.persistent Decides whether the interval should be immediately unref-ed.
   */
  makeInterval(opts) {
    const interval = setInterval(() => {
      const currentStats = this.stat();
      const previousStats = this.lastStats;
      if ($9aad6e7feda16c1c965cc1338532a368$var$statUtils.areStatsEqual(currentStats, previousStats)) return;
      this.lastStats = currentStats;
      this.emit($9aad6e7feda16c1c965cc1338532a368$var$Event.Change, currentStats, previousStats);
    }, opts.interval);
    return opts.persistent ? interval : interval.unref();
  }
  /**
   * Registers a listener and assigns it an interval.
   */


  /**
   * Registers a listener and assigns it an interval.
   */
  registerChangeListener(listener, opts) {
    this.addListener($9aad6e7feda16c1c965cc1338532a368$var$Event.Change, listener);
    this.changeListeners.set(listener, this.makeInterval(opts));
  }
  /**
   * Unregisters the listener and clears the assigned interval.
   */


  /**
   * Unregisters the listener and clears the assigned interval.
   */
  unregisterChangeListener(listener) {
    this.removeListener($9aad6e7feda16c1c965cc1338532a368$var$Event.Change, listener);
    const interval = this.changeListeners.get(listener);
    if (typeof interval !== `undefined`) clearInterval(interval);
    this.changeListeners.delete(listener);
  }
  /**
   * Unregisters all listeners and clears all assigned intervals.
   */


  /**
   * Unregisters all listeners and clears all assigned intervals.
   */
  unregisterAllChangeListeners() {
    for (const listener of this.changeListeners.keys()) {
      this.unregisterChangeListener(listener);
    }
  }

  hasChangeListeners() {
    return this.changeListeners.size > 0;
  }
  /**
   * Refs all stored intervals.
   */


  /**
   * Refs all stored intervals.
   */
  ref() {
    for (const interval of this.changeListeners.values()) interval.ref();

    return this;
  }
  /**
   * Unrefs all stored intervals.
   */


  /**
   * Unrefs all stored intervals.
   */
  unref() {
    for (const interval of this.changeListeners.values()) interval.unref();

    return this;
  }

}

$9aad6e7feda16c1c965cc1338532a368$export$CustomStatWatcher = $9aad6e7feda16c1c965cc1338532a368$var$CustomStatWatcher;
$9aad6e7feda16c1c965cc1338532a368$exports.CustomStatWatcher = $9aad6e7feda16c1c965cc1338532a368$export$CustomStatWatcher;
const $75399b2ee6b8925a853aad4408c7e400$var$statWatchersByFakeFS = new WeakMap();

function $75399b2ee6b8925a853aad4408c7e400$var$watchFile(fakeFs, path, a, b) {
  let bigint;
  let persistent;
  let interval;
  let listener;

  switch (typeof a) {
    case `function`:
      {
        bigint = false;
        persistent = true;
        interval = 5007;
        listener = a;
      }
      break;

    default:
      {
        ({
          bigint = false,
          persistent = true,
          interval = 5007
        } = a);
        listener = b;
      }
      break;
  }

  let statWatchers = $75399b2ee6b8925a853aad4408c7e400$var$statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) $75399b2ee6b8925a853aad4408c7e400$var$statWatchersByFakeFS.set(fakeFs, statWatchers = new Map());
  let statWatcher = statWatchers.get(path);

  if (typeof statWatcher === `undefined`) {
    statWatcher = $9aad6e7feda16c1c965cc1338532a368$exports.CustomStatWatcher.create(fakeFs, path, {
      bigint
    });
    statWatchers.set(path, statWatcher);
  }

  statWatcher.registerChangeListener(listener, {
    persistent,
    interval
  });
  return statWatcher;
}

var $75399b2ee6b8925a853aad4408c7e400$export$watchFile = $75399b2ee6b8925a853aad4408c7e400$var$watchFile;
$75399b2ee6b8925a853aad4408c7e400$exports.watchFile = $75399b2ee6b8925a853aad4408c7e400$export$watchFile;

function $75399b2ee6b8925a853aad4408c7e400$var$unwatchFile(fakeFs, path, cb) {
  const statWatchers = $75399b2ee6b8925a853aad4408c7e400$var$statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) return;
  const statWatcher = statWatchers.get(path);
  if (typeof statWatcher === `undefined`) return;
  if (typeof cb === `undefined`) statWatcher.unregisterAllChangeListeners();else statWatcher.unregisterChangeListener(cb);

  if (!statWatcher.hasChangeListeners()) {
    statWatcher.stop();
    statWatchers.delete(path);
  }
}

var $75399b2ee6b8925a853aad4408c7e400$export$unwatchFile = $75399b2ee6b8925a853aad4408c7e400$var$unwatchFile;
$75399b2ee6b8925a853aad4408c7e400$exports.unwatchFile = $75399b2ee6b8925a853aad4408c7e400$export$unwatchFile;

function $75399b2ee6b8925a853aad4408c7e400$var$unwatchAllFiles(fakeFs) {
  const statWatchers = $75399b2ee6b8925a853aad4408c7e400$var$statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) return;

  for (const path of statWatchers.keys()) {
    $75399b2ee6b8925a853aad4408c7e400$var$unwatchFile(fakeFs, path);
  }
}

$75399b2ee6b8925a853aad4408c7e400$export$unwatchAllFiles = $75399b2ee6b8925a853aad4408c7e400$var$unwatchAllFiles;
$75399b2ee6b8925a853aad4408c7e400$exports.unwatchAllFiles = $75399b2ee6b8925a853aad4408c7e400$export$unwatchAllFiles;
const $96dc529002d169e2098dfb4902acf701$var$errors = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($e48497dbe7c3225ab014a812e5154d30$exports);
const $96dc529002d169e2098dfb4902acf701$var$statUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($0be3cf17f95cc3f98aedc294fb6f7f45$exports);
var $96dc529002d169e2098dfb4902acf701$export$DEFAULT_COMPRESSION_LEVEL = `mixed`;
$96dc529002d169e2098dfb4902acf701$exports.DEFAULT_COMPRESSION_LEVEL = $96dc529002d169e2098dfb4902acf701$export$DEFAULT_COMPRESSION_LEVEL;

function $96dc529002d169e2098dfb4902acf701$var$toUnixTimestamp(time) {
  if (typeof time === `string` && String(+time) === time) return +time;

  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    } else {
      return time;
    }
  } // convert to 123.456 UNIX timestamp


  // convert to 123.456 UNIX timestamp
  if ($96dc529002d169e2098dfb4902acf701$var$util_1.isDate(time)) return time.getTime() / 1000;
  throw new Error(`Invalid time`);
}

class $96dc529002d169e2098dfb4902acf701$var$ZipFS extends $3d7a702246aa4634d36ede659b8d4727$exports.BasePortableFakeFS {
  constructor(source, opts) {
    super();
    this.lzSource = null;
    this.listings = new Map();
    this.entries = new Map();
    /**
     * A cache of indices mapped to file sources.
     * Populated by `setFileSource` calls.
     * Required for supporting read after write.
     */

    /**
     * A cache of indices mapped to file sources.
     * Populated by `setFileSource` calls.
     * Required for supporting read after write.
     */
    this.fileSources = new Map();
    this.fds = new Map();
    this.nextFd = 0;
    this.ready = false;
    this.readOnly = false;
    this.libzip = opts.libzip;
    const pathOptions = opts;
    this.level = typeof pathOptions.level !== `undefined` ? pathOptions.level : $96dc529002d169e2098dfb4902acf701$exports.DEFAULT_COMPRESSION_LEVEL;

    if (source === null) {
      source = $96dc529002d169e2098dfb4902acf701$var$Buffer.from([0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    }

    if (typeof source === `string`) {
      const {
        baseFs = new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS()
      } = pathOptions;
      this.baseFs = baseFs;
      this.path = source;
    } else {
      this.path = null;
      this.baseFs = null;
    }

    if (opts.stats) {
      this.stats = opts.stats;
    } else {
      if (typeof source === `string`) {
        try {
          this.stats = this.baseFs.statSync(source);
        } catch (error) {
          if (error.code === `ENOENT` && pathOptions.create) {
            this.stats = $96dc529002d169e2098dfb4902acf701$var$statUtils.makeDefaultStats();
          } else {
            throw error;
          }
        }
      } else {
        this.stats = $96dc529002d169e2098dfb4902acf701$var$statUtils.makeDefaultStats();
      }
    }

    const errPtr = this.libzip.malloc(4);

    try {
      let flags = 0;
      if (typeof source === `string` && pathOptions.create) flags |= this.libzip.ZIP_CREATE | this.libzip.ZIP_TRUNCATE;

      if (opts.readOnly) {
        flags |= this.libzip.ZIP_RDONLY;
        this.readOnly = true;
      }

      if (typeof source === `string`) {
        this.zip = this.libzip.open($68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(source), flags, errPtr);
      } else {
        const lzSource = this.allocateUnattachedSource(source);

        try {
          this.zip = this.libzip.openFromSource(lzSource, flags, errPtr);
          this.lzSource = lzSource;
        } catch (error) {
          this.libzip.source.free(lzSource);
          throw error;
        }
      }

      if (this.zip === 0) {
        const error = this.libzip.struct.errorS();
        this.libzip.error.initWithCode(error, this.libzip.getValue(errPtr, `i32`));
        throw this.makeLibzipError(error);
      }
    } finally {
      this.libzip.free(errPtr);
    }

    this.listings.set($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, new Set());
    const entryCount = this.libzip.getNumEntries(this.zip, 0);

    for (let t = 0; t < entryCount; ++t) {
      const raw = this.libzip.getName(this.zip, t, 0);
      if ($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.isAbsolute(raw)) continue;
      const p = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, raw);
      this.registerEntry(p, t); // If the raw path is a directory, register it
      // to prevent empty folder being skipped

      // If the raw path is a directory, register it
      // to prevent empty folder being skipped
      if (raw.endsWith(`/`)) {
        this.registerListing(p);
      }
    }

    this.symlinkCount = this.libzip.ext.countSymlinks(this.zip);
    if (this.symlinkCount === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.ready = true;
  }

  makeLibzipError(error) {
    const errorCode = this.libzip.struct.errorCodeZip(error);
    const strerror = this.libzip.error.strerror(error);
    const libzipError = new $96dc529002d169e2098dfb4902acf701$var$errors.LibzipError(strerror, this.libzip.errors[errorCode]); // This error should never come up because of the file source cache

    // This error should never come up because of the file source cache
    if (errorCode === this.libzip.errors.ZIP_ER_CHANGED) throw new Error(`Assertion failed: Unexpected libzip error: ${libzipError.message}`);
    return libzipError;
  }

  getExtractHint(hints) {
    for (const fileName of this.entries.keys()) {
      const ext = this.pathUtils.extname(fileName);

      if (hints.relevantExtensions.has(ext)) {
        return true;
      }
    }

    return false;
  }

  getAllFiles() {
    return Array.from(this.entries.keys());
  }

  getRealPath() {
    if (!this.path) throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
    return this.path;
  }

  getBufferAndClose() {
    this.prepareClose();
    if (!this.lzSource) throw new Error(`ZipFS was not created from a Buffer`);

    try {
      // Prevent close from cleaning up the source
      this.libzip.source.keep(this.lzSource); // Close the zip archive

      // Close the zip archive
      if (this.libzip.close(this.zip) === -1) throw this.makeLibzipError(this.libzip.getError(this.zip)); // Open the source for reading

      // Open the source for reading
      if (this.libzip.source.open(this.lzSource) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Move to the end of source

      // Move to the end of source
      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_END) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Get the size of source

      // Get the size of source
      const size = this.libzip.source.tell(this.lzSource);
      if (size === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Move to the start of source

      // Move to the start of source
      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_SET) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
      const buffer = this.libzip.malloc(size);
      if (!buffer) throw new Error(`Couldn't allocate enough memory`);

      try {
        const rc = this.libzip.source.read(this.lzSource, buffer, size);
        if (rc === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        return $96dc529002d169e2098dfb4902acf701$var$Buffer.from(memory);
      } finally {
        this.libzip.free(buffer);
      }
    } finally {
      this.libzip.source.close(this.lzSource);
      this.libzip.source.free(this.lzSource);
      this.ready = false;
    }
  }

  prepareClose() {
    if (!this.ready) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBUSY(`archive closed, close`);
    $75399b2ee6b8925a853aad4408c7e400$exports.unwatchAllFiles(this);
  }

  saveAndClose() {
    if (!this.path || !this.baseFs) throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
    this.prepareClose();

    if (this.readOnly) {
      this.discardAndClose();
      return;
    }

    const previousMod = this.baseFs.existsSync(this.path) ? this.baseFs.statSync(this.path).mode & 0o777 : null;
    const rc = this.libzip.close(this.zip);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip)); // this.libzip overrides the chmod when writing the archive, which is a weird
    // behavior I don't totally understand (plus the umask seems bogus in some
    // weird cases - maybe related to emscripten?)
    //
    // See also https://github.com/nih-at/libzip/issues/77

    // this.libzip overrides the chmod when writing the archive, which is a weird
    // behavior I don't totally understand (plus the umask seems bogus in some
    // weird cases - maybe related to emscripten?)
    //
    // See also https://github.com/nih-at/libzip/issues/77
    if (previousMod === null) this.baseFs.chmodSync(this.path, this.stats.mode);else if (previousMod !== (this.baseFs.statSync(this.path).mode & 0o777)) this.baseFs.chmodSync(this.path, previousMod);
    this.ready = false;
  }

  discardAndClose() {
    this.prepareClose();
    this.libzip.discard(this.zip);
    this.ready = false;
  }

  resolve(p) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, p);
  }

  async openPromise(p, flags, mode) {
    return this.openSync(p, flags, mode);
  }

  openSync(p, flags, mode) {
    const fd = this.nextFd++;
    this.fds.set(fd, {
      cursor: 0,
      p
    });
    return fd;
  }

  hasOpenFileHandles() {
    return !!this.fds.size;
  }

  async opendirPromise(p, opts) {
    return this.opendirSync(p, opts);
  }

  opendirSync(p, opts = {}) {
    const resolvedP = this.resolveFilename(`opendir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`opendir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`opendir '${p}'`);
    const entries = [...directoryListing];
    const fd = this.openSync(resolvedP, `r`);

    const onClose = () => {
      this.closeSync(fd);
    };

    return $8a2b416ad49313b6a58ccb22c63fdf6d$exports.opendir(this, resolvedP, entries, {
      onClose
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    return this.readSync(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset = 0, length = 0, position = -1) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBADF(`read`);
    let realPosition;
    if (position === -1 || position === null) realPosition = entry.cursor;else realPosition = position;
    const source = this.readFileSync(entry.p);
    source.copy(buffer, offset, realPosition, realPosition + length);
    const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
    if (position === -1 || position === null) entry.cursor += bytesRead;
    return bytesRead;
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.writeSync(fd, buffer, position);
    } else {
      return this.writeSync(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBADF(`read`);
    throw new Error(`Unimplemented`);
  }

  async closePromise(fd) {
    return this.closeSync(fd);
  }

  closeSync(fd) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBADF(`read`);
    this.fds.delete(fd);
  }

  createReadStream(p, {
    encoding
  } = {}) {
    if (p === null) throw new Error(`Unimplemented`);
    const fd = this.openSync(p, `r`);
    const stream = Object.assign(new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough({
      emitClose: true,
      autoDestroy: true,
      destroy: (error, callback) => {
        clearImmediate(immediate);
        this.closeSync(fd);
        callback(error);
      }
    }), {
      close() {
        stream.destroy();
      },

      bytesRead: 0,
      path: p
    });
    const immediate = setImmediate(async () => {
      try {
        const data = await this.readFilePromise(p, encoding);
        stream.bytesRead = data.length;
        stream.end(data);
      } catch (error) {
        stream.destroy(error);
      }
    });
    return stream;
  }

  createWriteStream(p, {
    encoding
  } = {}) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`open '${p}'`);
    if (p === null) throw new Error(`Unimplemented`);
    const chunks = [];
    const fd = this.openSync(p, `w`);
    const stream = Object.assign(new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough({
      autoDestroy: true,
      emitClose: true,
      destroy: (error, callback) => {
        try {
          if (error) {
            callback(error);
          } else {
            this.writeFileSync(p, $96dc529002d169e2098dfb4902acf701$var$Buffer.concat(chunks), encoding);
            callback(null);
          }
        } catch (err) {
          callback(err);
        } finally {
          this.closeSync(fd);
        }
      }
    }), {
      bytesWritten: 0,
      path: p,

      close() {
        stream.destroy();
      }

    });
    stream.on(`data`, chunk => {
      const chunkBuffer = $96dc529002d169e2098dfb4902acf701$var$Buffer.from(chunk);
      stream.bytesWritten += chunkBuffer.length;
      chunks.push(chunkBuffer);
    });
    return stream;
  }

  async realpathPromise(p) {
    return this.realpathSync(p);
  }

  realpathSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`lstat '${p}'`);
    return resolvedP;
  }

  async existsPromise(p) {
    return this.existsSync(p);
  }

  existsSync(p) {
    if (!this.ready) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBUSY(`archive closed, existsSync '${p}'`);

    if (this.symlinkCount === 0) {
      const resolvedP = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, p);
      return this.entries.has(resolvedP) || this.listings.has(resolvedP);
    }

    let resolvedP;

    try {
      resolvedP = this.resolveFilename(`stat '${p}'`, p);
    } catch (error) {
      return false;
    }

    return this.entries.has(resolvedP) || this.listings.has(resolvedP);
  }

  async accessPromise(p, mode) {
    return this.accessSync(p, mode);
  }

  accessSync(p, mode = $96dc529002d169e2098dfb4902acf701$var$fs_1.constants.F_OK) {
    const resolvedP = this.resolveFilename(`access '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`access '${p}'`);

    if (this.readOnly && mode & $96dc529002d169e2098dfb4902acf701$var$fs_1.constants.W_OK) {
      throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`access '${p}'`);
    }
  }

  async statPromise(p) {
    return this.statSync(p);
  }

  statSync(p) {
    const resolvedP = this.resolveFilename(`stat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`stat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`stat '${p}'`);
    return this.statImpl(`stat '${p}'`, resolvedP);
  }

  async lstatPromise(p) {
    return this.lstatSync(p);
  }

  lstatSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`lstat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`lstat '${p}'`);
    return this.statImpl(`lstat '${p}'`, resolvedP);
  }

  statImpl(reason, p) {
    const entry = this.entries.get(p); // File, or explicit directory

    // File, or explicit directory
    if (typeof entry !== `undefined`) {
      const stat = this.libzip.struct.statS();
      const rc = this.libzip.statIndex(this.zip, entry, 0, 0, stat);
      if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = this.libzip.struct.statSize(stat) >>> 0;
      const blksize = 512;
      const blocks = Math.ceil(size / blksize);
      const mtimeMs = (this.libzip.struct.statMtime(stat) >>> 0) * 1000;
      const atimeMs = mtimeMs;
      const birthtimeMs = mtimeMs;
      const ctimeMs = mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const type = this.listings.has(p) ? $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR : this.isSymbolicLink(entry) ? $7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK : $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG;
      const defaultMode = type === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR ? 0o755 : 0o644;
      const mode = type | this.getUnixMode(entry, defaultMode) & 0o777;
      return Object.assign(new $96dc529002d169e2098dfb4902acf701$var$statUtils.StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    } // Implicit directory


    // Implicit directory
    if (this.listings.has(p)) {
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = 0;
      const blksize = 512;
      const blocks = 0;
      const atimeMs = this.stats.mtimeMs;
      const birthtimeMs = this.stats.mtimeMs;
      const ctimeMs = this.stats.mtimeMs;
      const mtimeMs = this.stats.mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const mode = $7fb32670047e8d9f167a62d4977192ea$exports.S_IFDIR | 0o755;
      return Object.assign(new $96dc529002d169e2098dfb4902acf701$var$statUtils.StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    }

    throw new Error(`Unreachable`);
  }

  getUnixMode(index, defaultMode) {
    const rc = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return defaultMode;
    return this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
  }

  registerListing(p) {
    let listing = this.listings.get(p);
    if (listing) return listing;
    const parentListing = this.registerListing($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(p));
    listing = new Set();
    parentListing.add($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(p));
    this.listings.set(p, listing);
    return listing;
  }

  registerEntry(p, index) {
    const parentListing = this.registerListing($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(p));
    parentListing.add($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(p));
    this.entries.set(p, index);
  }

  unregisterListing(p) {
    this.listings.delete(p);
    const parentListing = this.listings.get($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(p));
    parentListing === null || parentListing === void 0 ? void 0 : parentListing.delete($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(p));
  }

  unregisterEntry(p) {
    this.unregisterListing(p);
    const entry = this.entries.get(p);
    this.entries.delete(p);
    if (typeof entry === `undefined`) return;
    this.fileSources.delete(entry);

    if (this.isSymbolicLink(entry)) {
      this.symlinkCount--;
    }
  }

  deleteEntry(p, index) {
    this.unregisterEntry(p);
    const rc = this.libzip.delete(this.zip, index);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  resolveFilename(reason, p, resolveLastComponent = true) {
    if (!this.ready) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBUSY(`archive closed, ${reason}`);
    let resolvedP = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, p);
    if (resolvedP === `/`) return $68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root;
    const fileIndex = this.entries.get(resolvedP);

    if (resolveLastComponent && fileIndex !== undefined) {
      if (this.symlinkCount !== 0 && this.isSymbolicLink(fileIndex)) {
        const target = this.getFileSource(fileIndex).toString();
        return this.resolveFilename(reason, $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(resolvedP), target), true);
      } else {
        return resolvedP;
      }
    }

    while (true) {
      const parentP = this.resolveFilename(reason, $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(resolvedP), true);
      const isDir = this.listings.has(parentP);
      const doesExist = this.entries.has(parentP);
      if (!isDir && !doesExist) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(reason);
      if (!isDir) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(reason);
      resolvedP = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve(parentP, $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(resolvedP));
      if (!resolveLastComponent || this.symlinkCount === 0) break;
      const index = this.libzip.name.locate(this.zip, resolvedP.slice(1));
      if (index === -1) break;

      if (this.isSymbolicLink(index)) {
        const target = this.getFileSource(index).toString();
        resolvedP = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(resolvedP), target);
      } else {
        break;
      }
    }

    return resolvedP;
  }

  allocateBuffer(content) {
    if (!$96dc529002d169e2098dfb4902acf701$var$Buffer.isBuffer(content)) content = $96dc529002d169e2098dfb4902acf701$var$Buffer.from(content);
    const buffer = this.libzip.malloc(content.byteLength);
    if (!buffer) throw new Error(`Couldn't allocate enough memory`); // Copy the file into the Emscripten heap

    // Copy the file into the Emscripten heap
    const heap = new Uint8Array(this.libzip.HEAPU8.buffer, buffer, content.byteLength);
    heap.set(content);
    return {
      buffer,
      byteLength: content.byteLength
    };
  }

  allocateUnattachedSource(content) {
    const error = this.libzip.struct.errorS();
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);

    if (source === 0) {
      this.libzip.free(error);
      throw this.makeLibzipError(error);
    }

    return source;
  }

  allocateSource(content) {
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromBuffer(this.zip, buffer, byteLength, 0, true);

    if (source === 0) {
      this.libzip.free(buffer);
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }

    return source;
  }

  setFileSource(p, content) {
    const buffer = $96dc529002d169e2098dfb4902acf701$var$Buffer.isBuffer(content) ? content : $96dc529002d169e2098dfb4902acf701$var$Buffer.from(content);
    const target = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.relative($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, p);
    const lzSource = this.allocateSource(content);

    try {
      const newIndex = this.libzip.file.add(this.zip, target, lzSource, this.libzip.ZIP_FL_OVERWRITE);
      if (newIndex === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));

      if (this.level !== `mixed`) {
        // Use store for level 0, and deflate for 1..9
        let method;
        if (this.level === 0) method = this.libzip.ZIP_CM_STORE;else method = this.libzip.ZIP_CM_DEFLATE;
        const rc = this.libzip.file.setCompression(this.zip, newIndex, 0, method, this.level);

        if (rc === -1) {
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
      }

      this.fileSources.set(newIndex, buffer);
      return newIndex;
    } catch (error) {
      this.libzip.source.free(lzSource);
      throw error;
    }
  }

  isSymbolicLink(index) {
    if (this.symlinkCount === 0) return false;
    const attrs = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (attrs === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return false;
    const attributes = this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
    return (attributes & $7fb32670047e8d9f167a62d4977192ea$exports.S_IFMT) === $7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK;
  }

  getFileSource(index, opts = {
    asyncDecompress: false
  }) {
    const cachedFileSource = this.fileSources.get(index);
    if (typeof cachedFileSource !== `undefined`) return cachedFileSource;
    const stat = this.libzip.struct.statS();
    const rc = this.libzip.statIndex(this.zip, index, 0, 0, stat);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip)); // use wasm instead of browserify zlib

    // use wasm instead of browserify zlib
    const size = this.libzip.struct.statSize(stat);
    const buffer = this.libzip.malloc(size);

    try {
      const file = this.libzip.fopenIndex(this.zip, index, 0, 0);
      if (file === 0) throw this.makeLibzipError(this.libzip.getError(this.zip));

      try {
        const rc = this.libzip.fread(file, buffer, size, 0);
        if (rc === -1) throw this.makeLibzipError(this.libzip.file.getError(file));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        const data = $96dc529002d169e2098dfb4902acf701$var$Buffer.from(memory);
        return data;
      } finally {
        this.libzip.fclose(file);
      }
    } finally {
      this.libzip.free(buffer);
    }
  }

  async chmodPromise(p, mask) {
    return this.chmodSync(p, mask);
  }

  chmodSync(p, mask) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`chmod '${p}'`); // We don't allow to make the extracted entries group-writable

    // We don't allow to make the extracted entries group-writable
    mask &= 0o755;
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
    const entry = this.entries.get(resolvedP);
    if (typeof entry === `undefined`) throw new Error(`Assertion failed: The entry should have been registered (${resolvedP})`);
    const oldMod = this.getUnixMode(entry, $7fb32670047e8d9f167a62d4977192ea$exports.S_IFREG | 0o000);
    const newMod = oldMod & ~0o777 | mask;
    const rc = this.libzip.file.setExternalAttributes(this.zip, entry, 0, 0, this.libzip.ZIP_OPSYS_UNIX, newMod << 16);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  async chownPromise(p, uid, gid) {
    return this.chownSync(p, uid, gid);
  }

  chownSync(p, uid, gid) {
    throw new Error(`Unimplemented`);
  }

  async renamePromise(oldP, newP) {
    return this.renameSync(oldP, newP);
  }

  renameSync(oldP, newP) {
    throw new Error(`Unimplemented`);
  }

  async copyFilePromise(sourceP, destP, flags) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = await this.getFileSource(indexSource, {
      asyncDecompress: true
    });
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = this.getFileSource(indexSource);
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  prepareCopyFile(sourceP, destP, flags = 0) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`copyfile '${sourceP} -> '${destP}'`);
    if ((flags & $96dc529002d169e2098dfb4902acf701$var$fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
    const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
    const indexSource = this.entries.get(resolvedSourceP);
    if (typeof indexSource === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
    const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
    const indexDest = this.entries.get(resolvedDestP);
    if ((flags & ($96dc529002d169e2098dfb4902acf701$var$fs_1.constants.COPYFILE_EXCL | $96dc529002d169e2098dfb4902acf701$var$fs_1.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
    return {
      indexSource,
      resolvedDestP,
      indexDest
    };
  }

  async appendFilePromise(p, content, opts) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFilePromise(p, content, opts);
  }

  appendFileSync(p, content, opts = {}) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFileSync(p, content, opts);
  }

  async writeFilePromise(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = $96dc529002d169e2098dfb4902acf701$var$Buffer.concat([await this.getFileSource(index, {
      asyncDecompress: true
    }), $96dc529002d169e2098dfb4902acf701$var$Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  writeFileSync(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = $96dc529002d169e2098dfb4902acf701$var$Buffer.concat([this.getFileSource(index), $96dc529002d169e2098dfb4902acf701$var$Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  prepareWriteFile(p, opts) {
    if (typeof p !== `string`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBADF(`read`);
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`open '${p}'`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EISDIR(`open '${p}'`);
    let encoding = null;
    if (typeof opts === `string`) encoding = opts;else if (typeof opts === `object` && opts.encoding) encoding = opts.encoding;
    const index = this.entries.get(resolvedP);
    return {
      encoding,
      resolvedP,
      index
    };
  }

  async unlinkPromise(p) {
    return this.unlinkSync(p);
  }

  unlinkSync(p) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`unlink '${p}'`);
    const resolvedP = this.resolveFilename(`unlink '${p}'`, p);
    if (this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EISDIR(`unlink '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`unlink '${p}'`);
    this.deleteEntry(resolvedP, index);
  }

  async utimesPromise(p, atime, mtime) {
    return this.utimesSync(p, atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`utimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p);
    this.utimesImpl(resolvedP, mtime);
  }

  async lutimesPromise(p, atime, mtime) {
    return this.lutimesSync(p, atime, mtime);
  }

  lutimesSync(p, atime, mtime) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`lutimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p, false);
    this.utimesImpl(resolvedP, mtime);
  }

  utimesImpl(resolvedP, mtime) {
    if (this.listings.has(resolvedP)) if (!this.entries.has(resolvedP)) this.hydrateDirectory(resolvedP);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const rc = this.libzip.file.setMtime(this.zip, entry, 0, $96dc529002d169e2098dfb4902acf701$var$toUnixTimestamp(mtime), 0);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  async mkdirPromise(p, opts) {
    return this.mkdirSync(p, opts);
  }

  mkdirSync(p, {
    mode = 0o755,
    recursive = false
  } = {}) {
    if (recursive) {
      this.mkdirpSync(p, {
        chmod: mode
      });
      return;
    }

    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`mkdir '${p}'`);
    const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
    if (this.entries.has(resolvedP) || this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EEXIST(`mkdir '${p}'`);
    this.hydrateDirectory(resolvedP);
    this.chmodSync(resolvedP, mode);
  }

  async rmdirPromise(p, opts) {
    return this.rmdirSync(p, opts);
  }

  rmdirSync(p, {
    recursive = false
  } = {}) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`rmdir '${p}'`);

    if (recursive) {
      this.removeSync(p);
      return;
    }

    const resolvedP = this.resolveFilename(`rmdir '${p}'`, p);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`rmdir '${p}'`);
    if (directoryListing.size > 0) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTEMPTY(`rmdir '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`rmdir '${p}'`);
    this.deleteEntry(p, index);
  }

  hydrateDirectory(resolvedP) {
    const index = this.libzip.dir.add(this.zip, $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.relative($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, resolvedP));
    if (index === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.registerListing(resolvedP);
    this.registerEntry(resolvedP, index);
    return index;
  }

  async linkPromise(existingP, newP) {
    return this.linkSync(existingP, newP);
  }

  linkSync(existingP, newP) {
    // Zip archives don't support hard links:
    // https://stackoverflow.com/questions/8859616/are-hard-links-possible-within-a-zip-archive
    throw $96dc529002d169e2098dfb4902acf701$var$errors.EOPNOTSUPP(`link '${existingP}' -> '${newP}'`);
  }

  async symlinkPromise(target, p) {
    return this.symlinkSync(target, p);
  }

  symlinkSync(target, p) {
    if (this.readOnly) throw $96dc529002d169e2098dfb4902acf701$var$errors.EROFS(`symlink '${target}' -> '${p}'`);
    const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
    if (this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EISDIR(`symlink '${target}' -> '${p}'`);
    if (this.entries.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EEXIST(`symlink '${target}' -> '${p}'`);
    const index = this.setFileSource(resolvedP, target);
    this.registerEntry(resolvedP, index);
    const rc = this.libzip.file.setExternalAttributes(this.zip, index, 0, 0, this.libzip.ZIP_OPSYS_UNIX, ($7fb32670047e8d9f167a62d4977192ea$exports.S_IFLNK | 0o777) << 16);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.symlinkCount += 1;
  }

  async readFilePromise(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-expect-error
      encoding = encoding ? encoding.encoding : undefined;
    const data = await this.readFileBuffer(p, {
      asyncDecompress: true
    });
    return encoding ? data.toString(encoding) : data;
  }

  readFileSync(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-expect-error
      encoding = encoding ? encoding.encoding : undefined;
    const data = this.readFileBuffer(p);
    return encoding ? data.toString(encoding) : data;
  }

  readFileBuffer(p, opts = {
    asyncDecompress: false
  }) {
    if (typeof p !== `string`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EBADF(`read`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`open '${p}'`); // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)

    // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EISDIR(`read`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    return this.getFileSource(entry, opts);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.readdirSync(p, {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`scandir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`scandir '${p}'`);
    const entries = [...directoryListing];
    if (!withFileTypes) return entries;
    return entries.map(name => {
      return Object.assign(this.statImpl(`lstat`, $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.join(p, name)), {
        name
      });
    });
  }

  async readlinkPromise(p) {
    const entry = this.prepareReadlink(p);
    return (await this.getFileSource(entry, {
      asyncDecompress: true
    })).toString();
  }

  readlinkSync(p) {
    const entry = this.prepareReadlink(p);
    return this.getFileSource(entry).toString();
  }

  prepareReadlink(p) {
    const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOENT(`readlink '${p}'`); // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)

    // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`readlink '${p}'`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    if (!this.isSymbolicLink(entry)) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`readlink '${p}'`);
    return entry;
  }

  async truncatePromise(p, len = 0) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`open '${p}'`);
    const source = await this.getFileSource(index, {
      asyncDecompress: true
    });
    const truncated = $96dc529002d169e2098dfb4902acf701$var$Buffer.alloc(len, 0x00);
    source.copy(truncated);
    return await this.writeFilePromise(p, truncated);
  }

  truncateSync(p, len = 0) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw $96dc529002d169e2098dfb4902acf701$var$errors.EINVAL(`open '${p}'`);
    const source = this.getFileSource(index);
    const truncated = $96dc529002d169e2098dfb4902acf701$var$Buffer.alloc(len, 0x00);
    source.copy(truncated);
    return this.writeFileSync(p, truncated);
  }

  watch(p, a, b) {
    let persistent;

    switch (typeof a) {
      case `function`:
      case `string`:
      case `undefined`:
        {
          persistent = true;
        }
        break;

      default:
        {
          ({
            persistent = true
          } = a);
        }
        break;
    }

    if (!persistent) return {
      on: () => {},
      close: () => {}
    };
    const interval = setInterval(() => {}, 24 * 60 * 60 * 1000);
    return {
      on: () => {},
      close: () => {
        clearInterval(interval);
      }
    };
  }

  watchFile(p, a, b) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    return $75399b2ee6b8925a853aad4408c7e400$exports.watchFile(this, resolvedP, a, b);
  }

  unwatchFile(p, cb) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    return $75399b2ee6b8925a853aad4408c7e400$exports.unwatchFile(this, resolvedP, cb);
  }

}

$96dc529002d169e2098dfb4902acf701$export$ZipFS = $96dc529002d169e2098dfb4902acf701$var$ZipFS;
$96dc529002d169e2098dfb4902acf701$exports.ZipFS = $96dc529002d169e2098dfb4902acf701$export$ZipFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "DEFAULT_COMPRESSION_LEVEL", {
  enumerable: true,
  get: function () {
    return $96dc529002d169e2098dfb4902acf701$exports.DEFAULT_COMPRESSION_LEVEL;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "PortablePath", {
  enumerable: true,
  get: function () {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "Filename", {
  enumerable: true,
  get: function () {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.Filename;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "npath", {
  enumerable: true,
  get: function () {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.npath;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "ppath", {
  enumerable: true,
  get: function () {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.ppath;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "toFilename", {
  enumerable: true,
  get: function () {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.toFilename;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/AliasFS.js
var $0ee12425187b5df314bccea39b742f7a$exports = {};
Object.defineProperty($0ee12425187b5df314bccea39b742f7a$exports, "__esModule", {
  value: true
});
var $0ee12425187b5df314bccea39b742f7a$export$AliasFS = void 0;
$0ee12425187b5df314bccea39b742f7a$exports.AliasFS = $0ee12425187b5df314bccea39b742f7a$export$AliasFS;
// ASSET: node_modules/@yarnpkg/fslib/lib/ProxiedFS.js
var $af1c7d5032749c3b08b6edb661cc77c9$exports = {};
Object.defineProperty($af1c7d5032749c3b08b6edb661cc77c9$exports, "__esModule", {
  value: true
});
var $af1c7d5032749c3b08b6edb661cc77c9$export$ProxiedFS = void 0;
$af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS = $af1c7d5032749c3b08b6edb661cc77c9$export$ProxiedFS;

class $af1c7d5032749c3b08b6edb661cc77c9$var$ProxiedFS extends $3d7a702246aa4634d36ede659b8d4727$exports.FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }

  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }

  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }

  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), {
      path: p
    });
  }

  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), {
      path: p
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }

  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }

  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }

  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }

  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }

  async statPromise(p) {
    return this.baseFs.statPromise(this.mapToBase(p));
  }

  statSync(p) {
    return this.baseFs.statSync(this.mapToBase(p));
  }

  async lstatPromise(p) {
    return this.baseFs.lstatPromise(this.mapToBase(p));
  }

  lstatSync(p) {
    return this.baseFs.lstatSync(this.mapToBase(p));
  }

  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }

  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }

  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }

  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }

  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }

  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }

  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }

  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }

  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }

  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }

  async symlinkPromise(target, p, type) {
    return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p), type);
  }

  symlinkSync(target, p, type) {
    return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p), type);
  }

  async readFilePromise(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirPromise(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirSync(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }

  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }

  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }

  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }

  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.baseFs.watchFile(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }

  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }

}

$af1c7d5032749c3b08b6edb661cc77c9$export$ProxiedFS = $af1c7d5032749c3b08b6edb661cc77c9$var$ProxiedFS;
$af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS = $af1c7d5032749c3b08b6edb661cc77c9$export$ProxiedFS;

class $0ee12425187b5df314bccea39b742f7a$var$AliasFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor(target, {
    baseFs,
    pathUtils
  }) {
    super(pathUtils);
    this.target = target;
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

$0ee12425187b5df314bccea39b742f7a$export$AliasFS = $0ee12425187b5df314bccea39b742f7a$var$AliasFS;
$0ee12425187b5df314bccea39b742f7a$exports.AliasFS = $0ee12425187b5df314bccea39b742f7a$export$AliasFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "AliasFS", {
  enumerable: true,
  get: function () {
    return $0ee12425187b5df314bccea39b742f7a$exports.AliasFS;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "FakeFS", {
  enumerable: true,
  get: function () {
    return $3d7a702246aa4634d36ede659b8d4727$exports.FakeFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/CwdFS.js
var $2e0b1ce66672db0970de7b37736d28d7$exports = {};
Object.defineProperty($2e0b1ce66672db0970de7b37736d28d7$exports, "__esModule", {
  value: true
});
var $2e0b1ce66672db0970de7b37736d28d7$export$CwdFS = void 0;
$2e0b1ce66672db0970de7b37736d28d7$exports.CwdFS = $2e0b1ce66672db0970de7b37736d28d7$export$CwdFS;

class $2e0b1ce66672db0970de7b37736d28d7$var$CwdFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor(target, {
    baseFs = new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS()
  } = {}) {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.ppath);
    this.target = this.pathUtils.normalize(target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
  }

  resolve(p) {
    if (this.pathUtils.isAbsolute(p)) {
      return $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.normalize(p);
    } else {
      return this.baseFs.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.join(this.target, p));
    }
  }

  mapFromBase(path) {
    return path;
  }

  mapToBase(path) {
    if (this.pathUtils.isAbsolute(path)) {
      return path;
    } else {
      return this.pathUtils.join(this.target, path);
    }
  }

}

$2e0b1ce66672db0970de7b37736d28d7$export$CwdFS = $2e0b1ce66672db0970de7b37736d28d7$var$CwdFS;
$2e0b1ce66672db0970de7b37736d28d7$exports.CwdFS = $2e0b1ce66672db0970de7b37736d28d7$export$CwdFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "CwdFS", {
  enumerable: true,
  get: function () {
    return $2e0b1ce66672db0970de7b37736d28d7$exports.CwdFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/JailFS.js
var $a1b1753c1350026970ee430147a9767a$exports = {};
Object.defineProperty($a1b1753c1350026970ee430147a9767a$exports, "__esModule", {
  value: true
});
var $a1b1753c1350026970ee430147a9767a$export$JailFS = void 0;
$a1b1753c1350026970ee430147a9767a$exports.JailFS = $a1b1753c1350026970ee430147a9767a$export$JailFS;
const $a1b1753c1350026970ee430147a9767a$var$JAIL_ROOT = $68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root;

class $a1b1753c1350026970ee430147a9767a$var$JailFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor(target, {
    baseFs = new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS()
  } = {}) {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.ppath);
    this.target = this.pathUtils.resolve($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, this.target));
  }

  getTarget() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapToBase(p) {
    const normalized = this.pathUtils.normalize(p);
    if (this.pathUtils.isAbsolute(p)) return this.pathUtils.resolve(this.target, this.pathUtils.relative($a1b1753c1350026970ee430147a9767a$var$JAIL_ROOT, p));
    if (normalized.match(/^\.\.\/?/)) throw new Error(`Resolving this path (${p}) would escape the jail`);
    return this.pathUtils.resolve(this.target, p);
  }

  mapFromBase(p) {
    return this.pathUtils.resolve($a1b1753c1350026970ee430147a9767a$var$JAIL_ROOT, this.pathUtils.relative(this.target, p));
  }

}

$a1b1753c1350026970ee430147a9767a$export$JailFS = $a1b1753c1350026970ee430147a9767a$var$JailFS;
$a1b1753c1350026970ee430147a9767a$exports.JailFS = $a1b1753c1350026970ee430147a9767a$export$JailFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "JailFS", {
  enumerable: true,
  get: function () {
    return $a1b1753c1350026970ee430147a9767a$exports.JailFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/LazyFS.js
var $149225605bf1c369a6cf5b01b4a8029f$exports = {};
Object.defineProperty($149225605bf1c369a6cf5b01b4a8029f$exports, "__esModule", {
  value: true
});
var $149225605bf1c369a6cf5b01b4a8029f$export$LazyFS = void 0;
$149225605bf1c369a6cf5b01b4a8029f$exports.LazyFS = $149225605bf1c369a6cf5b01b4a8029f$export$LazyFS;

class $149225605bf1c369a6cf5b01b4a8029f$var$LazyFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor(factory, pathUtils) {
    super(pathUtils);
    this.instance = null;
    this.factory = factory;
  }

  get baseFs() {
    if (!this.instance) this.instance = this.factory();
    return this.instance;
  }

  set baseFs(value) {
    this.instance = value;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

$149225605bf1c369a6cf5b01b4a8029f$export$LazyFS = $149225605bf1c369a6cf5b01b4a8029f$var$LazyFS;
$149225605bf1c369a6cf5b01b4a8029f$exports.LazyFS = $149225605bf1c369a6cf5b01b4a8029f$export$LazyFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "LazyFS", {
  enumerable: true,
  get: function () {
    return $149225605bf1c369a6cf5b01b4a8029f$exports.LazyFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/NoFS.js
var $1deb466621cfc4833c85df64133bfec6$exports = {};
Object.defineProperty($1deb466621cfc4833c85df64133bfec6$exports, "__esModule", {
  value: true
});
var $1deb466621cfc4833c85df64133bfec6$export$NoFS = void 0;
$1deb466621cfc4833c85df64133bfec6$exports.NoFS = $1deb466621cfc4833c85df64133bfec6$export$NoFS;

const $1deb466621cfc4833c85df64133bfec6$var$makeError = () => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), {
  code: `ENOSYS`
});

class $1deb466621cfc4833c85df64133bfec6$var$NoFS extends $3d7a702246aa4634d36ede659b8d4727$exports.FakeFS {
  constructor() {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.ppath);
  }

  getExtractHint() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  getRealPath() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  resolve() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async openPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  openSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async opendirPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  opendirSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async readPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  readSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async writePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  writeSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async closePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  closeSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  createWriteStream() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  createReadStream() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async realpathPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  realpathSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async readdirPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  readdirSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async existsPromise(p) {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  existsSync(p) {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async accessPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  accessSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async statPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  statSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async lstatPromise(p) {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  lstatSync(p) {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async chmodPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  chmodSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async chownPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  chownSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async mkdirPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  mkdirSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async rmdirPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  rmdirSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async linkPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  linkSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async symlinkPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  symlinkSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async renamePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  renameSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async copyFilePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  copyFileSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async appendFilePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  appendFileSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async writeFilePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  writeFileSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async unlinkPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  unlinkSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async utimesPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  utimesSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async readFilePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  readFileSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async readlinkPromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  readlinkSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  async truncatePromise() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  truncateSync() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  watch() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  watchFile() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

  unwatchFile() {
    throw $1deb466621cfc4833c85df64133bfec6$var$makeError();
  }

}

$1deb466621cfc4833c85df64133bfec6$export$NoFS = $1deb466621cfc4833c85df64133bfec6$var$NoFS;
$1deb466621cfc4833c85df64133bfec6$exports.NoFS = $1deb466621cfc4833c85df64133bfec6$export$NoFS;
$1deb466621cfc4833c85df64133bfec6$var$NoFS.instance = new $1deb466621cfc4833c85df64133bfec6$var$NoFS();
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "NoFS", {
  enumerable: true,
  get: function () {
    return $1deb466621cfc4833c85df64133bfec6$exports.NoFS;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "NodeFS", {
  enumerable: true,
  get: function () {
    return $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/PosixFS.js
var $053f8296cba30366fe6d0599dac58de3$exports = {};
Object.defineProperty($053f8296cba30366fe6d0599dac58de3$exports, "__esModule", {
  value: true
});
var $053f8296cba30366fe6d0599dac58de3$export$PosixFS = void 0;
$053f8296cba30366fe6d0599dac58de3$exports.PosixFS = $053f8296cba30366fe6d0599dac58de3$export$PosixFS;

class $053f8296cba30366fe6d0599dac58de3$var$PosixFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor(baseFs) {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.npath);
    this.baseFs = baseFs;
  }

  mapFromBase(path) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.fromPortablePath(path);
  }

  mapToBase(path) {
    return $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath(path);
  }

}

$053f8296cba30366fe6d0599dac58de3$export$PosixFS = $053f8296cba30366fe6d0599dac58de3$var$PosixFS;
$053f8296cba30366fe6d0599dac58de3$exports.PosixFS = $053f8296cba30366fe6d0599dac58de3$export$PosixFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "PosixFS", {
  enumerable: true,
  get: function () {
    return $053f8296cba30366fe6d0599dac58de3$exports.PosixFS;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "ProxiedFS", {
  enumerable: true,
  get: function () {
    return $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/VirtualFS.js
var $b6d598bea51ddd370d8d80a8d6b238ad$exports = {};
Object.defineProperty($b6d598bea51ddd370d8d80a8d6b238ad$exports, "__esModule", {
  value: true
});
var $b6d598bea51ddd370d8d80a8d6b238ad$export$VirtualFS = void 0;
$b6d598bea51ddd370d8d80a8d6b238ad$exports.VirtualFS = $b6d598bea51ddd370d8d80a8d6b238ad$export$VirtualFS;
const $b6d598bea51ddd370d8d80a8d6b238ad$var$NUMBER_REGEXP = /^[0-9]+$/; // $0: full path
// $1: virtual folder
// $2: virtual segment
// $3: hash
// $4: depth
// $5: subpath

// $0: full path
// $1: virtual folder
// $2: virtual segment
// $3: hash
// $4: depth
// $5: subpath
const $b6d598bea51ddd370d8d80a8d6b238ad$var$VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?\$\$virtual)((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const $b6d598bea51ddd370d8d80a8d6b238ad$var$VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;

class $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS extends $af1c7d5032749c3b08b6edb661cc77c9$exports.ProxiedFS {
  constructor({
    baseFs = new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS()
  } = {}) {
    super($68fec5135ffa9bcaf015baca3dd61152$exports.ppath);
    this.baseFs = baseFs;
  }

  static makeVirtualPath(base, component, to) {
    if ($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(base) !== `$$virtual`) throw new Error(`Assertion failed: Virtual folders must be named "$$virtual"`);
    if (!$68fec5135ffa9bcaf015baca3dd61152$exports.ppath.basename(component).match($b6d598bea51ddd370d8d80a8d6b238ad$var$VALID_COMPONENT)) throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`); // Obtains the relative distance between the virtual path and its actual target

    // Obtains the relative distance between the virtual path and its actual target
    const target = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.relative($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(base), to);
    const segments = target.split(`/`); // Counts how many levels we need to go back to start applying the rest of the path

    // Counts how many levels we need to go back to start applying the rest of the path
    let depth = 0;

    while (depth < segments.length && segments[depth] === `..`) depth += 1;

    const finalSegments = segments.slice(depth);
    const fullVirtualPath = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }

  static resolveVirtual(p) {
    const match = p.match($b6d598bea51ddd370d8d80a8d6b238ad$var$VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5]) return p;
    const target = $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.dirname(match[1]);
    if (!match[3] || !match[4]) return target;
    const isnum = $b6d598bea51ddd370d8d80a8d6b238ad$var$NUMBER_REGEXP.test(match[4]);
    if (!isnum) return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS.resolveVirtual($68fec5135ffa9bcaf015baca3dd61152$exports.ppath.join(target, backstep, subpath));
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  realpathSync(p) {
    const match = p.match($b6d598bea51ddd370d8d80a8d6b238ad$var$VIRTUAL_REGEXP);
    if (!match) return this.baseFs.realpathSync(p);
    if (!match[5]) return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  async realpathPromise(p) {
    const match = p.match($b6d598bea51ddd370d8d80a8d6b238ad$var$VIRTUAL_REGEXP);
    if (!match) return await this.baseFs.realpathPromise(p);
    if (!match[5]) return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  mapToBase(p) {
    return $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS.resolveVirtual(p);
  }

  mapFromBase(p) {
    return p;
  }

}

$b6d598bea51ddd370d8d80a8d6b238ad$export$VirtualFS = $b6d598bea51ddd370d8d80a8d6b238ad$var$VirtualFS;
$b6d598bea51ddd370d8d80a8d6b238ad$exports.VirtualFS = $b6d598bea51ddd370d8d80a8d6b238ad$export$VirtualFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "VirtualFS", {
  enumerable: true,
  get: function () {
    return $b6d598bea51ddd370d8d80a8d6b238ad$exports.VirtualFS;
  }
});
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "ZipFS", {
  enumerable: true,
  get: function () {
    return $96dc529002d169e2098dfb4902acf701$exports.ZipFS;
  }
});
// ASSET: node_modules/@yarnpkg/fslib/lib/ZipOpenFS.js
var $e7efc781070f1372a3836800ed3697cd$exports = {};
Object.defineProperty($e7efc781070f1372a3836800ed3697cd$exports, "__esModule", {
  value: true
});
var $e7efc781070f1372a3836800ed3697cd$export$ZipOpenFS = void 0;
$e7efc781070f1372a3836800ed3697cd$exports.ZipOpenFS = $e7efc781070f1372a3836800ed3697cd$export$ZipOpenFS;
const $e7efc781070f1372a3836800ed3697cd$var$fs_1 = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
const $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD = 0x80000000;
const $e7efc781070f1372a3836800ed3697cd$var$FILE_PARTS_REGEX = /.*?\.zip(?=\/|$)/;

class $e7efc781070f1372a3836800ed3697cd$var$ZipOpenFS extends $3d7a702246aa4634d36ede659b8d4727$exports.BasePortableFakeFS {
  constructor({
    libzip,
    baseFs = new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS(),
    filter = null,
    maxOpenFiles = Infinity,
    readOnlyArchives = false,
    useCache = true,
    maxAge = 5000
  }) {
    super();
    this.fdMap = new Map();
    this.nextFd = 3;
    this.isZip = new Set();
    this.notZip = new Set();
    this.realPaths = new Map();
    this.limitOpenFilesTimeout = null;
    this.libzip = libzip;
    this.baseFs = baseFs;
    this.zipInstances = useCache ? new Map() : null;
    this.filter = filter;
    this.maxOpenFiles = maxOpenFiles;
    this.readOnlyArchives = readOnlyArchives;
    this.maxAge = maxAge;
  }

  static async openPromise(fn, opts) {
    const zipOpenFs = new $e7efc781070f1372a3836800ed3697cd$var$ZipOpenFS(opts);

    try {
      return await fn(zipOpenFs);
    } finally {
      zipOpenFs.saveAndClose();
    }
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  saveAndClose() {
    $75399b2ee6b8925a853aad4408c7e400$exports.unwatchAllFiles(this);

    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  discardAndClose() {
    $75399b2ee6b8925a853aad4408c7e400$exports.unwatchAllFiles(this);

    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.discardAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  resolve(p) {
    return this.baseFs.resolve(p);
  }

  remapFd(zipFs, fd) {
    const remappedFd = this.nextFd++ | $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD;
    this.fdMap.set(remappedFd, [zipFs, fd]);
    return remappedFd;
  }

  async openPromise(p, flags, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.openPromise(p, flags, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
    });
  }

  openSync(p, flags, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.openSync(p, flags, mode);
    }, (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
    });
  }

  async opendirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.opendirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.opendirPromise(subPath, opts);
    }, {
      requireSubpath: false
    });
  }

  opendirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.opendirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.opendirSync(subPath, opts);
    }, {
      requireSubpath: false
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return await zipFs.readPromise(realFd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) return this.baseFs.readSync(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return zipFs.readSync(realFd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return await zipFs.writePromise(realFd, buffer, offset);
    } else {
      return await zipFs.writePromise(realFd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return zipFs.writeSync(realFd, buffer, offset);
    } else {
      return zipFs.writeSync(realFd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) return await this.baseFs.closePromise(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return await zipFs.closePromise(realFd);
  }

  closeSync(fd) {
    if ((fd & $e7efc781070f1372a3836800ed3697cd$var$ZIP_FD) === 0) return this.baseFs.closeSync(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return zipFs.closeSync(realFd);
  }

  createReadStream(p, opts) {
    if (p === null) return this.baseFs.createReadStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createReadStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createReadStream(subPath, opts);
    });
  }

  createWriteStream(p, opts) {
    if (p === null) return this.baseFs.createWriteStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createWriteStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createWriteStream(subPath, opts);
    });
  }

  async realpathPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.realpathPromise(p);
    }, async (zipFs, {
      archivePath,
      subPath
    }) => {
      let realArchivePath = this.realPaths.get(archivePath);

      if (typeof realArchivePath === `undefined`) {
        realArchivePath = await this.baseFs.realpathPromise(archivePath);
        this.realPaths.set(archivePath, realArchivePath);
      }

      return this.pathUtils.join(realArchivePath, this.pathUtils.relative($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, await zipFs.realpathPromise(subPath)));
    });
  }

  realpathSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.realpathSync(p);
    }, (zipFs, {
      archivePath,
      subPath
    }) => {
      let realArchivePath = this.realPaths.get(archivePath);

      if (typeof realArchivePath === `undefined`) {
        realArchivePath = this.baseFs.realpathSync(archivePath);
        this.realPaths.set(archivePath, realArchivePath);
      }

      return this.pathUtils.join(realArchivePath, this.pathUtils.relative($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, zipFs.realpathSync(subPath)));
    });
  }

  async existsPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.existsPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.existsPromise(subPath);
    });
  }

  existsSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.existsSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.existsSync(subPath);
    });
  }

  async accessPromise(p, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.accessPromise(p, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.accessPromise(subPath, mode);
    });
  }

  accessSync(p, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.accessSync(p, mode);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.accessSync(subPath, mode);
    });
  }

  async statPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.statPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.statPromise(subPath);
    });
  }

  statSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.statSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.statSync(subPath);
    });
  }

  async lstatPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.lstatPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.lstatPromise(subPath);
    });
  }

  lstatSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.lstatSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.lstatSync(subPath);
    });
  }

  async chmodPromise(p, mask) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chmodPromise(p, mask);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chmodPromise(subPath, mask);
    });
  }

  chmodSync(p, mask) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chmodSync(p, mask);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chmodSync(subPath, mask);
    });
  }

  async chownPromise(p, uid, gid) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chownPromise(p, uid, gid);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chownPromise(subPath, uid, gid);
    });
  }

  chownSync(p, uid, gid) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chownSync(p, uid, gid);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chownSync(subPath, uid, gid);
    });
  }

  async renamePromise(oldP, newP) {
    return await this.makeCallPromise(oldP, async () => {
      return await this.makeCallPromise(newP, async () => {
        return await this.baseFs.renamePromise(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, async (zipFsO, {
      subPath: subPathO
    }) => {
      return await this.makeCallPromise(newP, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, async (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return await zipFsO.renamePromise(subPathO, subPathN);
        }
      });
    });
  }

  renameSync(oldP, newP) {
    return this.makeCallSync(oldP, () => {
      return this.makeCallSync(newP, () => {
        return this.baseFs.renameSync(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, (zipFsO, {
      subPath: subPathO
    }) => {
      return this.makeCallSync(newP, () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return zipFsO.renameSync(subPathO, subPathN);
        }
      });
    });
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    const fallback = async (sourceFs, sourceP, destFs, destP) => {
      if ((flags & $e7efc781070f1372a3836800ed3697cd$var$fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & $e7efc781070f1372a3836800ed3697cd$var$fs_1.constants.COPYFILE_EXCL && (await this.existsPromise(sourceP))) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = await sourceFs.readFilePromise(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      await destFs.writeFilePromise(destP, content);
    };

    return await this.makeCallPromise(sourceP, async () => {
      return await this.makeCallPromise(destP, async () => {
        return await this.baseFs.copyFilePromise(sourceP, destP, flags);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, async (zipFsS, {
      subPath: subPathS
    }) => {
      return await this.makeCallPromise(destP, async () => {
        return await fallback(zipFsS, subPathS, this.baseFs, destP);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return await fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
        }
      });
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const fallback = (sourceFs, sourceP, destFs, destP) => {
      if ((flags & $e7efc781070f1372a3836800ed3697cd$var$fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & $e7efc781070f1372a3836800ed3697cd$var$fs_1.constants.COPYFILE_EXCL && this.existsSync(sourceP)) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = sourceFs.readFileSync(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      destFs.writeFileSync(destP, content);
    };

    return this.makeCallSync(sourceP, () => {
      return this.makeCallSync(destP, () => {
        return this.baseFs.copyFileSync(sourceP, destP, flags);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        return fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, (zipFsS, {
      subPath: subPathS
    }) => {
      return this.makeCallSync(destP, () => {
        return fallback(zipFsS, subPathS, this.baseFs, destP);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return zipFsS.copyFileSync(subPathS, subPathD, flags);
        }
      });
    });
  }

  async appendFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.appendFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.appendFilePromise(subPath, content, opts);
    });
  }

  appendFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.appendFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.appendFileSync(subPath, content, opts);
    });
  }

  async writeFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.writeFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.writeFilePromise(subPath, content, opts);
    });
  }

  writeFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.writeFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.writeFileSync(subPath, content, opts);
    });
  }

  async unlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.unlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.unlinkPromise(subPath);
    });
  }

  unlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.unlinkSync(subPath);
    });
  }

  async utimesPromise(p, atime, mtime) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.utimesPromise(p, atime, mtime);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.utimesPromise(subPath, atime, mtime);
    });
  }

  utimesSync(p, atime, mtime) {
    return this.makeCallSync(p, () => {
      return this.baseFs.utimesSync(p, atime, mtime);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.utimesSync(subPath, atime, mtime);
    });
  }

  async mkdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.mkdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.mkdirPromise(subPath, opts);
    });
  }

  mkdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.mkdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.mkdirSync(subPath, opts);
    });
  }

  async rmdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.rmdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.rmdirPromise(subPath, opts);
    });
  }

  rmdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.rmdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.rmdirSync(subPath, opts);
    });
  }

  async linkPromise(existingP, newP) {
    return await this.makeCallPromise(newP, async () => {
      return await this.baseFs.linkPromise(existingP, newP);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.linkPromise(existingP, subPath);
    });
  }

  linkSync(existingP, newP) {
    return this.makeCallSync(newP, () => {
      return this.baseFs.linkSync(existingP, newP);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.linkSync(existingP, subPath);
    });
  }

  async symlinkPromise(target, p, type) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.symlinkPromise(target, p, type);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.symlinkPromise(target, subPath);
    });
  }

  symlinkSync(target, p, type) {
    return this.makeCallSync(p, () => {
      return this.baseFs.symlinkSync(target, p, type);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.symlinkSync(target, subPath);
    });
  }

  async readFilePromise(p, encoding) {
    return this.makeCallPromise(p, async () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return await this.baseFs.readFilePromise(p, encoding);

        default:
          return await this.baseFs.readFilePromise(p, encoding);
      }
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readFilePromise(subPath, encoding);
    });
  }

  readFileSync(p, encoding) {
    return this.makeCallSync(p, () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return this.baseFs.readFileSync(p, encoding);

        default:
          return this.baseFs.readFileSync(p, encoding);
      }
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readFileSync(subPath, encoding);
    });
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readdirPromise(p, {
        withFileTypes: withFileTypes
      });
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readdirPromise(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readdirSync(p, {
        withFileTypes: withFileTypes
      });
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readdirSync(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  async readlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readlinkPromise(subPath);
    });
  }

  readlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readlinkSync(subPath);
    });
  }

  async truncatePromise(p, len) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.truncatePromise(p, len);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.truncatePromise(subPath, len);
    });
  }

  truncateSync(p, len) {
    return this.makeCallSync(p, () => {
      return this.baseFs.truncateSync(p, len);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.truncateSync(subPath, len);
    });
  }

  watch(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watch(p, // @ts-expect-error
      a, b);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.watch(subPath, // @ts-expect-error
      a, b);
    });
  }

  watchFile(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watchFile(p, // @ts-expect-error
      a, b);
    }, () => {
      return $75399b2ee6b8925a853aad4408c7e400$exports.watchFile(this, p, a, b);
    });
  }

  unwatchFile(p, cb) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unwatchFile(p, cb);
    }, () => {
      return $75399b2ee6b8925a853aad4408c7e400$exports.unwatchFile(this, p, cb);
    });
  }

  async makeCallPromise(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return await discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return await discard();
    if (requireSubpath && zipInfo.subPath === `/`) return await discard();
    return await this.getZipPromise(zipInfo.archivePath, async zipFs => await accept(zipFs, zipInfo));
  }

  makeCallSync(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return discard();
    if (requireSubpath && zipInfo.subPath === `/`) return discard();
    return this.getZipSync(zipInfo.archivePath, zipFs => accept(zipFs, zipInfo));
  }

  findZip(p) {
    if (this.filter && !this.filter.test(p)) return null;
    let filePath = ``;

    while (true) {
      const parts = $e7efc781070f1372a3836800ed3697cd$var$FILE_PARTS_REGEX.exec(p.substr(filePath.length));
      if (!parts) return null;
      filePath = this.pathUtils.join(filePath, parts[0]);

      if (this.isZip.has(filePath) === false) {
        if (this.notZip.has(filePath)) continue;

        try {
          if (!this.baseFs.lstatSync(filePath).isFile()) {
            this.notZip.add(filePath);
            continue;
          }
        } catch (_a) {
          return null;
        }

        this.isZip.add(filePath);
      }

      return {
        archivePath: filePath,
        subPath: this.pathUtils.join($68fec5135ffa9bcaf015baca3dd61152$exports.PortablePath.root, p.substr(filePath.length))
      };
    }
  }

  limitOpenFiles(max) {
    if (this.zipInstances === null) return;
    const now = Date.now();
    let nextExpiresAt = now + this.maxAge;
    let closeCount = max === null ? 0 : this.zipInstances.size - max;

    for (const [path, {
      zipFs,
      expiresAt,
      refCount
    }] of this.zipInstances.entries()) {
      if (refCount !== 0 || zipFs.hasOpenFileHandles()) {
        continue;
      } else if (now >= expiresAt) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
        closeCount -= 1;
        continue;
      } else if (max === null || closeCount <= 0) {
        nextExpiresAt = expiresAt;
        break;
      }

      zipFs.saveAndClose();
      this.zipInstances.delete(path);
      closeCount -= 1;
    }

    if (this.limitOpenFilesTimeout === null && (max === null && this.zipInstances.size > 0 || max !== null)) {
      this.limitOpenFilesTimeout = setTimeout(() => {
        this.limitOpenFilesTimeout = null;
        this.limitOpenFiles(null);
      }, nextExpiresAt - now);
    }
  }

  async getZipPromise(p, accept) {
    const getZipOptions = async () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: await this.baseFs.statPromise(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        const zipOptions = await getZipOptions(); // We need to recheck because concurrent getZipPromise calls may
        // have instantiated the zip archive while we were waiting

        // We need to recheck because concurrent getZipPromise calls may
        // have instantiated the zip archive while we were waiting
        cachedZipFs = this.zipInstances.get(p);

        if (!cachedZipFs) {
          cachedZipFs = {
            zipFs: new $96dc529002d169e2098dfb4902acf701$exports.ZipFS(p, zipOptions),
            expiresAt: 0,
            refCount: 0
          };
        }
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy
      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      cachedZipFs.refCount += 1;

      try {
        return await accept(cachedZipFs.zipFs);
      } finally {
        cachedZipFs.refCount -= 1;
      }
    } else {
      const zipFs = new $96dc529002d169e2098dfb4902acf701$exports.ZipFS(p, await getZipOptions());

      try {
        return await accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

  getZipSync(p, accept) {
    const getZipOptions = () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: this.baseFs.statSync(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        cachedZipFs = {
          zipFs: new $96dc529002d169e2098dfb4902acf701$exports.ZipFS(p, getZipOptions()),
          expiresAt: 0,
          refCount: 0
        };
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy
      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      return accept(cachedZipFs.zipFs);
    } else {
      const zipFs = new $96dc529002d169e2098dfb4902acf701$exports.ZipFS(p, getZipOptions());

      try {
        return accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

}

$e7efc781070f1372a3836800ed3697cd$export$ZipOpenFS = $e7efc781070f1372a3836800ed3697cd$var$ZipOpenFS;
$e7efc781070f1372a3836800ed3697cd$exports.ZipOpenFS = $e7efc781070f1372a3836800ed3697cd$export$ZipOpenFS;
Object.defineProperty($ea9c1e38c3e8cca334929a597a084311$exports, "ZipOpenFS", {
  enumerable: true,
  get: function () {
    return $e7efc781070f1372a3836800ed3697cd$exports.ZipOpenFS;
  }
});

function $ea9c1e38c3e8cca334929a597a084311$var$getTempName(prefix) {
  const tmpdir = $68fec5135ffa9bcaf015baca3dd61152$exports.npath.toPortablePath($ea9c1e38c3e8cca334929a597a084311$var$os_1.default.tmpdir());
  const hash = Math.ceil(Math.random() * 0x100000000).toString(16).padStart(8, `0`);
  return $68fec5135ffa9bcaf015baca3dd61152$exports.ppath.join(tmpdir, `${prefix}${hash}`);
}

function $ea9c1e38c3e8cca334929a597a084311$var$patchFs(patchedFs, fakeFs) {
  const SYNC_IMPLEMENTATIONS = new Set([`accessSync`, `appendFileSync`, `createReadStream`, `chmodSync`, `chownSync`, `closeSync`, `copyFileSync`, `linkSync`, `lstatSync`, `lutimesSync`, `mkdirSync`, `openSync`, `opendirSync`, `readSync`, `readlinkSync`, `readFileSync`, `readdirSync`, `readlinkSync`, `realpathSync`, `renameSync`, `rmdirSync`, `statSync`, `symlinkSync`, `truncateSync`, `unlinkSync`, `unwatchFile`, `utimesSync`, `watch`, `watchFile`, `writeFileSync`, `writeSync`]);
  const ASYNC_IMPLEMENTATIONS = new Set([`accessPromise`, `appendFilePromise`, `chmodPromise`, `chownPromise`, `closePromise`, `copyFilePromise`, `linkPromise`, `lstatPromise`, `lutimesPromise`, `mkdirPromise`, `openPromise`, `opendirPromise`, `readdirPromise`, `realpathPromise`, `readFilePromise`, `readdirPromise`, `readlinkPromise`, `renamePromise`, `rmdirPromise`, `statPromise`, `symlinkPromise`, `truncatePromise`, `unlinkPromise`, `utimesPromise`, `writeFilePromise`, `writeSync`]);
  const FILEHANDLE_IMPLEMENTATIONS = new Set([`appendFilePromise`, `chmodPromise`, `chownPromise`, `closePromise`, `readPromise`, `readFilePromise`, `statPromise`, `truncatePromise`, `utimesPromise`, `writePromise`, `writeFilePromise`]);

  const setupFn = (target, name, replacement) => {
    const orig = target[name];
    target[name] = replacement; // Preserve any util.promisify implementations

    // Preserve any util.promisify implementations
    if (typeof (orig === null || orig === void 0 ? void 0 : orig[$ea9c1e38c3e8cca334929a597a084311$var$util_1.promisify.custom]) !== `undefined`) {
      replacement[$ea9c1e38c3e8cca334929a597a084311$var$util_1.promisify.custom] = orig[$ea9c1e38c3e8cca334929a597a084311$var$util_1.promisify.custom];
    }
  };
  /** Callback implementations */


  /** Callback implementations */
  {
    setupFn(patchedFs, `exists`, (p, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      $ea9c1e38c3e8cca334929a597a084311$var$process.nextTick(() => {
        fakeFs.existsPromise(p).then(exists => {
          callback(exists);
        }, () => {
          callback(false);
        });
      });
    });
    setupFn(patchedFs, `read`, (p, buffer, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      $ea9c1e38c3e8cca334929a597a084311$var$process.nextTick(() => {
        fakeFs.readPromise(p, buffer, ...args).then(bytesRead => {
          callback(null, bytesRead, buffer);
        }, error => {
          callback(error);
        });
      });
    });

    for (const fnName of ASYNC_IMPLEMENTATIONS) {
      const origName = fnName.replace(/Promise$/, ``);
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;

      const wrapper = (...args) => {
        const hasCallback = typeof args[args.length - 1] === `function`;
        const callback = hasCallback ? args.pop() : () => {};
        $ea9c1e38c3e8cca334929a597a084311$var$process.nextTick(() => {
          fakeImpl.apply(fakeFs, args).then(result => {
            callback(null, result);
          }, error => {
            callback(error);
          });
        });
      };

      setupFn(patchedFs, origName, wrapper);
    }

    patchedFs.realpath.native = patchedFs.realpath;
  }
  /** Sync implementations */

  /** Sync implementations */
  {
    setupFn(patchedFs, `existsSync`, p => {
      try {
        return fakeFs.existsSync(p);
      } catch (error) {
        return false;
      }
    });

    for (const fnName of SYNC_IMPLEMENTATIONS) {
      const origName = fnName;
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;
      setupFn(patchedFs, origName, fakeImpl.bind(fakeFs));
    }

    patchedFs.realpathSync.native = patchedFs.realpathSync;
  }
  /** Promise implementations */

  /** Promise implementations */
  {
    // `fs.promises` is a getter that returns a reference to require(`fs/promises`),
    // so we can just patch `fs.promises` and both will be updated
    const origEmitWarning = $ea9c1e38c3e8cca334929a597a084311$var$process.emitWarning;

    $ea9c1e38c3e8cca334929a597a084311$var$process.emitWarning = () => {};

    let patchedFsPromises;

    try {
      patchedFsPromises = patchedFs.promises;
    } finally {
      $ea9c1e38c3e8cca334929a597a084311$var$process.emitWarning = origEmitWarning;
    }

    if (typeof patchedFsPromises !== `undefined`) {
      // `fs.promises.exists` doesn't exist
      for (const fnName of ASYNC_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        if (typeof patchedFsPromises[origName] === `undefined`) continue;
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue; // Open is a bit particular with fs.promises: it returns a file handle
        // instance instead of the traditional file descriptor number

        // Open is a bit particular with fs.promises: it returns a file handle
        // instance instead of the traditional file descriptor number
        if (fnName === `open`) continue;
        setupFn(patchedFsPromises, origName, fakeImpl.bind(fakeFs));
      }

      class FileHandle {
        constructor(fd) {
          this.fd = fd;
        }

      }

      for (const fnName of FILEHANDLE_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue;
        setupFn(FileHandle.prototype, origName, function (...args) {
          return fakeImpl.call(fakeFs, this.fd, ...args);
        });
      }

      setupFn(patchedFsPromises, `open`, async (...args) => {
        // @ts-expect-error
        const fd = await fakeFs.openPromise(...args);
        return new FileHandle(fd);
      }); // `fs.promises.realpath` doesn't have a `native` property
    }
  }
  /** util.promisify implementations */

  /** util.promisify implementations */
  {
    // Override the promisified version of `fs.read` to return an object as per
    // https://github.com/nodejs/node/blob/dc79f3f37caf6f25b8efee4623bec31e2c20f595/lib/fs.js#L559-L560
    // and
    // https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L293
    // @ts-expect-error
    patchedFs.read[$ea9c1e38c3e8cca334929a597a084311$var$util_1.promisify.custom] = async (p, buffer, ...args) => {
      const res = fakeFs.readPromise(p, buffer, ...args);
      return {
        bytesRead: await res,
        buffer
      };
    };
  }
}

var $ea9c1e38c3e8cca334929a597a084311$export$patchFs = $ea9c1e38c3e8cca334929a597a084311$var$patchFs;
$ea9c1e38c3e8cca334929a597a084311$exports.patchFs = $ea9c1e38c3e8cca334929a597a084311$export$patchFs;

function $ea9c1e38c3e8cca334929a597a084311$var$extendFs(realFs, fakeFs) {
  const patchedFs = Object.create(realFs);
  $ea9c1e38c3e8cca334929a597a084311$var$patchFs(patchedFs, fakeFs);
  return patchedFs;
}

var $ea9c1e38c3e8cca334929a597a084311$export$extendFs = $ea9c1e38c3e8cca334929a597a084311$var$extendFs;
$ea9c1e38c3e8cca334929a597a084311$exports.extendFs = $ea9c1e38c3e8cca334929a597a084311$export$extendFs;
const $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs = new Set();
let $ea9c1e38c3e8cca334929a597a084311$var$cleanExitRegistered = false;

function $ea9c1e38c3e8cca334929a597a084311$var$registerCleanExit() {
  if ($ea9c1e38c3e8cca334929a597a084311$var$cleanExitRegistered) return;
  $ea9c1e38c3e8cca334929a597a084311$var$cleanExitRegistered = true;
  $ea9c1e38c3e8cca334929a597a084311$var$process.once(`exit`, () => {
    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.rmtempSync();
  });
}

$ea9c1e38c3e8cca334929a597a084311$export$xfs = Object.assign(new $12d39dac46e76cf7bd93ac42e706530e$exports.NodeFS(), {
  detachTemp(p) {
    $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.delete(p);
  },

  mktempSync(cb) {
    $ea9c1e38c3e8cca334929a597a084311$var$registerCleanExit();

    while (true) {
      const p = $ea9c1e38c3e8cca334929a597a084311$var$getTempName(`xfs-`);

      try {
        this.mkdirSync(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = this.realpathSync(p);
      $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return cb(realP);
        } finally {
          if ($ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.has(realP)) {
            $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.delete(realP);

            try {
              this.removeSync(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return p;
      }
    }
  },

  async mktempPromise(cb) {
    $ea9c1e38c3e8cca334929a597a084311$var$registerCleanExit();

    while (true) {
      const p = $ea9c1e38c3e8cca334929a597a084311$var$getTempName(`xfs-`);

      try {
        await this.mkdirPromise(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = await this.realpathPromise(p);
      $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return await cb(realP);
        } finally {
          if ($ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.has(realP)) {
            $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.delete(realP);

            try {
              await this.removePromise(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return realP;
      }
    }
  },

  async rmtempPromise() {
    await Promise.all(Array.from($ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.values()).map(async p => {
      try {
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(p, {
          maxRetries: 0
        });
        $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.delete(p);
      } catch (_a) {// Too bad if there's an error
      }
    }));
  },

  rmtempSync() {
    for (const p of $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs) {
      try {
        $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removeSync(p);
        $ea9c1e38c3e8cca334929a597a084311$var$tmpdirs.delete(p);
      } catch (_a) {// Too bad if there's an error
      }
    }
  }

});
$ea9c1e38c3e8cca334929a597a084311$exports.xfs = $ea9c1e38c3e8cca334929a597a084311$export$xfs;
// ASSET: node_modules/cross-spawn/index.js
var $9e1caa6808b9b77bfb60d20caf7d6ad4$exports = {};
const $9e1caa6808b9b77bfb60d20caf7d6ad4$var$cp = {};
// ASSET: node_modules/cross-spawn/lib/parse.js
var $305f95dd14f4f5382f14cc45c7d4f3e7$exports = {};
var $305f95dd14f4f5382f14cc45c7d4f3e7$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $305f95dd14f4f5382f14cc45c7d4f3e7$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/cross-spawn/lib/util/resolveCommand.js
var $eded1b8bf70d7110a376762ac3876d42$exports = {};
var $eded1b8bf70d7110a376762ac3876d42$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $eded1b8bf70d7110a376762ac3876d42$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/which/which.js
var $6353741863f81224e6f569531aad505f$exports = {};
var $6353741863f81224e6f569531aad505f$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $6353741863f81224e6f569531aad505f$var$isWindows = $6353741863f81224e6f569531aad505f$var$process.platform === 'win32' || undefined === 'cygwin' || undefined === 'msys';
const $6353741863f81224e6f569531aad505f$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const $6353741863f81224e6f569531aad505f$var$COLON = $6353741863f81224e6f569531aad505f$var$isWindows ? ';' : ':';
// ASSET: node_modules/isexe/windows.js
var $b29a2de5521434531f96c59803bafc88$exports,
    $b29a2de5521434531f96c59803bafc88$var$fs,
    $b29a2de5521434531f96c59803bafc88$executed = false;

function $b29a2de5521434531f96c59803bafc88$var$checkPathExt(path, options) {
  var pathext = options.pathExt !== undefined ? options.pathExt : undefined;

  if (!pathext) {
    return true;
  }

  pathext = pathext.split(';');

  if (pathext.indexOf('') !== -1) {
    return true;
  }

  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase();

    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true;
    }
  }

  return false;
}

function $b29a2de5521434531f96c59803bafc88$var$checkStat(stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false;
  }

  return $b29a2de5521434531f96c59803bafc88$var$checkPathExt(path, options);
}

function $b29a2de5521434531f96c59803bafc88$var$isexe(path, options, cb) {
  $b29a2de5521434531f96c59803bafc88$var$fs.stat(path, function (er, stat) {
    cb(er, er ? false : $b29a2de5521434531f96c59803bafc88$var$checkStat(stat, path, options));
  });
}

function $b29a2de5521434531f96c59803bafc88$var$sync(path, options) {
  return $b29a2de5521434531f96c59803bafc88$var$checkStat($b29a2de5521434531f96c59803bafc88$var$fs.statSync(path), path, options);
}

function $b29a2de5521434531f96c59803bafc88$exec() {
  $b29a2de5521434531f96c59803bafc88$exports = {};
  $b29a2de5521434531f96c59803bafc88$exports = $b29a2de5521434531f96c59803bafc88$var$isexe;
  $b29a2de5521434531f96c59803bafc88$var$isexe.sync = $b29a2de5521434531f96c59803bafc88$var$sync;
  $b29a2de5521434531f96c59803bafc88$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
}

function $b29a2de5521434531f96c59803bafc88$init() {
  if (!$b29a2de5521434531f96c59803bafc88$executed) {
    $b29a2de5521434531f96c59803bafc88$executed = true;
    $b29a2de5521434531f96c59803bafc88$exec();
  }

  return $b29a2de5521434531f96c59803bafc88$exports;
}

// ASSET: node_modules/isexe/mode.js
var $50c3b9278cf9d5acfe446ec9df8fb126$exports,
    $50c3b9278cf9d5acfe446ec9df8fb126$var$process,
    $50c3b9278cf9d5acfe446ec9df8fb126$var$fs,
    $50c3b9278cf9d5acfe446ec9df8fb126$executed = false;

function $50c3b9278cf9d5acfe446ec9df8fb126$var$isexe(path, options, cb) {
  $50c3b9278cf9d5acfe446ec9df8fb126$var$fs.stat(path, function (er, stat) {
    cb(er, er ? false : $50c3b9278cf9d5acfe446ec9df8fb126$var$checkStat(stat, options));
  });
}

function $50c3b9278cf9d5acfe446ec9df8fb126$var$sync(path, options) {
  return $50c3b9278cf9d5acfe446ec9df8fb126$var$checkStat($50c3b9278cf9d5acfe446ec9df8fb126$var$fs.statSync(path), options);
}

function $50c3b9278cf9d5acfe446ec9df8fb126$var$checkStat(stat, options) {
  return stat.isFile() && $50c3b9278cf9d5acfe446ec9df8fb126$var$checkMode(stat, options);
}

function $50c3b9278cf9d5acfe446ec9df8fb126$var$checkMode(stat, options) {
  var mod = stat.mode;
  var uid = stat.uid;
  var gid = stat.gid;
  var myUid = options.uid !== undefined ? options.uid : $50c3b9278cf9d5acfe446ec9df8fb126$var$process.getuid && $50c3b9278cf9d5acfe446ec9df8fb126$var$process.getuid();
  var myGid = options.gid !== undefined ? options.gid : $50c3b9278cf9d5acfe446ec9df8fb126$var$process.getgid && $50c3b9278cf9d5acfe446ec9df8fb126$var$process.getgid();
  var u = parseInt('100', 8);
  var g = parseInt('010', 8);
  var o = parseInt('001', 8);
  var ug = u | g;
  var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
  return ret;
}

function $50c3b9278cf9d5acfe446ec9df8fb126$exec() {
  $50c3b9278cf9d5acfe446ec9df8fb126$exports = {};
  $50c3b9278cf9d5acfe446ec9df8fb126$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  $50c3b9278cf9d5acfe446ec9df8fb126$exports = $50c3b9278cf9d5acfe446ec9df8fb126$var$isexe;
  $50c3b9278cf9d5acfe446ec9df8fb126$var$isexe.sync = $50c3b9278cf9d5acfe446ec9df8fb126$var$sync;
  $50c3b9278cf9d5acfe446ec9df8fb126$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
}

function $50c3b9278cf9d5acfe446ec9df8fb126$init() {
  if (!$50c3b9278cf9d5acfe446ec9df8fb126$executed) {
    $50c3b9278cf9d5acfe446ec9df8fb126$executed = true;
    $50c3b9278cf9d5acfe446ec9df8fb126$exec();
  }

  return $50c3b9278cf9d5acfe446ec9df8fb126$exports;
}

// ASSET: node_modules/isexe/index.js
var $6c4bf8a6651cae33bb3abf7e08f33d18$exports = {};
var $6c4bf8a6651cae33bb3abf7e08f33d18$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $6c4bf8a6651cae33bb3abf7e08f33d18$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
var $6c4bf8a6651cae33bb3abf7e08f33d18$var$core;

if ($6c4bf8a6651cae33bb3abf7e08f33d18$var$process.platform === 'win32' || $parcel$global.TESTING_WINDOWS) {
  $6c4bf8a6651cae33bb3abf7e08f33d18$var$core = $b29a2de5521434531f96c59803bafc88$init();
} else {
  $6c4bf8a6651cae33bb3abf7e08f33d18$var$core = $50c3b9278cf9d5acfe446ec9df8fb126$init();
}

$6c4bf8a6651cae33bb3abf7e08f33d18$exports = $6c4bf8a6651cae33bb3abf7e08f33d18$var$isexe;
$6c4bf8a6651cae33bb3abf7e08f33d18$var$isexe.sync = $6c4bf8a6651cae33bb3abf7e08f33d18$var$sync;

function $6c4bf8a6651cae33bb3abf7e08f33d18$var$isexe(path, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided');
    }

    return new Promise(function (resolve, reject) {
      $6c4bf8a6651cae33bb3abf7e08f33d18$var$isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er);
        } else {
          resolve(is);
        }
      });
    });
  }

  $6c4bf8a6651cae33bb3abf7e08f33d18$var$core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null;
        is = false;
      }
    }

    cb(er, is);
  });
}

function $6c4bf8a6651cae33bb3abf7e08f33d18$var$sync(path, options) {
  // my kingdom for a filtered catch
  try {
    return $6c4bf8a6651cae33bb3abf7e08f33d18$var$core.sync(path, options || {});
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false;
    } else {
      throw er;
    }
  }
}

const $6353741863f81224e6f569531aad505f$var$getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {
  code: 'ENOENT'
});

const $6353741863f81224e6f569531aad505f$var$getPathInfo = (cmd, opt) => {
  const colon = opt.colon || $6353741863f81224e6f569531aad505f$var$COLON; // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || $6353741863f81224e6f569531aad505f$var$isWindows && cmd.match(/\\/) ? [''] : [// windows always checks the cwd first
    // ...(isWindows ? [process.cwd()] : []),
    // ...(opt.path || process.env.PATH ||
    //  /* istanbul ignore next: very unusual */ '').split(colon),
  ];
  const pathExtExe = $6353741863f81224e6f569531aad505f$var$isWindows ? opt.pathExt || undefined || '.EXE;.CMD;.BAT;.COM' : '';
  const pathExt = $6353741863f81224e6f569531aad505f$var$isWindows ? pathExtExe.split(colon) : [''];

  if ($6353741863f81224e6f569531aad505f$var$isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe
  };
};

const $6353741863f81224e6f569531aad505f$var$which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt;
    opt = {};
  }

  if (!opt) opt = {};
  const {
    pathEnv,
    pathExt,
    pathExtExe
  } = $6353741863f81224e6f569531aad505f$var$getPathInfo(cmd, opt);
  const found = [];

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject($6353741863f81224e6f569531aad505f$var$getNotFoundError(cmd));
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = $6353741863f81224e6f569531aad505f$var$path.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    resolve(subStep(p, i, 0));
  });

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length) return resolve(step(i + 1));
    const ext = pathExt[ii];
    $6c4bf8a6651cae33bb3abf7e08f33d18$exports(p + ext, {
      pathExt: pathExtExe
    }, (er, is) => {
      if (!er && is) {
        if (opt.all) found.push(p + ext);else return resolve(p + ext);
      }

      return resolve(subStep(p, i, ii + 1));
    });
  });

  return cb ? step(0).then(res => cb(null, res), cb) : step(0);
};

const $6353741863f81224e6f569531aad505f$var$whichSync = (cmd, opt) => {
  opt = opt || {};
  const {
    pathEnv,
    pathExt,
    pathExtExe
  } = $6353741863f81224e6f569531aad505f$var$getPathInfo(cmd, opt);
  const found = [];

  for (let i = 0; i < pathEnv.length; i++) {
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = $6353741863f81224e6f569531aad505f$var$path.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;

    for (let j = 0; j < pathExt.length; j++) {
      const cur = p + pathExt[j];

      try {
        const is = $6c4bf8a6651cae33bb3abf7e08f33d18$exports.sync(cur, {
          pathExt: pathExtExe
        });

        if (is) {
          if (opt.all) found.push(cur);else return cur;
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length) return found;
  if (opt.nothrow) return null;
  throw $6353741863f81224e6f569531aad505f$var$getNotFoundError(cmd);
};

$6353741863f81224e6f569531aad505f$exports = $6353741863f81224e6f569531aad505f$var$which;
$6353741863f81224e6f569531aad505f$var$which.sync = $6353741863f81224e6f569531aad505f$var$whichSync;
// ASSET: node_modules/path-key/index.js
var $e880b3e764c09689f515c9e4942ed5ce$exports = {};
var $e880b3e764c09689f515c9e4942ed5ce$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

const $e880b3e764c09689f515c9e4942ed5ce$var$pathKey = (options = {}) => {
  const environment = options.env || $e880b3e764c09689f515c9e4942ed5ce$var$process.env;
  const platform = options.platform || $e880b3e764c09689f515c9e4942ed5ce$var$process.platform;

  if (platform !== 'win32') {
    return 'PATH';
  }

  return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

$e880b3e764c09689f515c9e4942ed5ce$exports = $e880b3e764c09689f515c9e4942ed5ce$var$pathKey; // TODO: Remove this for the next major release

var $e880b3e764c09689f515c9e4942ed5ce$export$default = $e880b3e764c09689f515c9e4942ed5ce$var$pathKey;
// TODO: Remove this for the next major release
$e880b3e764c09689f515c9e4942ed5ce$exports.default = $e880b3e764c09689f515c9e4942ed5ce$export$default;

function $eded1b8bf70d7110a376762ac3876d42$var$resolveCommandAttempt(parsed, withoutPathExt) {
  const env = parsed.options.env || $eded1b8bf70d7110a376762ac3876d42$var$process.env;
  const cwd = $eded1b8bf70d7110a376762ac3876d42$var$process.cwd();
  const hasCustomCwd = parsed.options.cwd != null; // Worker threads do not have process.chdir()

  // Worker threads do not have process.chdir()
  const shouldSwitchCwd = hasCustomCwd && $eded1b8bf70d7110a376762ac3876d42$var$process.chdir !== undefined && !$eded1b8bf70d7110a376762ac3876d42$var$process.chdir.disabled; // If a custom `cwd` was specified, we need to change the process cwd
  // because `which` will do stat calls but does not support a custom cwd

  // If a custom `cwd` was specified, we need to change the process cwd
  // because `which` will do stat calls but does not support a custom cwd
  if (shouldSwitchCwd) {
    try {
      $eded1b8bf70d7110a376762ac3876d42$var$process.chdir(parsed.options.cwd);
    } catch (err) {
      /* Empty */
    }
  }

  let resolved;

  try {
    resolved = $6353741863f81224e6f569531aad505f$exports.sync(parsed.command, {
      path: env[$e880b3e764c09689f515c9e4942ed5ce$exports({
        env
      })],
      pathExt: withoutPathExt ? $eded1b8bf70d7110a376762ac3876d42$var$path.delimiter : undefined
    });
  } catch (e) {
    /* Empty */
  } finally {
    if (shouldSwitchCwd) {
      $eded1b8bf70d7110a376762ac3876d42$var$process.chdir(cwd);
    }
  } // If we successfully resolved, ensure that an absolute path is returned
  // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it


  // If we successfully resolved, ensure that an absolute path is returned
  // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
  if (resolved) {
    resolved = $eded1b8bf70d7110a376762ac3876d42$var$path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
  }

  return resolved;
}

function $eded1b8bf70d7110a376762ac3876d42$var$resolveCommand(parsed) {
  return $eded1b8bf70d7110a376762ac3876d42$var$resolveCommandAttempt(parsed) || $eded1b8bf70d7110a376762ac3876d42$var$resolveCommandAttempt(parsed, true);
}

$eded1b8bf70d7110a376762ac3876d42$exports = $eded1b8bf70d7110a376762ac3876d42$var$resolveCommand;
// See http://www.robvanderwoude.com/escapechars.php
const $7b38fd27dbfd89ec94cc6665fc56b777$var$metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function $7b38fd27dbfd89ec94cc6665fc56b777$var$escapeCommand(arg) {
  // Escape meta chars
  arg = arg.replace($7b38fd27dbfd89ec94cc6665fc56b777$var$metaCharsRegExp, '^$1');
  return arg;
}

function $7b38fd27dbfd89ec94cc6665fc56b777$var$escapeArgument(arg, doubleEscapeMetaChars) {
  // Convert to string
  arg = `${arg}`; // Algorithm below is based on https://qntm.org/cmd
  // Sequence of backslashes followed by a double quote:
  // double up all the backslashes and escape the double quote

  // Algorithm below is based on https://qntm.org/cmd
  // Sequence of backslashes followed by a double quote:
  // double up all the backslashes and escape the double quote
  arg = arg.replace(/(\\*)"/g, '$1$1\\"'); // Sequence of backslashes followed by the end of the string
  // (which will become a double quote later):
  // double up all the backslashes

  // Sequence of backslashes followed by the end of the string
  // (which will become a double quote later):
  // double up all the backslashes
  arg = arg.replace(/(\\*)$/, '$1$1'); // All other backslashes occur literally
  // Quote the whole thing:

  // All other backslashes occur literally
  // Quote the whole thing:
  arg = `"${arg}"`; // Escape meta chars

  // Escape meta chars
  arg = arg.replace($7b38fd27dbfd89ec94cc6665fc56b777$var$metaCharsRegExp, '^$1'); // Double escape meta chars if necessary

  // Double escape meta chars if necessary
  if (doubleEscapeMetaChars) {
    arg = arg.replace($7b38fd27dbfd89ec94cc6665fc56b777$var$metaCharsRegExp, '^$1');
  }

  return arg;
}

var $7b38fd27dbfd89ec94cc6665fc56b777$export$command = $7b38fd27dbfd89ec94cc6665fc56b777$var$escapeCommand;
var $7b38fd27dbfd89ec94cc6665fc56b777$export$argument = $7b38fd27dbfd89ec94cc6665fc56b777$var$escapeArgument;
// ASSET: node_modules/cross-spawn/lib/util/readShebang.js
var $b6d9d8a09f4e33bb38ad216ef572f812$exports = {};
var $b6d9d8a09f4e33bb38ad216ef572f812$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
const $b6d9d8a09f4e33bb38ad216ef572f812$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
// ASSET: node_modules/shebang-command/index.js
var $2a8a7f5a5d5b76432d1a6e768b7261bc$exports = {};
// ASSET: node_modules/shebang-regex/index.js
var $75738b9e9ad20788f5fb9cfc8571b318$exports = {};
$75738b9e9ad20788f5fb9cfc8571b318$exports = /^#!(.*)/;

$2a8a7f5a5d5b76432d1a6e768b7261bc$exports = (string = '') => {
  const match = string.match($75738b9e9ad20788f5fb9cfc8571b318$exports);

  if (!match) {
    return null;
  }

  const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
  const binary = path.split('/').pop();

  if (binary === 'env') {
    return argument;
  }

  return argument ? `${binary} ${argument}` : binary;
};

function $b6d9d8a09f4e33bb38ad216ef572f812$var$readShebang(command) {
  // Read the first 150 bytes from the file
  const size = 150;
  const buffer = $b6d9d8a09f4e33bb38ad216ef572f812$var$Buffer.alloc(size);
  let fd;

  try {
    fd = $b6d9d8a09f4e33bb38ad216ef572f812$var$fs.openSync(command, 'r');
    $b6d9d8a09f4e33bb38ad216ef572f812$var$fs.readSync(fd, buffer, 0, size, 0);
    $b6d9d8a09f4e33bb38ad216ef572f812$var$fs.closeSync(fd);
  } catch (e) {
    /* Empty */
  } // Attempt to extract shebang (null is returned if not a shebang)


  // Attempt to extract shebang (null is returned if not a shebang)
  return $2a8a7f5a5d5b76432d1a6e768b7261bc$exports(buffer.toString());
}

$b6d9d8a09f4e33bb38ad216ef572f812$exports = $b6d9d8a09f4e33bb38ad216ef572f812$var$readShebang;
const $305f95dd14f4f5382f14cc45c7d4f3e7$var$isWin = $305f95dd14f4f5382f14cc45c7d4f3e7$var$process.platform === 'win32';
const $305f95dd14f4f5382f14cc45c7d4f3e7$var$isExecutableRegExp = /\.(?:com|exe)$/i;
const $305f95dd14f4f5382f14cc45c7d4f3e7$var$isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function $305f95dd14f4f5382f14cc45c7d4f3e7$var$detectShebang(parsed) {
  parsed.file = $eded1b8bf70d7110a376762ac3876d42$exports(parsed);
  const shebang = parsed.file && $b6d9d8a09f4e33bb38ad216ef572f812$exports(parsed.file);

  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return $eded1b8bf70d7110a376762ac3876d42$exports(parsed);
  }

  return parsed.file;
}

function $305f95dd14f4f5382f14cc45c7d4f3e7$var$parseNonShell(parsed) {
  if (!$305f95dd14f4f5382f14cc45c7d4f3e7$var$isWin) {
    return parsed;
  } // Detect & add support for shebangs


  // Detect & add support for shebangs
  const commandFile = $305f95dd14f4f5382f14cc45c7d4f3e7$var$detectShebang(parsed); // We don't need a shell if the command filename is an executable

  // We don't need a shell if the command filename is an executable
  const needsShell = !$305f95dd14f4f5382f14cc45c7d4f3e7$var$isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly
  // Note that `forceShell` is an hidden option used only in tests

  // If a shell is required, use cmd.exe and take care of escaping everything correctly
  // Note that `forceShell` is an hidden option used only in tests
  if (parsed.options.forceShell || needsShell) {
    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
    // we need to double escape them
    const needsDoubleEscapeMetaChars = $305f95dd14f4f5382f14cc45c7d4f3e7$var$isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
    // This is necessary otherwise it will always fail with ENOENT in those cases

    // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
    // This is necessary otherwise it will always fail with ENOENT in those cases
    parsed.command = $305f95dd14f4f5382f14cc45c7d4f3e7$var$path.normalize(parsed.command); // Escape command & arguments

    // Escape command & arguments
    parsed.command = $7b38fd27dbfd89ec94cc6665fc56b777$export$command(parsed.command);
    parsed.args = parsed.args.map(arg => $7b38fd27dbfd89ec94cc6665fc56b777$export$argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(' ');
    parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
    parsed.command = undefined || 'cmd.exe';
    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
  }

  return parsed;
}

function $305f95dd14f4f5382f14cc45c7d4f3e7$var$parse(command, args, options) {
  // Normalize arguments, similar to nodejs
  if (args && !Array.isArray(args)) {
    options = args;
    args = null;
  }

  args = args ? args.slice(0) : []; // Clone array to avoid changing the original

  // Clone array to avoid changing the original
  options = Object.assign({}, options); // Clone object to avoid changing the original
  // Build our parsed object

  // Clone object to avoid changing the original
  // Build our parsed object
  const parsed = {
    command,
    args,
    options,
    file: undefined,
    original: {
      command,
      args
    }
  }; // Delegate further parsing to shell or non-shell

  // Delegate further parsing to shell or non-shell
  return options.shell ? parsed : $305f95dd14f4f5382f14cc45c7d4f3e7$var$parseNonShell(parsed);
}

$305f95dd14f4f5382f14cc45c7d4f3e7$exports = $305f95dd14f4f5382f14cc45c7d4f3e7$var$parse;
// ASSET: node_modules/cross-spawn/lib/enoent.js
var $5933f00167a4f674d2e7a43606397abc$exports = {};
var $5933f00167a4f674d2e7a43606397abc$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $5933f00167a4f674d2e7a43606397abc$var$isWin = $5933f00167a4f674d2e7a43606397abc$var$process.platform === 'win32';

function $5933f00167a4f674d2e7a43606397abc$var$notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: 'ENOENT',
    errno: 'ENOENT',
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}

function $5933f00167a4f674d2e7a43606397abc$var$hookChildProcess(cp, parsed) {
  if (!$5933f00167a4f674d2e7a43606397abc$var$isWin) {
    return;
  }

  const originalEmit = cp.emit;

  cp.emit = function (name, arg1) {
    // If emitting "exit" event and exit code is 1, we need to check if
    // the command exists and emit an "error" instead
    // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
    if (name === 'exit') {
      const err = $5933f00167a4f674d2e7a43606397abc$var$verifyENOENT(arg1, parsed, 'spawn');

      if (err) {
        return originalEmit.call(cp, 'error', err);
      }
    }

    return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
  };
}

function $5933f00167a4f674d2e7a43606397abc$var$verifyENOENT(status, parsed) {
  if ($5933f00167a4f674d2e7a43606397abc$var$isWin && status === 1 && !parsed.file) {
    return $5933f00167a4f674d2e7a43606397abc$var$notFoundError(parsed.original, 'spawn');
  }

  return null;
}

function $5933f00167a4f674d2e7a43606397abc$var$verifyENOENTSync(status, parsed) {
  if ($5933f00167a4f674d2e7a43606397abc$var$isWin && status === 1 && !parsed.file) {
    return $5933f00167a4f674d2e7a43606397abc$var$notFoundError(parsed.original, 'spawnSync');
  }

  return null;
}

$5933f00167a4f674d2e7a43606397abc$exports = {
  hookChildProcess: $5933f00167a4f674d2e7a43606397abc$var$hookChildProcess,
  verifyENOENT: $5933f00167a4f674d2e7a43606397abc$var$verifyENOENT,
  verifyENOENTSync: $5933f00167a4f674d2e7a43606397abc$var$verifyENOENTSync,
  notFoundError: $5933f00167a4f674d2e7a43606397abc$var$notFoundError
};

function $9e1caa6808b9b77bfb60d20caf7d6ad4$var$spawn(command, args, options) {
  // Parse the arguments
  const parsed = $305f95dd14f4f5382f14cc45c7d4f3e7$exports(command, args, options); // Spawn the child process

  // Spawn the child process
  const spawned = $9e1caa6808b9b77bfb60d20caf7d6ad4$var$cp.spawn(parsed.command, parsed.args, parsed.options); // Hook into child process "exit" event to emit an error if the command
  // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16

  // Hook into child process "exit" event to emit an error if the command
  // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
  $5933f00167a4f674d2e7a43606397abc$exports.hookChildProcess(spawned, parsed);
  return spawned;
}

function $9e1caa6808b9b77bfb60d20caf7d6ad4$var$spawnSync(command, args, options) {
  // Parse the arguments
  const parsed = $305f95dd14f4f5382f14cc45c7d4f3e7$exports(command, args, options); // Spawn the child process

  // Spawn the child process
  const result = $9e1caa6808b9b77bfb60d20caf7d6ad4$var$cp.spawnSync(parsed.command, parsed.args, parsed.options); // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16

  // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
  result.error = result.error || $5933f00167a4f674d2e7a43606397abc$exports.verifyENOENTSync(result.status, parsed);
  return result;
}

$9e1caa6808b9b77bfb60d20caf7d6ad4$exports = $9e1caa6808b9b77bfb60d20caf7d6ad4$var$spawn;
var $9e1caa6808b9b77bfb60d20caf7d6ad4$export$spawn = $9e1caa6808b9b77bfb60d20caf7d6ad4$var$spawn;
$9e1caa6808b9b77bfb60d20caf7d6ad4$exports.spawn = $9e1caa6808b9b77bfb60d20caf7d6ad4$export$spawn;
var $9e1caa6808b9b77bfb60d20caf7d6ad4$export$sync = $9e1caa6808b9b77bfb60d20caf7d6ad4$var$spawnSync;
$9e1caa6808b9b77bfb60d20caf7d6ad4$exports.sync = $9e1caa6808b9b77bfb60d20caf7d6ad4$export$sync;
$9e1caa6808b9b77bfb60d20caf7d6ad4$exports._parse = $305f95dd14f4f5382f14cc45c7d4f3e7$exports;
$9e1caa6808b9b77bfb60d20caf7d6ad4$exports._enoent = $5933f00167a4f674d2e7a43606397abc$exports;
const $a1aaa55bbb549bd0e69fc516a4c245d6$var$cross_spawn_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($9e1caa6808b9b77bfb60d20caf7d6ad4$exports);
var $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy;

(function (EndStrategy) {
  EndStrategy[EndStrategy["Never"] = 0] = "Never";
  EndStrategy[EndStrategy["ErrorCode"] = 1] = "ErrorCode";
  EndStrategy[EndStrategy["Always"] = 2] = "Always";
})($a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy = $a1aaa55bbb549bd0e69fc516a4c245d6$exports.EndStrategy || ($a1aaa55bbb549bd0e69fc516a4c245d6$export$EndStrategy = {}, $a1aaa55bbb549bd0e69fc516a4c245d6$exports.EndStrategy = $a1aaa55bbb549bd0e69fc516a4c245d6$export$EndStrategy));

function $a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stream) {
  // @ts-expect-error: Not sure how to typecheck this field
  return stream !== null && typeof stream.fd === `number`;
}

function $a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintHandler() {// We don't want SIGINT to kill our process; we want it to kill the
  // innermost process, whose end will cause our own to exit.
} // Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.


// Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.
let $a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintRefCount = 0;

async function $a1aaa55bbb549bd0e69fc516a4c245d6$var$pipevp(fileName, args, {
  cwd,
  env = $a1aaa55bbb549bd0e69fc516a4c245d6$var$process.env,
  strict = false,
  stdin = null,
  stdout,
  stderr,
  end = $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy.Always
}) {
  const stdio = [`pipe`, `pipe`, `pipe`];
  if (stdin === null) stdio[0] = `ignore`;else if ($a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stdin)) stdio[0] = stdin;
  if ($a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stdout)) stdio[1] = stdout;
  if ($a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stderr)) stdio[2] = stderr;
  if ($a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintRefCount++ === 0) $a1aaa55bbb549bd0e69fc516a4c245d6$var$process.on(`SIGINT`, $a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintHandler);
  const child = $a1aaa55bbb549bd0e69fc516a4c245d6$var$cross_spawn_1.default(fileName, args, {
    cwd: $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(cwd),
    env: { ...env,
      PWD: $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(cwd)
    },
    stdio
  });
  if (!$a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stdin) && stdin !== null) stdin.pipe(child.stdin);
  if (!$a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stdout)) child.stdout.pipe(stdout, {
    end: false
  });
  if (!$a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stderr)) child.stderr.pipe(stderr, {
    end: false
  });

  const closeStreams = () => {
    for (const stream of new Set([stdout, stderr])) {
      if (!$a1aaa55bbb549bd0e69fc516a4c245d6$var$hasFd(stream)) {
        stream.end();
      }
    }
  };

  return new Promise((resolve, reject) => {
    child.on(`error`, error => {
      if (--$a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintRefCount === 0) $a1aaa55bbb549bd0e69fc516a4c245d6$var$process.off(`SIGINT`, $a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintHandler);
      if (end === $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy.Always || end === $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy.ErrorCode) closeStreams();
      reject(error);
    });
    child.on(`close`, (code, sig) => {
      if (--$a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintRefCount === 0) $a1aaa55bbb549bd0e69fc516a4c245d6$var$process.off(`SIGINT`, $a1aaa55bbb549bd0e69fc516a4c245d6$var$sigintHandler);
      if (end === $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy.Always || end === $a1aaa55bbb549bd0e69fc516a4c245d6$var$EndStrategy.ErrorCode && code > 0) closeStreams();

      if (code === 0 || !strict) {
        resolve({
          code: $a1aaa55bbb549bd0e69fc516a4c245d6$var$getExitCode(code, sig)
        });
      } else if (code !== null) {
        reject(new Error(`Child "${fileName}" exited with exit code ${code}`));
      } else {
        reject(new Error(`Child "${fileName}" exited with signal ${sig}`));
      }
    });
  });
}

var $a1aaa55bbb549bd0e69fc516a4c245d6$export$pipevp = $a1aaa55bbb549bd0e69fc516a4c245d6$var$pipevp;
$a1aaa55bbb549bd0e69fc516a4c245d6$exports.pipevp = $a1aaa55bbb549bd0e69fc516a4c245d6$export$pipevp;

async function $a1aaa55bbb549bd0e69fc516a4c245d6$var$execvp(fileName, args, {
  cwd,
  env = $a1aaa55bbb549bd0e69fc516a4c245d6$var$process.env,
  encoding = `utf8`,
  strict = false
}) {
  const stdio = [`ignore`, `pipe`, `pipe`];
  const stdoutChunks = [];
  const stderrChunks = [];
  const nativeCwd = $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(cwd);
  if (typeof env.PWD !== `undefined`) env = { ...env,
    PWD: nativeCwd
  };
  const subprocess = $a1aaa55bbb549bd0e69fc516a4c245d6$var$cross_spawn_1.default(fileName, args, {
    cwd: nativeCwd,
    env,
    stdio
  });
  subprocess.stdout.on(`data`, chunk => {
    stdoutChunks.push(chunk);
  });
  subprocess.stderr.on(`data`, chunk => {
    stderrChunks.push(chunk);
  });
  return await new Promise((resolve, reject) => {
    subprocess.on(`error`, reject);
    subprocess.on(`close`, (code, signal) => {
      const stdout = encoding === `buffer` ? $a1aaa55bbb549bd0e69fc516a4c245d6$var$Buffer.concat(stdoutChunks) : $a1aaa55bbb549bd0e69fc516a4c245d6$var$Buffer.concat(stdoutChunks).toString(encoding);
      const stderr = encoding === `buffer` ? $a1aaa55bbb549bd0e69fc516a4c245d6$var$Buffer.concat(stderrChunks) : $a1aaa55bbb549bd0e69fc516a4c245d6$var$Buffer.concat(stderrChunks).toString(encoding);

      if (code === 0 || !strict) {
        resolve({
          code: $a1aaa55bbb549bd0e69fc516a4c245d6$var$getExitCode(code, signal),
          stdout,
          stderr
        });
      } else {
        reject(Object.assign(new Error(`Child "${fileName}" exited with exit code ${code}\n\n${stderr}`), {
          code: $a1aaa55bbb549bd0e69fc516a4c245d6$var$getExitCode(code, signal),
          stdout,
          stderr
        }));
      }
    });
  });
}

$a1aaa55bbb549bd0e69fc516a4c245d6$export$execvp = $a1aaa55bbb549bd0e69fc516a4c245d6$var$execvp;
$a1aaa55bbb549bd0e69fc516a4c245d6$exports.execvp = $a1aaa55bbb549bd0e69fc516a4c245d6$export$execvp;
const $a1aaa55bbb549bd0e69fc516a4c245d6$var$signalToCodeMap = new Map([[`SIGINT`, 2], [`SIGQUIT`, 3], [`SIGKILL`, 9], [`SIGTERM`, 15]]);

function $a1aaa55bbb549bd0e69fc516a4c245d6$var$getExitCode(code, signal) {
  const signalCode = $a1aaa55bbb549bd0e69fc516a4c245d6$var$signalToCodeMap.get(signal);

  if (typeof signalCode !== `undefined`) {
    return 128 + signalCode;
  } else {
    return code !== null && code !== void 0 ? code : 1;
  }
}

const $b0ffa420366ed37c7cf8ff798018d16e$var$execUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($a1aaa55bbb549bd0e69fc516a4c245d6$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$execUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$execUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.execUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$execUtils;
// ASSET: node_modules/@yarnpkg/core/lib/folderUtils.js
var $4e053bc37466537c5bd23b074c01d016$exports = {};
var $4e053bc37466537c5bd23b074c01d016$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($4e053bc37466537c5bd23b074c01d016$exports, "__esModule", {
  value: true
});
var $4e053bc37466537c5bd23b074c01d016$export$isFolderInside = ($4e053bc37466537c5bd23b074c01d016$export$getHomeFolder = ($4e053bc37466537c5bd23b074c01d016$export$getDefaultGlobalFolder = void 0, $4e053bc37466537c5bd23b074c01d016$exports.getDefaultGlobalFolder = $4e053bc37466537c5bd23b074c01d016$export$getDefaultGlobalFolder), $4e053bc37466537c5bd23b074c01d016$exports.getHomeFolder = $4e053bc37466537c5bd23b074c01d016$export$getHomeFolder);
$4e053bc37466537c5bd23b074c01d016$exports.isFolderInside = $4e053bc37466537c5bd23b074c01d016$export$isFolderInside;

function $4e053bc37466537c5bd23b074c01d016$var$getDefaultGlobalFolder() {
  if ($4e053bc37466537c5bd23b074c01d016$var$process.platform === `win32`) {
    const base = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(undefined || $ea9c1e38c3e8cca334929a597a084311$exports.npath.join($0bbf89852e2ec8b574a90d9f54bf96d7$export$homedir(), `AppData`, `Local`));
    return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(base, `Yarn/Berry`);
  }

  if (undefined) {
    const base = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(undefined);
    return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(base, `yarn/berry`);
  }

  return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve($4e053bc37466537c5bd23b074c01d016$var$getHomeFolder(), `.yarn/berry`);
}

var $4e053bc37466537c5bd23b074c01d016$export$getDefaultGlobalFolder = $4e053bc37466537c5bd23b074c01d016$var$getDefaultGlobalFolder;
$4e053bc37466537c5bd23b074c01d016$exports.getDefaultGlobalFolder = $4e053bc37466537c5bd23b074c01d016$export$getDefaultGlobalFolder;

function $4e053bc37466537c5bd23b074c01d016$var$getHomeFolder() {
  return $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath($0bbf89852e2ec8b574a90d9f54bf96d7$export$homedir() || `/usr/local/share`);
}

var $4e053bc37466537c5bd23b074c01d016$export$getHomeFolder = $4e053bc37466537c5bd23b074c01d016$var$getHomeFolder;
$4e053bc37466537c5bd23b074c01d016$exports.getHomeFolder = $4e053bc37466537c5bd23b074c01d016$export$getHomeFolder;

function $4e053bc37466537c5bd23b074c01d016$var$isFolderInside(target, parent) {
  const relative = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative(parent, target);
  return relative && !relative.startsWith(`..`) && !$ea9c1e38c3e8cca334929a597a084311$exports.ppath.isAbsolute(relative);
}

$4e053bc37466537c5bd23b074c01d016$export$isFolderInside = $4e053bc37466537c5bd23b074c01d016$var$isFolderInside;
$4e053bc37466537c5bd23b074c01d016$exports.isFolderInside = $4e053bc37466537c5bd23b074c01d016$export$isFolderInside;
const $b0ffa420366ed37c7cf8ff798018d16e$var$folderUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4e053bc37466537c5bd23b074c01d016$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$folderUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$folderUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.folderUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$folderUtils;
// ASSET: node_modules/@yarnpkg/core/lib/formatUtils.js
var $b0a0c0c8655104e8248dfbd97bf5098e$export$Type,
    $b0a0c0c8655104e8248dfbd97bf5098e$export$Style,
    $b0a0c0c8655104e8248dfbd97bf5098e$export$LogLevel,
    $b0a0c0c8655104e8248dfbd97bf5098e$exports = {};
Object.defineProperty($b0a0c0c8655104e8248dfbd97bf5098e$exports, "__esModule", {
  value: true
});
var $b0a0c0c8655104e8248dfbd97bf5098e$export$addLogFilterSupport = ($b0a0c0c8655104e8248dfbd97bf5098e$export$LogLevel = ($b0a0c0c8655104e8248dfbd97bf5098e$export$mark = ($b0a0c0c8655104e8248dfbd97bf5098e$export$json = ($b0a0c0c8655104e8248dfbd97bf5098e$export$prettyList = ($b0a0c0c8655104e8248dfbd97bf5098e$export$pretty = ($b0a0c0c8655104e8248dfbd97bf5098e$export$applyColor = ($b0a0c0c8655104e8248dfbd97bf5098e$export$applyStyle = ($b0a0c0c8655104e8248dfbd97bf5098e$export$tuple = ($b0a0c0c8655104e8248dfbd97bf5098e$export$supportsHyperlinks = ($b0a0c0c8655104e8248dfbd97bf5098e$export$supportsColor = ($b0a0c0c8655104e8248dfbd97bf5098e$export$Style = ($b0a0c0c8655104e8248dfbd97bf5098e$export$Type = void 0, $b0a0c0c8655104e8248dfbd97bf5098e$exports.Type = $b0a0c0c8655104e8248dfbd97bf5098e$export$Type), $b0a0c0c8655104e8248dfbd97bf5098e$exports.Style = $b0a0c0c8655104e8248dfbd97bf5098e$export$Style), $b0a0c0c8655104e8248dfbd97bf5098e$exports.supportsColor = $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsColor), $b0a0c0c8655104e8248dfbd97bf5098e$exports.supportsHyperlinks = $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsHyperlinks), $b0a0c0c8655104e8248dfbd97bf5098e$exports.tuple = $b0a0c0c8655104e8248dfbd97bf5098e$export$tuple), $b0a0c0c8655104e8248dfbd97bf5098e$exports.applyStyle = $b0a0c0c8655104e8248dfbd97bf5098e$export$applyStyle), $b0a0c0c8655104e8248dfbd97bf5098e$exports.applyColor = $b0a0c0c8655104e8248dfbd97bf5098e$export$applyColor), $b0a0c0c8655104e8248dfbd97bf5098e$exports.pretty = $b0a0c0c8655104e8248dfbd97bf5098e$export$pretty), $b0a0c0c8655104e8248dfbd97bf5098e$exports.prettyList = $b0a0c0c8655104e8248dfbd97bf5098e$export$prettyList), $b0a0c0c8655104e8248dfbd97bf5098e$exports.json = $b0a0c0c8655104e8248dfbd97bf5098e$export$json), $b0a0c0c8655104e8248dfbd97bf5098e$exports.mark = $b0a0c0c8655104e8248dfbd97bf5098e$export$mark), $b0a0c0c8655104e8248dfbd97bf5098e$exports.LogLevel = $b0a0c0c8655104e8248dfbd97bf5098e$export$LogLevel);
$b0a0c0c8655104e8248dfbd97bf5098e$exports.addLogFilterSupport = $b0a0c0c8655104e8248dfbd97bf5098e$export$addLogFilterSupport;
// ASSET: node_modules/@yarnpkg/core/node_modules/chalk/source/index.js
var $fa2793b60b4b73ef124cf8f9fb7e368b$exports = {};
// ASSET: node_modules/color-name/index.js
var $9f4f91c012811212cd92aea8fa5a7d18$exports,
    $9f4f91c012811212cd92aea8fa5a7d18$executed = false;

function $9f4f91c012811212cd92aea8fa5a7d18$exec() {
  $9f4f91c012811212cd92aea8fa5a7d18$exports = {};
  $9f4f91c012811212cd92aea8fa5a7d18$exports = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
}

function $9f4f91c012811212cd92aea8fa5a7d18$init() {
  if (!$9f4f91c012811212cd92aea8fa5a7d18$executed) {
    $9f4f91c012811212cd92aea8fa5a7d18$executed = true;
    $9f4f91c012811212cd92aea8fa5a7d18$exec();
  }

  return $9f4f91c012811212cd92aea8fa5a7d18$exports;
}

// ASSET: node_modules/ansi-styles/node_modules/color-convert/conversions.js
var $6068b55a40b1ee8ba7347b73277f7bdb$exports,
    $6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords,
    $6068b55a40b1ee8ba7347b73277f7bdb$var$reverseKeywords,
    $6068b55a40b1ee8ba7347b73277f7bdb$var$convert,
    $6068b55a40b1ee8ba7347b73277f7bdb$executed = false;

function $6068b55a40b1ee8ba7347b73277f7bdb$var$comparativeDistance(x, y) {
  /*
  	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
  */
  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}

function $6068b55a40b1ee8ba7347b73277f7bdb$exec() {
  $6068b55a40b1ee8ba7347b73277f7bdb$exports = {};
  $6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords = $9f4f91c012811212cd92aea8fa5a7d18$init();
  $6068b55a40b1ee8ba7347b73277f7bdb$var$reverseKeywords = {};

  for (const key of Object.keys($6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords)) {
    $6068b55a40b1ee8ba7347b73277f7bdb$var$reverseKeywords[$6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords[key]] = key;
  }

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };
  $6068b55a40b1ee8ba7347b73277f7bdb$exports = $6068b55a40b1ee8ba7347b73277f7bdb$var$convert; // Hide .channels and .labels properties

  // Hide .channels and .labels properties
  for (const model of Object.keys($6068b55a40b1ee8ba7347b73277f7bdb$var$convert)) {
    if (!('channels' in $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model])) {
      throw new Error('missing channels property: ' + model);
    }

    if (!('labels' in $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }

    if ($6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model].labels.length !== $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }

    const {
      channels,
      labels
    } = $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model];
    delete $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model].channels;
    delete $6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model].labels;
    Object.defineProperty($6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty($6068b55a40b1ee8ba7347b73277f7bdb$var$convert[model], 'labels', {
      value: labels
    });
  }

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    const l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);

    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.keyword = function (rgb) {
    const reversed = $6068b55a40b1ee8ba7347b73277f7bdb$var$reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    let currentClosestDistance = Infinity;
    let currentClosestKeyword;

    for (const keyword of Object.keys($6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords)) {
      const value = $6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords[keyword]; // Compute comparative distance

      // Compute comparative distance
      const distance = $6068b55a40b1ee8ba7347b73277f7bdb$var$comparativeDistance(rgb, value); // Check if its less, if so set as closest

      // Check if its less, if so set as closest
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }

    return currentClosestKeyword;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.keyword.rgb = function (keyword) {
    return $6068b55a40b1ee8ba7347b73277f7bdb$var$cssKeywords[keyword];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255; // Assume sRGB

    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.lab = function (rgb) {
    const xyz = $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];

    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f; // Wh + bl cant be > 1

    // Wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    const n = wh + f * (v - wh); // Linear interpolation

    // Linear interpolation
    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */

    /* eslint-disable max-statements-per-line,no-multi-spaces */
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */


    /* eslint-enable max-statements-per-line,no-multi-spaces */
    return [r * 255, g * 255, b * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570; // Assume sRGB

    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    // Hsv -> ansi16 optimization
    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsv.ansi16 = function (args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.ansi16($6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsv.rgb(args), args[2]);
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2]; // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.

    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.ansi16.rgb = function (args) {
    let color = args % 10; // Handle greyscale

    // Handle greyscale
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.ansi256.rgb = function (args) {
    // Handle greyscale
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hex = function (args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    let colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(char => {
        return char + char;
      }).join('');
    }

    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [r, g, b];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */

    /* eslint-disable max-statements-per-line */
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */


    /* eslint-enable max-statements-per-line */
    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.hsv = $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.hsl;

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.gray.hex = function (gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  $6068b55a40b1ee8ba7347b73277f7bdb$var$convert.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
}

function $6068b55a40b1ee8ba7347b73277f7bdb$init() {
  if (!$6068b55a40b1ee8ba7347b73277f7bdb$executed) {
    $6068b55a40b1ee8ba7347b73277f7bdb$executed = true;
    $6068b55a40b1ee8ba7347b73277f7bdb$exec();
  }

  return $6068b55a40b1ee8ba7347b73277f7bdb$exports;
}

// ASSET: node_modules/ansi-styles/node_modules/color-convert/route.js
var $89c43f744e228ec9b15d545167e429c9$exports,
    $89c43f744e228ec9b15d545167e429c9$var$conversions,
    $89c43f744e228ec9b15d545167e429c9$executed = false;

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/
function $89c43f744e228ec9b15d545167e429c9$var$buildGraph() {
  const graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  // https://jsperf.com/object-keys-vs-for-in-with-closure/3
  const models = Object.keys($89c43f744e228ec9b15d545167e429c9$var$conversions);

  for (let len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


// https://en.wikipedia.org/wiki/Breadth-first_search
function $89c43f744e228ec9b15d545167e429c9$var$deriveBFS(fromModel) {
  const graph = $89c43f744e228ec9b15d545167e429c9$var$buildGraph();
  const queue = [fromModel]; // Unshift -> queue -> pop

  // Unshift -> queue -> pop
  graph[fromModel].distance = 0;

  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys($89c43f744e228ec9b15d545167e429c9$var$conversions[current]);

    for (let len = adjacents.length, i = 0; i < len; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function $89c43f744e228ec9b15d545167e429c9$var$link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function $89c43f744e228ec9b15d545167e429c9$var$wrapConversion(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = $89c43f744e228ec9b15d545167e429c9$var$conversions[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = $89c43f744e228ec9b15d545167e429c9$var$link($89c43f744e228ec9b15d545167e429c9$var$conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

function $89c43f744e228ec9b15d545167e429c9$exec() {
  $89c43f744e228ec9b15d545167e429c9$exports = {};
  $89c43f744e228ec9b15d545167e429c9$var$conversions = $6068b55a40b1ee8ba7347b73277f7bdb$init();

  $89c43f744e228ec9b15d545167e429c9$exports = function (fromModel) {
    const graph = $89c43f744e228ec9b15d545167e429c9$var$deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);

    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];

      if (node.parent === null) {
        // No possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = $89c43f744e228ec9b15d545167e429c9$var$wrapConversion(toModel, graph);
    }

    return conversion;
  };
}

function $89c43f744e228ec9b15d545167e429c9$init() {
  if (!$89c43f744e228ec9b15d545167e429c9$executed) {
    $89c43f744e228ec9b15d545167e429c9$executed = true;
    $89c43f744e228ec9b15d545167e429c9$exec();
  }

  return $89c43f744e228ec9b15d545167e429c9$exports;
}

// ASSET: node_modules/ansi-styles/node_modules/color-convert/index.js
var $b87c9bcc844d042c427af90260928d40$exports,
    $b87c9bcc844d042c427af90260928d40$var$conversions,
    $b87c9bcc844d042c427af90260928d40$var$route,
    $b87c9bcc844d042c427af90260928d40$var$convert,
    $b87c9bcc844d042c427af90260928d40$var$models,
    $b87c9bcc844d042c427af90260928d40$executed = false;

function $b87c9bcc844d042c427af90260928d40$var$wrapRaw(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    return fn(args);
  }; // Preserve .conversion property if there is one


  // Preserve .conversion property if there is one
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function $b87c9bcc844d042c427af90260928d40$var$wrapRounded(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    const result = fn(args); // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.
    if (typeof result === 'object') {
      for (let len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // Preserve .conversion property if there is one


  // Preserve .conversion property if there is one
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function $b87c9bcc844d042c427af90260928d40$exec() {
  $b87c9bcc844d042c427af90260928d40$exports = {};
  $b87c9bcc844d042c427af90260928d40$var$conversions = $6068b55a40b1ee8ba7347b73277f7bdb$init();
  $b87c9bcc844d042c427af90260928d40$var$route = $89c43f744e228ec9b15d545167e429c9$init();
  $b87c9bcc844d042c427af90260928d40$var$convert = {};
  $b87c9bcc844d042c427af90260928d40$var$models = Object.keys($b87c9bcc844d042c427af90260928d40$var$conversions);
  $b87c9bcc844d042c427af90260928d40$var$models.forEach(fromModel => {
    $b87c9bcc844d042c427af90260928d40$var$convert[fromModel] = {};
    Object.defineProperty($b87c9bcc844d042c427af90260928d40$var$convert[fromModel], 'channels', {
      value: $b87c9bcc844d042c427af90260928d40$var$conversions[fromModel].channels
    });
    Object.defineProperty($b87c9bcc844d042c427af90260928d40$var$convert[fromModel], 'labels', {
      value: $b87c9bcc844d042c427af90260928d40$var$conversions[fromModel].labels
    });
    const routes = $b87c9bcc844d042c427af90260928d40$var$route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach(toModel => {
      const fn = routes[toModel];
      $b87c9bcc844d042c427af90260928d40$var$convert[fromModel][toModel] = $b87c9bcc844d042c427af90260928d40$var$wrapRounded(fn);
      $b87c9bcc844d042c427af90260928d40$var$convert[fromModel][toModel].raw = $b87c9bcc844d042c427af90260928d40$var$wrapRaw(fn);
    });
  });
  $b87c9bcc844d042c427af90260928d40$exports = $b87c9bcc844d042c427af90260928d40$var$convert;
}

function $b87c9bcc844d042c427af90260928d40$init() {
  if (!$b87c9bcc844d042c427af90260928d40$executed) {
    $b87c9bcc844d042c427af90260928d40$executed = true;
    $b87c9bcc844d042c427af90260928d40$exec();
  }

  return $b87c9bcc844d042c427af90260928d40$exports;
}

// ASSET: node_modules/ansi-styles/index.js
var $a2c6feb3263970c79d50a18a65b7c08d$exports = function () {
  var exports = this;
  var module = {
    exports: this
  };

  const wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\u001B[${code + offset}m`;
  };

  const wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\u001B[${38 + offset};5;${code}m`;
  };

  const wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };

  const ansi2ansi = n => n;

  const rgb2rgb = (r, g, b) => [r, g, b];

  const setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  /** @type {typeof import('color-convert')} */


  /** @type {typeof import('color-convert')} */
  let colorConvert;

  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = $b87c9bcc844d042c427af90260928d40$init();
    }

    const offset = isBackground ? 10 : 0;
    const styles = {};

    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;

      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === 'object') {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }

    return styles;
  };

  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    }; // Alias bright black as gray (and grey)

    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\u001B[${style[0]}m`,
          close: `\u001B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }

    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
    setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
    return styles;
  } // Make the export immutable


  // Make the export immutable
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  return module.exports;
}.call({});

// ASSET: node_modules/@yarnpkg/core/node_modules/supports-color/browser.js
var $25ee314747d78cc7db29032dc7b9da52$exports = {};
$25ee314747d78cc7db29032dc7b9da52$exports = {
  stdout: false,
  stderr: false
};
const {
  stdout: $fa2793b60b4b73ef124cf8f9fb7e368b$var$stdoutColor,
  stderr: $fa2793b60b4b73ef124cf8f9fb7e368b$var$stderrColor
} = $25ee314747d78cc7db29032dc7b9da52$exports;
// ASSET: node_modules/@yarnpkg/core/node_modules/chalk/source/util.js
var $a1baf432464ff3fbfc58a05c81870b6b$exports = {};

const $a1baf432464ff3fbfc58a05c81870b6b$var$stringReplaceAll = (string, substring, replacer) => {
  let index = string.indexOf(substring);

  if (index === -1) {
    return string;
  }

  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = '';

  do {
    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);

  returnValue += string.substr(endIndex);
  return returnValue;
};

const $a1baf432464ff3fbfc58a05c81870b6b$var$stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = '';

  do {
    const gotCR = string[index - 1] === '\r';
    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
    endIndex = index + 1;
    index = string.indexOf('\n', endIndex);
  } while (index !== -1);

  returnValue += string.substr(endIndex);
  return returnValue;
};

$a1baf432464ff3fbfc58a05c81870b6b$exports = {
  stringReplaceAll: $a1baf432464ff3fbfc58a05c81870b6b$var$stringReplaceAll,
  stringEncaseCRLFWithFirstIndex: $a1baf432464ff3fbfc58a05c81870b6b$var$stringEncaseCRLFWithFirstIndex
};
const {
  stringReplaceAll: $fa2793b60b4b73ef124cf8f9fb7e368b$var$stringReplaceAll,
  stringEncaseCRLFWithFirstIndex: $fa2793b60b4b73ef124cf8f9fb7e368b$var$stringEncaseCRLFWithFirstIndex
} = $a1baf432464ff3fbfc58a05c81870b6b$exports; // `supportsColor.level`  `ansiStyles.color[name]` mapping

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const $fa2793b60b4b73ef124cf8f9fb7e368b$var$levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
const $fa2793b60b4b73ef124cf8f9fb7e368b$var$styles = Object.create(null);

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$applyOptions = (object, options = {}) => {
  if (options.level > 3 || options.level < 0) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  } // Detect level if not set manually


  // Detect level if not set manually
  const colorLevel = $fa2793b60b4b73ef124cf8f9fb7e368b$var$stdoutColor ? $fa2793b60b4b73ef124cf8f9fb7e368b$var$stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};

class $fa2793b60b4b73ef124cf8f9fb7e368b$var$ChalkClass {
  constructor(options) {
    return $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalkFactory(options);
  }

}

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalkFactory = options => {
  const chalk = {};
  $fa2793b60b4b73ef124cf8f9fb7e368b$var$applyOptions(chalk, options);

  chalk.template = (...arguments_) => $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalkTag(chalk.template, ...arguments_);

  Object.setPrototypeOf(chalk, $fa2793b60b4b73ef124cf8f9fb7e368b$var$Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);

  chalk.template.constructor = () => {
    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
  };

  chalk.template.Instance = $fa2793b60b4b73ef124cf8f9fb7e368b$var$ChalkClass;
  return chalk.template;
};

function $fa2793b60b4b73ef124cf8f9fb7e368b$var$Chalk(options) {
  return $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalkFactory(options);
}

for (const [styleName, style] of Object.entries($a2c6feb3263970c79d50a18a65b7c08d$exports)) {
  $fa2793b60b4b73ef124cf8f9fb7e368b$var$styles[styleName] = {
    get() {
      const builder = $fa2793b60b4b73ef124cf8f9fb7e368b$var$createBuilder(this, $fa2793b60b4b73ef124cf8f9fb7e368b$var$createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }

  };
}

$fa2793b60b4b73ef124cf8f9fb7e368b$var$styles.visible = {
  get() {
    const builder = $fa2793b60b4b73ef124cf8f9fb7e368b$var$createBuilder(this, this._styler, true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }

};
const $fa2793b60b4b73ef124cf8f9fb7e368b$var$usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of $fa2793b60b4b73ef124cf8f9fb7e368b$var$usedModels) {
  $fa2793b60b4b73ef124cf8f9fb7e368b$var$styles[model] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = $fa2793b60b4b73ef124cf8f9fb7e368b$var$createStyler($a2c6feb3263970c79d50a18a65b7c08d$exports.color[$fa2793b60b4b73ef124cf8f9fb7e368b$var$levelMapping[level]][model](...arguments_), $a2c6feb3263970c79d50a18a65b7c08d$exports.color.close, this._styler);
        return $fa2793b60b4b73ef124cf8f9fb7e368b$var$createBuilder(this, styler, this._isEmpty);
      };
    }

  };
}

for (const model of $fa2793b60b4b73ef124cf8f9fb7e368b$var$usedModels) {
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  $fa2793b60b4b73ef124cf8f9fb7e368b$var$styles[bgModel] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = $fa2793b60b4b73ef124cf8f9fb7e368b$var$createStyler($a2c6feb3263970c79d50a18a65b7c08d$exports.bgColor[$fa2793b60b4b73ef124cf8f9fb7e368b$var$levelMapping[level]][model](...arguments_), $a2c6feb3263970c79d50a18a65b7c08d$exports.bgColor.close, this._styler);
        return $fa2793b60b4b73ef124cf8f9fb7e368b$var$createBuilder(this, styler, this._isEmpty);
      };
    }

  };
}

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$proto = Object.defineProperties(() => {}, { ...$fa2793b60b4b73ef124cf8f9fb7e368b$var$styles,
  level: {
    enumerable: true,

    get() {
      return this._generator.level;
    },

    set(level) {
      this._generator.level = level;
    }

  }
});

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;

  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }

  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    return $fa2793b60b4b73ef124cf8f9fb7e368b$var$applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  }; // `__proto__` is used because we must return a function, but there is
  // no way to create a function with a different prototype


  // `__proto__` is used because we must return a function, but there is
  // no way to create a function with a different prototype
  builder.__proto__ = $fa2793b60b4b73ef124cf8f9fb7e368b$var$proto; // eslint-disable-line no-proto

  // eslint-disable-line no-proto
  builder._generator = self;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self._isEmpty ? '' : string;
  }

  let styler = self._styler;

  if (styler === undefined) {
    return string;
  }

  const {
    openAll,
    closeAll
  } = styler;

  if (string.indexOf('\u001B') !== -1) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = $fa2793b60b4b73ef124cf8f9fb7e368b$var$stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  } // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92


  // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
  const lfIndex = string.indexOf('\n');

  if (lfIndex !== -1) {
    string = $fa2793b60b4b73ef124cf8f9fb7e368b$var$stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }

  return openAll + string + closeAll;
};

let $fa2793b60b4b73ef124cf8f9fb7e368b$var$template;
// ASSET: node_modules/@yarnpkg/core/node_modules/chalk/source/templates.js
var $620a2b17a4ec830cc44d7b11b85c420b$exports,
    $620a2b17a4ec830cc44d7b11b85c420b$var$TEMPLATE_REGEX,
    $620a2b17a4ec830cc44d7b11b85c420b$var$STYLE_REGEX,
    $620a2b17a4ec830cc44d7b11b85c420b$var$STRING_REGEX,
    $620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPE_REGEX,
    $620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPES,
    $620a2b17a4ec830cc44d7b11b85c420b$executed = false;

function $620a2b17a4ec830cc44d7b11b85c420b$var$unescape(c) {
  const u = c[0] === 'u';
  const bracket = c[1] === '{';

  if (u && !bracket && c.length === 5 || c[0] === 'x' && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }

  if (u && bracket) {
    return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
  }

  return $620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPES.get(c) || c;
}

function $620a2b17a4ec830cc44d7b11b85c420b$var$parseArguments(name, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches;

  for (const chunk of chunks) {
    const number = Number(chunk);

    if (!Number.isNaN(number)) {
      results.push(number);
    } else if (matches = chunk.match($620a2b17a4ec830cc44d7b11b85c420b$var$STRING_REGEX)) {
      results.push(matches[2].replace($620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPE_REGEX, (m, escape, character) => escape ? $620a2b17a4ec830cc44d7b11b85c420b$var$unescape(escape) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
  }

  return results;
}

function $620a2b17a4ec830cc44d7b11b85c420b$var$parseStyle(style) {
  $620a2b17a4ec830cc44d7b11b85c420b$var$STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;

  while ((matches = $620a2b17a4ec830cc44d7b11b85c420b$var$STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];

    if (matches[2]) {
      const args = $620a2b17a4ec830cc44d7b11b85c420b$var$parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }

  return results;
}

function $620a2b17a4ec830cc44d7b11b85c420b$var$buildStyle(chalk, styles) {
  const enabled = {};

  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }

  let current = chalk;

  for (const [styleName, styles] of Object.entries(enabled)) {
    if (!Array.isArray(styles)) {
      continue;
    }

    if (!(styleName in current)) {
      throw new Error(`Unknown Chalk style: ${styleName}`);
    }

    current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
  }

  return current;
}

function $620a2b17a4ec830cc44d7b11b85c420b$exec() {
  $620a2b17a4ec830cc44d7b11b85c420b$exports = {};
  $620a2b17a4ec830cc44d7b11b85c420b$var$TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  $620a2b17a4ec830cc44d7b11b85c420b$var$STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  $620a2b17a4ec830cc44d7b11b85c420b$var$STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  $620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;
  $620a2b17a4ec830cc44d7b11b85c420b$var$ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', '\u001B'], ['a', '\u0007']]);

  $620a2b17a4ec830cc44d7b11b85c420b$exports = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = []; // eslint-disable-next-line max-params

    // eslint-disable-next-line max-params
    temporary.replace($620a2b17a4ec830cc44d7b11b85c420b$var$TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push($620a2b17a4ec830cc44d7b11b85c420b$var$unescape(escapeCharacter));
      } else if (style) {
        const string = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? string : $620a2b17a4ec830cc44d7b11b85c420b$var$buildStyle(chalk, styles)(string));
        styles.push({
          inverse,
          styles: $620a2b17a4ec830cc44d7b11b85c420b$var$parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push($620a2b17a4ec830cc44d7b11b85c420b$var$buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
      throw new Error(errMsg);
    }

    return chunks.join('');
  };
}

function $620a2b17a4ec830cc44d7b11b85c420b$init() {
  if (!$620a2b17a4ec830cc44d7b11b85c420b$executed) {
    $620a2b17a4ec830cc44d7b11b85c420b$executed = true;
    $620a2b17a4ec830cc44d7b11b85c420b$exec();
  }

  return $620a2b17a4ec830cc44d7b11b85c420b$exports;
}

const $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalkTag = (chalk, ...strings) => {
  const [firstString] = strings;

  if (!Array.isArray(firstString)) {
    // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(' ');
  }

  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];

  for (let i = 1; i < firstString.length; i++) {
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
  }

  if ($fa2793b60b4b73ef124cf8f9fb7e368b$var$template === undefined) {
    $fa2793b60b4b73ef124cf8f9fb7e368b$var$template = $620a2b17a4ec830cc44d7b11b85c420b$init();
  }

  return $fa2793b60b4b73ef124cf8f9fb7e368b$var$template(chalk, parts.join(''));
};

Object.defineProperties($fa2793b60b4b73ef124cf8f9fb7e368b$var$Chalk.prototype, $fa2793b60b4b73ef124cf8f9fb7e368b$var$styles);
const $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk = $fa2793b60b4b73ef124cf8f9fb7e368b$var$Chalk(); // eslint-disable-line new-cap

// eslint-disable-line new-cap
$fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk.supportsColor = $fa2793b60b4b73ef124cf8f9fb7e368b$var$stdoutColor;
$fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk.stderr = $fa2793b60b4b73ef124cf8f9fb7e368b$var$Chalk({
  level: $fa2793b60b4b73ef124cf8f9fb7e368b$var$stderrColor ? $fa2793b60b4b73ef124cf8f9fb7e368b$var$stderrColor.level : 0
}); // eslint-disable-line new-cap

// eslint-disable-line new-cap
$fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk.stderr.supportsColor = $fa2793b60b4b73ef124cf8f9fb7e368b$var$stderrColor; // For TypeScript

// For TypeScript
$fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk.Level = {
  None: 0,
  Basic: 1,
  Ansi256: 2,
  TrueColor: 3,
  0: 'None',
  1: 'Basic',
  2: 'Ansi256',
  3: 'TrueColor'
};
$fa2793b60b4b73ef124cf8f9fb7e368b$exports = $fa2793b60b4b73ef124cf8f9fb7e368b$var$chalk;
const $b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($fa2793b60b4b73ef124cf8f9fb7e368b$exports);
// ASSET: node_modules/@yarnpkg/core/lib/MessageName.js
var $3d67898ffca54ab381ec6b3d32821fc7$export$MessageName,
    $3d67898ffca54ab381ec6b3d32821fc7$exports = {};
Object.defineProperty($3d67898ffca54ab381ec6b3d32821fc7$exports, "__esModule", {
  value: true
});
var $3d67898ffca54ab381ec6b3d32821fc7$export$stringifyMessageName = ($3d67898ffca54ab381ec6b3d32821fc7$export$MessageName = void 0, $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName = $3d67898ffca54ab381ec6b3d32821fc7$export$MessageName);
$3d67898ffca54ab381ec6b3d32821fc7$exports.stringifyMessageName = $3d67898ffca54ab381ec6b3d32821fc7$export$stringifyMessageName; // The values in this enum should never be reassigned, even if some are removed
// over time (it would mess up the search results, which are the whole point of
// having this system)

// The values in this enum should never be reassigned, even if some are removed
// over time (it would mess up the search results, which are the whole point of
// having this system)
var $3d67898ffca54ab381ec6b3d32821fc7$var$MessageName;

(function (MessageName) {
  MessageName[MessageName["UNNAMED"] = 0] = "UNNAMED";
  MessageName[MessageName["EXCEPTION"] = 1] = "EXCEPTION";
  MessageName[MessageName["MISSING_PEER_DEPENDENCY"] = 2] = "MISSING_PEER_DEPENDENCY";
  MessageName[MessageName["CYCLIC_DEPENDENCIES"] = 3] = "CYCLIC_DEPENDENCIES";
  MessageName[MessageName["DISABLED_BUILD_SCRIPTS"] = 4] = "DISABLED_BUILD_SCRIPTS";
  MessageName[MessageName["BUILD_DISABLED"] = 5] = "BUILD_DISABLED";
  MessageName[MessageName["SOFT_LINK_BUILD"] = 6] = "SOFT_LINK_BUILD";
  MessageName[MessageName["MUST_BUILD"] = 7] = "MUST_BUILD";
  MessageName[MessageName["MUST_REBUILD"] = 8] = "MUST_REBUILD";
  MessageName[MessageName["BUILD_FAILED"] = 9] = "BUILD_FAILED";
  MessageName[MessageName["RESOLVER_NOT_FOUND"] = 10] = "RESOLVER_NOT_FOUND";
  MessageName[MessageName["FETCHER_NOT_FOUND"] = 11] = "FETCHER_NOT_FOUND";
  MessageName[MessageName["LINKER_NOT_FOUND"] = 12] = "LINKER_NOT_FOUND";
  MessageName[MessageName["FETCH_NOT_CACHED"] = 13] = "FETCH_NOT_CACHED";
  MessageName[MessageName["YARN_IMPORT_FAILED"] = 14] = "YARN_IMPORT_FAILED";
  MessageName[MessageName["REMOTE_INVALID"] = 15] = "REMOTE_INVALID";
  MessageName[MessageName["REMOTE_NOT_FOUND"] = 16] = "REMOTE_NOT_FOUND";
  MessageName[MessageName["RESOLUTION_PACK"] = 17] = "RESOLUTION_PACK";
  MessageName[MessageName["CACHE_CHECKSUM_MISMATCH"] = 18] = "CACHE_CHECKSUM_MISMATCH";
  MessageName[MessageName["UNUSED_CACHE_ENTRY"] = 19] = "UNUSED_CACHE_ENTRY";
  MessageName[MessageName["MISSING_LOCKFILE_ENTRY"] = 20] = "MISSING_LOCKFILE_ENTRY";
  MessageName[MessageName["WORKSPACE_NOT_FOUND"] = 21] = "WORKSPACE_NOT_FOUND";
  MessageName[MessageName["TOO_MANY_MATCHING_WORKSPACES"] = 22] = "TOO_MANY_MATCHING_WORKSPACES";
  MessageName[MessageName["CONSTRAINTS_MISSING_DEPENDENCY"] = 23] = "CONSTRAINTS_MISSING_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_DEPENDENCY"] = 24] = "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_DEPENDENCY"] = 25] = "CONSTRAINTS_EXTRANEOUS_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INVALID_DEPENDENCY"] = 26] = "CONSTRAINTS_INVALID_DEPENDENCY";
  MessageName[MessageName["CANT_SUGGEST_RESOLUTIONS"] = 27] = "CANT_SUGGEST_RESOLUTIONS";
  MessageName[MessageName["FROZEN_LOCKFILE_EXCEPTION"] = 28] = "FROZEN_LOCKFILE_EXCEPTION";
  MessageName[MessageName["CROSS_DRIVE_VIRTUAL_LOCAL"] = 29] = "CROSS_DRIVE_VIRTUAL_LOCAL";
  MessageName[MessageName["FETCH_FAILED"] = 30] = "FETCH_FAILED";
  MessageName[MessageName["DANGEROUS_NODE_MODULES"] = 31] = "DANGEROUS_NODE_MODULES";
  MessageName[MessageName["NODE_GYP_INJECTED"] = 32] = "NODE_GYP_INJECTED";
  MessageName[MessageName["AUTHENTICATION_NOT_FOUND"] = 33] = "AUTHENTICATION_NOT_FOUND";
  MessageName[MessageName["INVALID_CONFIGURATION_KEY"] = 34] = "INVALID_CONFIGURATION_KEY";
  MessageName[MessageName["NETWORK_ERROR"] = 35] = "NETWORK_ERROR";
  MessageName[MessageName["LIFECYCLE_SCRIPT"] = 36] = "LIFECYCLE_SCRIPT";
  MessageName[MessageName["CONSTRAINTS_MISSING_FIELD"] = 37] = "CONSTRAINTS_MISSING_FIELD";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_FIELD"] = 38] = "CONSTRAINTS_INCOMPATIBLE_FIELD";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_FIELD"] = 39] = "CONSTRAINTS_EXTRANEOUS_FIELD";
  MessageName[MessageName["CONSTRAINTS_INVALID_FIELD"] = 40] = "CONSTRAINTS_INVALID_FIELD";
  MessageName[MessageName["AUTHENTICATION_INVALID"] = 41] = "AUTHENTICATION_INVALID";
  MessageName[MessageName["PROLOG_UNKNOWN_ERROR"] = 42] = "PROLOG_UNKNOWN_ERROR";
  MessageName[MessageName["PROLOG_SYNTAX_ERROR"] = 43] = "PROLOG_SYNTAX_ERROR";
  MessageName[MessageName["PROLOG_EXISTENCE_ERROR"] = 44] = "PROLOG_EXISTENCE_ERROR";
  MessageName[MessageName["STACK_OVERFLOW_RESOLUTION"] = 45] = "STACK_OVERFLOW_RESOLUTION";
  MessageName[MessageName["AUTOMERGE_FAILED_TO_PARSE"] = 46] = "AUTOMERGE_FAILED_TO_PARSE";
  MessageName[MessageName["AUTOMERGE_IMMUTABLE"] = 47] = "AUTOMERGE_IMMUTABLE";
  MessageName[MessageName["AUTOMERGE_SUCCESS"] = 48] = "AUTOMERGE_SUCCESS";
  MessageName[MessageName["AUTOMERGE_REQUIRED"] = 49] = "AUTOMERGE_REQUIRED";
  MessageName[MessageName["DEPRECATED_CLI_SETTINGS"] = 50] = "DEPRECATED_CLI_SETTINGS";
  MessageName[MessageName["PLUGIN_NAME_NOT_FOUND"] = 51] = "PLUGIN_NAME_NOT_FOUND";
  MessageName[MessageName["INVALID_PLUGIN_REFERENCE"] = 52] = "INVALID_PLUGIN_REFERENCE";
  MessageName[MessageName["CONSTRAINTS_AMBIGUITY"] = 53] = "CONSTRAINTS_AMBIGUITY";
  MessageName[MessageName["CACHE_OUTSIDE_PROJECT"] = 54] = "CACHE_OUTSIDE_PROJECT";
  MessageName[MessageName["IMMUTABLE_INSTALL"] = 55] = "IMMUTABLE_INSTALL";
  MessageName[MessageName["IMMUTABLE_CACHE"] = 56] = "IMMUTABLE_CACHE";
  MessageName[MessageName["INVALID_MANIFEST"] = 57] = "INVALID_MANIFEST";
  MessageName[MessageName["PACKAGE_PREPARATION_FAILED"] = 58] = "PACKAGE_PREPARATION_FAILED";
  MessageName[MessageName["INVALID_RANGE_PEER_DEPENDENCY"] = 59] = "INVALID_RANGE_PEER_DEPENDENCY";
  MessageName[MessageName["INCOMPATIBLE_PEER_DEPENDENCY"] = 60] = "INCOMPATIBLE_PEER_DEPENDENCY";
  MessageName[MessageName["DEPRECATED_PACKAGE"] = 61] = "DEPRECATED_PACKAGE";
  MessageName[MessageName["INCOMPATIBLE_OS"] = 62] = "INCOMPATIBLE_OS";
  MessageName[MessageName["INCOMPATIBLE_CPU"] = 63] = "INCOMPATIBLE_CPU";
  MessageName[MessageName["FROZEN_ARTIFACT_EXCEPTION"] = 64] = "FROZEN_ARTIFACT_EXCEPTION";
  MessageName[MessageName["TELEMETRY_NOTICE"] = 65] = "TELEMETRY_NOTICE";
  MessageName[MessageName["PATCH_HUNK_FAILED"] = 66] = "PATCH_HUNK_FAILED";
  MessageName[MessageName["INVALID_CONFIGURATION_VALUE"] = 67] = "INVALID_CONFIGURATION_VALUE";
  MessageName[MessageName["UNUSED_PACKAGE_EXTENSION"] = 68] = "UNUSED_PACKAGE_EXTENSION";
  MessageName[MessageName["REDUNDANT_PACKAGE_EXTENSION"] = 69] = "REDUNDANT_PACKAGE_EXTENSION";
})($3d67898ffca54ab381ec6b3d32821fc7$var$MessageName = $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName || ($3d67898ffca54ab381ec6b3d32821fc7$export$MessageName = {}, $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName = $3d67898ffca54ab381ec6b3d32821fc7$export$MessageName));

function $3d67898ffca54ab381ec6b3d32821fc7$var$stringifyMessageName(name) {
  return `YN${name.toString(10).padStart(4, `0`)}`;
}

$3d67898ffca54ab381ec6b3d32821fc7$export$stringifyMessageName = $3d67898ffca54ab381ec6b3d32821fc7$var$stringifyMessageName;
$3d67898ffca54ab381ec6b3d32821fc7$exports.stringifyMessageName = $3d67898ffca54ab381ec6b3d32821fc7$export$stringifyMessageName;
// ASSET: node_modules/@yarnpkg/core/lib/miscUtils.js
var $dcb6c32e8116e2ce740eb0f8758d7b31$exports = {};
var $dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($dcb6c32e8116e2ce740eb0f8758d7b31$exports, "__esModule", {
  value: true
});
var $dcb6c32e8116e2ce740eb0f8758d7b31$export$tryParseOptionalBoolean = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$parseOptionalBoolean = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$parseBoolean = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$replaceEnvVariables = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$buildIgnorePattern = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$sortMap = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequireNoCache = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequire = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$DefaultStream = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$BufferStream = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$bufferStream = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifySyncErrors = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifyAsyncErrors = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$releaseAfterUseAsync = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$getMapWithDefault = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$getSetWithDefault = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$getArrayWithDefault = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$getFactoryWithDefault = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$convertMapsToIndexableObjects = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$isIndexableObject = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFind = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFilter = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$validateEnum = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$assertNever = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$overrideType = ($dcb6c32e8116e2ce740eb0f8758d7b31$export$escapeRegExp = void 0, $dcb6c32e8116e2ce740eb0f8758d7b31$exports.escapeRegExp = $dcb6c32e8116e2ce740eb0f8758d7b31$export$escapeRegExp), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.overrideType = $dcb6c32e8116e2ce740eb0f8758d7b31$export$overrideType), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.assertNever = $dcb6c32e8116e2ce740eb0f8758d7b31$export$assertNever), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.validateEnum = $dcb6c32e8116e2ce740eb0f8758d7b31$export$validateEnum), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.mapAndFilter = $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFilter), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.mapAndFind = $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFind), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.isIndexableObject = $dcb6c32e8116e2ce740eb0f8758d7b31$export$isIndexableObject), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.convertMapsToIndexableObjects = $dcb6c32e8116e2ce740eb0f8758d7b31$export$convertMapsToIndexableObjects), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.getFactoryWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getFactoryWithDefault), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.getArrayWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getArrayWithDefault), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.getSetWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getSetWithDefault), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.getMapWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getMapWithDefault), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.releaseAfterUseAsync = $dcb6c32e8116e2ce740eb0f8758d7b31$export$releaseAfterUseAsync), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.prettifyAsyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifyAsyncErrors), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.prettifySyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifySyncErrors), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.bufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$bufferStream), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.BufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$BufferStream), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.DefaultStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$DefaultStream), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.dynamicRequire = $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequire), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.dynamicRequireNoCache = $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequireNoCache), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.sortMap = $dcb6c32e8116e2ce740eb0f8758d7b31$export$sortMap), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.buildIgnorePattern = $dcb6c32e8116e2ce740eb0f8758d7b31$export$buildIgnorePattern), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.replaceEnvVariables = $dcb6c32e8116e2ce740eb0f8758d7b31$export$replaceEnvVariables), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.parseBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseBoolean), $dcb6c32e8116e2ce740eb0f8758d7b31$exports.parseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseOptionalBoolean);
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.tryParseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$tryParseOptionalBoolean;
const $58f473d264f81a9cc788ca133b8fa697$export$UsageError = Error;
// ASSET: node_modules/micromatch/index.js
var $c8e139b8ad76c5430a20f7d24c8c66b6$exports = {};
const $c8e139b8ad76c5430a20f7d24c8c66b6$var$util = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/braces/index.js
var $dd0abcff7fbb508f8d29b21f53ac899d$exports = {};
// ASSET: node_modules/braces/lib/stringify.js
var $0b4411bf6585d648d8d6b45a0f2dd608$exports = {};

var $14c4eeae45f7e3589d77d69102603937$export$isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }

  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }

  return false;
};

var $14c4eeae45f7e3589d77d69102603937$export$exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!$14c4eeae45f7e3589d77d69102603937$export$isInteger(min) || !$14c4eeae45f7e3589d77d69102603937$export$isInteger(max)) return false;
  return (Number(max) - Number(min)) / Number(step) >= limit;
};

var $14c4eeae45f7e3589d77d69102603937$export$encloseBrace = node => {
  if (node.type !== 'brace') return false;

  if (node.commas >> 0 + node.ranges >> 0 === 0) {
    node.invalid = true;
    return true;
  }

  return false;
};

var $14c4eeae45f7e3589d77d69102603937$export$isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;

  if (block.commas >> 0 + block.ranges >> 0 === 0) {
    block.invalid = true;
    return true;
  }

  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }

  return false;
};

var $14c4eeae45f7e3589d77d69102603937$export$isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }

  return node.open === true || node.close === true;
};

var $14c4eeae45f7e3589d77d69102603937$export$reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

var $14c4eeae45f7e3589d77d69102603937$export$flatten = (...args) => {
  const result = [];

  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }

    return result;
  };

  flat(args);
  return result;
};

$0b4411bf6585d648d8d6b45a0f2dd608$exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && $14c4eeae45f7e3589d77d69102603937$export$isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && $14c4eeae45f7e3589d77d69102603937$export$isOpenOrClose(node)) {
        return '\\' + node.value;
      }

      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }

    return output;
  };

  return stringify(ast);
};

// ASSET: node_modules/braces/lib/compile.js
var $54e3a8257f9bd72318a5e2431097f1fd$exports = {};
// ASSET: node_modules/fill-range/index.js
var $b3cc09209b468be8ceea00f2cc592d49$exports = {};
const $b3cc09209b468be8ceea00f2cc592d49$var$util = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/to-regex-range/index.js
var $6cff39b6914d222d22e4895d1cbba41c$exports = {};
// ASSET: node_modules/to-regex-range/node_modules/is-number/index.js
var $d122b37135f639650b49925c68bd852f$exports = {};

$d122b37135f639650b49925c68bd852f$exports = function (num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }

  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }

  return false;
};

const $6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange = (min, max, options) => {
  if ($d122b37135f639650b49925c68bd852f$exports(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if ($d122b37135f639650b49925c68bd852f$exports(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = {
    relaxZeros: true,
    ...options
  };

  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if ($6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return $6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;

    if (opts.capture) {
      return `(${result})`;
    }

    if (opts.wrap === false) {
      return result;
    }

    return `(?:${result})`;
  }

  let isPadded = $6cff39b6914d222d22e4895d1cbba41c$var$hasPadding(min) || $6cff39b6914d222d22e4895d1cbba41c$var$hasPadding(max);
  let state = {
    min,
    max,
    a,
    b
  };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = $6cff39b6914d222d22e4895d1cbba41c$var$splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = $6cff39b6914d222d22e4895d1cbba41c$var$splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = $6cff39b6914d222d22e4895d1cbba41c$var$collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state.result = `(?:${state.result})`;
  }

  $6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function $6cff39b6914d222d22e4895d1cbba41c$var$collatePatterns(neg, pos, options) {
  let onlyNegative = $6cff39b6914d222d22e4895d1cbba41c$var$filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = $6cff39b6914d222d22e4895d1cbba41c$var$filterPatterns(pos, neg, '', false, options) || [];
  let intersected = $6cff39b6914d222d22e4895d1cbba41c$var$filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function $6cff39b6914d222d22e4895d1cbba41c$var$splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;
  let stop = $6cff39b6914d222d22e4895d1cbba41c$var$countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = $6cff39b6914d222d22e4895d1cbba41c$var$countNines(min, nines);
  }

  stop = $6cff39b6914d222d22e4895d1cbba41c$var$countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = $6cff39b6914d222d22e4895d1cbba41c$var$countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort($6cff39b6914d222d22e4895d1cbba41c$var$compare);
  return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */


/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */
function $6cff39b6914d222d22e4895d1cbba41c$var$rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {
      pattern: start,
      count: [],
      digits: 0
    };
  }

  let zipped = $6cff39b6914d222d22e4895d1cbba41c$var$zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;
    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += $6cff39b6914d222d22e4895d1cbba41c$var$toCharacterClass(startDigit, stopDigit, options);
    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return {
    pattern,
    count: [count],
    digits
  };
}

function $6cff39b6914d222d22e4895d1cbba41c$var$splitToPatterns(min, max, tok, options) {
  let ranges = $6cff39b6914d222d22e4895d1cbba41c$var$splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = $6cff39b6914d222d22e4895d1cbba41c$var$rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + $6cff39b6914d222d22e4895d1cbba41c$var$toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = $6cff39b6914d222d22e4895d1cbba41c$var$padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + $6cff39b6914d222d22e4895d1cbba41c$var$toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function $6cff39b6914d222d22e4895d1cbba41c$var$filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let {
      string
    } = ele; // only push if _both_ are negative...

    // only push if _both_ are negative...
    if (!intersection && !$6cff39b6914d222d22e4895d1cbba41c$var$contains(comparison, 'string', string)) {
      result.push(prefix + string);
    } // or _both_ are positive


    // or _both_ are positive
    if (intersection && $6cff39b6914d222d22e4895d1cbba41c$var$contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }

  return result;
}
/**
 * Zip strings
 */


/**
 * Zip strings
 */
function $6cff39b6914d222d22e4895d1cbba41c$var$zip(a, b) {
  let arr = [];

  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);

  return arr;
}

function $6cff39b6914d222d22e4895d1cbba41c$var$compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function $6cff39b6914d222d22e4895d1cbba41c$var$contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function $6cff39b6914d222d22e4895d1cbba41c$var$countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function $6cff39b6914d222d22e4895d1cbba41c$var$countZeros(integer, zeros) {
  return integer - integer % Math.pow(10, zeros);
}

function $6cff39b6914d222d22e4895d1cbba41c$var$toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;

  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }

  return '';
}

function $6cff39b6914d222d22e4895d1cbba41c$var$toCharacterClass(a, b, options) {
  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;
}

function $6cff39b6914d222d22e4895d1cbba41c$var$hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function $6cff39b6914d222d22e4895d1cbba41c$var$padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';

    case 1:
      return relax ? '0?' : '0';

    case 2:
      return relax ? '0{0,2}' : '00';

    default:
      {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
  }
}
/**
 * Cache
 */


/**
 * Cache
 */
$6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.cache = {};

$6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.clearCache = () => $6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange.cache = {};
/**
 * Expose `toRegexRange`
 */


/**
 * Expose `toRegexRange`
 */
$6cff39b6914d222d22e4895d1cbba41c$exports = $6cff39b6914d222d22e4895d1cbba41c$var$toRegexRange;

const $b3cc09209b468be8ceea00f2cc592d49$var$isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const $b3cc09209b468be8ceea00f2cc592d49$var$transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const $b3cc09209b468be8ceea00f2cc592d49$var$isValidValue = value => {
  return typeof value === 'number' || typeof value === 'string' && value !== '';
};

const $b3cc09209b468be8ceea00f2cc592d49$var$isNumber = num => Number.isInteger(+num);

const $b3cc09209b468be8ceea00f2cc592d49$var$zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;

  while (value[++index] === '0');

  return index > 0;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }

  return options.stringify === true;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
  }

  if (toNumber === false) {
    return String(input);
  }

  return input;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';

  if (negative) {
    input = input.slice(1);
    maxLength--;
  }

  while (input.length < maxLength) input = '0' + input;

  return negative ? '-' + input : input;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return $6cff39b6914d222d22e4895d1cbba41c$exports(a, b, {
      wrap: false,
      ...options
    });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;
  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }

  return $6cff39b6914d222d22e4895d1cbba41c$exports(start, end, options);
};

const $b3cc09209b468be8ceea00f2cc592d49$var$rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + $b3cc09209b468be8ceea00f2cc592d49$var$util.inspect(...args));
};

const $b3cc09209b468be8ceea00f2cc592d49$var$invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw $b3cc09209b468be8ceea00f2cc592d49$var$rangeError([start, end]);
  return [];
};

const $b3cc09209b468be8ceea00f2cc592d49$var$invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }

  return [];
};

const $b3cc09209b468be8ceea00f2cc592d49$var$fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw $b3cc09209b468be8ceea00f2cc592d49$var$rangeError([start, end]);
    return [];
  } // fix negative zero


  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;
  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  let padded = $b3cc09209b468be8ceea00f2cc592d49$var$zeros(startString) || $b3cc09209b468be8ceea00f2cc592d49$var$zeros(endString) || $b3cc09209b468be8ceea00f2cc592d49$var$zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && $b3cc09209b468be8ceea00f2cc592d49$var$stringify(start, end, options) === false;
  let format = options.transform || $b3cc09209b468be8ceea00f2cc592d49$var$transform(toNumber);

  if (options.toRegex && step === 1) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$toRange($b3cc09209b468be8ceea00f2cc592d49$var$toMaxLen(start, maxLen), $b3cc09209b468be8ceea00f2cc592d49$var$toMaxLen(end, maxLen), true, options);
  }

  let parts = {
    negatives: [],
    positives: []
  };

  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push($b3cc09209b468be8ceea00f2cc592d49$var$pad(format(a, index), maxLen, toNumber));
    }

    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1 ? $b3cc09209b468be8ceea00f2cc592d49$var$toSequence(parts, options) : $b3cc09209b468be8ceea00f2cc592d49$var$toRegex(range, null, {
      wrap: false,
      ...options
    });
  }

  return range;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$fillLetters = (start, end, step = 1, options = {}) => {
  if (!$b3cc09209b468be8ceea00f2cc592d49$var$isNumber(start) && start.length > 1 || !$b3cc09209b468be8ceea00f2cc592d49$var$isNumber(end) && end.length > 1) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$invalidRange(start, end, options);
  }

  let format = options.transform || (val => String.fromCharCode(val));

  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);
  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$toRegex(range, null, {
      wrap: false,
      options
    });
  }

  return range;
};

const $b3cc09209b468be8ceea00f2cc592d49$var$fill = (start, end, step, options = {}) => {
  if (end == null && $b3cc09209b468be8ceea00f2cc592d49$var$isValidValue(start)) {
    return [start];
  }

  if (!$b3cc09209b468be8ceea00f2cc592d49$var$isValidValue(start) || !$b3cc09209b468be8ceea00f2cc592d49$var$isValidValue(end)) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return $b3cc09209b468be8ceea00f2cc592d49$var$fill(start, end, 1, {
      transform: step
    });
  }

  if ($b3cc09209b468be8ceea00f2cc592d49$var$isObject(step)) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$fill(start, end, 0, step);
  }

  let opts = { ...options
  };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!$b3cc09209b468be8ceea00f2cc592d49$var$isNumber(step)) {
    if (step != null && !$b3cc09209b468be8ceea00f2cc592d49$var$isObject(step)) return $b3cc09209b468be8ceea00f2cc592d49$var$invalidStep(step, opts);
    return $b3cc09209b468be8ceea00f2cc592d49$var$fill(start, end, 1, step);
  }

  if ($b3cc09209b468be8ceea00f2cc592d49$var$isNumber(start) && $b3cc09209b468be8ceea00f2cc592d49$var$isNumber(end)) {
    return $b3cc09209b468be8ceea00f2cc592d49$var$fillNumbers(start, end, step, opts);
  }

  return $b3cc09209b468be8ceea00f2cc592d49$var$fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

$b3cc09209b468be8ceea00f2cc592d49$exports = $b3cc09209b468be8ceea00f2cc592d49$var$fill;

const $54e3a8257f9bd72318a5e2431097f1fd$var$compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = $14c4eeae45f7e3589d77d69102603937$export$isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }

    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? prefix + node.value : '(';
    }

    if (node.type === 'close') {
      return invalid ? prefix + node.value : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = $14c4eeae45f7e3589d77d69102603937$export$reduce(node.nodes);
      let range = $b3cc09209b468be8ceea00f2cc592d49$exports(...args, { ...options,
        wrap: false,
        toRegex: true
      });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }

    return output;
  };

  return walk(ast);
};

$54e3a8257f9bd72318a5e2431097f1fd$exports = $54e3a8257f9bd72318a5e2431097f1fd$var$compile;
// ASSET: node_modules/braces/lib/expand.js
var $60bf9460ec77186db26efe5bd04806ca$exports = {};

const $60bf9460ec77186db26efe5bd04806ca$var$append = (queue = '', stash = '', enclose = false) => {
  let result = [];
  queue = [].concat(queue);
  stash = [].concat(stash);
  if (!stash.length) return queue;

  if (!queue.length) {
    return enclose ? $14c4eeae45f7e3589d77d69102603937$export$flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push($60bf9460ec77186db26efe5bd04806ca$var$append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? $60bf9460ec77186db26efe5bd04806ca$var$append(item, ele, enclose) : item + ele);
      }
    }
  }

  return $14c4eeae45f7e3589d77d69102603937$export$flatten(result);
};

const $60bf9460ec77186db26efe5bd04806ca$var$expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];
    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push($60bf9460ec77186db26efe5bd04806ca$var$append(q.pop(), $0b4411bf6585d648d8d6b45a0f2dd608$exports(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push($60bf9460ec77186db26efe5bd04806ca$var$append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = $14c4eeae45f7e3589d77d69102603937$export$reduce(node.nodes);

      if ($14c4eeae45f7e3589d77d69102603937$export$exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = $b3cc09209b468be8ceea00f2cc592d49$exports(...args, options);

      if (range.length === 0) {
        range = $0b4411bf6585d648d8d6b45a0f2dd608$exports(node, options);
      }

      q.push($60bf9460ec77186db26efe5bd04806ca$var$append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = $14c4eeae45f7e3589d77d69102603937$export$encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push($60bf9460ec77186db26efe5bd04806ca$var$append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push($60bf9460ec77186db26efe5bd04806ca$var$append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return $14c4eeae45f7e3589d77d69102603937$export$flatten(walk(ast));
};

$60bf9460ec77186db26efe5bd04806ca$exports = $60bf9460ec77186db26efe5bd04806ca$var$expand;
// ASSET: node_modules/braces/lib/parse.js
var $64f2efec3e54150f1551115775819a73$exports = {};
// ASSET: node_modules/braces/lib/constants.js
var $763214e0153fe9b7a70c1a4bf6d1eac4$exports = {};
$763214e0153fe9b7a70c1a4bf6d1eac4$exports = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: '0',

  /* 0 */
  CHAR_9: '9',

  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A',

  /* A */
  CHAR_LOWERCASE_A: 'a',

  /* a */
  CHAR_UPPERCASE_Z: 'Z',

  /* Z */
  CHAR_LOWERCASE_Z: 'z',

  /* z */
  CHAR_LEFT_PARENTHESES: '(',

  /* ( */
  CHAR_RIGHT_PARENTHESES: ')',

  /* ) */
  CHAR_ASTERISK: '*',

  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&',

  /* & */
  CHAR_AT: '@',

  /* @ */
  CHAR_BACKSLASH: '\\',

  /* \ */
  CHAR_BACKTICK: '`',

  /* ` */
  CHAR_CARRIAGE_RETURN: '\r',

  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^',

  /* ^ */
  CHAR_COLON: ':',

  /* : */
  CHAR_COMMA: ',',

  /* , */
  CHAR_DOLLAR: '$',

  /* . */
  CHAR_DOT: '.',

  /* . */
  CHAR_DOUBLE_QUOTE: '"',

  /* " */
  CHAR_EQUAL: '=',

  /* = */
  CHAR_EXCLAMATION_MARK: '!',

  /* ! */
  CHAR_FORM_FEED: '\f',

  /* \f */
  CHAR_FORWARD_SLASH: '/',

  /* / */
  CHAR_HASH: '#',

  /* # */
  CHAR_HYPHEN_MINUS: '-',

  /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<',

  /* < */
  CHAR_LEFT_CURLY_BRACE: '{',

  /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[',

  /* [ */
  CHAR_LINE_FEED: '\n',

  /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0',

  /* \u00A0 */
  CHAR_PERCENT: '%',

  /* % */
  CHAR_PLUS: '+',

  /* + */
  CHAR_QUESTION_MARK: '?',

  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>',

  /* > */
  CHAR_RIGHT_CURLY_BRACE: '}',

  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']',

  /* ] */
  CHAR_SEMICOLON: ';',

  /* ; */
  CHAR_SINGLE_QUOTE: '\'',

  /* ' */
  CHAR_SPACE: ' ',

  /*   */
  CHAR_TAB: '\t',

  /* \t */
  CHAR_UNDERSCORE: '_',

  /* _ */
  CHAR_VERTICAL_LINE: '|',

  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF'
  /* \uFEFF */

};

/**
 * Constants
 */
const {
  MAX_LENGTH: $64f2efec3e54150f1551115775819a73$var$MAX_LENGTH,
  CHAR_BACKSLASH: $64f2efec3e54150f1551115775819a73$var$CHAR_BACKSLASH,

  /* \ */
  CHAR_BACKTICK: $64f2efec3e54150f1551115775819a73$var$CHAR_BACKTICK,

  /* ` */
  CHAR_COMMA: $64f2efec3e54150f1551115775819a73$var$CHAR_COMMA,

  /* , */
  CHAR_DOT: $64f2efec3e54150f1551115775819a73$var$CHAR_DOT,

  /* . */
  CHAR_LEFT_PARENTHESES: $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_PARENTHESES,

  /* ( */
  CHAR_RIGHT_PARENTHESES: $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_PARENTHESES,

  /* ) */
  CHAR_LEFT_CURLY_BRACE: $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_CURLY_BRACE,

  /* { */
  CHAR_RIGHT_CURLY_BRACE: $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_CURLY_BRACE,

  /* } */
  CHAR_LEFT_SQUARE_BRACKET: $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_SQUARE_BRACKET,

  /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_SQUARE_BRACKET,

  /* ] */
  CHAR_DOUBLE_QUOTE: $64f2efec3e54150f1551115775819a73$var$CHAR_DOUBLE_QUOTE,

  /* " */
  CHAR_SINGLE_QUOTE: $64f2efec3e54150f1551115775819a73$var$CHAR_SINGLE_QUOTE,

  /* ' */
  CHAR_NO_BREAK_SPACE: $64f2efec3e54150f1551115775819a73$var$CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: $64f2efec3e54150f1551115775819a73$var$CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = $763214e0153fe9b7a70c1a4bf6d1eac4$exports;
/**
 * parse
 */

/**
 * parse
 */
const $64f2efec3e54150f1551115775819a73$var$parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min($64f2efec3e54150f1551115775819a73$var$MAX_LENGTH, opts.maxLength) : $64f2efec3e54150f1551115775819a73$var$MAX_LENGTH;

  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = {
    type: 'root',
    input,
    nodes: []
  };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};
  /**
   * Helpers
   */

  /**
   * Helpers
   */
  const advance = () => input[index++];

  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({
    type: 'bos'
  });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();
    /**
     * Invalid chars
     */

    /**
     * Invalid chars
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === $64f2efec3e54150f1551115775819a73$var$CHAR_NO_BREAK_SPACE) {
      continue;
    }
    /**
     * Escaped chars
     */


    /**
     * Escaped chars
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_BACKSLASH) {
      push({
        type: 'text',
        value: (options.keepEscaping ? value : '') + advance()
      });
      continue;
    }
    /**
     * Right square bracket (literal): ']'
     */


    /**
     * Right square bracket (literal): ']'
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_SQUARE_BRACKET) {
      push({
        type: 'text',
        value: '\\' + value
      });
      continue;
    }
    /**
     * Left square bracket: '['
     */


    /**
     * Left square bracket: '['
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === $64f2efec3e54150f1551115775819a73$var$CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({
        type: 'text',
        value
      });
      continue;
    }
    /**
     * Parentheses
     */


    /**
     * Parentheses
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_PARENTHESES) {
      block = push({
        type: 'paren',
        nodes: []
      });
      stack.push(block);
      push({
        type: 'text',
        value
      });
      continue;
    }

    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({
          type: 'text',
          value
        });
        continue;
      }

      block = stack.pop();
      push({
        type: 'text',
        value
      });
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Quotes: '|"|`
     */


    /**
     * Quotes: '|"|`
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_DOUBLE_QUOTE || value === $64f2efec3e54150f1551115775819a73$var$CHAR_SINGLE_QUOTE || value === $64f2efec3e54150f1551115775819a73$var$CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === $64f2efec3e54150f1551115775819a73$var$CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({
        type: 'text',
        value
      });
      continue;
    }
    /**
     * Left curly brace: '{'
     */


    /**
     * Left curly brace: '{'
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_LEFT_CURLY_BRACE) {
      depth++;
      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block = push(brace);
      stack.push(block);
      push({
        type: 'open',
        value
      });
      continue;
    }
    /**
     * Right curly brace: '}'
     */


    /**
     * Right curly brace: '}'
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({
          type: 'text',
          value
        });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;
      push({
        type,
        value
      });
      depth--;
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Comma: ','
     */


    /**
     * Comma: ','
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, {
          type: 'text',
          value: $0b4411bf6585d648d8d6b45a0f2dd608$exports(block)
        }];
      }

      push({
        type: 'comma',
        value
      });
      block.commas++;
      continue;
    }
    /**
     * Dot: '.'
     */


    /**
     * Dot: '.'
     */
    if (value === $64f2efec3e54150f1551115775819a73$var$CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({
          type: 'text',
          value
        });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();
        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({
        type: 'dot',
        value
      });
      continue;
    }
    /**
     * Text
     */


    /**
     * Text
     */
    push({
      type: 'text',
      value
    });
  } // Mark imbalanced braces and brackets as invalid


  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      }); // get the location of the block on parent.nodes (block's siblings)

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes

      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({
    type: 'eos'
  });
  return ast;
};

$64f2efec3e54150f1551115775819a73$exports = $64f2efec3e54150f1551115775819a73$var$parse;

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */
const $dd0abcff7fbb508f8d29b21f53ac899d$var$braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = $dd0abcff7fbb508f8d29b21f53ac899d$var$braces.create(pattern, options);

      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat($dd0abcff7fbb508f8d29b21f53ac899d$var$braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }

  return output;
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */


/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */
$dd0abcff7fbb508f8d29b21f53ac899d$var$braces.parse = (input, options = {}) => $64f2efec3e54150f1551115775819a73$exports(input, options);
/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
$dd0abcff7fbb508f8d29b21f53ac899d$var$braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return $0b4411bf6585d648d8d6b45a0f2dd608$exports($dd0abcff7fbb508f8d29b21f53ac899d$var$braces.parse(input, options), options);
  }

  return $0b4411bf6585d648d8d6b45a0f2dd608$exports(input, options);
};
/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
$dd0abcff7fbb508f8d29b21f53ac899d$var$braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = $dd0abcff7fbb508f8d29b21f53ac899d$var$braces.parse(input, options);
  }

  return $54e3a8257f9bd72318a5e2431097f1fd$exports(input, options);
};
/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
$dd0abcff7fbb508f8d29b21f53ac899d$var$braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = $dd0abcff7fbb508f8d29b21f53ac899d$var$braces.parse(input, options);
  }

  let result = $60bf9460ec77186db26efe5bd04806ca$exports(input, options); // filter out empty strings if specified

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  } // filter out duplicates if specified


  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};
/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
$dd0abcff7fbb508f8d29b21f53ac899d$var$braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

  return options.expand !== true ? $dd0abcff7fbb508f8d29b21f53ac899d$var$braces.compile(input, options) : $dd0abcff7fbb508f8d29b21f53ac899d$var$braces.expand(input, options);
};
/**
 * Expose "braces"
 */


/**
 * Expose "braces"
 */
$dd0abcff7fbb508f8d29b21f53ac899d$exports = $dd0abcff7fbb508f8d29b21f53ac899d$var$braces;
// ASSET: node_modules/picomatch/index.js
var $e317ddf903547cedea8a0a0c15ed75d8$exports = {};
// ASSET: node_modules/picomatch/lib/picomatch.js
var $b947622a246cf936af5a1aef9434f40c$exports = {};
const $b947622a246cf936af5a1aef9434f40c$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/picomatch/lib/scan.js
var $d6f369032fc58e338a32e7be9898cb41$exports = {};
var $31ff0c9c0dc7333de677031e250e90a2$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $31ff0c9c0dc7333de677031e250e90a2$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const $31ff0c9c0dc7333de677031e250e90a2$var$win32 = $31ff0c9c0dc7333de677031e250e90a2$var$process.platform === 'win32';
// ASSET: node_modules/picomatch/lib/constants.js
var $4345757fb3c93f2eb115814085dc9ee4$exports = {};
const $4345757fb3c93f2eb115814085dc9ee4$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const $4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH = '\\\\/';
const $4345757fb3c93f2eb115814085dc9ee4$var$WIN_NO_SLASH = `[^${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]`;
/**
 * Posix glob regex
 */

/**
 * Posix glob regex
 */
const $4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL = '\\.';
const $4345757fb3c93f2eb115814085dc9ee4$var$PLUS_LITERAL = '\\+';
const $4345757fb3c93f2eb115814085dc9ee4$var$QMARK_LITERAL = '\\?';
const $4345757fb3c93f2eb115814085dc9ee4$var$SLASH_LITERAL = '\\/';
const $4345757fb3c93f2eb115814085dc9ee4$var$ONE_CHAR = '(?=.)';
const $4345757fb3c93f2eb115814085dc9ee4$var$QMARK = '[^/]';
const $4345757fb3c93f2eb115814085dc9ee4$var$END_ANCHOR = `(?:${$4345757fb3c93f2eb115814085dc9ee4$var$SLASH_LITERAL}|$)`;
const $4345757fb3c93f2eb115814085dc9ee4$var$START_ANCHOR = `(?:^|${$4345757fb3c93f2eb115814085dc9ee4$var$SLASH_LITERAL})`;
const $4345757fb3c93f2eb115814085dc9ee4$var$DOTS_SLASH = `${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{1,2}${$4345757fb3c93f2eb115814085dc9ee4$var$END_ANCHOR}`;
const $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOT = `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL})`;
const $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOTS = `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$START_ANCHOR}${$4345757fb3c93f2eb115814085dc9ee4$var$DOTS_SLASH})`;
const $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOT_SLASH = `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{0,1}${$4345757fb3c93f2eb115814085dc9ee4$var$END_ANCHOR})`;
const $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOTS_SLASH = `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOTS_SLASH})`;
const $4345757fb3c93f2eb115814085dc9ee4$var$QMARK_NO_DOT = `[^.${$4345757fb3c93f2eb115814085dc9ee4$var$SLASH_LITERAL}]`;
const $4345757fb3c93f2eb115814085dc9ee4$var$STAR = `${$4345757fb3c93f2eb115814085dc9ee4$var$QMARK}*?`;
const $4345757fb3c93f2eb115814085dc9ee4$var$POSIX_CHARS = {
  DOT_LITERAL: $4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL,
  PLUS_LITERAL: $4345757fb3c93f2eb115814085dc9ee4$var$PLUS_LITERAL,
  QMARK_LITERAL: $4345757fb3c93f2eb115814085dc9ee4$var$QMARK_LITERAL,
  SLASH_LITERAL: $4345757fb3c93f2eb115814085dc9ee4$var$SLASH_LITERAL,
  ONE_CHAR: $4345757fb3c93f2eb115814085dc9ee4$var$ONE_CHAR,
  QMARK: $4345757fb3c93f2eb115814085dc9ee4$var$QMARK,
  END_ANCHOR: $4345757fb3c93f2eb115814085dc9ee4$var$END_ANCHOR,
  DOTS_SLASH: $4345757fb3c93f2eb115814085dc9ee4$var$DOTS_SLASH,
  NO_DOT: $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOT,
  NO_DOTS: $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOTS,
  NO_DOT_SLASH: $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOT_SLASH,
  NO_DOTS_SLASH: $4345757fb3c93f2eb115814085dc9ee4$var$NO_DOTS_SLASH,
  QMARK_NO_DOT: $4345757fb3c93f2eb115814085dc9ee4$var$QMARK_NO_DOT,
  STAR: $4345757fb3c93f2eb115814085dc9ee4$var$STAR,
  START_ANCHOR: $4345757fb3c93f2eb115814085dc9ee4$var$START_ANCHOR
};
/**
 * Windows glob regex
 */

/**
 * Windows glob regex
 */
const $4345757fb3c93f2eb115814085dc9ee4$var$WINDOWS_CHARS = { ...$4345757fb3c93f2eb115814085dc9ee4$var$POSIX_CHARS,
  SLASH_LITERAL: `[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]`,
  QMARK: $4345757fb3c93f2eb115814085dc9ee4$var$WIN_NO_SLASH,
  STAR: `${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{1,2}(?:[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]|$)`,
  NO_DOT: `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}])${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{1,2}(?:[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{0,1}(?:[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${$4345757fb3c93f2eb115814085dc9ee4$var$DOT_LITERAL}{1,2}(?:[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}])`,
  END_ANCHOR: `(?:[${$4345757fb3c93f2eb115814085dc9ee4$var$WIN_SLASH}]|$)`
};
/**
 * POSIX Bracket Regex
 */

/**
 * POSIX Bracket Regex
 */
const $4345757fb3c93f2eb115814085dc9ee4$var$POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};
$4345757fb3c93f2eb115814085dc9ee4$exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: $4345757fb3c93f2eb115814085dc9ee4$var$POSIX_REGEX_SOURCE,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },
  // Digits
  CHAR_0: 48,

  /* 0 */
  CHAR_9: 57,

  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,

  /* A */
  CHAR_LOWERCASE_A: 97,

  /* a */
  CHAR_UPPERCASE_Z: 90,

  /* Z */
  CHAR_LOWERCASE_Z: 122,

  /* z */
  CHAR_LEFT_PARENTHESES: 40,

  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,

  /* ) */
  CHAR_ASTERISK: 42,

  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,

  /* & */
  CHAR_AT: 64,

  /* @ */
  CHAR_BACKWARD_SLASH: 92,

  /* \ */
  CHAR_CARRIAGE_RETURN: 13,

  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,

  /* ^ */
  CHAR_COLON: 58,

  /* : */
  CHAR_COMMA: 44,

  /* , */
  CHAR_DOT: 46,

  /* . */
  CHAR_DOUBLE_QUOTE: 34,

  /* " */
  CHAR_EQUAL: 61,

  /* = */
  CHAR_EXCLAMATION_MARK: 33,

  /* ! */
  CHAR_FORM_FEED: 12,

  /* \f */
  CHAR_FORWARD_SLASH: 47,

  /* / */
  CHAR_GRAVE_ACCENT: 96,

  /* ` */
  CHAR_HASH: 35,

  /* # */
  CHAR_HYPHEN_MINUS: 45,

  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,

  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,

  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,

  /* [ */
  CHAR_LINE_FEED: 10,

  /* \n */
  CHAR_NO_BREAK_SPACE: 160,

  /* \u00A0 */
  CHAR_PERCENT: 37,

  /* % */
  CHAR_PLUS: 43,

  /* + */
  CHAR_QUESTION_MARK: 63,

  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,

  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,

  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,

  /* ] */
  CHAR_SEMICOLON: 59,

  /* ; */
  CHAR_SINGLE_QUOTE: 39,

  /* ' */
  CHAR_SPACE: 32,

  /*   */
  CHAR_TAB: 9,

  /* \t */
  CHAR_UNDERSCORE: 95,

  /* _ */
  CHAR_VERTICAL_LINE: 124,

  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

  /* \uFEFF */
  SEP: $4345757fb3c93f2eb115814085dc9ee4$var$path.sep,

  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(chars) {
    return {
      '!': {
        type: 'negate',
        open: '(?:(?!(?:',
        close: `))${chars.STAR})`
      },
      '?': {
        type: 'qmark',
        open: '(?:',
        close: ')?'
      },
      '+': {
        type: 'plus',
        open: '(?:',
        close: ')+'
      },
      '*': {
        type: 'star',
        open: '(?:',
        close: ')*'
      },
      '@': {
        type: 'at',
        open: '(?:',
        close: ')'
      }
    };
  },

  /**
   * Create GLOB_CHARS
   */
  globChars(win32) {
    return win32 === true ? $4345757fb3c93f2eb115814085dc9ee4$var$WINDOWS_CHARS : $4345757fb3c93f2eb115814085dc9ee4$var$POSIX_CHARS;
  }

};
const {
  REGEX_BACKSLASH: $31ff0c9c0dc7333de677031e250e90a2$var$REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH: $31ff0c9c0dc7333de677031e250e90a2$var$REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS: $31ff0c9c0dc7333de677031e250e90a2$var$REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL: $31ff0c9c0dc7333de677031e250e90a2$var$REGEX_SPECIAL_CHARS_GLOBAL
} = $4345757fb3c93f2eb115814085dc9ee4$exports;

var $31ff0c9c0dc7333de677031e250e90a2$export$isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

var $31ff0c9c0dc7333de677031e250e90a2$export$hasRegexChars = str => $31ff0c9c0dc7333de677031e250e90a2$var$REGEX_SPECIAL_CHARS.test(str);

var $31ff0c9c0dc7333de677031e250e90a2$export$escapeRegex = str => str.replace($31ff0c9c0dc7333de677031e250e90a2$var$REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');

var $31ff0c9c0dc7333de677031e250e90a2$export$toPosixSlashes = str => str.replace($31ff0c9c0dc7333de677031e250e90a2$var$REGEX_BACKSLASH, '/');

var $31ff0c9c0dc7333de677031e250e90a2$export$removeBackslashes = str => {
  return str.replace($31ff0c9c0dc7333de677031e250e90a2$var$REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

var $31ff0c9c0dc7333de677031e250e90a2$export$supportsLookbehinds = () => {
  const segs = $31ff0c9c0dc7333de677031e250e90a2$var$process.version.slice(1).split('.').map(Number);

  if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
    return true;
  }

  return false;
};

var $31ff0c9c0dc7333de677031e250e90a2$export$isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }

  return $31ff0c9c0dc7333de677031e250e90a2$var$win32 === true || $31ff0c9c0dc7333de677031e250e90a2$var$path.sep === '\\';
};

var $31ff0c9c0dc7333de677031e250e90a2$export$escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return $31ff0c9c0dc7333de677031e250e90a2$export$escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

var $31ff0c9c0dc7333de677031e250e90a2$export$removePrefix = (input, state = {}) => {
  let output = input;

  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }

  return output;
};

var $31ff0c9c0dc7333de677031e250e90a2$export$wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';
  let output = `${prepend}(?:${input})${append}`;

  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }

  return output;
};

const {
  CHAR_ASTERISK: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_ASTERISK,

  /* * */
  CHAR_AT: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_AT,

  /* @ */
  CHAR_BACKWARD_SLASH: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH,

  /* \ */
  CHAR_COMMA: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_COMMA,

  /* , */
  CHAR_DOT: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_DOT,

  /* . */
  CHAR_EXCLAMATION_MARK: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_EXCLAMATION_MARK,

  /* ! */
  CHAR_FORWARD_SLASH: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_FORWARD_SLASH,

  /* / */
  CHAR_LEFT_CURLY_BRACE: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_CURLY_BRACE,

  /* { */
  CHAR_LEFT_PARENTHESES: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_PARENTHESES,

  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_SQUARE_BRACKET,

  /* [ */
  CHAR_PLUS: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_PLUS,

  /* + */
  CHAR_QUESTION_MARK: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_QUESTION_MARK,

  /* ? */
  CHAR_RIGHT_CURLY_BRACE: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_CURLY_BRACE,

  /* } */
  CHAR_RIGHT_PARENTHESES: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_PARENTHESES,

  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_SQUARE_BRACKET
  /* ] */

} = $4345757fb3c93f2eb115814085dc9ee4$exports;

const $d6f369032fc58e338a32e7be9898cb41$var$isPathSeparator = code => {
  return code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_FORWARD_SLASH || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH;
};

const $d6f369032fc58e338a32e7be9898cb41$var$depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */


/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */
const $d6f369032fc58e338a32e7be9898cb41$var$scan = (input, options) => {
  const opts = options || {};
  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];
  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = {
    value: '',
    depth: 0,
    isGlob: false
  };

  const eos = () => index >= length;

  const peek = () => str.charCodeAt(index + 1);

  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }

      continue;
    }

    if (braceEscaped === true || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_DOT && (code = advance()) === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = {
        value: '',
        depth: 0,
        isGlob: false
      };
      if (finished === true) continue;

      if (prev === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_DOT && index === start + 1) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_PLUS || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_AT || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_ASTERISK || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_QUESTION_MARK || code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }
    }

    if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_ASTERISK) {
      if (prev === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }
      }
    }

    if (opts.nonegate !== true && code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === $d6f369032fc58e338a32e7be9898cb41$var$CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }

        continue;
      }

      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if ($d6f369032fc58e338a32e7be9898cb41$var$isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = $31ff0c9c0dc7333de677031e250e90a2$export$removeBackslashes(glob);

    if (base && backslashes === true) {
      base = $31ff0c9c0dc7333de677031e250e90a2$export$removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;

    if (!$d6f369032fc58e338a32e7be9898cb41$var$isPathSeparator(code)) {
      tokens.push(token);
    }

    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);

      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }

        $d6f369032fc58e338a32e7be9898cb41$var$depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }

      if (idx !== 0 || value !== '') {
        parts.push(value);
      }

      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        $d6f369032fc58e338a32e7be9898cb41$var$depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

$d6f369032fc58e338a32e7be9898cb41$exports = $d6f369032fc58e338a32e7be9898cb41$var$scan;
// ASSET: node_modules/picomatch/lib/parse.js
var $ff7b922ed06d1c3bda955091c86b169d$exports = {};

/**
 * Constants
 */
const {
  MAX_LENGTH: $ff7b922ed06d1c3bda955091c86b169d$var$MAX_LENGTH,
  POSIX_REGEX_SOURCE: $ff7b922ed06d1c3bda955091c86b169d$var$POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS: $ff7b922ed06d1c3bda955091c86b169d$var$REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF: $ff7b922ed06d1c3bda955091c86b169d$var$REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS: $ff7b922ed06d1c3bda955091c86b169d$var$REPLACEMENTS
} = $4345757fb3c93f2eb115814085dc9ee4$exports;
/**
 * Helpers
 */

/**
 * Helpers
 */
const $ff7b922ed06d1c3bda955091c86b169d$var$expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => $31ff0c9c0dc7333de677031e250e90a2$export$escapeRegex(v)).join('..');
  }

  return value;
};
/**
 * Create the message for a syntax error
 */


/**
 * Create the message for a syntax error
 */
const $ff7b922ed06d1c3bda955091c86b169d$var$syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */


/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */
const $ff7b922ed06d1c3bda955091c86b169d$var$parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = $ff7b922ed06d1c3bda955091c86b169d$var$REPLACEMENTS[input] || input;
  const opts = { ...options
  };
  const max = typeof opts.maxLength === 'number' ? Math.min($ff7b922ed06d1c3bda955091c86b169d$var$MAX_LENGTH, opts.maxLength) : $ff7b922ed06d1c3bda955091c86b169d$var$MAX_LENGTH;
  let len = input.length;

  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = {
    type: 'bos',
    value: '',
    output: opts.prepend || ''
  };
  const tokens = [bos];
  const capture = opts.capture ? '' : '?:';
  const win32 = $31ff0c9c0dc7333de677031e250e90a2$export$isWindows(options); // create constants based on platform, for windows or posix

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = $4345757fb3c93f2eb115814085dc9ee4$exports.globChars(win32);
  const EXTGLOB_CHARS = $4345757fb3c93f2eb115814085dc9ee4$exports.extglobChars(PLATFORM_CHARS);
  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  } // minimatch options support


  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };
  input = $31ff0c9c0dc7333de677031e250e90a2$export$removePrefix(input, state);
  len = input.length;
  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;
  /**
   * Tokenizing helpers
   */

  /**
   * Tokenizing helpers
   */
  const eos = () => state.index === len - 1;

  const peek = state.peek = (n = 1) => input[state.index + n];

  const advance = state.advance = () => input[++state.index];

  const remaining = () => input.slice(state.index + 1);

  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };
  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */


  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */
  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);

    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value],
      conditions: 1,
      inner: ''
    };
    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;
    increment('parens');
    push({
      type,
      value,
      output: state.output ? '' : ONE_CHAR
    });
    push({
      type: 'paren',
      extglob: true,
      value: advance(),
      output
    });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({
      type: 'paren',
      extglob: true,
      value,
      output
    });
    decrement('parens');
  };
  /**
   * Fast paths
   */


  /**
   * Fast paths
   */
  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;
    let output = input.replace($ff7b922ed06d1c3bda955091c86b169d$var$REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }

        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }

        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }

        return star;
      }

      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = $31ff0c9c0dc7333de677031e250e90a2$export$wrapOutput(output, state, options);
    return state;
  }
  /**
   * Tokenize input until we reach end-of-string
   */


  /**
   * Tokenize input until we reach end-of-string
   */
  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }
    /**
     * Escaped characters
     */


    /**
     * Escaped characters
     */
    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({
          type: 'text',
          value
        });
        continue;
      } // collapse slashes to reduce potential for exploits


      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;

        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({
          type: 'text',
          value
        });
        continue;
      }
    }
    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */


    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */
    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);

        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = $ff7b922ed06d1c3bda955091c86b169d$var$POSIX_REGEX_SOURCE[rest];

            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }

              continue;
            }
          }
        }
      }

      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({
        value
      });
      continue;
    }
    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */


    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */
    if (state.quotes === 1 && value !== '"') {
      value = $31ff0c9c0dc7333de677031e250e90a2$export$escapeRegex(value);
      prev.value += value;
      append({
        value
      });
      continue;
    }
    /**
     * Double quotes
     */


    /**
     * Double quotes
     */
    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;

      if (opts.keepQuotes === true) {
        push({
          type: 'text',
          value
        });
      }

      continue;
    }
    /**
     * Parentheses
     */


    /**
     * Parentheses
     */
    if (value === '(') {
      increment('parens');
      push({
        type: 'paren',
        value
      });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];

      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({
        type: 'paren',
        value,
        output: state.parens ? ')' : '\\)'
      });
      decrement('parens');
      continue;
    }
    /**
     * Square brackets
     */


    /**
     * Square brackets
     */
    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({
        type: 'bracket',
        value
      });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
        push({
          type: 'text',
          value,
          output: `\\${value}`
        });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('opening', '['));
        }

        push({
          type: 'text',
          value,
          output: `\\${value}`
        });
        continue;
      }

      decrement('brackets');
      const prevValue = prev.value.slice(1);

      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({
        value
      }); // when literal brackets are explicitly disabled
      // assume we should match with a regex character class

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || $31ff0c9c0dc7333de677031e250e90a2$export$hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = $31ff0c9c0dc7333de677031e250e90a2$export$escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      } // when the user specifies nothing, try to match both


      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }
    /**
     * Braces
     */


    /**
     * Braces
     */
    if (value === '{' && opts.nobrace !== true) {
      increment('braces');
      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };
      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({
          type: 'text',
          value,
          output: value
        });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();

          if (arr[i].type === 'brace') {
            break;
          }

          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = $ff7b922ed06d1c3bda955091c86b169d$var$expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;

        for (const t of toks) {
          state.output += t.output || t.value;
        }
      }

      push({
        type: 'brace',
        value,
        output
      });
      decrement('braces');
      braces.pop();
      continue;
    }
    /**
     * Pipes
     */


    /**
     * Pipes
     */
    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }

      push({
        type: 'text',
        value
      });
      continue;
    }
    /**
     * Commas
     */


    /**
     * Commas
     */
    if (value === ',') {
      let output = value;
      const brace = braces[braces.length - 1];

      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({
        type: 'comma',
        value,
        output
      });
      continue;
    }
    /**
     * Slashes
     */


    /**
     * Slashes
     */
    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token

        // reset "prev" to the first token
        continue;
      }

      push({
        type: 'slash',
        value,
        output: SLASH_LITERAL
      });
      continue;
    }
    /**
     * Dots
     */


    /**
     * Dots
     */
    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({
          type: 'text',
          value,
          output: DOT_LITERAL
        });
        continue;
      }

      push({
        type: 'dot',
        value,
        output: DOT_LITERAL
      });
      continue;
    }
    /**
     * Question marks
     */


    /**
     * Question marks
     */
    if (value === '?') {
      const isGroup = prev && prev.value === '(';

      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !$31ff0c9c0dc7333de677031e250e90a2$export$supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
          output = `\\${value}`;
        }

        push({
          type: 'text',
          value,
          output
        });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({
          type: 'qmark',
          value,
          output: QMARK_NO_DOT
        });
        continue;
      }

      push({
        type: 'qmark',
        value,
        output: QMARK
      });
      continue;
    }
    /**
     * Exclamation
     */


    /**
     * Exclamation
     */
    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }
    /**
     * Plus
     */


    /**
     * Plus
     */
    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if (prev && prev.value === '(' || opts.regex === false) {
        push({
          type: 'plus',
          value,
          output: PLUS_LITERAL
        });
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
        push({
          type: 'plus',
          value
        });
        continue;
      }

      push({
        type: 'plus',
        value: PLUS_LITERAL
      });
      continue;
    }
    /**
     * Plain text
     */


    /**
     * Plain text
     */
    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({
          type: 'at',
          extglob: true,
          value,
          output: ''
        });
        continue;
      }

      push({
        type: 'text',
        value
      });
      continue;
    }
    /**
     * Plain text
     */


    /**
     * Plain text
     */
    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = $ff7b922ed06d1c3bda955091c86b169d$var$REGEX_NON_SPECIAL_CHARS.exec(remaining());

      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({
        type: 'text',
        value
      });
      continue;
    }
    /**
     * Stars
     */


    /**
     * Stars
     */
    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();

    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
        push({
          type: 'star',
          value,
          output: ''
        });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({
          type: 'star',
          value,
          output: ''
        });
        continue;
      } // strip consecutive `/**/`


      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];

        if (after && after !== '/') {
          break;
        }

        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;
        state.output += prior.output + prev.output;
        state.globstar = true;
        consume(value + advance());
        push({
          type: 'slash',
          value: '/',
          output: ''
        });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({
          type: 'slash',
          value: '/',
          output: ''
        });
        continue;
      } // remove single star from output


      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value; // reset output with globstar

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = {
      type: 'star',
      value,
      output: star
    };

    if (opts.bash === true) {
      token.output = '.*?';

      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }

      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;
      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;
      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('closing', ']'));
    state.output = $31ff0c9c0dc7333de677031e250e90a2$export$escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('closing', ')'));
    state.output = $31ff0c9c0dc7333de677031e250e90a2$export$escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError($ff7b922ed06d1c3bda955091c86b169d$var$syntaxError('closing', '}'));
    state.output = $31ff0c9c0dc7333de677031e250e90a2$export$escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({
      type: 'maybe_slash',
      value: '',
      output: `${SLASH_LITERAL}?`
    });
  } // rebuild the output if we had to backtrack at any point


  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */


/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */
$ff7b922ed06d1c3bda955091c86b169d$var$parse.fastpaths = (input, options) => {
  const opts = { ...options
  };
  const max = typeof opts.maxLength === 'number' ? Math.min($ff7b922ed06d1c3bda955091c86b169d$var$MAX_LENGTH, opts.maxLength) : $ff7b922ed06d1c3bda955091c86b169d$var$MAX_LENGTH;
  const len = input.length;

  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = $ff7b922ed06d1c3bda955091c86b169d$var$REPLACEMENTS[input] || input;
  const win32 = $31ff0c9c0dc7333de677031e250e90a2$export$isWindows(options); // create constants based on platform, for windows or posix

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = $4345757fb3c93f2eb115814085dc9ee4$exports.globChars(win32);
  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = {
    negated: false,
    prefix: ''
  };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default:
        {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match) return;
          const source = create(match[1]);
          if (!source) return;
          return source + DOT_LITERAL + match[2];
        }
    }
  };

  const output = $31ff0c9c0dc7333de677031e250e90a2$export$removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

$ff7b922ed06d1c3bda955091c86b169d$exports = $ff7b922ed06d1c3bda955091c86b169d$var$parse;

const $b947622a246cf936af5a1aef9434f40c$var$isObject = val => val && typeof val === 'object' && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */


/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */
const $b947622a246cf936af5a1aef9434f40c$var$picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => $b947622a246cf936af5a1aef9434f40c$var$picomatch(input, options, returnState));

    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }

      return false;
    };

    return arrayMatcher;
  }

  const isState = $b947622a246cf936af5a1aef9434f40c$var$isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || typeof glob !== 'string' && !isState) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = $31ff0c9c0dc7333de677031e250e90a2$export$isWindows(options);
  const regex = isState ? $b947622a246cf936af5a1aef9434f40c$var$picomatch.compileRe(glob, options) : $b947622a246cf936af5a1aef9434f40c$var$picomatch.makeRe(glob, options, false, true);
  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;

  if (opts.ignore) {
    const ignoreOpts = { ...options,
      ignore: null,
      onMatch: null,
      onResult: null
    };
    isIgnored = $b947622a246cf936af5a1aef9434f40c$var$picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const {
      isMatch,
      match,
      output
    } = $b947622a246cf936af5a1aef9434f40c$var$picomatch.test(input, regex, options, {
      glob,
      posix
    });
    const result = {
      glob,
      state,
      regex,
      posix,
      input,
      output,
      match,
      isMatch
    };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }

      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }

    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */


/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.test = (input, regex, options, {
  glob,
  posix
} = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return {
      isMatch: false,
      output: ''
    };
  }

  const opts = options || {};
  const format = opts.format || (posix ? $31ff0c9c0dc7333de677031e250e90a2$export$toPosixSlashes : null);
  let match = input === glob;
  let output = match && format ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = $b947622a246cf936af5a1aef9434f40c$var$picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return {
    isMatch: Boolean(match),
    match,
    output
  };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */


/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.matchBase = (input, glob, options, posix = $31ff0c9c0dc7333de677031e250e90a2$export$isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : $b947622a246cf936af5a1aef9434f40c$var$picomatch.makeRe(glob, options);
  return regex.test($b947622a246cf936af5a1aef9434f40c$var$path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.isMatch = (str, patterns, options) => $b947622a246cf936af5a1aef9434f40c$var$picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */


/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => $b947622a246cf936af5a1aef9434f40c$var$picomatch.parse(p, options));
  return $ff7b922ed06d1c3bda955091c86b169d$exports(pattern, { ...options,
    fastpaths: false
  });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */


/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.scan = (input, options) => $d6f369032fc58e338a32e7be9898cb41$exports(input, options);
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */


/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';
  let source = `${prepend}(?:${parsed.output})${append}`;

  if (parsed && parsed.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = $b947622a246cf936af5a1aef9434f40c$var$picomatch.toRegex(source, options);

  if (returnState === true) {
    regex.state = parsed;
  }

  return regex;
};

$b947622a246cf936af5a1aef9434f40c$var$picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = {
    negated: false,
    fastpaths: true
  };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = $ff7b922ed06d1c3bda955091c86b169d$exports.fastpaths(input, options);
  }

  if (output === undefined) {
    parsed = $ff7b922ed06d1c3bda955091c86b169d$exports(input, options);
    parsed.prefix = prefix + (parsed.prefix || '');
  } else {
    parsed.output = output;
  }

  return $b947622a246cf936af5a1aef9434f40c$var$picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */


/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};
/**
 * Picomatch constants.
 * @return {Object}
 */


/**
 * Picomatch constants.
 * @return {Object}
 */
$b947622a246cf936af5a1aef9434f40c$var$picomatch.constants = $4345757fb3c93f2eb115814085dc9ee4$exports;
/**
 * Expose "picomatch"
 */

/**
 * Expose "picomatch"
 */
$b947622a246cf936af5a1aef9434f40c$exports = $b947622a246cf936af5a1aef9434f40c$var$picomatch;
$e317ddf903547cedea8a0a0c15ed75d8$exports = $b947622a246cf936af5a1aef9434f40c$exports;

const $c8e139b8ad76c5430a20f7d24c8c66b6$var$isEmptyString = val => typeof val === 'string' && (val === '' || val === './');
/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */


/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */
const $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);
  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);

    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = $e317ddf903547cedea8a0a0c15ed75d8$exports(String(patterns[i]), { ...options,
      onResult
    }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);
      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};
/**
 * Backwards compatibility
 */


/**
 * Backwards compatibility
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.match = $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch;
/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.matcher = (pattern, options) => $e317ddf903547cedea8a0a0c15ed75d8$exports(pattern, options);
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.isMatch = (str, patterns, options) => $e317ddf903547cedea8a0a0c15ed75d8$exports(patterns, options)(str);
/**
 * Backwards compatibility
 */


/**
 * Backwards compatibility
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.any = $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.isMatch;
/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch(list, patterns, { ...options,
    onResult
  });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }

  return [...result];
};
/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */


/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${$c8e139b8ad76c5430a20f7d24c8c66b6$var$util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if ($c8e139b8ad76c5430a20f7d24c8c66b6$var$isEmptyString(str) || $c8e139b8ad76c5430a20f7d24c8c66b6$var$isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
      return true;
    }
  }

  return $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.isMatch(str, pattern, { ...options,
    contains: true
  });
};
/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */


/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.matchKeys = (obj, patterns, options) => {
  if (!$31ff0c9c0dc7333de677031e250e90a2$export$isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }

  let keys = $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch(Object.keys(obj), patterns, options);
  let res = {};

  for (let key of keys) res[key] = obj[key];

  return res;
};
/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = $e317ddf903547cedea8a0a0c15ed75d8$exports(String(pattern), options);

    if (items.some(item => isMatch(item))) {
      return true;
    }
  }

  return false;
};
/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = $e317ddf903547cedea8a0a0c15ed75d8$exports(String(pattern), options);

    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }

  return true;
};
/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${$c8e139b8ad76c5430a20f7d24c8c66b6$var$util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => $e317ddf903547cedea8a0a0c15ed75d8$exports(p, options)(str));
};
/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */


/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.capture = (glob, input, options) => {
  let posix = $31ff0c9c0dc7333de677031e250e90a2$export$isWindows(options);
  let regex = $e317ddf903547cedea8a0a0c15ed75d8$exports.makeRe(String(glob), { ...options,
    capture: true
  });
  let match = regex.exec(posix ? $31ff0c9c0dc7333de677031e250e90a2$export$toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};
/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */


/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.makeRe = (...args) => $e317ddf903547cedea8a0a0c15ed75d8$exports.makeRe(...args);
/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */


/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.scan = (...args) => $e317ddf903547cedea8a0a0c15ed75d8$exports.scan(...args);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */


/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.parse = (patterns, options) => {
  let res = [];

  for (let pattern of [].concat(patterns || [])) {
    for (let str of $dd0abcff7fbb508f8d29b21f53ac899d$exports(String(pattern), options)) {
      res.push($e317ddf903547cedea8a0a0c15ed75d8$exports.parse(str, options));
    }
  }

  return res;
};
/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */


/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');

  if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }

  return $dd0abcff7fbb508f8d29b21f53ac899d$exports(pattern, options);
};
/**
 * Expand braces
 */


/**
 * Expand braces
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch.braces(pattern, { ...options,
    expand: true
  });
};
/**
 * Expose micromatch
 */


/**
 * Expose micromatch
 */
$c8e139b8ad76c5430a20f7d24c8c66b6$exports = $c8e139b8ad76c5430a20f7d24c8c66b6$var$micromatch;
const $dcb6c32e8116e2ce740eb0f8758d7b31$var$micromatch_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($c8e139b8ad76c5430a20f7d24c8c66b6$exports);

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$escapeRegExp = $dcb6c32e8116e2ce740eb0f8758d7b31$var$escapeRegExp;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.escapeRegExp = $dcb6c32e8116e2ce740eb0f8758d7b31$export$escapeRegExp;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$overrideType(val) {}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$overrideType = $dcb6c32e8116e2ce740eb0f8758d7b31$var$overrideType;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.overrideType = $dcb6c32e8116e2ce740eb0f8758d7b31$export$overrideType;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$assertNever(arg) {
  throw new Error(`Assertion failed: Unexpected object '${arg}'`);
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$assertNever = $dcb6c32e8116e2ce740eb0f8758d7b31$var$assertNever;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.assertNever = $dcb6c32e8116e2ce740eb0f8758d7b31$export$assertNever;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$validateEnum(def, value) {
  if (!Object.values(def).includes(value)) throw new Error(`Assertion failed: Invalid value for enumeration`);
  return value;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$validateEnum = $dcb6c32e8116e2ce740eb0f8758d7b31$var$validateEnum;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.validateEnum = $dcb6c32e8116e2ce740eb0f8758d7b31$export$validateEnum;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilter(iterable, cb) {
  const output = [];

  for (const value of iterable) {
    const out = cb(value);

    if (out !== $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilterSkip) {
      output.push(out);
    }
  }

  return output;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFilter = $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilter;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.mapAndFilter = $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFilter;
const $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilterSkip = Symbol();
$dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilter.skip = $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFilterSkip;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFind(iterable, cb) {
  for (const value of iterable) {
    const out = cb(value);

    if (out !== $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFindSkip) {
      return out;
    }
  }

  return undefined;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFind = $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFind;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.mapAndFind = $dcb6c32e8116e2ce740eb0f8758d7b31$export$mapAndFind;
const $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFindSkip = Symbol();
$dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFind.skip = $dcb6c32e8116e2ce740eb0f8758d7b31$var$mapAndFindSkip;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$isIndexableObject(value) {
  return typeof value === `object` && value !== null;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$isIndexableObject = $dcb6c32e8116e2ce740eb0f8758d7b31$var$isIndexableObject;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.isIndexableObject = $dcb6c32e8116e2ce740eb0f8758d7b31$export$isIndexableObject;
/**
 * Converts Maps to indexable objects recursively.
 */

/**
 * Converts Maps to indexable objects recursively.
 */
function $dcb6c32e8116e2ce740eb0f8758d7b31$var$convertMapsToIndexableObjects(arg) {
  if (arg instanceof Map) arg = Object.fromEntries(arg);

  if ($dcb6c32e8116e2ce740eb0f8758d7b31$var$isIndexableObject(arg)) {
    for (const key of Object.keys(arg)) {
      const value = arg[key];

      if ($dcb6c32e8116e2ce740eb0f8758d7b31$var$isIndexableObject(value)) {
        // @ts-expect-error: Apparently nothing in this world can be used to index type 'T & { [key: string]: unknown; }'
        arg[key] = $dcb6c32e8116e2ce740eb0f8758d7b31$var$convertMapsToIndexableObjects(value);
      }
    }
  }

  return arg;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$convertMapsToIndexableObjects = $dcb6c32e8116e2ce740eb0f8758d7b31$var$convertMapsToIndexableObjects;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.convertMapsToIndexableObjects = $dcb6c32e8116e2ce740eb0f8758d7b31$export$convertMapsToIndexableObjects;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$getFactoryWithDefault(map, key, factory) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = factory());
  return value;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$getFactoryWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$var$getFactoryWithDefault;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.getFactoryWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getFactoryWithDefault;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$getArrayWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = []);
  return value;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$getArrayWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$var$getArrayWithDefault;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.getArrayWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getArrayWithDefault;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$getSetWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Set());
  return value;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$getSetWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$var$getSetWithDefault;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.getSetWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getSetWithDefault;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$getMapWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Map());
  return value;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$getMapWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$var$getMapWithDefault;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.getMapWithDefault = $dcb6c32e8116e2ce740eb0f8758d7b31$export$getMapWithDefault; // Executes a chunk of code and calls a cleanup function once it returns (even
// if it throws an exception)

// Executes a chunk of code and calls a cleanup function once it returns (even
// if it throws an exception)
async function $dcb6c32e8116e2ce740eb0f8758d7b31$var$releaseAfterUseAsync(fn, cleanup) {
  if (cleanup == null) return await fn();

  try {
    return await fn();
  } finally {
    await cleanup();
  }
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$releaseAfterUseAsync = $dcb6c32e8116e2ce740eb0f8758d7b31$var$releaseAfterUseAsync;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.releaseAfterUseAsync = $dcb6c32e8116e2ce740eb0f8758d7b31$export$releaseAfterUseAsync; // Executes a chunk of code but slightly modify its exception message if it
// throws something

// Executes a chunk of code but slightly modify its exception message if it
// throws something
async function $dcb6c32e8116e2ce740eb0f8758d7b31$var$prettifyAsyncErrors(fn, update) {
  try {
    return await fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifyAsyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$var$prettifyAsyncErrors;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.prettifyAsyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifyAsyncErrors; // Same thing but synchronous

// Same thing but synchronous
function $dcb6c32e8116e2ce740eb0f8758d7b31$var$prettifySyncErrors(fn, update) {
  try {
    return fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifySyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$var$prettifySyncErrors;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.prettifySyncErrors = $dcb6c32e8116e2ce740eb0f8758d7b31$export$prettifySyncErrors; // Converts a Node stream into a Buffer instance

// Converts a Node stream into a Buffer instance
async function $dcb6c32e8116e2ce740eb0f8758d7b31$var$bufferStream(stream) {
  return await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`data`, chunk => {
      chunks.push(chunk);
    });
    stream.on(`end`, () => {
      resolve($dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer.concat(chunks));
    });
  });
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$bufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$var$bufferStream;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.bufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$bufferStream; // A stream implementation that buffers a stream to send it all at once

// A stream implementation that buffers a stream to send it all at once
class $dcb6c32e8116e2ce740eb0f8758d7b31$var$BufferStream extends $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform {
  constructor() {
    super(...arguments);
    this.chunks = [];
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !$dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: BufferStream only accept buffers`);
    this.chunks.push(chunk);
    cb(null, null);
  }

  _flush(cb) {
    cb(null, $dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer.concat(this.chunks));
  }

}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$BufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$var$BufferStream;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.BufferStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$BufferStream; // A stream implementation that prints a message if nothing was output

// A stream implementation that prints a message if nothing was output
class $dcb6c32e8116e2ce740eb0f8758d7b31$var$DefaultStream extends $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform {
  constructor(ifEmpty = $dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer.alloc(0)) {
    super();
    this.active = true;
    this.ifEmpty = ifEmpty;
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !$dcb6c32e8116e2ce740eb0f8758d7b31$var$Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: DefaultStream only accept buffers`);
    this.active = false;
    cb(null, chunk);
  }

  _flush(cb) {
    if (this.active && this.ifEmpty.length > 0) {
      cb(null, this.ifEmpty);
    }
  }

}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$DefaultStream = $dcb6c32e8116e2ce740eb0f8758d7b31$var$DefaultStream;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.DefaultStream = $dcb6c32e8116e2ce740eb0f8758d7b31$export$DefaultStream; // Webpack has this annoying tendency to replace dynamic requires by a stub
// code that simply throws when called. It's all fine and dandy in the context
// of a web application, but is quite annoying when working with Node projects!

// Webpack has this annoying tendency to replace dynamic requires by a stub
// code that simply throws when called. It's all fine and dandy in the context
// of a web application, but is quite annoying when working with Node projects!
function $dcb6c32e8116e2ce740eb0f8758d7b31$var$dynamicRequire(path) {
  // @ts-expect-error
  if (typeof __non_webpack_require__ !== `undefined`) {
    // @ts-expect-error
    return __non_webpack_require__(path);
  } else {
    return require(path);
  }
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequire = $dcb6c32e8116e2ce740eb0f8758d7b31$var$dynamicRequire;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.dynamicRequire = $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequire;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$dynamicRequireNoCache(path) {
  const physicalPath = $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(path);
  const currentCacheEntry = require.cache[physicalPath];
  delete require.cache[physicalPath];
  let result;

  try {
    result = $dcb6c32e8116e2ce740eb0f8758d7b31$var$dynamicRequire(physicalPath);
    const freshCacheEntry = require.cache[physicalPath];
    const freshCacheIndex = module.children.indexOf(freshCacheEntry);

    if (freshCacheIndex !== -1) {
      module.children.splice(freshCacheIndex, 1);
    }
  } finally {
    require.cache[physicalPath] = currentCacheEntry;
  }

  return result;
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequireNoCache = $dcb6c32e8116e2ce740eb0f8758d7b31$var$dynamicRequireNoCache;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.dynamicRequireNoCache = $dcb6c32e8116e2ce740eb0f8758d7b31$export$dynamicRequireNoCache; // This function transforms an iterable into an array and sorts it according to
// the mapper functions provided as parameter. The mappers are expected to take
// each element from the iterable and generate a string from it, that will then
// be used to compare the entries.
//
// Using sortMap is more efficient than kinda reimplementing the logic in a sort
// predicate because sortMap caches the result of the mappers in such a way that
// they are guaranteed to be executed exactly once for each element.

// This function transforms an iterable into an array and sorts it according to
// the mapper functions provided as parameter. The mappers are expected to take
// each element from the iterable and generate a string from it, that will then
// be used to compare the entries.
//
// Using sortMap is more efficient than kinda reimplementing the logic in a sort
// predicate because sortMap caches the result of the mappers in such a way that
// they are guaranteed to be executed exactly once for each element.
function $dcb6c32e8116e2ce740eb0f8758d7b31$var$sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$sortMap = $dcb6c32e8116e2ce740eb0f8758d7b31$var$sortMap;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.sortMap = $dcb6c32e8116e2ce740eb0f8758d7b31$export$sortMap;
/**
 * Combines an Array of glob patterns into a regular expression.
 *
 * @param ignorePatterns An array of glob patterns
 *
 * @returns A `string` representing a regular expression or `null` if no glob patterns are provided
 */

/**
 * Combines an Array of glob patterns into a regular expression.
 *
 * @param ignorePatterns An array of glob patterns
 *
 * @returns A `string` representing a regular expression or `null` if no glob patterns are provided
 */
function $dcb6c32e8116e2ce740eb0f8758d7b31$var$buildIgnorePattern(ignorePatterns) {
  if (ignorePatterns.length === 0) return null;
  return ignorePatterns.map(pattern => {
    return `(${$dcb6c32e8116e2ce740eb0f8758d7b31$var$micromatch_1.default.makeRe(pattern, {
      windows: false
    }).source})`;
  }).join(`|`);
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$buildIgnorePattern = $dcb6c32e8116e2ce740eb0f8758d7b31$var$buildIgnorePattern;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.buildIgnorePattern = $dcb6c32e8116e2ce740eb0f8758d7b31$export$buildIgnorePattern;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$replaceEnvVariables(value, {
  env
}) {
  const regex = /\${(?<variableName>[\d\w_]+)(?<colon>:)?(?:-(?<fallback>[^}]*))?}/g;
  return value.replace(regex, (...args) => {
    const {
      variableName,
      colon,
      fallback
    } = args[args.length - 1];
    const variableExist = Object.prototype.hasOwnProperty.call(env, variableName);
    const variableValue = env[variableName];
    if (variableValue) return variableValue;
    if (variableExist && !colon) return variableValue;
    if (fallback != null) return fallback;
    throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Environment variable not found (${variableName})`);
  });
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$replaceEnvVariables = $dcb6c32e8116e2ce740eb0f8758d7b31$var$replaceEnvVariables;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.replaceEnvVariables = $dcb6c32e8116e2ce740eb0f8758d7b31$export$replaceEnvVariables;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseBoolean(value) {
  switch (value) {
    case `true`:
    case `1`:
    case 1:
    case true:
      {
        return true;
      }

    case `false`:
    case `0`:
    case 0:
    case false:
      {
        return false;
      }

    default:
      {
        throw new Error(`Couldn't parse "${value}" as a boolean`);
      }
  }
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseBoolean;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.parseBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseBoolean;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseOptionalBoolean(value) {
  if (typeof value === `undefined`) return value;
  return $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseBoolean(value);
}

var $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseOptionalBoolean;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.parseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$parseOptionalBoolean;

function $dcb6c32e8116e2ce740eb0f8758d7b31$var$tryParseOptionalBoolean(value) {
  try {
    return $dcb6c32e8116e2ce740eb0f8758d7b31$var$parseOptionalBoolean(value);
  } catch (_a) {
    return null;
  }
}

$dcb6c32e8116e2ce740eb0f8758d7b31$export$tryParseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$var$tryParseOptionalBoolean;
$dcb6c32e8116e2ce740eb0f8758d7b31$exports.tryParseOptionalBoolean = $dcb6c32e8116e2ce740eb0f8758d7b31$export$tryParseOptionalBoolean;
const $b0a0c0c8655104e8248dfbd97bf5098e$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
// ASSET: node_modules/@yarnpkg/core/lib/structUtils.js
var $1cd0a18ca6ebf8e9e9c7770e206c865e$exports = {};
Object.defineProperty($1cd0a18ca6ebf8e9e9c7770e206c865e$exports, "__esModule", {
  value: true
});
var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$getIdentVendorPath = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDependent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyResolution = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyWorkspace = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$sortDescriptors = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocatorNoColors = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyReference = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyRange = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$requirableIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToManifestRange = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeRange = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseFileStyleRange = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseRange = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$areVirtualPackagesEquivalent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$areLocatorsEqual = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$areDescriptorsEqual = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$areIdentsEqual = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizePackage = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizeDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$copyPackage = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$renamePackage = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertPackageToLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertLocatorToDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertDescriptorToLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToIdent = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeLocator = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeDescriptor = ($1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeIdent = void 0, $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertToIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertDescriptorToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertDescriptorToLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertLocatorToDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertLocatorToDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertPackageToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertPackageToLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.renamePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$renamePackage), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.copyPackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$copyPackage), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.virtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizeDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.virtualizePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizePackage), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.isVirtualDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.isVirtualLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.devirtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.devirtualizeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.bindDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.bindLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areIdentsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areIdentsEqual), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areDescriptorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areDescriptorsEqual), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areLocatorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areLocatorsEqual), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areVirtualPackagesEquivalent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areVirtualPackagesEquivalent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseRange), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseFileStyleRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseFileStyleRange), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeRange), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertToManifestRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToManifestRange), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.requirableIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$requirableIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.slugifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.slugifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyIdent), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyRange), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDescriptor), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyReference = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyReference), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocator), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyLocatorNoColors = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocatorNoColors), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.sortDescriptors = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$sortDescriptors), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyWorkspace = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyWorkspace), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyResolution = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyResolution), $1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyDependent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDependent);
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.getIdentVendorPath = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$getIdentVendorPath;
// ASSET: node_modules/querystring-es3/index.js
var $43f01e65249c3aac5a0040ce1b80da02$export$parse,
    $43f01e65249c3aac5a0040ce1b80da02$export$stringify,
    $43f01e65249c3aac5a0040ce1b80da02$exports = {};
// ASSET: node_modules/querystring-es3/decode.js
var $ba482388032ed33441520bbb21223c35$exports = {};

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function $ba482388032ed33441520bbb21223c35$var$hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

$ba482388032ed33441520bbb21223c35$exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!$ba482388032ed33441520bbb21223c35$var$hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if ($ba482388032ed33441520bbb21223c35$var$isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var $ba482388032ed33441520bbb21223c35$var$isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

var $43f01e65249c3aac5a0040ce1b80da02$export$decode = ($43f01e65249c3aac5a0040ce1b80da02$export$parse = $ba482388032ed33441520bbb21223c35$exports, $43f01e65249c3aac5a0040ce1b80da02$exports.parse = $43f01e65249c3aac5a0040ce1b80da02$export$parse);
$43f01e65249c3aac5a0040ce1b80da02$exports.decode = $43f01e65249c3aac5a0040ce1b80da02$export$decode;
// ASSET: node_modules/querystring-es3/encode.js
var $69657f8d3228435ac966429f5777cfc6$exports = {};

var $69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

$69657f8d3228435ac966429f5777cfc6$exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return $69657f8d3228435ac966429f5777cfc6$var$map($69657f8d3228435ac966429f5777cfc6$var$objectKeys(obj), function (k) {
      var ks = encodeURIComponent($69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive(k)) + eq;

      if ($69657f8d3228435ac966429f5777cfc6$var$isArray(obj[k])) {
        return $69657f8d3228435ac966429f5777cfc6$var$map(obj[k], function (v) {
          return ks + encodeURIComponent($69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent($69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent($69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive(name)) + eq + encodeURIComponent($69657f8d3228435ac966429f5777cfc6$var$stringifyPrimitive(obj));
};

var $69657f8d3228435ac966429f5777cfc6$var$isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function $69657f8d3228435ac966429f5777cfc6$var$map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var $69657f8d3228435ac966429f5777cfc6$var$objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

var $43f01e65249c3aac5a0040ce1b80da02$export$encode = ($43f01e65249c3aac5a0040ce1b80da02$export$stringify = $69657f8d3228435ac966429f5777cfc6$exports, $43f01e65249c3aac5a0040ce1b80da02$exports.stringify = $43f01e65249c3aac5a0040ce1b80da02$export$stringify);
$43f01e65249c3aac5a0040ce1b80da02$exports.encode = $43f01e65249c3aac5a0040ce1b80da02$export$encode;
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($43f01e65249c3aac5a0040ce1b80da02$exports);
// ASSET: node_modules/semver/index.js
var $472287880c3e8d04bc38855fbd388e1f$exports = {};
// ASSET: node_modules/semver/internal/re.js
var $370b691cddaa8013c401511fceda2353$cjs_exports, $370b691cddaa8013c401511fceda2353$export$re, $370b691cddaa8013c401511fceda2353$export$src, $370b691cddaa8013c401511fceda2353$export$t;
// ASSET: node_modules/semver/internal/constants.js
var $c736c5dbbcfed02f22613ddbcbd396a0$exports = {};
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const $c736c5dbbcfed02f22613ddbcbd396a0$var$SEMVER_SPEC_VERSION = '2.0.0';
const $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_LENGTH = 256;
const $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

// Max safe segment length for coercion.
const $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_SAFE_COMPONENT_LENGTH = 16;
$c736c5dbbcfed02f22613ddbcbd396a0$exports = {
  SEMVER_SPEC_VERSION: $c736c5dbbcfed02f22613ddbcbd396a0$var$SEMVER_SPEC_VERSION,
  MAX_LENGTH: $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_LENGTH,
  MAX_SAFE_INTEGER: $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH: $c736c5dbbcfed02f22613ddbcbd396a0$var$MAX_SAFE_COMPONENT_LENGTH
};
const {
  MAX_SAFE_COMPONENT_LENGTH: $370b691cddaa8013c401511fceda2353$var$MAX_SAFE_COMPONENT_LENGTH
} = $c736c5dbbcfed02f22613ddbcbd396a0$exports;
// ASSET: node_modules/semver/internal/debug.js
var $9c3ef858f451ee9627c1dd0d65c9dc2f$exports = {};
var $9c3ef858f451ee9627c1dd0d65c9dc2f$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $9c3ef858f451ee9627c1dd0d65c9dc2f$var$debug = typeof $9c3ef858f451ee9627c1dd0d65c9dc2f$var$process === 'object' && $9c3ef858f451ee9627c1dd0d65c9dc2f$var$process.env && undefined && /\bsemver\b/i.test(undefined) ? (...args) => console.error('SEMVER', ...args) : () => {};
$9c3ef858f451ee9627c1dd0d65c9dc2f$exports = $9c3ef858f451ee9627c1dd0d65c9dc2f$var$debug;
$370b691cddaa8013c401511fceda2353$cjs_exports = {}; // The actual regexps go on exports.re

// The actual regexps go on exports.re
const $370b691cddaa8013c401511fceda2353$var$re = ($370b691cddaa8013c401511fceda2353$export$re = [], $370b691cddaa8013c401511fceda2353$export$re);
const $370b691cddaa8013c401511fceda2353$var$src = ($370b691cddaa8013c401511fceda2353$export$src = [], $370b691cddaa8013c401511fceda2353$export$src);
const $370b691cddaa8013c401511fceda2353$var$t = ($370b691cddaa8013c401511fceda2353$export$t = {}, $370b691cddaa8013c401511fceda2353$export$t);
let $370b691cddaa8013c401511fceda2353$var$R = 0;

const $370b691cddaa8013c401511fceda2353$var$createToken = (name, value, isGlobal) => {
  const index = $370b691cddaa8013c401511fceda2353$var$R++;
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports(index, value);
  $370b691cddaa8013c401511fceda2353$var$t[name] = index;
  $370b691cddaa8013c401511fceda2353$var$src[index] = value;
  $370b691cddaa8013c401511fceda2353$var$re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
}; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
$370b691cddaa8013c401511fceda2353$var$createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
$370b691cddaa8013c401511fceda2353$var$createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+'); // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
$370b691cddaa8013c401511fceda2353$var$createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'); // ## Main Version
// Three dot-separated numeric identifiers.

// ## Main Version
// Three dot-separated numeric identifiers.
$370b691cddaa8013c401511fceda2353$var$createToken('MAINVERSION', `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIER]})\\.` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIER]})\\.` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIER]})`);
$370b691cddaa8013c401511fceda2353$var$createToken('MAINVERSIONLOOSE', `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIERLOOSE]})`); // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
$370b691cddaa8013c401511fceda2353$var$createToken('PRERELEASEIDENTIFIER', `(?:${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIER]}|${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NONNUMERICIDENTIFIER]})`);
$370b691cddaa8013c401511fceda2353$var$createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIERLOOSE]}|${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NONNUMERICIDENTIFIER]})`); // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
$370b691cddaa8013c401511fceda2353$var$createToken('PRERELEASE', `(?:-(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASEIDENTIFIER]}(?:\\.${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASEIDENTIFIER]})*))`);
$370b691cddaa8013c401511fceda2353$var$createToken('PRERELEASELOOSE', `(?:-?(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASEIDENTIFIERLOOSE]})*))`); // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
$370b691cddaa8013c401511fceda2353$var$createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+'); // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
$370b691cddaa8013c401511fceda2353$var$createToken('BUILD', `(?:\\+(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILDIDENTIFIER]}(?:\\.${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILDIDENTIFIER]})*))`); // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
$370b691cddaa8013c401511fceda2353$var$createToken('FULLPLAIN', `v?${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.MAINVERSION]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASE]}?${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILD]}?`);
$370b691cddaa8013c401511fceda2353$var$createToken('FULL', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.FULLPLAIN]}$`); // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
$370b691cddaa8013c401511fceda2353$var$createToken('LOOSEPLAIN', `[v=\\s]*${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.MAINVERSIONLOOSE]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASELOOSE]}?${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILD]}?`);
$370b691cddaa8013c401511fceda2353$var$createToken('LOOSE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LOOSEPLAIN]}$`);
$370b691cddaa8013c401511fceda2353$var$createToken('GTLT', '((?:<|>)?=?)'); // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGEIDENTIFIERLOOSE', `${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGEIDENTIFIER', `${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.NUMERICIDENTIFIER]}|x|X|\\*`);
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGEPLAIN', `[v=\\s]*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIER]})` + `(?:\\.(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIER]})` + `(?:\\.(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIER]})` + `(?:${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASE]})?${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILD]}?` + `)?)?`);
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEIDENTIFIERLOOSE]})` + `(?:${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.PRERELEASELOOSE]})?${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.BUILD]}?` + `)?)?`);
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.GTLT]}\\s*${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]}$`);
$370b691cddaa8013c401511fceda2353$var$createToken('XRANGELOOSE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.GTLT]}\\s*${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAINLOOSE]}$`); // Coercion.
// Extract anything that could conceivably be a part of a valid semver

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
$370b691cddaa8013c401511fceda2353$var$createToken('COERCE', `${'(^|[^\\d])' + '(\\d{1,'}${$370b691cddaa8013c401511fceda2353$var$MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${$370b691cddaa8013c401511fceda2353$var$MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${$370b691cddaa8013c401511fceda2353$var$MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
$370b691cddaa8013c401511fceda2353$var$createToken('COERCERTL', $370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.COERCE], true); // Tilde ranges.
// Meaning is "reasonably at or greater than"

// Tilde ranges.
// Meaning is "reasonably at or greater than"
$370b691cddaa8013c401511fceda2353$var$createToken('LONETILDE', '(?:~>?)');
$370b691cddaa8013c401511fceda2353$var$createToken('TILDETRIM', `(\\s*)${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONETILDE]}\\s+`, true);
var $370b691cddaa8013c401511fceda2353$export$tildeTrimReplace = '$1~';
$370b691cddaa8013c401511fceda2353$var$createToken('TILDE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONETILDE]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]}$`);
$370b691cddaa8013c401511fceda2353$var$createToken('TILDELOOSE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONETILDE]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAINLOOSE]}$`); // Caret ranges.
// Meaning is "at least and backwards compatible with"

// Caret ranges.
// Meaning is "at least and backwards compatible with"
$370b691cddaa8013c401511fceda2353$var$createToken('LONECARET', '(?:\\^)');
$370b691cddaa8013c401511fceda2353$var$createToken('CARETTRIM', `(\\s*)${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONECARET]}\\s+`, true);
var $370b691cddaa8013c401511fceda2353$export$caretTrimReplace = '$1^';
$370b691cddaa8013c401511fceda2353$var$createToken('CARET', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONECARET]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]}$`);
$370b691cddaa8013c401511fceda2353$var$createToken('CARETLOOSE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LONECARET]}${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAINLOOSE]}$`); // A simple gt/lt/eq thing, or just "" to indicate "any version"

// A simple gt/lt/eq thing, or just "" to indicate "any version"
$370b691cddaa8013c401511fceda2353$var$createToken('COMPARATORLOOSE', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.GTLT]}\\s*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LOOSEPLAIN]})$|^$`);
$370b691cddaa8013c401511fceda2353$var$createToken('COMPARATOR', `^${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.GTLT]}\\s*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.FULLPLAIN]})$|^$`); // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
$370b691cddaa8013c401511fceda2353$var$createToken('COMPARATORTRIM', `(\\s*)${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.GTLT]}\\s*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.LOOSEPLAIN]}|${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]})`, true);
var $370b691cddaa8013c401511fceda2353$export$comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
$370b691cddaa8013c401511fceda2353$var$createToken('HYPHENRANGE', `^\\s*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAIN]})` + `\\s*$`);
$370b691cddaa8013c401511fceda2353$var$createToken('HYPHENRANGELOOSE', `^\\s*(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${$370b691cddaa8013c401511fceda2353$var$src[$370b691cddaa8013c401511fceda2353$var$t.XRANGEPLAINLOOSE]})` + `\\s*$`); // Star ranges basically just allow anything at all.

// Star ranges basically just allow anything at all.
$370b691cddaa8013c401511fceda2353$var$createToken('STAR', '(<|>)?=?\\s*\\*'); // >=0.0.0 is like a star

// >=0.0.0 is like a star
$370b691cddaa8013c401511fceda2353$var$createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
$370b691cddaa8013c401511fceda2353$var$createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
// ASSET: node_modules/semver/classes/semver.js
var $90838788dbff9b531e37a7e32d08f442$exports = {};
const {
  MAX_LENGTH: $90838788dbff9b531e37a7e32d08f442$var$MAX_LENGTH,
  MAX_SAFE_INTEGER: $90838788dbff9b531e37a7e32d08f442$var$MAX_SAFE_INTEGER
} = $c736c5dbbcfed02f22613ddbcbd396a0$exports;
// ASSET: node_modules/semver/internal/parse-options.js
var $4b941ffbc66a76f9fdd1f91328ceb1f6$exports = {};
// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const $4b941ffbc66a76f9fdd1f91328ceb1f6$var$opts = ['includePrerelease', 'loose', 'rtl'];

const $4b941ffbc66a76f9fdd1f91328ceb1f6$var$parseOptions = options => !options ? {} : typeof options !== 'object' ? {
  loose: true
} : $4b941ffbc66a76f9fdd1f91328ceb1f6$var$opts.filter(k => options[k]).reduce((options, k) => {
  options[k] = true;
  return options;
}, {});

$4b941ffbc66a76f9fdd1f91328ceb1f6$exports = $4b941ffbc66a76f9fdd1f91328ceb1f6$var$parseOptions;
// ASSET: node_modules/semver/internal/identifiers.js
var $d4209f4727b9f5f1b7a0035d1fe52f17$exports = {};
const $d4209f4727b9f5f1b7a0035d1fe52f17$var$numeric = /^[0-9]+$/;

const $d4209f4727b9f5f1b7a0035d1fe52f17$var$compareIdentifiers = (a, b) => {
  const anum = $d4209f4727b9f5f1b7a0035d1fe52f17$var$numeric.test(a);
  const bnum = $d4209f4727b9f5f1b7a0035d1fe52f17$var$numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};

const $d4209f4727b9f5f1b7a0035d1fe52f17$var$rcompareIdentifiers = (a, b) => $d4209f4727b9f5f1b7a0035d1fe52f17$var$compareIdentifiers(b, a);

$d4209f4727b9f5f1b7a0035d1fe52f17$exports = {
  compareIdentifiers: $d4209f4727b9f5f1b7a0035d1fe52f17$var$compareIdentifiers,
  rcompareIdentifiers: $d4209f4727b9f5f1b7a0035d1fe52f17$var$rcompareIdentifiers
};
const {
  compareIdentifiers: $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers
} = $d4209f4727b9f5f1b7a0035d1fe52f17$exports;

class $90838788dbff9b531e37a7e32d08f442$var$SemVer {
  constructor(version, options) {
    options = $4b941ffbc66a76f9fdd1f91328ceb1f6$exports(options);

    if (version instanceof $90838788dbff9b531e37a7e32d08f442$var$SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`);
    }

    if (version.length > $90838788dbff9b531e37a7e32d08f442$var$MAX_LENGTH) {
      throw new TypeError(`version is longer than ${$90838788dbff9b531e37a7e32d08f442$var$MAX_LENGTH} characters`);
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose; // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.

    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.LOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }

    this.raw = version; // these are actually numbers

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > $90838788dbff9b531e37a7e32d08f442$var$MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > $90838788dbff9b531e37a7e32d08f442$var$MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > $90838788dbff9b531e37a7e32d08f442$var$MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    } // numberify any prerelease numeric ids


    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(id => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;

          if (num >= 0 && num < $90838788dbff9b531e37a7e32d08f442$var$MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;

    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }

    return this.version;
  }

  toString() {
    return this.version;
  }

  compare(other) {
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof $90838788dbff9b531e37a7e32d08f442$var$SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0;
      }

      other = new $90838788dbff9b531e37a7e32d08f442$var$SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0;
    }

    return this.compareMain(other) || this.comparePre(other);
  }

  compareMain(other) {
    if (!(other instanceof $90838788dbff9b531e37a7e32d08f442$var$SemVer)) {
      other = new $90838788dbff9b531e37a7e32d08f442$var$SemVer(other, this.options);
    }

    return $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers(this.major, other.major) || $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers(this.minor, other.minor) || $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers(this.patch, other.patch);
  }

  comparePre(other) {
    if (!(other instanceof $90838788dbff9b531e37a7e32d08f442$var$SemVer)) {
      other = new $90838788dbff9b531e37a7e32d08f442$var$SemVer(other, this.options);
    } // NOT having a prerelease is > having one


    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    let i = 0;

    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers(a, b);
      }
    } while (++i);
  }

  compareBuild(other) {
    if (!(other instanceof $90838788dbff9b531e37a7e32d08f442$var$SemVer)) {
      other = new $90838788dbff9b531e37a7e32d08f442$var$SemVer(other, this.options);
    }

    let i = 0;

    do {
      const a = this.build[i];
      const b = other.build[i];
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return $90838788dbff9b531e37a7e32d08f442$var$compareIdentifiers(a, b);
      }
    } while (++i);
  } // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.


  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.

      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.

      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error(`invalid increment argument: ${release}`);
    }

    this.format();
    this.raw = this.version;
    return this;
  }

}

$90838788dbff9b531e37a7e32d08f442$exports = $90838788dbff9b531e37a7e32d08f442$var$SemVer;
// ASSET: node_modules/semver/functions/parse.js
var $2059718adffe7d8f119f10a8c82da252$exports = {};
const {
  MAX_LENGTH: $2059718adffe7d8f119f10a8c82da252$var$MAX_LENGTH
} = $c736c5dbbcfed02f22613ddbcbd396a0$exports;

const $2059718adffe7d8f119f10a8c82da252$var$parse = (version, options) => {
  options = $4b941ffbc66a76f9fdd1f91328ceb1f6$exports(options);

  if (version instanceof $90838788dbff9b531e37a7e32d08f442$exports) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > $2059718adffe7d8f119f10a8c82da252$var$MAX_LENGTH) {
    return null;
  }

  const r = options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.LOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new $90838788dbff9b531e37a7e32d08f442$exports(version, options);
  } catch (er) {
    return null;
  }
};

$2059718adffe7d8f119f10a8c82da252$exports = $2059718adffe7d8f119f10a8c82da252$var$parse;
// ASSET: node_modules/semver/functions/valid.js
var $10e1ac856f2bc602ee35b81d7da56c4c$exports = {};

const $10e1ac856f2bc602ee35b81d7da56c4c$var$valid = (version, options) => {
  const v = $2059718adffe7d8f119f10a8c82da252$exports(version, options);
  return v ? v.version : null;
};

$10e1ac856f2bc602ee35b81d7da56c4c$exports = $10e1ac856f2bc602ee35b81d7da56c4c$var$valid;
// ASSET: node_modules/semver/functions/clean.js
var $a568db2d6518e0098588ce5e76fa9713$exports = {};

const $a568db2d6518e0098588ce5e76fa9713$var$clean = (version, options) => {
  const s = $2059718adffe7d8f119f10a8c82da252$exports(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
};

$a568db2d6518e0098588ce5e76fa9713$exports = $a568db2d6518e0098588ce5e76fa9713$var$clean;
// ASSET: node_modules/semver/functions/inc.js
var $3620e9574650170b96196996d194ac67$exports = {};

const $3620e9574650170b96196996d194ac67$var$inc = (version, release, options, identifier) => {
  if (typeof options === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new $90838788dbff9b531e37a7e32d08f442$exports(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};

$3620e9574650170b96196996d194ac67$exports = $3620e9574650170b96196996d194ac67$var$inc;
// ASSET: node_modules/semver/functions/diff.js
var $08e0d6ecb4dab1a59d94e7b6dc646668$exports = {};
// ASSET: node_modules/semver/functions/eq.js
var $4301714d519beec67211d188478d1247$exports = {};
// ASSET: node_modules/semver/functions/compare.js
var $6db67f46b1a7eea902776301e8e52b4d$exports = {};

const $6db67f46b1a7eea902776301e8e52b4d$var$compare = (a, b, loose) => new $90838788dbff9b531e37a7e32d08f442$exports(a, loose).compare(new $90838788dbff9b531e37a7e32d08f442$exports(b, loose));

$6db67f46b1a7eea902776301e8e52b4d$exports = $6db67f46b1a7eea902776301e8e52b4d$var$compare;

const $4301714d519beec67211d188478d1247$var$eq = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) === 0;

$4301714d519beec67211d188478d1247$exports = $4301714d519beec67211d188478d1247$var$eq;

const $08e0d6ecb4dab1a59d94e7b6dc646668$var$diff = (version1, version2) => {
  if ($4301714d519beec67211d188478d1247$exports(version1, version2)) {
    return null;
  } else {
    const v1 = $2059718adffe7d8f119f10a8c82da252$exports(version1);
    const v2 = $2059718adffe7d8f119f10a8c82da252$exports(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? 'pre' : '';
    const defaultResult = hasPre ? 'prerelease' : '';

    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
};

$08e0d6ecb4dab1a59d94e7b6dc646668$exports = $08e0d6ecb4dab1a59d94e7b6dc646668$var$diff;
// ASSET: node_modules/semver/functions/major.js
var $a2c74fb40341f6fec6b3a07eb80926b0$exports = {};

const $a2c74fb40341f6fec6b3a07eb80926b0$var$major = (a, loose) => new $90838788dbff9b531e37a7e32d08f442$exports(a, loose).major;

$a2c74fb40341f6fec6b3a07eb80926b0$exports = $a2c74fb40341f6fec6b3a07eb80926b0$var$major;
// ASSET: node_modules/semver/functions/minor.js
var $b24c96e1fe79ad76416666fb3ed3ef09$exports = {};

const $b24c96e1fe79ad76416666fb3ed3ef09$var$minor = (a, loose) => new $90838788dbff9b531e37a7e32d08f442$exports(a, loose).minor;

$b24c96e1fe79ad76416666fb3ed3ef09$exports = $b24c96e1fe79ad76416666fb3ed3ef09$var$minor;
// ASSET: node_modules/semver/functions/patch.js
var $94619145c94354305e261fd291b0671a$exports = {};

const $94619145c94354305e261fd291b0671a$var$patch = (a, loose) => new $90838788dbff9b531e37a7e32d08f442$exports(a, loose).patch;

$94619145c94354305e261fd291b0671a$exports = $94619145c94354305e261fd291b0671a$var$patch;
// ASSET: node_modules/semver/functions/prerelease.js
var $734eb46e11638e724e8ff5fa63211557$exports = {};

const $734eb46e11638e724e8ff5fa63211557$var$prerelease = (version, options) => {
  const parsed = $2059718adffe7d8f119f10a8c82da252$exports(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};

$734eb46e11638e724e8ff5fa63211557$exports = $734eb46e11638e724e8ff5fa63211557$var$prerelease;
// ASSET: node_modules/semver/functions/rcompare.js
var $5b623ca9eb757af784a32500dc22c2bf$exports = {};

const $5b623ca9eb757af784a32500dc22c2bf$var$rcompare = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(b, a, loose);

$5b623ca9eb757af784a32500dc22c2bf$exports = $5b623ca9eb757af784a32500dc22c2bf$var$rcompare;
// ASSET: node_modules/semver/functions/compare-loose.js
var $f0f67bfa59f94595577b7f3da5f679d8$exports = {};

const $f0f67bfa59f94595577b7f3da5f679d8$var$compareLoose = (a, b) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, true);

$f0f67bfa59f94595577b7f3da5f679d8$exports = $f0f67bfa59f94595577b7f3da5f679d8$var$compareLoose;
// ASSET: node_modules/semver/functions/compare-build.js
var $b5ac5815fe2e9d5e6229dd738a335c52$exports = {};

const $b5ac5815fe2e9d5e6229dd738a335c52$var$compareBuild = (a, b, loose) => {
  const versionA = new $90838788dbff9b531e37a7e32d08f442$exports(a, loose);
  const versionB = new $90838788dbff9b531e37a7e32d08f442$exports(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};

$b5ac5815fe2e9d5e6229dd738a335c52$exports = $b5ac5815fe2e9d5e6229dd738a335c52$var$compareBuild;
// ASSET: node_modules/semver/functions/sort.js
var $4eeb86212d5ddef4d220f36a3c13afd3$exports = {};

const $4eeb86212d5ddef4d220f36a3c13afd3$var$sort = (list, loose) => list.sort((a, b) => $b5ac5815fe2e9d5e6229dd738a335c52$exports(a, b, loose));

$4eeb86212d5ddef4d220f36a3c13afd3$exports = $4eeb86212d5ddef4d220f36a3c13afd3$var$sort;
// ASSET: node_modules/semver/functions/rsort.js
var $0dc8b73484dbf130d08d0346763a91ec$exports = {};

const $0dc8b73484dbf130d08d0346763a91ec$var$rsort = (list, loose) => list.sort((a, b) => $b5ac5815fe2e9d5e6229dd738a335c52$exports(b, a, loose));

$0dc8b73484dbf130d08d0346763a91ec$exports = $0dc8b73484dbf130d08d0346763a91ec$var$rsort;
// ASSET: node_modules/semver/functions/gt.js
var $8d8cfccbf9956169e396368f4b2186a7$exports = {};

const $8d8cfccbf9956169e396368f4b2186a7$var$gt = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) > 0;

$8d8cfccbf9956169e396368f4b2186a7$exports = $8d8cfccbf9956169e396368f4b2186a7$var$gt;
// ASSET: node_modules/semver/functions/lt.js
var $39b174882da85e7dec7309e68b502352$exports = {};

const $39b174882da85e7dec7309e68b502352$var$lt = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) < 0;

$39b174882da85e7dec7309e68b502352$exports = $39b174882da85e7dec7309e68b502352$var$lt;
// ASSET: node_modules/semver/functions/neq.js
var $e1c0855f55d4c4b59130785b673b42ab$exports = {};

const $e1c0855f55d4c4b59130785b673b42ab$var$neq = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) !== 0;

$e1c0855f55d4c4b59130785b673b42ab$exports = $e1c0855f55d4c4b59130785b673b42ab$var$neq;
// ASSET: node_modules/semver/functions/gte.js
var $e8aba9e682682b9e1b770ea77508fd3e$exports = {};

const $e8aba9e682682b9e1b770ea77508fd3e$var$gte = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) >= 0;

$e8aba9e682682b9e1b770ea77508fd3e$exports = $e8aba9e682682b9e1b770ea77508fd3e$var$gte;
// ASSET: node_modules/semver/functions/lte.js
var $0cf4a6b86009163ef37342af6f4a3362$exports = {};

const $0cf4a6b86009163ef37342af6f4a3362$var$lte = (a, b, loose) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, loose) <= 0;

$0cf4a6b86009163ef37342af6f4a3362$exports = $0cf4a6b86009163ef37342af6f4a3362$var$lte;
// ASSET: node_modules/semver/functions/cmp.js
var $8bf97baf408c2c1ba865ddfd33ccd65e$exports = {};

const $8bf97baf408c2c1ba865ddfd33ccd65e$var$cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a === b;

    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return $4301714d519beec67211d188478d1247$exports(a, b, loose);

    case '!=':
      return $e1c0855f55d4c4b59130785b673b42ab$exports(a, b, loose);

    case '>':
      return $8d8cfccbf9956169e396368f4b2186a7$exports(a, b, loose);

    case '>=':
      return $e8aba9e682682b9e1b770ea77508fd3e$exports(a, b, loose);

    case '<':
      return $39b174882da85e7dec7309e68b502352$exports(a, b, loose);

    case '<=':
      return $0cf4a6b86009163ef37342af6f4a3362$exports(a, b, loose);

    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};

$8bf97baf408c2c1ba865ddfd33ccd65e$exports = $8bf97baf408c2c1ba865ddfd33ccd65e$var$cmp;
// ASSET: node_modules/semver/functions/coerce.js
var $2256fecbe87afa313b690f866ce87073$exports = {};

const $2256fecbe87afa313b690f866ce87073$var$coerce = (version, options) => {
  if (version instanceof $90838788dbff9b531e37a7e32d08f442$exports) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  let match = null;

  if (!options.rtl) {
    match = version.match($370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;

    while ((next = $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    // leave it in a clean state
    $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COERCERTL].lastIndex = -1;
  }

  if (match === null) return null;
  return $2059718adffe7d8f119f10a8c82da252$exports(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options);
};

$2256fecbe87afa313b690f866ce87073$exports = $2256fecbe87afa313b690f866ce87073$var$coerce;
// ASSET: node_modules/semver/classes/comparator.js
var $bbdb0047a126baa32311c88919becbc2$exports = {};
const $bbdb0047a126baa32311c88919becbc2$var$ANY = Symbol('SemVer ANY'); // hoisted class for cyclic dependency

// hoisted class for cyclic dependency
class $bbdb0047a126baa32311c88919becbc2$var$Comparator {
  static get ANY() {
    return $bbdb0047a126baa32311c88919becbc2$var$ANY;
  }

  constructor(comp, options) {
    options = $4b941ffbc66a76f9fdd1f91328ceb1f6$exports(options);

    if (comp instanceof $bbdb0047a126baa32311c88919becbc2$var$Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === $bbdb0047a126baa32311c88919becbc2$var$ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('comp', this);
  }

  parse(comp) {
    const r = this.options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATORLOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATOR];
    const m = comp.match(r);

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }

    this.operator = m[1] !== undefined ? m[1] : '';

    if (this.operator === '=') {
      this.operator = '';
    } // if it literally is just '>' or '' then allow anything.


    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = $bbdb0047a126baa32311c88919becbc2$var$ANY;
    } else {
      this.semver = new $90838788dbff9b531e37a7e32d08f442$exports(m[2], this.options.loose);
    }
  }

  toString() {
    return this.value;
  }

  test(version) {
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('Comparator.test', version, this.options.loose);

    if (this.semver === $bbdb0047a126baa32311c88919becbc2$var$ANY || version === $bbdb0047a126baa32311c88919becbc2$var$ANY) {
      return true;
    }

    if (typeof version === 'string') {
      try {
        version = new $90838788dbff9b531e37a7e32d08f442$exports(version, this.options);
      } catch (er) {
        return false;
      }
    }

    return $8bf97baf408c2c1ba865ddfd33ccd65e$exports(version, this.operator, this.semver, this.options);
  }

  intersects(comp, options) {
    if (!(comp instanceof $bbdb0047a126baa32311c88919becbc2$var$Comparator)) {
      throw new TypeError('a Comparator is required');
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true;
      }

      return new $fa7a598bb3a5cbf09268615b77c3a165$exports(comp.value, options).test(this.value);
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true;
      }

      return new $fa7a598bb3a5cbf09268615b77c3a165$exports(this.value, options).test(comp.semver);
    }

    const sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
    const sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
    const oppositeDirectionsLessThan = $8bf97baf408c2c1ba865ddfd33ccd65e$exports(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
    const oppositeDirectionsGreaterThan = $8bf97baf408c2c1ba865ddfd33ccd65e$exports(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }

}

$bbdb0047a126baa32311c88919becbc2$exports = $bbdb0047a126baa32311c88919becbc2$var$Comparator;
// ASSET: node_modules/semver/classes/range.js
var $fa7a598bb3a5cbf09268615b77c3a165$exports = {};

// hoisted class for cyclic dependency
class $fa7a598bb3a5cbf09268615b77c3a165$var$Range {
  constructor(range, options) {
    options = $4b941ffbc66a76f9fdd1f91328ceb1f6$exports(options);

    if (range instanceof $fa7a598bb3a5cbf09268615b77c3a165$var$Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new $fa7a598bb3a5cbf09268615b77c3a165$var$Range(range.raw, options);
      }
    }

    if (range instanceof $bbdb0047a126baa32311c88919becbc2$exports) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.format();
      return this;
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

    // First, split based on boolean or ||
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/) // map the range to a 2d array of comparators
    . // map the range to a 2d array of comparators
    map(range => this.parseRange(range.trim())) // throw out any comparator lists that are empty
    // this generally means that it was not a valid range, which is allowed
    // in loose mode, but will still throw if the WHOLE range is invalid.
    . // throw out any comparator lists that are empty
    // this generally means that it was not a valid range, which is allowed
    // in loose mode, but will still throw if the WHOLE range is invalid.
    filter(c => c.length);

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`);
    } // if we have any that are not the null set, throw out null sets.


    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0];
      this.set = this.set.filter(c => !$fa7a598bb3a5cbf09268615b77c3a165$var$isNullSet(c[0]));
      if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && $fa7a598bb3a5cbf09268615b77c3a165$var$isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }

    this.format();
  }

  format() {
    this.range = this.set.map(comps => {
      return comps.join(' ').trim();
    }).join('||').trim();
    return this.range;
  }

  toString() {
    return this.range;
  }

  parseRange(range) {
    range = range.trim(); // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',');
    const memoKey = `parseRange:${memoOpts}:${range}`;
    const cached = $fa7a598bb3a5cbf09268615b77c3a165$var$cache.get(memoKey);
    if (cached) return cached;
    const loose = this.options.loose; // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.HYPHENRANGELOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.HYPHENRANGE];
    range = range.replace(hr, $fa7a598bb3a5cbf09268615b77c3a165$var$hyphenReplace(this.options.includePrerelease));
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace($370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATORTRIM], $370b691cddaa8013c401511fceda2353$export$comparatorTrimReplace);
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('comparator trim', range, $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace($370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.TILDETRIM], $370b691cddaa8013c401511fceda2353$export$tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace($370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.CARETTRIM], $370b691cddaa8013c401511fceda2353$export$caretTrimReplace); // normalize spaces

    // normalize spaces
    range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.
    const compRe = loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATORLOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.COMPARATOR];
    const rangeList = range.split(' ').map(comp => $fa7a598bb3a5cbf09268615b77c3a165$var$parseComparator(comp, this.options)).join(' ').split(/\s+/) // >=0.0.0 is equivalent to *
    . // >=0.0.0 is equivalent to *
    map(comp => $fa7a598bb3a5cbf09268615b77c3a165$var$replaceGTE0(comp, this.options)) // in loose mode, throw out any that are not valid comparators
    . // in loose mode, throw out any that are not valid comparators
    filter(this.options.loose ? comp => !!comp.match(compRe) : () => true).map(comp => new $bbdb0047a126baa32311c88919becbc2$exports(comp, this.options)); // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length;
    const rangeMap = new Map();

    for (const comp of rangeList) {
      if ($fa7a598bb3a5cbf09268615b77c3a165$var$isNullSet(comp)) return [comp];
      rangeMap.set(comp.value, comp);
    }

    if (rangeMap.size > 1 && rangeMap.has('')) rangeMap.delete('');
    const result = [...rangeMap.values()];
    $fa7a598bb3a5cbf09268615b77c3a165$var$cache.set(memoKey, result);
    return result;
  }

  intersects(range, options) {
    if (!(range instanceof $fa7a598bb3a5cbf09268615b77c3a165$var$Range)) {
      throw new TypeError('a Range is required');
    }

    return this.set.some(thisComparators => {
      return $fa7a598bb3a5cbf09268615b77c3a165$var$isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => {
        return $fa7a598bb3a5cbf09268615b77c3a165$var$isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => {
          return rangeComparators.every(rangeComparator => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  } // if ANY of the sets match ALL of its comparators, then pass


  // if ANY of the sets match ALL of its comparators, then pass
  test(version) {
    if (!version) {
      return false;
    }

    if (typeof version === 'string') {
      try {
        version = new $90838788dbff9b531e37a7e32d08f442$exports(version, this.options);
      } catch (er) {
        return false;
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if ($fa7a598bb3a5cbf09268615b77c3a165$var$testSet(this.set[i], version, this.options)) {
        return true;
      }
    }

    return false;
  }

}

$fa7a598bb3a5cbf09268615b77c3a165$exports = $fa7a598bb3a5cbf09268615b77c3a165$var$Range;
// ASSET: node_modules/lru-cache/index.js
var $88604d50530c57f8814c8ae430bbad8b$exports = {};
// ASSET: node_modules/yallist/iterator.js
var $80286fd1a314c316b832a8d5c27e4e9c$exports,
    $80286fd1a314c316b832a8d5c27e4e9c$executed = false;

function $80286fd1a314c316b832a8d5c27e4e9c$exec() {
  $80286fd1a314c316b832a8d5c27e4e9c$exports = {};

  $80286fd1a314c316b832a8d5c27e4e9c$exports = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
}

function $80286fd1a314c316b832a8d5c27e4e9c$init() {
  if (!$80286fd1a314c316b832a8d5c27e4e9c$executed) {
    $80286fd1a314c316b832a8d5c27e4e9c$executed = true;
    $80286fd1a314c316b832a8d5c27e4e9c$exec();
  }

  return $80286fd1a314c316b832a8d5c27e4e9c$exports;
}

// ASSET: node_modules/yallist/yallist.js
var $d597a1c17218136531f0ec9980dc10d7$exports = {};
$d597a1c17218136531f0ec9980dc10d7$exports = $d597a1c17218136531f0ec9980dc10d7$var$Yallist;
$d597a1c17218136531f0ec9980dc10d7$var$Yallist.Node = $d597a1c17218136531f0ec9980dc10d7$var$Node;
$d597a1c17218136531f0ec9980dc10d7$var$Yallist.create = $d597a1c17218136531f0ec9980dc10d7$var$Yallist;

function $d597a1c17218136531f0ec9980dc10d7$var$Yallist(list) {
  var self = this;

  if (!(self instanceof $d597a1c17218136531f0ec9980dc10d7$var$Yallist)) {
    self = new $d597a1c17218136531f0ec9980dc10d7$var$Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    $d597a1c17218136531f0ec9980dc10d7$var$push(this, arguments[i]);
  }

  return this.length;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    $d597a1c17218136531f0ec9980dc10d7$var$unshift(this, arguments[i]);
  }

  return this.length;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new $d597a1c17218136531f0ec9980dc10d7$var$Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new $d597a1c17218136531f0ec9980dc10d7$var$Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new $d597a1c17218136531f0ec9980dc10d7$var$Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new $d597a1c17218136531f0ec9980dc10d7$var$Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = $d597a1c17218136531f0ec9980dc10d7$var$insert(this, walker, nodes[i]);
  }

  return ret;
};

$d597a1c17218136531f0ec9980dc10d7$var$Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function $d597a1c17218136531f0ec9980dc10d7$var$insert(self, node, value) {
  var inserted = node === self.head ? new $d597a1c17218136531f0ec9980dc10d7$var$Node(value, null, node, self) : new $d597a1c17218136531f0ec9980dc10d7$var$Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function $d597a1c17218136531f0ec9980dc10d7$var$push(self, item) {
  self.tail = new $d597a1c17218136531f0ec9980dc10d7$var$Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function $d597a1c17218136531f0ec9980dc10d7$var$unshift(self, item) {
  self.head = new $d597a1c17218136531f0ec9980dc10d7$var$Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function $d597a1c17218136531f0ec9980dc10d7$var$Node(value, prev, next, list) {
  if (!(this instanceof $d597a1c17218136531f0ec9980dc10d7$var$Node)) {
    return new $d597a1c17218136531f0ec9980dc10d7$var$Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  $80286fd1a314c316b832a8d5c27e4e9c$init()($d597a1c17218136531f0ec9980dc10d7$var$Yallist);
} catch (er) {}

const $88604d50530c57f8814c8ae430bbad8b$var$MAX = Symbol('max');
const $88604d50530c57f8814c8ae430bbad8b$var$LENGTH = Symbol('length');
const $88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR = Symbol('lengthCalculator');
const $88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE = Symbol('allowStale');
const $88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE = Symbol('maxAge');
const $88604d50530c57f8814c8ae430bbad8b$var$DISPOSE = Symbol('dispose');
const $88604d50530c57f8814c8ae430bbad8b$var$NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
const $88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST = Symbol('lruList');
const $88604d50530c57f8814c8ae430bbad8b$var$CACHE = Symbol('cache');
const $88604d50530c57f8814c8ae430bbad8b$var$UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

const $88604d50530c57f8814c8ae430bbad8b$var$naiveLength = () => 1; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class $88604d50530c57f8814c8ae430bbad8b$var$LRUCache {
  constructor(options) {
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[$88604d50530c57f8814c8ae430bbad8b$var$MAX] = options.max || Infinity;
    const lc = options.length || $88604d50530c57f8814c8ae430bbad8b$var$naiveLength;
    this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR] = typeof lc !== 'function' ? $88604d50530c57f8814c8ae430bbad8b$var$naiveLength : lc;
    this[$88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE] = options.maxAge || 0;
    this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE] = options.dispose;
    this[$88604d50530c57f8814c8ae430bbad8b$var$NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[$88604d50530c57f8814c8ae430bbad8b$var$UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
    this[$88604d50530c57f8814c8ae430bbad8b$var$MAX] = mL || Infinity;
    $88604d50530c57f8814c8ae430bbad8b$var$trim(this);
  }

  get max() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$MAX];
  }

  set allowStale(allowStale) {
    this[$88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE] = !!allowStale;
  }

  get allowStale() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE];
  }

  set maxAge(mA) {
    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
    this[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE] = mA;
    $88604d50530c57f8814c8ae430bbad8b$var$trim(this);
  }

  get maxAge() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE];
  } // resize the cache when the lengthCalculator changes.


  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== 'function') lC = $88604d50530c57f8814c8ae430bbad8b$var$naiveLength;

    if (lC !== this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR]) {
      this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR] = lC;
      this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] = 0;
      this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].forEach(hit => {
        hit.length = this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR](hit.value, hit.key);
        this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] += hit.length;
      });
    }

    $88604d50530c57f8814c8ae430bbad8b$var$trim(this);
  }

  get lengthCalculator() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR];
  }

  get length() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH];
  }

  get itemCount() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].length;
  }

  rforEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev;
      $88604d50530c57f8814c8ae430bbad8b$var$forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }

  forEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].head; walker !== null;) {
      const next = walker.next;
      $88604d50530c57f8814c8ae430bbad8b$var$forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }

  keys() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].toArray().map(k => k.key);
  }

  values() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].toArray().map(k => k.value);
  }

  reset() {
    if (this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE] && this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST] && this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].length) {
      this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].forEach(hit => this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE](hit.key, hit.value));
    }

    this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE] = new Map(); // hash of items by key

    // hash of items by key
    this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST] = new $d597a1c17218136531f0ec9980dc10d7$exports(); // list of items in order of use recency

    // list of items in order of use recency
    this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] = 0; // length of items in the list
  }

  dump() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].map(hit => $88604d50530c57f8814c8ae430bbad8b$var$isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter(h => h);
  }

  dumpLru() {
    return this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST];
  }

  set(key, value, maxAge) {
    maxAge = maxAge || this[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE];
    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
    const now = maxAge ? Date.now() : 0;
    const len = this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH_CALCULATOR](value, key);

    if (this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].has(key)) {
      if (len > this[$88604d50530c57f8814c8ae430bbad8b$var$MAX]) {
        $88604d50530c57f8814c8ae430bbad8b$var$del(this, this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].get(key));
        return false;
      }

      const node = this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].get(key);
      const item = node.value; // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE]) {
        if (!this[$88604d50530c57f8814c8ae430bbad8b$var$NO_DISPOSE_ON_SET]) this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE](key, item.value);
      }

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      $88604d50530c57f8814c8ae430bbad8b$var$trim(this);
      return true;
    }

    const hit = new $88604d50530c57f8814c8ae430bbad8b$var$Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

    // oversized objects fall out of cache automatically.
    if (hit.length > this[$88604d50530c57f8814c8ae430bbad8b$var$MAX]) {
      if (this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE]) this[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE](key, value);
      return false;
    }

    this[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] += hit.length;
    this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].unshift(hit);
    this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].set(key, this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].head);
    $88604d50530c57f8814c8ae430bbad8b$var$trim(this);
    return true;
  }

  has(key) {
    if (!this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].has(key)) return false;
    const hit = this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].get(key).value;
    return !$88604d50530c57f8814c8ae430bbad8b$var$isStale(this, hit);
  }

  get(key) {
    return $88604d50530c57f8814c8ae430bbad8b$var$get(this, key, true);
  }

  peek(key) {
    return $88604d50530c57f8814c8ae430bbad8b$var$get(this, key, false);
  }

  pop() {
    const node = this[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].tail;
    if (!node) return null;
    $88604d50530c57f8814c8ae430bbad8b$var$del(this, node);
    return node.value;
  }

  del(key) {
    $88604d50530c57f8814c8ae430bbad8b$var$del(this, this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].get(key));
  }

  load(arr) {
    // reset the cache
    this.reset();
    const now = Date.now(); // A previous serialized cache has the most recent items first

    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0) // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v);else {
        const maxAge = expiresAt - now; // dont add already expired items

        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }

  prune() {
    this[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].forEach((value, key) => $88604d50530c57f8814c8ae430bbad8b$var$get(this, key, false));
  }

}

const $88604d50530c57f8814c8ae430bbad8b$var$get = (self, key, doUse) => {
  const node = self[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].get(key);

  if (node) {
    const hit = node.value;

    if ($88604d50530c57f8814c8ae430bbad8b$var$isStale(self, hit)) {
      $88604d50530c57f8814c8ae430bbad8b$var$del(self, node);
      if (!self[$88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[$88604d50530c57f8814c8ae430bbad8b$var$UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

const $88604d50530c57f8814c8ae430bbad8b$var$isStale = (self, hit) => {
  if (!hit || !hit.maxAge && !self[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE]) return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE] && diff > self[$88604d50530c57f8814c8ae430bbad8b$var$MAX_AGE];
};

const $88604d50530c57f8814c8ae430bbad8b$var$trim = self => {
  if (self[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] > self[$88604d50530c57f8814c8ae430bbad8b$var$MAX]) {
    for (let walker = self[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].tail; self[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] > self[$88604d50530c57f8814c8ae430bbad8b$var$MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev;
      $88604d50530c57f8814c8ae430bbad8b$var$del(self, walker);
      walker = prev;
    }
  }
};

const $88604d50530c57f8814c8ae430bbad8b$var$del = (self, node) => {
  if (node) {
    const hit = node.value;
    if (self[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE]) self[$88604d50530c57f8814c8ae430bbad8b$var$DISPOSE](hit.key, hit.value);
    self[$88604d50530c57f8814c8ae430bbad8b$var$LENGTH] -= hit.length;
    self[$88604d50530c57f8814c8ae430bbad8b$var$CACHE].delete(hit.key);
    self[$88604d50530c57f8814c8ae430bbad8b$var$LRU_LIST].removeNode(node);
  }
};

class $88604d50530c57f8814c8ae430bbad8b$var$Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }

}

const $88604d50530c57f8814c8ae430bbad8b$var$forEachStep = (self, fn, node, thisp) => {
  let hit = node.value;

  if ($88604d50530c57f8814c8ae430bbad8b$var$isStale(self, hit)) {
    $88604d50530c57f8814c8ae430bbad8b$var$del(self, node);
    if (!self[$88604d50530c57f8814c8ae430bbad8b$var$ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

$88604d50530c57f8814c8ae430bbad8b$exports = $88604d50530c57f8814c8ae430bbad8b$var$LRUCache;
const $fa7a598bb3a5cbf09268615b77c3a165$var$cache = new $88604d50530c57f8814c8ae430bbad8b$exports({
  max: 1000
});

const $fa7a598bb3a5cbf09268615b77c3a165$var$isNullSet = c => c.value === '<0.0.0-0';

const $fa7a598bb3a5cbf09268615b77c3a165$var$isAny = c => c.value === ''; // take a set of comparators and determine whether there
// exists a version which can satisfy it


// take a set of comparators and determine whether there
// exists a version which can satisfy it
const $fa7a598bb3a5cbf09268615b77c3a165$var$isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(otherComparator => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
}; // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const $fa7a598bb3a5cbf09268615b77c3a165$var$parseComparator = (comp, options) => {
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('comp', comp, options);
  comp = $fa7a598bb3a5cbf09268615b77c3a165$var$replaceCarets(comp, options);
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('caret', comp);
  comp = $fa7a598bb3a5cbf09268615b77c3a165$var$replaceTildes(comp, options);
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('tildes', comp);
  comp = $fa7a598bb3a5cbf09268615b77c3a165$var$replaceXRanges(comp, options);
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('xrange', comp);
  comp = $fa7a598bb3a5cbf09268615b77c3a165$var$replaceStars(comp, options);
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('stars', comp);
  return comp;
};

const $fa7a598bb3a5cbf09268615b77c3a165$var$isX = id => !id || id.toLowerCase() === 'x' || id === '*'; // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0


// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceTildes = (comp, options) => comp.trim().split(/\s+/).map(comp => {
  return $fa7a598bb3a5cbf09268615b77c3a165$var$replaceTilde(comp, options);
}).join(' ');

const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceTilde = (comp, options) => {
  const r = options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.TILDELOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('tilde', comp, _, M, m, p, pr);
    let ret;

    if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(M)) {
      ret = '';
    } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
    } else if (pr) {
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('replaceTilde pr', pr);
      ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('tilde return', ret);
    return ret;
  });
}; // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0


// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceCarets = (comp, options) => comp.trim().split(/\s+/).map(comp => {
  return $fa7a598bb3a5cbf09268615b77c3a165$var$replaceCaret(comp, options);
}).join(' ');

const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceCaret = (comp, options) => {
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('caret', comp, options);
  const r = options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.CARETLOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.CARET];
  const z = options.includePrerelease ? '-0' : '';
  return comp.replace(r, (_, M, m, p, pr) => {
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('caret', comp, _, M, m, p, pr);
    let ret;

    if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(M)) {
      ret = '';
    } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
      }
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('caret return', ret);
    return ret;
  });
};

const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceXRanges = (comp, options) => {
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(comp => {
    return $fa7a598bb3a5cbf09268615b77c3a165$var$replaceXRange(comp, options);
  }).join(' ');
};

const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.XRANGELOOSE] : $370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('xRange', comp, ret, gtlt, M, m, p, pr);
    const xM = $fa7a598bb3a5cbf09268615b77c3a165$var$isX(M);
    const xm = xM || $fa7a598bb3a5cbf09268615b77c3a165$var$isX(m);
    const xp = xm || $fa7a598bb3a5cbf09268615b77c3a165$var$isX(p);
    const anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      if (gtlt === '<') pr = '-0';
      ret = `${gtlt + M}.${m}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
    }

    $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('xRange return', ret);
    return ret;
  });
}; // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceStars = (comp, options) => {
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace($370b691cddaa8013c401511fceda2353$export$re[$370b691cddaa8013c401511fceda2353$export$t.STAR], '');
};

const $fa7a598bb3a5cbf09268615b77c3a165$var$replaceGTE0 = (comp, options) => {
  $9c3ef858f451ee9627c1dd0d65c9dc2f$exports('replaceGTE0', comp, options);
  return comp.trim().replace($370b691cddaa8013c401511fceda2353$export$re[options.includePrerelease ? $370b691cddaa8013c401511fceda2353$export$t.GTE0PRE : $370b691cddaa8013c401511fceda2353$export$t.GTE0], '');
}; // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0


// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const $fa7a598bb3a5cbf09268615b77c3a165$var$hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(fM)) {
    from = '';
  } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
  } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`;
  }

  if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(tM)) {
    to = '';
  } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if ($fa7a598bb3a5cbf09268615b77c3a165$var$isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }

  return `${from} ${to}`.trim();
};

const $fa7a598bb3a5cbf09268615b77c3a165$var$testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      $9c3ef858f451ee9627c1dd0d65c9dc2f$exports(set[i].semver);

      if (set[i].semver === $bbdb0047a126baa32311c88919becbc2$exports.ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
};

// ASSET: node_modules/semver/functions/satisfies.js
var $dc42a2bc159776302c9d30280645ea9d$exports = {};

const $dc42a2bc159776302c9d30280645ea9d$var$satisfies = (version, range, options) => {
  try {
    range = new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
};

$dc42a2bc159776302c9d30280645ea9d$exports = $dc42a2bc159776302c9d30280645ea9d$var$satisfies;
// ASSET: node_modules/semver/ranges/to-comparators.js
var $2441de1581b9dc4fa7fb632471137700$exports = {};

// Mostly just for testing and legacy API reasons
const $2441de1581b9dc4fa7fb632471137700$var$toComparators = (range, options) => new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options).set.map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

$2441de1581b9dc4fa7fb632471137700$exports = $2441de1581b9dc4fa7fb632471137700$var$toComparators;
// ASSET: node_modules/semver/ranges/max-satisfying.js
var $9e0e8148b004cc7e913bc49ac34b7a93$exports = {};

const $9e0e8148b004cc7e913bc49ac34b7a93$var$maxSatisfying = (versions, range, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;

  try {
    rangeObj = new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(v => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new $90838788dbff9b531e37a7e32d08f442$exports(max, options);
      }
    }
  });
  return max;
};

$9e0e8148b004cc7e913bc49ac34b7a93$exports = $9e0e8148b004cc7e913bc49ac34b7a93$var$maxSatisfying;
// ASSET: node_modules/semver/ranges/min-satisfying.js
var $08e25405466308aba5b6166023e85984$exports = {};

const $08e25405466308aba5b6166023e85984$var$minSatisfying = (versions, range, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;

  try {
    rangeObj = new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(v => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new $90838788dbff9b531e37a7e32d08f442$exports(min, options);
      }
    }
  });
  return min;
};

$08e25405466308aba5b6166023e85984$exports = $08e25405466308aba5b6166023e85984$var$minSatisfying;
// ASSET: node_modules/semver/ranges/min-version.js
var $9abe4b2fe4aebb70cf9a12f0a114a84f$exports = {};

const $9abe4b2fe4aebb70cf9a12f0a114a84f$var$minVersion = (range, loose) => {
  range = new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, loose);
  let minver = new $90838788dbff9b531e37a7e32d08f442$exports('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new $90838788dbff9b531e37a7e32d08f442$exports('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];
    let setMin = null;
    comparators.forEach(comparator => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new $90838788dbff9b531e37a7e32d08f442$exports(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        /* fallthrough */
        case '':
        case '>=':
          if (!setMin || $8d8cfccbf9956169e396368f4b2186a7$exports(compver, setMin)) {
            setMin = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`);
      }
    });
    if (setMin && (!minver || $8d8cfccbf9956169e396368f4b2186a7$exports(minver, setMin))) minver = setMin;
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
};

$9abe4b2fe4aebb70cf9a12f0a114a84f$exports = $9abe4b2fe4aebb70cf9a12f0a114a84f$var$minVersion;
// ASSET: node_modules/semver/ranges/valid.js
var $e03b174bf0f3299d323d548eee3d194b$exports = {};

const $e03b174bf0f3299d323d548eee3d194b$var$validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options).range || '*';
  } catch (er) {
    return null;
  }
};

$e03b174bf0f3299d323d548eee3d194b$exports = $e03b174bf0f3299d323d548eee3d194b$var$validRange;
// ASSET: node_modules/semver/ranges/outside.js
var $70a5c4bf9d94232cc8311897b3d9abcb$exports = {};
const {
  ANY: $70a5c4bf9d94232cc8311897b3d9abcb$var$ANY
} = $bbdb0047a126baa32311c88919becbc2$exports;

const $70a5c4bf9d94232cc8311897b3d9abcb$var$outside = (version, range, hilo, options) => {
  version = new $90838788dbff9b531e37a7e32d08f442$exports(version, options);
  range = new $fa7a598bb3a5cbf09268615b77c3a165$exports(range, options);
  let gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = $8d8cfccbf9956169e396368f4b2186a7$exports;
      ltefn = $0cf4a6b86009163ef37342af6f4a3362$exports;
      ltfn = $39b174882da85e7dec7309e68b502352$exports;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = $39b174882da85e7dec7309e68b502352$exports;
      ltefn = $e8aba9e682682b9e1b770ea77508fd3e$exports;
      ltfn = $8d8cfccbf9956169e396368f4b2186a7$exports;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisfies the range it is not outside


  // If it satisfies the range it is not outside
  if ($dc42a2bc159776302c9d30280645ea9d$exports(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];
    let high = null;
    let low = null;
    comparators.forEach(comparator => {
      if (comparator.semver === $70a5c4bf9d94232cc8311897b3d9abcb$var$ANY) {
        comparator = new $bbdb0047a126baa32311c88919becbc2$exports('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
};

$70a5c4bf9d94232cc8311897b3d9abcb$exports = $70a5c4bf9d94232cc8311897b3d9abcb$var$outside;
// ASSET: node_modules/semver/ranges/gtr.js
var $48dc7e170bdf0c2c525dc6d0a2626150$exports = {};

const $48dc7e170bdf0c2c525dc6d0a2626150$var$gtr = (version, range, options) => $70a5c4bf9d94232cc8311897b3d9abcb$exports(version, range, '>', options);

$48dc7e170bdf0c2c525dc6d0a2626150$exports = $48dc7e170bdf0c2c525dc6d0a2626150$var$gtr;
// ASSET: node_modules/semver/ranges/ltr.js
var $e968cc84d8e82fccac9f7d471ff27a61$exports = {};

// Determine if version is less than all the versions possible in the range
const $e968cc84d8e82fccac9f7d471ff27a61$var$ltr = (version, range, options) => $70a5c4bf9d94232cc8311897b3d9abcb$exports(version, range, '<', options);

$e968cc84d8e82fccac9f7d471ff27a61$exports = $e968cc84d8e82fccac9f7d471ff27a61$var$ltr;
// ASSET: node_modules/semver/ranges/intersects.js
var $364dd71b805587423a34dd03cf5ce28c$exports = {};

const $364dd71b805587423a34dd03cf5ce28c$var$intersects = (r1, r2, options) => {
  r1 = new $fa7a598bb3a5cbf09268615b77c3a165$exports(r1, options);
  r2 = new $fa7a598bb3a5cbf09268615b77c3a165$exports(r2, options);
  return r1.intersects(r2);
};

$364dd71b805587423a34dd03cf5ce28c$exports = $364dd71b805587423a34dd03cf5ce28c$var$intersects;
// ASSET: node_modules/semver/ranges/simplify.js
var $3a967302c1e997cfabb3e49e0d319a35$exports = {};

$3a967302c1e997cfabb3e49e0d319a35$exports = (versions, range, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => $6db67f46b1a7eea902776301e8e52b4d$exports(a, b, options));

  for (const version of v) {
    const included = $dc42a2bc159776302c9d30280645ea9d$exports(version, range, options);

    if (included) {
      prev = version;
      if (!min) min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }

      prev = null;
      min = null;
    }
  }

  if (min) set.push([min, null]);
  const ranges = [];

  for (const [min, max] of set) {
    if (min === max) ranges.push(min);else if (!max && min === v[0]) ranges.push('*');else if (!max) ranges.push(`>=${min}`);else if (min === v[0]) ranges.push(`<=${max}`);else ranges.push(`${min} - ${max}`);
  }

  const simplified = ranges.join(' || ');
  const original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range;
};

// ASSET: node_modules/semver/ranges/subset.js
var $6fd8cf7865ae87467ad0904ed1396911$exports = {};
const {
  ANY: $6fd8cf7865ae87467ad0904ed1396911$var$ANY
} = $bbdb0047a126baa32311c88919becbc2$exports;

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true
const $6fd8cf7865ae87467ad0904ed1396911$var$subset = (sub, dom, options) => {
  if (sub === dom) return true;
  sub = new $fa7a598bb3a5cbf09268615b77c3a165$exports(sub, options);
  dom = new $fa7a598bb3a5cbf09268615b77c3a165$exports(dom, options);
  let sawNonNull = false;

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = $6fd8cf7865ae87467ad0904ed1396911$var$simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) continue OUTER;
    } // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.


    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) return false;
  }

  return true;
};

const $6fd8cf7865ae87467ad0904ed1396911$var$simpleSubset = (sub, dom, options) => {
  if (sub === dom) return true;
  if (sub.length === 1 && sub[0].semver === $6fd8cf7865ae87467ad0904ed1396911$var$ANY) return dom.length === 1 && dom[0].semver === $6fd8cf7865ae87467ad0904ed1396911$var$ANY;
  const eqSet = new Set();
  let gt, lt;

  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') gt = $6fd8cf7865ae87467ad0904ed1396911$var$higherGT(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = $6fd8cf7865ae87467ad0904ed1396911$var$lowerLT(lt, c, options);else eqSet.add(c.semver);
  }

  if (eqSet.size > 1) return null;
  let gtltComp;

  if (gt && lt) {
    gtltComp = $6db67f46b1a7eea902776301e8e52b4d$exports(gt.semver, lt.semver, options);
    if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;
  } // will iterate one or zero times


  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !$dc42a2bc159776302c9d30280645ea9d$exports(eq, String(gt), options)) return null;
    if (lt && !$dc42a2bc159776302c9d30280645ea9d$exports(eq, String(lt), options)) return null;

    for (const c of dom) {
      if (!$dc42a2bc159776302c9d30280645ea9d$exports(eq, String(c), options)) return false;
    }

    return true;
  }

  let higher, lower;
  let hasDomLT, hasDomGT;

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';

    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = $6fd8cf7865ae87467ad0904ed1396911$var$higherGT(gt, c, options);
        if (higher === c && higher !== gt) return false;
      } else if (gt.operator === '>=' && !$dc42a2bc159776302c9d30280645ea9d$exports(gt.semver, String(c), options)) return false;
    }

    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = $6fd8cf7865ae87467ad0904ed1396911$var$lowerLT(lt, c, options);
        if (lower === c && lower !== lt) return false;
      } else if (lt.operator === '<=' && !$dc42a2bc159776302c9d30280645ea9d$exports(lt.semver, String(c), options)) return false;
    }

    if (!c.operator && (lt || gt) && gtltComp !== 0) return false;
  } // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0


  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
  if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
  return true;
}; // >=1.2.3 is lower than >1.2.3


// >=1.2.3 is lower than >1.2.3
const $6fd8cf7865ae87467ad0904ed1396911$var$higherGT = (a, b, options) => {
  if (!a) return b;
  const comp = $6db67f46b1a7eea902776301e8e52b4d$exports(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
}; // <=1.2.3 is higher than <1.2.3


// <=1.2.3 is higher than <1.2.3
const $6fd8cf7865ae87467ad0904ed1396911$var$lowerLT = (a, b, options) => {
  if (!a) return b;
  const comp = $6db67f46b1a7eea902776301e8e52b4d$exports(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};

$6fd8cf7865ae87467ad0904ed1396911$exports = $6fd8cf7865ae87467ad0904ed1396911$var$subset;
$472287880c3e8d04bc38855fbd388e1f$exports = {
  re: $370b691cddaa8013c401511fceda2353$export$re,
  src: $370b691cddaa8013c401511fceda2353$export$src,
  tokens: $370b691cddaa8013c401511fceda2353$export$t,
  SEMVER_SPEC_VERSION: $c736c5dbbcfed02f22613ddbcbd396a0$exports.SEMVER_SPEC_VERSION,
  SemVer: $90838788dbff9b531e37a7e32d08f442$exports,
  compareIdentifiers: $d4209f4727b9f5f1b7a0035d1fe52f17$exports.compareIdentifiers,
  rcompareIdentifiers: $d4209f4727b9f5f1b7a0035d1fe52f17$exports.rcompareIdentifiers,
  parse: $2059718adffe7d8f119f10a8c82da252$exports,
  valid: $10e1ac856f2bc602ee35b81d7da56c4c$exports,
  clean: $a568db2d6518e0098588ce5e76fa9713$exports,
  inc: $3620e9574650170b96196996d194ac67$exports,
  diff: $08e0d6ecb4dab1a59d94e7b6dc646668$exports,
  major: $a2c74fb40341f6fec6b3a07eb80926b0$exports,
  minor: $b24c96e1fe79ad76416666fb3ed3ef09$exports,
  patch: $94619145c94354305e261fd291b0671a$exports,
  prerelease: $734eb46e11638e724e8ff5fa63211557$exports,
  compare: $6db67f46b1a7eea902776301e8e52b4d$exports,
  rcompare: $5b623ca9eb757af784a32500dc22c2bf$exports,
  compareLoose: $f0f67bfa59f94595577b7f3da5f679d8$exports,
  compareBuild: $b5ac5815fe2e9d5e6229dd738a335c52$exports,
  sort: $4eeb86212d5ddef4d220f36a3c13afd3$exports,
  rsort: $0dc8b73484dbf130d08d0346763a91ec$exports,
  gt: $8d8cfccbf9956169e396368f4b2186a7$exports,
  lt: $39b174882da85e7dec7309e68b502352$exports,
  eq: $4301714d519beec67211d188478d1247$exports,
  neq: $e1c0855f55d4c4b59130785b673b42ab$exports,
  gte: $e8aba9e682682b9e1b770ea77508fd3e$exports,
  lte: $0cf4a6b86009163ef37342af6f4a3362$exports,
  cmp: $8bf97baf408c2c1ba865ddfd33ccd65e$exports,
  coerce: $2256fecbe87afa313b690f866ce87073$exports,
  Comparator: $bbdb0047a126baa32311c88919becbc2$exports,
  Range: $fa7a598bb3a5cbf09268615b77c3a165$exports,
  satisfies: $dc42a2bc159776302c9d30280645ea9d$exports,
  toComparators: $2441de1581b9dc4fa7fb632471137700$exports,
  maxSatisfying: $9e0e8148b004cc7e913bc49ac34b7a93$exports,
  minSatisfying: $08e25405466308aba5b6166023e85984$exports,
  minVersion: $9abe4b2fe4aebb70cf9a12f0a114a84f$exports,
  validRange: $e03b174bf0f3299d323d548eee3d194b$exports,
  outside: $70a5c4bf9d94232cc8311897b3d9abcb$exports,
  gtr: $48dc7e170bdf0c2c525dc6d0a2626150$exports,
  ltr: $e968cc84d8e82fccac9f7d471ff27a61$exports,
  intersects: $364dd71b805587423a34dd03cf5ce28c$exports,
  simplifyRange: $3a967302c1e997cfabb3e49e0d319a35$exports,
  subset: $6fd8cf7865ae87467ad0904ed1396911$exports
};
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
// ASSET: node_modules/@yarnpkg/core/lib/hashUtils.js
var $d8692e28e950b48ea4715ab19e9bf9a1$exports = {};
var $d8692e28e950b48ea4715ab19e9bf9a1$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($d8692e28e950b48ea4715ab19e9bf9a1$exports, "__esModule", {
  value: true
});
var $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumPattern = ($d8692e28e950b48ea4715ab19e9bf9a1$export$checksumFile = ($d8692e28e950b48ea4715ab19e9bf9a1$export$makeHash = void 0, $d8692e28e950b48ea4715ab19e9bf9a1$exports.makeHash = $d8692e28e950b48ea4715ab19e9bf9a1$export$makeHash), $d8692e28e950b48ea4715ab19e9bf9a1$exports.checksumFile = $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumFile);
$d8692e28e950b48ea4715ab19e9bf9a1$exports.checksumPattern = $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumPattern;
// ASSET: node_modules/randombytes/browser.js
var $147ca815017faf95a1acd6f358cb2be5$exports = {};
var $147ca815017faf95a1acd6f358cb2be5$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var $147ca815017faf95a1acd6f358cb2be5$var$MAX_BYTES = 65536; // Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var $147ca815017faf95a1acd6f358cb2be5$var$MAX_UINT32 = 4294967295;

function $147ca815017faf95a1acd6f358cb2be5$var$oldBrowser() {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11');
}

var $147ca815017faf95a1acd6f358cb2be5$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $147ca815017faf95a1acd6f358cb2be5$var$crypto = $parcel$global.crypto || $parcel$global.msCrypto;

if ($147ca815017faf95a1acd6f358cb2be5$var$crypto && $147ca815017faf95a1acd6f358cb2be5$var$crypto.getRandomValues) {
  $147ca815017faf95a1acd6f358cb2be5$exports = $147ca815017faf95a1acd6f358cb2be5$var$randomBytes;
} else {
  $147ca815017faf95a1acd6f358cb2be5$exports = $147ca815017faf95a1acd6f358cb2be5$var$oldBrowser;
}

function $147ca815017faf95a1acd6f358cb2be5$var$randomBytes(size, cb) {
  // phantomjs needs to throw
  if (size > $147ca815017faf95a1acd6f358cb2be5$var$MAX_UINT32) throw new RangeError('requested too many random bytes');
  var bytes = $147ca815017faf95a1acd6f358cb2be5$var$Buffer.allocUnsafe(size);

  if (size > 0) {
    // getRandomValues fails on IE if size == 0
    if (size > $147ca815017faf95a1acd6f358cb2be5$var$MAX_BYTES) {
      // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += $147ca815017faf95a1acd6f358cb2be5$var$MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        $147ca815017faf95a1acd6f358cb2be5$var$crypto.getRandomValues(bytes.slice(generated, generated + $147ca815017faf95a1acd6f358cb2be5$var$MAX_BYTES));
      }
    } else {
      $147ca815017faf95a1acd6f358cb2be5$var$crypto.getRandomValues(bytes);
    }
  }

  if (typeof cb === 'function') {
    return $147ca815017faf95a1acd6f358cb2be5$var$process.nextTick(function () {
      cb(null, bytes);
    });
  }

  return bytes;
}

// ASSET: node_modules/create-hash/browser.js
var $6d6129111db079da86df05b60d62b273$exports = {};
var $6d6129111db079da86df05b60d62b273$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/md5.js/index.js
var $42329dad2f5bf496d013cc797f687f91$exports = {};
var $42329dad2f5bf496d013cc797f687f91$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/hash-base/index.js
var $4a3f33849d4cf351a1d46fc24f48018c$exports = {};
var $4a3f33849d4cf351a1d46fc24f48018c$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $4a3f33849d4cf351a1d46fc24f48018c$var$Transform = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform;
var $4a3f33849d4cf351a1d46fc24f48018c$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();

function $4a3f33849d4cf351a1d46fc24f48018c$var$throwIfNotStringOrBuffer(val, prefix) {
  if (!$4a3f33849d4cf351a1d46fc24f48018c$var$Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}

function $4a3f33849d4cf351a1d46fc24f48018c$var$HashBase(blockSize) {
  $4a3f33849d4cf351a1d46fc24f48018c$var$Transform.call(this);
  this._block = $4a3f33849d4cf351a1d46fc24f48018c$var$Buffer.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}

$4a3f33849d4cf351a1d46fc24f48018c$var$inherits($4a3f33849d4cf351a1d46fc24f48018c$var$HashBase, $4a3f33849d4cf351a1d46fc24f48018c$var$Transform);

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null;

  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }

  callback(error);
};

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype._flush = function (callback) {
  var error = null;

  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }

  callback(error);
};

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype.update = function (data, encoding) {
  $4a3f33849d4cf351a1d46fc24f48018c$var$throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!$4a3f33849d4cf351a1d46fc24f48018c$var$Buffer.isBuffer(data)) data = $4a3f33849d4cf351a1d46fc24f48018c$var$Buffer.from(data, encoding); // consume data

  // consume data
  var block = this._block;
  var offset = 0;

  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];

    this._update();

    this._blockOffset = 0;
  }

  while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length


  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }

  return this;
};

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype._update = function () {
  throw new Error('_update is not implemented');
};

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;

  var digest = this._digest();

  if (encoding !== undefined) digest = digest.toString(encoding); // reset state

  // reset state
  this._block.fill(0);

  this._blockOffset = 0;

  for (var i = 0; i < 4; ++i) this._length[i] = 0;

  return digest;
};

$4a3f33849d4cf351a1d46fc24f48018c$var$HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};

$4a3f33849d4cf351a1d46fc24f48018c$exports = $4a3f33849d4cf351a1d46fc24f48018c$var$HashBase;
var $42329dad2f5bf496d013cc797f687f91$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $42329dad2f5bf496d013cc797f687f91$var$ARRAY16 = new Array(16);

function $42329dad2f5bf496d013cc797f687f91$var$MD5() {
  $4a3f33849d4cf351a1d46fc24f48018c$exports.call(this, 64); // state

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
}

$42329dad2f5bf496d013cc797f687f91$var$inherits($42329dad2f5bf496d013cc797f687f91$var$MD5, $4a3f33849d4cf351a1d46fc24f48018c$exports);

$42329dad2f5bf496d013cc797f687f91$var$MD5.prototype._update = function () {
  var M = $42329dad2f5bf496d013cc797f687f91$var$ARRAY16;

  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = $42329dad2f5bf496d013cc797f687f91$var$fnF(a, b, c, d, M[0], 0xd76aa478, 7);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnF(c, d, a, b, M[2], 0x242070db, 17);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnF(d, a, b, c, M[5], 0x4787c62a, 12);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnF(c, d, a, b, M[6], 0xa8304613, 17);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnF(b, c, d, a, M[7], 0xfd469501, 22);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnF(a, b, c, d, M[8], 0x698098d8, 7);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnF(b, c, d, a, M[11], 0x895cd7be, 22);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnF(a, b, c, d, M[12], 0x6b901122, 7);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnF(d, a, b, c, M[13], 0xfd987193, 12);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnF(c, d, a, b, M[14], 0xa679438e, 17);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnF(b, c, d, a, M[15], 0x49b40821, 22);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnG(a, b, c, d, M[1], 0xf61e2562, 5);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnG(d, a, b, c, M[6], 0xc040b340, 9);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnG(c, d, a, b, M[11], 0x265e5a51, 14);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnG(a, b, c, d, M[5], 0xd62f105d, 5);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnG(d, a, b, c, M[10], 0x02441453, 9);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnG(d, a, b, c, M[14], 0xc33707d6, 9);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnG(b, c, d, a, M[8], 0x455a14ed, 20);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnG(c, d, a, b, M[7], 0x676f02d9, 14);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnH(a, b, c, d, M[5], 0xfffa3942, 4);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnH(d, a, b, c, M[8], 0x8771f681, 11);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnH(b, c, d, a, M[14], 0xfde5380c, 23);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnH(a, b, c, d, M[1], 0xa4beea44, 4);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnH(b, c, d, a, M[6], 0x04881d05, 23);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnI(a, b, c, d, M[0], 0xf4292244, 6);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnI(d, a, b, c, M[7], 0x432aff97, 10);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnI(c, d, a, b, M[14], 0xab9423a7, 15);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnI(b, c, d, a, M[5], 0xfc93a039, 21);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnI(a, b, c, d, M[12], 0x655b59c3, 6);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnI(c, d, a, b, M[10], 0xffeff47d, 15);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnI(b, c, d, a, M[1], 0x85845dd1, 21);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnI(c, d, a, b, M[6], 0xa3014314, 15);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
  a = $42329dad2f5bf496d013cc797f687f91$var$fnI(a, b, c, d, M[4], 0xf7537e82, 6);
  d = $42329dad2f5bf496d013cc797f687f91$var$fnI(d, a, b, c, M[11], 0xbd3af235, 10);
  c = $42329dad2f5bf496d013cc797f687f91$var$fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
  b = $42329dad2f5bf496d013cc797f687f91$var$fnI(b, c, d, a, M[9], 0xeb86d391, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};

$42329dad2f5bf496d013cc797f687f91$var$MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  // produce result
  var buffer = $42329dad2f5bf496d013cc797f687f91$var$Buffer.allocUnsafe(16);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  return buffer;
};

function $42329dad2f5bf496d013cc797f687f91$var$rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function $42329dad2f5bf496d013cc797f687f91$var$fnF(a, b, c, d, m, k, s) {
  return $42329dad2f5bf496d013cc797f687f91$var$rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}

function $42329dad2f5bf496d013cc797f687f91$var$fnG(a, b, c, d, m, k, s) {
  return $42329dad2f5bf496d013cc797f687f91$var$rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}

function $42329dad2f5bf496d013cc797f687f91$var$fnH(a, b, c, d, m, k, s) {
  return $42329dad2f5bf496d013cc797f687f91$var$rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}

function $42329dad2f5bf496d013cc797f687f91$var$fnI(a, b, c, d, m, k, s) {
  return $42329dad2f5bf496d013cc797f687f91$var$rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}

$42329dad2f5bf496d013cc797f687f91$exports = $42329dad2f5bf496d013cc797f687f91$var$MD5;
// ASSET: node_modules/ripemd160/index.js
var $8af1e6938a9638dd69243425230f9e70$exports = {};
var $8af1e6938a9638dd69243425230f9e70$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $8af1e6938a9638dd69243425230f9e70$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $8af1e6938a9638dd69243425230f9e70$var$ARRAY16 = new Array(16);
var $8af1e6938a9638dd69243425230f9e70$var$zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var $8af1e6938a9638dd69243425230f9e70$var$zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var $8af1e6938a9638dd69243425230f9e70$var$sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var $8af1e6938a9638dd69243425230f9e70$var$sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var $8af1e6938a9638dd69243425230f9e70$var$hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var $8af1e6938a9638dd69243425230f9e70$var$hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

function $8af1e6938a9638dd69243425230f9e70$var$RIPEMD160() {
  $4a3f33849d4cf351a1d46fc24f48018c$exports.call(this, 64); // state

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
}

$8af1e6938a9638dd69243425230f9e70$var$inherits($8af1e6938a9638dd69243425230f9e70$var$RIPEMD160, $4a3f33849d4cf351a1d46fc24f48018c$exports);

$8af1e6938a9638dd69243425230f9e70$var$RIPEMD160.prototype._update = function () {
  var words = $8af1e6938a9638dd69243425230f9e70$var$ARRAY16;

  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0; // computation

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;

    if (i < 16) {
      tl = $8af1e6938a9638dd69243425230f9e70$var$fn1(al, bl, cl, dl, el, words[$8af1e6938a9638dd69243425230f9e70$var$zl[i]], $8af1e6938a9638dd69243425230f9e70$var$hl[0], $8af1e6938a9638dd69243425230f9e70$var$sl[i]);
      tr = $8af1e6938a9638dd69243425230f9e70$var$fn5(ar, br, cr, dr, er, words[$8af1e6938a9638dd69243425230f9e70$var$zr[i]], $8af1e6938a9638dd69243425230f9e70$var$hr[0], $8af1e6938a9638dd69243425230f9e70$var$sr[i]);
    } else if (i < 32) {
      tl = $8af1e6938a9638dd69243425230f9e70$var$fn2(al, bl, cl, dl, el, words[$8af1e6938a9638dd69243425230f9e70$var$zl[i]], $8af1e6938a9638dd69243425230f9e70$var$hl[1], $8af1e6938a9638dd69243425230f9e70$var$sl[i]);
      tr = $8af1e6938a9638dd69243425230f9e70$var$fn4(ar, br, cr, dr, er, words[$8af1e6938a9638dd69243425230f9e70$var$zr[i]], $8af1e6938a9638dd69243425230f9e70$var$hr[1], $8af1e6938a9638dd69243425230f9e70$var$sr[i]);
    } else if (i < 48) {
      tl = $8af1e6938a9638dd69243425230f9e70$var$fn3(al, bl, cl, dl, el, words[$8af1e6938a9638dd69243425230f9e70$var$zl[i]], $8af1e6938a9638dd69243425230f9e70$var$hl[2], $8af1e6938a9638dd69243425230f9e70$var$sl[i]);
      tr = $8af1e6938a9638dd69243425230f9e70$var$fn3(ar, br, cr, dr, er, words[$8af1e6938a9638dd69243425230f9e70$var$zr[i]], $8af1e6938a9638dd69243425230f9e70$var$hr[2], $8af1e6938a9638dd69243425230f9e70$var$sr[i]);
    } else if (i < 64) {
      tl = $8af1e6938a9638dd69243425230f9e70$var$fn4(al, bl, cl, dl, el, words[$8af1e6938a9638dd69243425230f9e70$var$zl[i]], $8af1e6938a9638dd69243425230f9e70$var$hl[3], $8af1e6938a9638dd69243425230f9e70$var$sl[i]);
      tr = $8af1e6938a9638dd69243425230f9e70$var$fn2(ar, br, cr, dr, er, words[$8af1e6938a9638dd69243425230f9e70$var$zr[i]], $8af1e6938a9638dd69243425230f9e70$var$hr[3], $8af1e6938a9638dd69243425230f9e70$var$sr[i]);
    } else {
      // if (i<80) {
      tl = $8af1e6938a9638dd69243425230f9e70$var$fn5(al, bl, cl, dl, el, words[$8af1e6938a9638dd69243425230f9e70$var$zl[i]], $8af1e6938a9638dd69243425230f9e70$var$hl[4], $8af1e6938a9638dd69243425230f9e70$var$sl[i]);
      tr = $8af1e6938a9638dd69243425230f9e70$var$fn1(ar, br, cr, dr, er, words[$8af1e6938a9638dd69243425230f9e70$var$zr[i]], $8af1e6938a9638dd69243425230f9e70$var$hr[4], $8af1e6938a9638dd69243425230f9e70$var$sr[i]);
    }

    al = el;
    el = dl;
    dl = $8af1e6938a9638dd69243425230f9e70$var$rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = $8af1e6938a9638dd69243425230f9e70$var$rotl(cr, 10);
    cr = br;
    br = tr;
  } // update state


  // update state
  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};

$8af1e6938a9638dd69243425230f9e70$var$RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  // produce result
  var buffer = $8af1e6938a9638dd69243425230f9e70$var$Buffer.alloc ? $8af1e6938a9638dd69243425230f9e70$var$Buffer.alloc(20) : new $8af1e6938a9638dd69243425230f9e70$var$Buffer(20);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  buffer.writeInt32LE(this._e, 16);
  return buffer;
};

function $8af1e6938a9638dd69243425230f9e70$var$rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function $8af1e6938a9638dd69243425230f9e70$var$fn1(a, b, c, d, e, m, k, s) {
  return $8af1e6938a9638dd69243425230f9e70$var$rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}

function $8af1e6938a9638dd69243425230f9e70$var$fn2(a, b, c, d, e, m, k, s) {
  return $8af1e6938a9638dd69243425230f9e70$var$rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}

function $8af1e6938a9638dd69243425230f9e70$var$fn3(a, b, c, d, e, m, k, s) {
  return $8af1e6938a9638dd69243425230f9e70$var$rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}

function $8af1e6938a9638dd69243425230f9e70$var$fn4(a, b, c, d, e, m, k, s) {
  return $8af1e6938a9638dd69243425230f9e70$var$rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}

function $8af1e6938a9638dd69243425230f9e70$var$fn5(a, b, c, d, e, m, k, s) {
  return $8af1e6938a9638dd69243425230f9e70$var$rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}

$8af1e6938a9638dd69243425230f9e70$exports = $8af1e6938a9638dd69243425230f9e70$var$RIPEMD160;
// ASSET: node_modules/sha.js/index.js
var $bed85122669a60ea1ae878d2fb66cc82$exports = {};

var $bed85122669a60ea1ae878d2fb66cc82$var$exports = $bed85122669a60ea1ae878d2fb66cc82$exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = $bed85122669a60ea1ae878d2fb66cc82$var$exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
  return new Algorithm();
};

// ASSET: node_modules/sha.js/sha.js
var $78872b876b5f2949a64bc5af2e441952$exports = {};

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */
var $78872b876b5f2949a64bc5af2e441952$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/sha.js/hash.js
var $0663f4fdbe786f69a86368015981108b$exports = {};
var $0663f4fdbe786f69a86368015981108b$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer; // prototype class for hash functions

// prototype class for hash functions
function $0663f4fdbe786f69a86368015981108b$var$Hash(blockSize, finalSize) {
  this._block = $0663f4fdbe786f69a86368015981108b$var$Buffer.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}

$0663f4fdbe786f69a86368015981108b$var$Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = $0663f4fdbe786f69a86368015981108b$var$Buffer.from(data, enc);
  }

  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if (accum % blockSize === 0) {
      this._update(block);
    }
  }

  this._len += length;
  return this;
};

$0663f4fdbe786f69a86368015981108b$var$Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1);

  if (rem >= this._finalSize) {
    this._update(this._block);

    this._block.fill(0);
  }

  var bits = this._len * 8; // uint32

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;

    this._block.writeUInt32BE(highBits, this._blockSize - 8);

    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }

  this._update(this._block);

  var hash = this._hash();

  return enc ? hash.toString(enc) : hash;
};

$0663f4fdbe786f69a86368015981108b$var$Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};

$0663f4fdbe786f69a86368015981108b$exports = $0663f4fdbe786f69a86368015981108b$var$Hash;
var $78872b876b5f2949a64bc5af2e441952$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $78872b876b5f2949a64bc5af2e441952$var$K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var $78872b876b5f2949a64bc5af2e441952$var$W = new Array(80);

function $78872b876b5f2949a64bc5af2e441952$var$Sha() {
  this.init();
  this._w = $78872b876b5f2949a64bc5af2e441952$var$W;
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 64, 56);
}

$78872b876b5f2949a64bc5af2e441952$var$inherits($78872b876b5f2949a64bc5af2e441952$var$Sha, $0663f4fdbe786f69a86368015981108b$exports);

$78872b876b5f2949a64bc5af2e441952$var$Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function $78872b876b5f2949a64bc5af2e441952$var$rotl5(num) {
  return num << 5 | num >>> 27;
}

function $78872b876b5f2949a64bc5af2e441952$var$rotl30(num) {
  return num << 30 | num >>> 2;
}

function $78872b876b5f2949a64bc5af2e441952$var$ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

$78872b876b5f2949a64bc5af2e441952$var$Sha.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = $78872b876b5f2949a64bc5af2e441952$var$rotl5(a) + $78872b876b5f2949a64bc5af2e441952$var$ft(s, b, c, d) + e + W[j] + $78872b876b5f2949a64bc5af2e441952$var$K[s] | 0;
    e = d;
    d = c;
    c = $78872b876b5f2949a64bc5af2e441952$var$rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

$78872b876b5f2949a64bc5af2e441952$var$Sha.prototype._hash = function () {
  var H = $78872b876b5f2949a64bc5af2e441952$var$Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

$78872b876b5f2949a64bc5af2e441952$exports = $78872b876b5f2949a64bc5af2e441952$var$Sha;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha = $78872b876b5f2949a64bc5af2e441952$exports;
// ASSET: node_modules/sha.js/sha1.js
var $4c2c03e7c59ff75e70c5d2ee120b2c86$exports = {};

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
var $4c2c03e7c59ff75e70c5d2ee120b2c86$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $4c2c03e7c59ff75e70c5d2ee120b2c86$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $4c2c03e7c59ff75e70c5d2ee120b2c86$var$K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var $4c2c03e7c59ff75e70c5d2ee120b2c86$var$W = new Array(80);

function $4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1() {
  this.init();
  this._w = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$W;
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 64, 56);
}

$4c2c03e7c59ff75e70c5d2ee120b2c86$var$inherits($4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1, $0663f4fdbe786f69a86368015981108b$exports);

$4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl1(num) {
  return num << 1 | num >>> 31;
}

function $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl5(num) {
  return num << 5 | num >>> 27;
}

function $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl30(num) {
  return num << 30 | num >>> 2;
}

function $4c2c03e7c59ff75e70c5d2ee120b2c86$var$ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

$4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 80; ++i) W[i] = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl5(a) + $4c2c03e7c59ff75e70c5d2ee120b2c86$var$ft(s, b, c, d) + e + W[j] + $4c2c03e7c59ff75e70c5d2ee120b2c86$var$K[s] | 0;
    e = d;
    d = c;
    c = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

$4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1.prototype._hash = function () {
  var H = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

$4c2c03e7c59ff75e70c5d2ee120b2c86$exports = $4c2c03e7c59ff75e70c5d2ee120b2c86$var$Sha1;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha1 = $4c2c03e7c59ff75e70c5d2ee120b2c86$exports;
// ASSET: node_modules/sha.js/sha224.js
var $77f25f3e5baeaf6f1ddef71932a90206$exports = {};

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var $77f25f3e5baeaf6f1ddef71932a90206$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/sha.js/sha256.js
var $2fa01d5d68e61fdb73e213c915bd4291$exports = {};

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var $2fa01d5d68e61fdb73e213c915bd4291$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $2fa01d5d68e61fdb73e213c915bd4291$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $2fa01d5d68e61fdb73e213c915bd4291$var$K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
var $2fa01d5d68e61fdb73e213c915bd4291$var$W = new Array(64);

function $2fa01d5d68e61fdb73e213c915bd4291$var$Sha256() {
  this.init();
  this._w = $2fa01d5d68e61fdb73e213c915bd4291$var$W; // new Array(64)

  // new Array(64)
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 64, 56);
}

$2fa01d5d68e61fdb73e213c915bd4291$var$inherits($2fa01d5d68e61fdb73e213c915bd4291$var$Sha256, $0663f4fdbe786f69a86368015981108b$exports);

$2fa01d5d68e61fdb73e213c915bd4291$var$Sha256.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;
  return this;
};

function $2fa01d5d68e61fdb73e213c915bd4291$var$ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function $2fa01d5d68e61fdb73e213c915bd4291$var$maj(x, y, z) {
  return x & y | z & (x | y);
}

function $2fa01d5d68e61fdb73e213c915bd4291$var$sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function $2fa01d5d68e61fdb73e213c915bd4291$var$sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function $2fa01d5d68e61fdb73e213c915bd4291$var$gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}

function $2fa01d5d68e61fdb73e213c915bd4291$var$gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}

$2fa01d5d68e61fdb73e213c915bd4291$var$Sha256.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 64; ++i) W[i] = $2fa01d5d68e61fdb73e213c915bd4291$var$gamma1(W[i - 2]) + W[i - 7] + $2fa01d5d68e61fdb73e213c915bd4291$var$gamma0(W[i - 15]) + W[i - 16] | 0;

  for (var j = 0; j < 64; ++j) {
    var T1 = h + $2fa01d5d68e61fdb73e213c915bd4291$var$sigma1(e) + $2fa01d5d68e61fdb73e213c915bd4291$var$ch(e, f, g) + $2fa01d5d68e61fdb73e213c915bd4291$var$K[j] + W[j] | 0;
    var T2 = $2fa01d5d68e61fdb73e213c915bd4291$var$sigma0(a) + $2fa01d5d68e61fdb73e213c915bd4291$var$maj(a, b, c) | 0;
    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};

$2fa01d5d68e61fdb73e213c915bd4291$var$Sha256.prototype._hash = function () {
  var H = $2fa01d5d68e61fdb73e213c915bd4291$var$Buffer.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};

$2fa01d5d68e61fdb73e213c915bd4291$exports = $2fa01d5d68e61fdb73e213c915bd4291$var$Sha256;
var $77f25f3e5baeaf6f1ddef71932a90206$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $77f25f3e5baeaf6f1ddef71932a90206$var$W = new Array(64);

function $77f25f3e5baeaf6f1ddef71932a90206$var$Sha224() {
  this.init();
  this._w = $77f25f3e5baeaf6f1ddef71932a90206$var$W; // new Array(64)

  // new Array(64)
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 64, 56);
}

$77f25f3e5baeaf6f1ddef71932a90206$var$inherits($77f25f3e5baeaf6f1ddef71932a90206$var$Sha224, $2fa01d5d68e61fdb73e213c915bd4291$exports);

$77f25f3e5baeaf6f1ddef71932a90206$var$Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;
  return this;
};

$77f25f3e5baeaf6f1ddef71932a90206$var$Sha224.prototype._hash = function () {
  var H = $77f25f3e5baeaf6f1ddef71932a90206$var$Buffer.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};

$77f25f3e5baeaf6f1ddef71932a90206$exports = $77f25f3e5baeaf6f1ddef71932a90206$var$Sha224;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha224 = $77f25f3e5baeaf6f1ddef71932a90206$exports;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha256 = $2fa01d5d68e61fdb73e213c915bd4291$exports;
// ASSET: node_modules/sha.js/sha384.js
var $20ca220ba0706fe9aa141197b3716fdb$exports = {};
var $20ca220ba0706fe9aa141197b3716fdb$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/sha.js/sha512.js
var $fa16515b7027143dfa02d2b7653ba27d$exports = {};
var $fa16515b7027143dfa02d2b7653ba27d$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $fa16515b7027143dfa02d2b7653ba27d$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $fa16515b7027143dfa02d2b7653ba27d$var$K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
var $fa16515b7027143dfa02d2b7653ba27d$var$W = new Array(160);

function $fa16515b7027143dfa02d2b7653ba27d$var$Sha512() {
  this.init();
  this._w = $fa16515b7027143dfa02d2b7653ba27d$var$W;
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 128, 112);
}

$fa16515b7027143dfa02d2b7653ba27d$var$inherits($fa16515b7027143dfa02d2b7653ba27d$var$Sha512, $0663f4fdbe786f69a86368015981108b$exports);

$fa16515b7027143dfa02d2b7653ba27d$var$Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;
  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;
  return this;
};

function $fa16515b7027143dfa02d2b7653ba27d$var$Ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$maj(x, y, z) {
  return x & y | z & (x | y);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}

function $fa16515b7027143dfa02d2b7653ba27d$var$Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}

function $fa16515b7027143dfa02d2b7653ba27d$var$Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}

function $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}

$fa16515b7027143dfa02d2b7653ba27d$var$Sha512.prototype._update = function (M) {
  var W = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }

  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = $fa16515b7027143dfa02d2b7653ba27d$var$Gamma0(xh, xl);
    var gamma0l = $fa16515b7027143dfa02d2b7653ba27d$var$Gamma0l(xl, xh);
    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = $fa16515b7027143dfa02d2b7653ba27d$var$Gamma1(xh, xl);
    var gamma1l = $fa16515b7027143dfa02d2b7653ba27d$var$Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];
    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(Wil, Wi16l) | 0;
    W[i] = Wih;
    W[i + 1] = Wil;
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];
    var majh = $fa16515b7027143dfa02d2b7653ba27d$var$maj(ah, bh, ch);
    var majl = $fa16515b7027143dfa02d2b7653ba27d$var$maj(al, bl, cl);
    var sigma0h = $fa16515b7027143dfa02d2b7653ba27d$var$sigma0(ah, al);
    var sigma0l = $fa16515b7027143dfa02d2b7653ba27d$var$sigma0(al, ah);
    var sigma1h = $fa16515b7027143dfa02d2b7653ba27d$var$sigma1(eh, el);
    var sigma1l = $fa16515b7027143dfa02d2b7653ba27d$var$sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = $fa16515b7027143dfa02d2b7653ba27d$var$K[j];
    var Kil = $fa16515b7027143dfa02d2b7653ba27d$var$K[j + 1];
    var chh = $fa16515b7027143dfa02d2b7653ba27d$var$Ch(eh, fh, gh);
    var chl = $fa16515b7027143dfa02d2b7653ba27d$var$Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(al, t1l) | 0;
  }

  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + $fa16515b7027143dfa02d2b7653ba27d$var$getCarry(this._hl, hl) | 0;
};

$fa16515b7027143dfa02d2b7653ba27d$var$Sha512.prototype._hash = function () {
  var H = $fa16515b7027143dfa02d2b7653ba27d$var$Buffer.allocUnsafe(64);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};

$fa16515b7027143dfa02d2b7653ba27d$exports = $fa16515b7027143dfa02d2b7653ba27d$var$Sha512;
var $20ca220ba0706fe9aa141197b3716fdb$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $20ca220ba0706fe9aa141197b3716fdb$var$W = new Array(160);

function $20ca220ba0706fe9aa141197b3716fdb$var$Sha384() {
  this.init();
  this._w = $20ca220ba0706fe9aa141197b3716fdb$var$W;
  $0663f4fdbe786f69a86368015981108b$exports.call(this, 128, 112);
}

$20ca220ba0706fe9aa141197b3716fdb$var$inherits($20ca220ba0706fe9aa141197b3716fdb$var$Sha384, $fa16515b7027143dfa02d2b7653ba27d$exports);

$20ca220ba0706fe9aa141197b3716fdb$var$Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;
  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;
  return this;
};

$20ca220ba0706fe9aa141197b3716fdb$var$Sha384.prototype._hash = function () {
  var H = $20ca220ba0706fe9aa141197b3716fdb$var$Buffer.allocUnsafe(48);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};

$20ca220ba0706fe9aa141197b3716fdb$exports = $20ca220ba0706fe9aa141197b3716fdb$var$Sha384;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha384 = $20ca220ba0706fe9aa141197b3716fdb$exports;
$bed85122669a60ea1ae878d2fb66cc82$var$exports.sha512 = $fa16515b7027143dfa02d2b7653ba27d$exports;
// ASSET: node_modules/cipher-base/index.js
var $4172c53b99923d9558a4d50bb467a00e$exports = {};
var $4172c53b99923d9558a4d50bb467a00e$var$Buffer = $2efb4c9703742d153fc2ca8a48c47fc1$init().Buffer;
var $4172c53b99923d9558a4d50bb467a00e$var$Transform = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Transform;
var $4172c53b99923d9558a4d50bb467a00e$var$StringDecoder = $9902be2109033b88050ebe7f370f9452$init().StringDecoder;
var $4172c53b99923d9558a4d50bb467a00e$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();

function $4172c53b99923d9558a4d50bb467a00e$var$CipherBase(hashMode) {
  $4172c53b99923d9558a4d50bb467a00e$var$Transform.call(this);
  this.hashMode = typeof hashMode === 'string';

  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }

  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }

  this._decoder = null;
  this._encoding = null;
}

$4172c53b99923d9558a4d50bb467a00e$var$inherits($4172c53b99923d9558a4d50bb467a00e$var$CipherBase, $4172c53b99923d9558a4d50bb467a00e$var$Transform);

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = $4172c53b99923d9558a4d50bb467a00e$var$Buffer.from(data, inputEnc);
  }

  var outData = this._update(data);

  if (this.hashMode) return this;

  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }

  return outData;
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype.setAutoPadding = function () {};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype._transform = function (data, _, next) {
  var err;

  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype._flush = function (done) {
  var err;

  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }

  done(err);
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || $4172c53b99923d9558a4d50bb467a00e$var$Buffer.alloc(0);

  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }

  return outData;
};

$4172c53b99923d9558a4d50bb467a00e$var$CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new $4172c53b99923d9558a4d50bb467a00e$var$StringDecoder(enc);
    this._encoding = enc;
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings');

  var out = this._decoder.write(value);

  if (fin) {
    out += this._decoder.end();
  }

  return out;
};

$4172c53b99923d9558a4d50bb467a00e$exports = $4172c53b99923d9558a4d50bb467a00e$var$CipherBase;

function $6d6129111db079da86df05b60d62b273$var$Hash(hash) {
  $4172c53b99923d9558a4d50bb467a00e$exports.call(this, 'digest');
  this._hash = hash;
}

$6d6129111db079da86df05b60d62b273$var$inherits($6d6129111db079da86df05b60d62b273$var$Hash, $4172c53b99923d9558a4d50bb467a00e$exports);

$6d6129111db079da86df05b60d62b273$var$Hash.prototype._update = function (data) {
  this._hash.update(data);
};

$6d6129111db079da86df05b60d62b273$var$Hash.prototype._final = function () {
  return this._hash.digest();
};

$6d6129111db079da86df05b60d62b273$exports = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === 'md5') return new $42329dad2f5bf496d013cc797f687f91$exports();
  if (alg === 'rmd160' || alg === 'ripemd160') return new $8af1e6938a9638dd69243425230f9e70$exports();
  return new $6d6129111db079da86df05b60d62b273$var$Hash($bed85122669a60ea1ae878d2fb66cc82$exports(alg));
};

// ASSET: polyfills/crypto.js
var $455b93f3205ad3b50df264ee7a92e43f$exports,
    $455b93f3205ad3b50df264ee7a92e43f$executed = false;
var $147ca815017faf95a1acd6f358cb2be5$$interop$default = $parcel$interopDefault($147ca815017faf95a1acd6f358cb2be5$exports);
var $6d6129111db079da86df05b60d62b273$$interop$default = $parcel$interopDefault($6d6129111db079da86df05b60d62b273$exports);

function $455b93f3205ad3b50df264ee7a92e43f$exec() {
  $455b93f3205ad3b50df264ee7a92e43f$exports = {};
  $parcel$export($455b93f3205ad3b50df264ee7a92e43f$exports, "prng", function () {
    return $147ca815017faf95a1acd6f358cb2be5$$interop$default;
  });
  $parcel$export($455b93f3205ad3b50df264ee7a92e43f$exports, "pseudoRandomBytes", function () {
    return $147ca815017faf95a1acd6f358cb2be5$$interop$default;
  });
  $parcel$export($455b93f3205ad3b50df264ee7a92e43f$exports, "rng", function () {
    return $147ca815017faf95a1acd6f358cb2be5$$interop$default;
  });
  $parcel$export($455b93f3205ad3b50df264ee7a92e43f$exports, "randombytes", function () {
    return $147ca815017faf95a1acd6f358cb2be5$$interop$default;
  });
  $parcel$export($455b93f3205ad3b50df264ee7a92e43f$exports, "createHash", function () {
    return $6d6129111db079da86df05b60d62b273$$interop$default;
  });
}

function $455b93f3205ad3b50df264ee7a92e43f$init() {
  if (!$455b93f3205ad3b50df264ee7a92e43f$executed) {
    $455b93f3205ad3b50df264ee7a92e43f$executed = true;
    $455b93f3205ad3b50df264ee7a92e43f$exec();
  }

  return $455b93f3205ad3b50df264ee7a92e43f$exports;
}

const $d8692e28e950b48ea4715ab19e9bf9a1$var$crypto_1 = $455b93f3205ad3b50df264ee7a92e43f$init();
// ASSET: node_modules/globby/index.js
var $c4246b2a105057577586469a990ffddf$exports = {};
const $c4246b2a105057577586469a990ffddf$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
// ASSET: node_modules/array-union/index.js
var $3fb7f4205b5db761498fc45e442147b5$exports = {};

$3fb7f4205b5db761498fc45e442147b5$exports = (...arguments_) => {
  return [...new Set([].concat(...arguments_))];
};

// ASSET: node_modules/merge2/index.js
var $fb8bb4f965dec78b60bb9e0acdcfcbfe$exports = {};
var $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$PassThrough = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough;
const $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$slice = Array.prototype.slice;
$fb8bb4f965dec78b60bb9e0acdcfcbfe$exports = $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$merge2;

function $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$merge2() {
  const streamsQueue = [];
  const args = $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$slice.call(arguments);
  let merging = false;
  let options = args[args.length - 1];

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop();
  } else {
    options = {};
  }

  const doEnd = options.end !== false;
  const doPipeError = options.pipeError === true;

  if (options.objectMode == null) {
    options.objectMode = true;
  }

  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024;
  }

  const mergedStream = $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$PassThrough(options);

  function addStream() {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push($fb8bb4f965dec78b60bb9e0acdcfcbfe$var$pauseStreams(arguments[i], options));
    }

    mergeStream();
    return this;
  }

  function mergeStream() {
    if (merging) {
      return;
    }

    merging = true;
    let streams = streamsQueue.shift();

    if (!streams) {
      $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$process.nextTick(endStream);
      return;
    }

    if (!Array.isArray(streams)) {
      streams = [streams];
    }

    let pipesCount = streams.length + 1;

    function next() {
      if (--pipesCount > 0) {
        return;
      }

      merging = false;
      mergeStream();
    }

    function pipe(stream) {
      function onend() {
        stream.removeListener('merge2UnpipeEnd', onend);
        stream.removeListener('end', onend);

        if (doPipeError) {
          stream.removeListener('error', onerror);
        }

        next();
      }

      function onerror(err) {
        mergedStream.emit('error', err);
      } // skip ended stream


      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next();
      }

      stream.on('merge2UnpipeEnd', onend);
      stream.on('end', onend);

      if (doPipeError) {
        stream.on('error', onerror);
      }

      stream.pipe(mergedStream, {
        end: false
      }); // compatible for old stream

      // compatible for old stream
      stream.resume();
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i]);
    }

    next();
  }

  function endStream() {
    merging = false; // emit 'queueDrain' when all streams merged.

    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain');

    if (doEnd) {
      mergedStream.end();
    }
  }

  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd');
  });

  if (args.length) {
    addStream.apply(null, args);
  }

  return mergedStream;
} // check and pause streams for pipe.


// check and pause streams for pipe.
function $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$pauseStreams(streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe($fb8bb4f965dec78b60bb9e0acdcfcbfe$var$PassThrough(options));
    }

    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.');
    }

    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = $fb8bb4f965dec78b60bb9e0acdcfcbfe$var$pauseStreams(streams[i], options);
    }
  }

  return streams;
}

// ASSET: node_modules/fast-glob/out/index.js
var $61dab73f6a7235989c6f2f871d1403c3$exports = {};
// ASSET: node_modules/fast-glob/out/managers/tasks.js
var $8e74aa6f5c2e1dabadcc8fa176ea0322$exports = {};
Object.defineProperty($8e74aa6f5c2e1dabadcc8fa176ea0322$exports, "__esModule", {
  value: true
});
var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupToTask = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupsToTasks = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$groupPatternsByBaseDirectory = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$getNegativePatternsAsPositive = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$getPositivePatterns = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternsToTasks = ($8e74aa6f5c2e1dabadcc8fa176ea0322$export$generate = void 0, $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.generate = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$generate), $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternsToTasks), $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.getPositivePatterns = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getPositivePatterns), $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.getNegativePatternsAsPositive = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getNegativePatternsAsPositive), $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.groupPatternsByBaseDirectory = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$groupPatternsByBaseDirectory), $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternGroupsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupsToTasks);
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternGroupToTask = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupToTask;
// ASSET: node_modules/fast-glob/out/utils/index.js
var $6bda9691bfa358c458d88d7e26adea34$exports = {};
Object.defineProperty($6bda9691bfa358c458d88d7e26adea34$exports, "__esModule", {
  value: true
});
var $6bda9691bfa358c458d88d7e26adea34$export$string = ($6bda9691bfa358c458d88d7e26adea34$export$stream = ($6bda9691bfa358c458d88d7e26adea34$export$pattern = ($6bda9691bfa358c458d88d7e26adea34$export$path = ($6bda9691bfa358c458d88d7e26adea34$export$fs = ($6bda9691bfa358c458d88d7e26adea34$export$errno = ($6bda9691bfa358c458d88d7e26adea34$export$array = void 0, $6bda9691bfa358c458d88d7e26adea34$exports.array = $6bda9691bfa358c458d88d7e26adea34$export$array), $6bda9691bfa358c458d88d7e26adea34$exports.errno = $6bda9691bfa358c458d88d7e26adea34$export$errno), $6bda9691bfa358c458d88d7e26adea34$exports.fs = $6bda9691bfa358c458d88d7e26adea34$export$fs), $6bda9691bfa358c458d88d7e26adea34$exports.path = $6bda9691bfa358c458d88d7e26adea34$export$path), $6bda9691bfa358c458d88d7e26adea34$exports.pattern = $6bda9691bfa358c458d88d7e26adea34$export$pattern), $6bda9691bfa358c458d88d7e26adea34$exports.stream = $6bda9691bfa358c458d88d7e26adea34$export$stream);
$6bda9691bfa358c458d88d7e26adea34$exports.string = $6bda9691bfa358c458d88d7e26adea34$export$string;
// ASSET: node_modules/fast-glob/out/utils/array.js
var $d92fca36d646566e3ef04a513e24a5af$exports = {};
Object.defineProperty($d92fca36d646566e3ef04a513e24a5af$exports, "__esModule", {
  value: true
});
var $d92fca36d646566e3ef04a513e24a5af$export$splitWhen = ($d92fca36d646566e3ef04a513e24a5af$export$flatten = void 0, $d92fca36d646566e3ef04a513e24a5af$exports.flatten = $d92fca36d646566e3ef04a513e24a5af$export$flatten);
$d92fca36d646566e3ef04a513e24a5af$exports.splitWhen = $d92fca36d646566e3ef04a513e24a5af$export$splitWhen;

function $d92fca36d646566e3ef04a513e24a5af$var$flatten(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}

var $d92fca36d646566e3ef04a513e24a5af$export$flatten = $d92fca36d646566e3ef04a513e24a5af$var$flatten;
$d92fca36d646566e3ef04a513e24a5af$exports.flatten = $d92fca36d646566e3ef04a513e24a5af$export$flatten;

function $d92fca36d646566e3ef04a513e24a5af$var$splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;

  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }

  return result;
}

$d92fca36d646566e3ef04a513e24a5af$export$splitWhen = $d92fca36d646566e3ef04a513e24a5af$var$splitWhen;
$d92fca36d646566e3ef04a513e24a5af$exports.splitWhen = $d92fca36d646566e3ef04a513e24a5af$export$splitWhen;
var $6bda9691bfa358c458d88d7e26adea34$export$array = $d92fca36d646566e3ef04a513e24a5af$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.array = $d92fca36d646566e3ef04a513e24a5af$exports;
// ASSET: node_modules/fast-glob/out/utils/errno.js
var $808c005069c8302f95b43c5c1c16228c$exports = {};
Object.defineProperty($808c005069c8302f95b43c5c1c16228c$exports, "__esModule", {
  value: true
});
var $808c005069c8302f95b43c5c1c16228c$export$isEnoentCodeError = void 0;
$808c005069c8302f95b43c5c1c16228c$exports.isEnoentCodeError = $808c005069c8302f95b43c5c1c16228c$export$isEnoentCodeError;

function $808c005069c8302f95b43c5c1c16228c$var$isEnoentCodeError(error) {
  return error.code === 'ENOENT';
}

$808c005069c8302f95b43c5c1c16228c$export$isEnoentCodeError = $808c005069c8302f95b43c5c1c16228c$var$isEnoentCodeError;
$808c005069c8302f95b43c5c1c16228c$exports.isEnoentCodeError = $808c005069c8302f95b43c5c1c16228c$export$isEnoentCodeError;
var $6bda9691bfa358c458d88d7e26adea34$export$errno = $808c005069c8302f95b43c5c1c16228c$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.errno = $808c005069c8302f95b43c5c1c16228c$exports;
// ASSET: node_modules/fast-glob/out/utils/fs.js
var $e86523f4f83c2f670b8788f93df7a746$exports = {};
Object.defineProperty($e86523f4f83c2f670b8788f93df7a746$exports, "__esModule", {
  value: true
});
var $e86523f4f83c2f670b8788f93df7a746$export$createDirentFromStats = void 0;
$e86523f4f83c2f670b8788f93df7a746$exports.createDirentFromStats = $e86523f4f83c2f670b8788f93df7a746$export$createDirentFromStats;

class $e86523f4f83c2f670b8788f93df7a746$var$DirentFromStats {
  constructor(name, stats) {
    this.name = name;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }

}

function $e86523f4f83c2f670b8788f93df7a746$var$createDirentFromStats(name, stats) {
  return new $e86523f4f83c2f670b8788f93df7a746$var$DirentFromStats(name, stats);
}

$e86523f4f83c2f670b8788f93df7a746$export$createDirentFromStats = $e86523f4f83c2f670b8788f93df7a746$var$createDirentFromStats;
$e86523f4f83c2f670b8788f93df7a746$exports.createDirentFromStats = $e86523f4f83c2f670b8788f93df7a746$export$createDirentFromStats;
var $6bda9691bfa358c458d88d7e26adea34$export$fs = $e86523f4f83c2f670b8788f93df7a746$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.fs = $e86523f4f83c2f670b8788f93df7a746$exports;
// ASSET: node_modules/fast-glob/out/utils/path.js
var $4b7cec869962d412539698a52fbaf567$exports = {};
Object.defineProperty($4b7cec869962d412539698a52fbaf567$exports, "__esModule", {
  value: true
});
var $4b7cec869962d412539698a52fbaf567$export$removeLeadingDotSegment = ($4b7cec869962d412539698a52fbaf567$export$escape = ($4b7cec869962d412539698a52fbaf567$export$makeAbsolute = ($4b7cec869962d412539698a52fbaf567$export$unixify = void 0, $4b7cec869962d412539698a52fbaf567$exports.unixify = $4b7cec869962d412539698a52fbaf567$export$unixify), $4b7cec869962d412539698a52fbaf567$exports.makeAbsolute = $4b7cec869962d412539698a52fbaf567$export$makeAbsolute), $4b7cec869962d412539698a52fbaf567$exports.escape = $4b7cec869962d412539698a52fbaf567$export$escape);
$4b7cec869962d412539698a52fbaf567$exports.removeLeadingDotSegment = $4b7cec869962d412539698a52fbaf567$export$removeLeadingDotSegment;
const $4b7cec869962d412539698a52fbaf567$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const $4b7cec869962d412539698a52fbaf567$var$LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\

// ./ or .\\
const $4b7cec869962d412539698a52fbaf567$var$UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */

/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function $4b7cec869962d412539698a52fbaf567$var$unixify(filepath) {
  return filepath.replace(/\\/g, '/');
}

var $4b7cec869962d412539698a52fbaf567$export$unixify = $4b7cec869962d412539698a52fbaf567$var$unixify;
$4b7cec869962d412539698a52fbaf567$exports.unixify = $4b7cec869962d412539698a52fbaf567$export$unixify;

function $4b7cec869962d412539698a52fbaf567$var$makeAbsolute(cwd, filepath) {
  return $4b7cec869962d412539698a52fbaf567$var$path.resolve(cwd, filepath);
}

var $4b7cec869962d412539698a52fbaf567$export$makeAbsolute = $4b7cec869962d412539698a52fbaf567$var$makeAbsolute;
$4b7cec869962d412539698a52fbaf567$exports.makeAbsolute = $4b7cec869962d412539698a52fbaf567$export$makeAbsolute;

function $4b7cec869962d412539698a52fbaf567$var$escape(pattern) {
  return pattern.replace($4b7cec869962d412539698a52fbaf567$var$UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}

var $4b7cec869962d412539698a52fbaf567$export$escape = $4b7cec869962d412539698a52fbaf567$var$escape;
$4b7cec869962d412539698a52fbaf567$exports.escape = $4b7cec869962d412539698a52fbaf567$export$escape;

function $4b7cec869962d412539698a52fbaf567$var$removeLeadingDotSegment(entry) {
  // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
  // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
  if (entry.charAt(0) === '.') {
    const secondCharactery = entry.charAt(1);

    if (secondCharactery === '/' || secondCharactery === '\\') {
      return entry.slice($4b7cec869962d412539698a52fbaf567$var$LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }

  return entry;
}

$4b7cec869962d412539698a52fbaf567$export$removeLeadingDotSegment = $4b7cec869962d412539698a52fbaf567$var$removeLeadingDotSegment;
$4b7cec869962d412539698a52fbaf567$exports.removeLeadingDotSegment = $4b7cec869962d412539698a52fbaf567$export$removeLeadingDotSegment;
var $6bda9691bfa358c458d88d7e26adea34$export$path = $4b7cec869962d412539698a52fbaf567$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.path = $4b7cec869962d412539698a52fbaf567$exports;
// ASSET: node_modules/fast-glob/out/utils/pattern.js
var $20b053220c9c357e10d9567fa4b8180e$exports = {};
Object.defineProperty($20b053220c9c357e10d9567fa4b8180e$exports, "__esModule", {
  value: true
});
var $20b053220c9c357e10d9567fa4b8180e$export$matchAny = ($20b053220c9c357e10d9567fa4b8180e$export$convertPatternsToRe = ($20b053220c9c357e10d9567fa4b8180e$export$makeRe = ($20b053220c9c357e10d9567fa4b8180e$export$getPatternParts = ($20b053220c9c357e10d9567fa4b8180e$export$expandBraceExpansion = ($20b053220c9c357e10d9567fa4b8180e$export$expandPatternsWithBraceExpansion = ($20b053220c9c357e10d9567fa4b8180e$export$isAffectDepthOfReadingPattern = ($20b053220c9c357e10d9567fa4b8180e$export$endsWithSlashGlobStar = ($20b053220c9c357e10d9567fa4b8180e$export$hasGlobStar = ($20b053220c9c357e10d9567fa4b8180e$export$getBaseDirectory = ($20b053220c9c357e10d9567fa4b8180e$export$getPositivePatterns = ($20b053220c9c357e10d9567fa4b8180e$export$getNegativePatterns = ($20b053220c9c357e10d9567fa4b8180e$export$isPositivePattern = ($20b053220c9c357e10d9567fa4b8180e$export$isNegativePattern = ($20b053220c9c357e10d9567fa4b8180e$export$convertToNegativePattern = ($20b053220c9c357e10d9567fa4b8180e$export$convertToPositivePattern = ($20b053220c9c357e10d9567fa4b8180e$export$isDynamicPattern = ($20b053220c9c357e10d9567fa4b8180e$export$isStaticPattern = void 0, $20b053220c9c357e10d9567fa4b8180e$exports.isStaticPattern = $20b053220c9c357e10d9567fa4b8180e$export$isStaticPattern), $20b053220c9c357e10d9567fa4b8180e$exports.isDynamicPattern = $20b053220c9c357e10d9567fa4b8180e$export$isDynamicPattern), $20b053220c9c357e10d9567fa4b8180e$exports.convertToPositivePattern = $20b053220c9c357e10d9567fa4b8180e$export$convertToPositivePattern), $20b053220c9c357e10d9567fa4b8180e$exports.convertToNegativePattern = $20b053220c9c357e10d9567fa4b8180e$export$convertToNegativePattern), $20b053220c9c357e10d9567fa4b8180e$exports.isNegativePattern = $20b053220c9c357e10d9567fa4b8180e$export$isNegativePattern), $20b053220c9c357e10d9567fa4b8180e$exports.isPositivePattern = $20b053220c9c357e10d9567fa4b8180e$export$isPositivePattern), $20b053220c9c357e10d9567fa4b8180e$exports.getNegativePatterns = $20b053220c9c357e10d9567fa4b8180e$export$getNegativePatterns), $20b053220c9c357e10d9567fa4b8180e$exports.getPositivePatterns = $20b053220c9c357e10d9567fa4b8180e$export$getPositivePatterns), $20b053220c9c357e10d9567fa4b8180e$exports.getBaseDirectory = $20b053220c9c357e10d9567fa4b8180e$export$getBaseDirectory), $20b053220c9c357e10d9567fa4b8180e$exports.hasGlobStar = $20b053220c9c357e10d9567fa4b8180e$export$hasGlobStar), $20b053220c9c357e10d9567fa4b8180e$exports.endsWithSlashGlobStar = $20b053220c9c357e10d9567fa4b8180e$export$endsWithSlashGlobStar), $20b053220c9c357e10d9567fa4b8180e$exports.isAffectDepthOfReadingPattern = $20b053220c9c357e10d9567fa4b8180e$export$isAffectDepthOfReadingPattern), $20b053220c9c357e10d9567fa4b8180e$exports.expandPatternsWithBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$export$expandPatternsWithBraceExpansion), $20b053220c9c357e10d9567fa4b8180e$exports.expandBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$export$expandBraceExpansion), $20b053220c9c357e10d9567fa4b8180e$exports.getPatternParts = $20b053220c9c357e10d9567fa4b8180e$export$getPatternParts), $20b053220c9c357e10d9567fa4b8180e$exports.makeRe = $20b053220c9c357e10d9567fa4b8180e$export$makeRe), $20b053220c9c357e10d9567fa4b8180e$exports.convertPatternsToRe = $20b053220c9c357e10d9567fa4b8180e$export$convertPatternsToRe);
$20b053220c9c357e10d9567fa4b8180e$exports.matchAny = $20b053220c9c357e10d9567fa4b8180e$export$matchAny;
const $20b053220c9c357e10d9567fa4b8180e$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/glob-parent/index.js
var $b778aad7b2c19dcc45d928022bed0ca6$exports = {};
// ASSET: node_modules/is-glob/index.js
var $4e07a89bad87e8c3586bda01ba300315$exports = {};
// ASSET: node_modules/is-extglob/index.js
var $879c4c1d66449906b43a9408acad3b4e$exports = {};

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
$879c4c1d66449906b43a9408acad3b4e$exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;

  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

var $4e07a89bad87e8c3586bda01ba300315$var$chars = {
  '{': '}',
  '(': ')',
  '[': ']'
};
var $4e07a89bad87e8c3586bda01ba300315$var$strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var $4e07a89bad87e8c3586bda01ba300315$var$relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

$4e07a89bad87e8c3586bda01ba300315$exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if ($879c4c1d66449906b43a9408acad3b4e$exports(str)) {
    return true;
  }

  var regex = $4e07a89bad87e8c3586bda01ba300315$var$strictRegex;
  var match; // optionally relax regex

  // optionally relax regex
  if (options && options.strict === false) {
    regex = $4e07a89bad87e8c3586bda01ba300315$var$relaxedRegex;
  }

  while (match = regex.exec(str)) {
    if (match[2]) return true;
    var idx = match.index + match[0].length; // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? $4e07a89bad87e8c3586bda01ba300315$var$chars[open] : null;

    if (open && close) {
      var n = str.indexOf(close, idx);

      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }

  return false;
};

var $b778aad7b2c19dcc45d928022bed0ca6$var$pathPosixDirname = $0111874a9358ffa1d71ad8eb9f6f16f8$init().posix.dirname;
var $b778aad7b2c19dcc45d928022bed0ca6$var$isWin32 = $0bbf89852e2ec8b574a90d9f54bf96d7$export$platform() === 'win32';
var $b778aad7b2c19dcc45d928022bed0ca6$var$slash = '/';
var $b778aad7b2c19dcc45d928022bed0ca6$var$backslash = /\\/g;
var $b778aad7b2c19dcc45d928022bed0ca6$var$enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
var $b778aad7b2c19dcc45d928022bed0ca6$var$globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var $b778aad7b2c19dcc45d928022bed0ca6$var$escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 */

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 */
$b778aad7b2c19dcc45d928022bed0ca6$exports = function globParent(str, opts) {
  var options = Object.assign({
    flipBackslashes: true
  }, opts); // flip windows path separators

  // flip windows path separators
  if (options.flipBackslashes && $b778aad7b2c19dcc45d928022bed0ca6$var$isWin32 && str.indexOf($b778aad7b2c19dcc45d928022bed0ca6$var$slash) < 0) {
    str = str.replace($b778aad7b2c19dcc45d928022bed0ca6$var$backslash, $b778aad7b2c19dcc45d928022bed0ca6$var$slash);
  } // special case for strings ending in enclosure containing path separator


  // special case for strings ending in enclosure containing path separator
  if ($b778aad7b2c19dcc45d928022bed0ca6$var$enclosure.test(str)) {
    str += $b778aad7b2c19dcc45d928022bed0ca6$var$slash;
  } // preserves full path in case of trailing path separator


  // preserves full path in case of trailing path separator
  str += 'a'; // remove path parts that are globby

  // remove path parts that are globby
  do {
    str = $b778aad7b2c19dcc45d928022bed0ca6$var$pathPosixDirname(str);
  } while ($4e07a89bad87e8c3586bda01ba300315$exports(str) || $b778aad7b2c19dcc45d928022bed0ca6$var$globby.test(str)); // remove escape chars and return result


  // remove escape chars and return result
  return str.replace($b778aad7b2c19dcc45d928022bed0ca6$var$escaped, '$1');
};

const $20b053220c9c357e10d9567fa4b8180e$var$GLOBSTAR = '**';
const $20b053220c9c357e10d9567fa4b8180e$var$ESCAPE_SYMBOL = '\\';
const $20b053220c9c357e10d9567fa4b8180e$var$COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const $20b053220c9c357e10d9567fa4b8180e$var$REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
const $20b053220c9c357e10d9567fa4b8180e$var$REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
const $20b053220c9c357e10d9567fa4b8180e$var$GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
const $20b053220c9c357e10d9567fa4b8180e$var$BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;

function $20b053220c9c357e10d9567fa4b8180e$var$isStaticPattern(pattern, options = {}) {
  return !$20b053220c9c357e10d9567fa4b8180e$var$isDynamicPattern(pattern, options);
}

var $20b053220c9c357e10d9567fa4b8180e$export$isStaticPattern = $20b053220c9c357e10d9567fa4b8180e$var$isStaticPattern;
$20b053220c9c357e10d9567fa4b8180e$exports.isStaticPattern = $20b053220c9c357e10d9567fa4b8180e$export$isStaticPattern;

function $20b053220c9c357e10d9567fa4b8180e$var$isDynamicPattern(pattern, options = {}) {
  /**
   * A special case with an empty string is necessary for matching patterns that start with a forward slash.
   * An empty string cannot be a dynamic pattern.
   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
   */
  if (pattern === '') {
    return false;
  }
  /**
   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
   * filepath directly (without read directory).
   */


  /**
   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
   * filepath directly (without read directory).
   */
  if (options.caseSensitiveMatch === false || pattern.includes($20b053220c9c357e10d9567fa4b8180e$var$ESCAPE_SYMBOL)) {
    return true;
  }

  if ($20b053220c9c357e10d9567fa4b8180e$var$COMMON_GLOB_SYMBOLS_RE.test(pattern) || $20b053220c9c357e10d9567fa4b8180e$var$REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || $20b053220c9c357e10d9567fa4b8180e$var$REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
    return true;
  }

  if (options.extglob !== false && $20b053220c9c357e10d9567fa4b8180e$var$GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
    return true;
  }

  if (options.braceExpansion !== false && $20b053220c9c357e10d9567fa4b8180e$var$BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
    return true;
  }

  return false;
}

var $20b053220c9c357e10d9567fa4b8180e$export$isDynamicPattern = $20b053220c9c357e10d9567fa4b8180e$var$isDynamicPattern;
$20b053220c9c357e10d9567fa4b8180e$exports.isDynamicPattern = $20b053220c9c357e10d9567fa4b8180e$export$isDynamicPattern;

function $20b053220c9c357e10d9567fa4b8180e$var$convertToPositivePattern(pattern) {
  return $20b053220c9c357e10d9567fa4b8180e$var$isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}

var $20b053220c9c357e10d9567fa4b8180e$export$convertToPositivePattern = $20b053220c9c357e10d9567fa4b8180e$var$convertToPositivePattern;
$20b053220c9c357e10d9567fa4b8180e$exports.convertToPositivePattern = $20b053220c9c357e10d9567fa4b8180e$export$convertToPositivePattern;

function $20b053220c9c357e10d9567fa4b8180e$var$convertToNegativePattern(pattern) {
  return '!' + pattern;
}

var $20b053220c9c357e10d9567fa4b8180e$export$convertToNegativePattern = $20b053220c9c357e10d9567fa4b8180e$var$convertToNegativePattern;
$20b053220c9c357e10d9567fa4b8180e$exports.convertToNegativePattern = $20b053220c9c357e10d9567fa4b8180e$export$convertToNegativePattern;

function $20b053220c9c357e10d9567fa4b8180e$var$isNegativePattern(pattern) {
  return pattern.startsWith('!') && pattern[1] !== '(';
}

var $20b053220c9c357e10d9567fa4b8180e$export$isNegativePattern = $20b053220c9c357e10d9567fa4b8180e$var$isNegativePattern;
$20b053220c9c357e10d9567fa4b8180e$exports.isNegativePattern = $20b053220c9c357e10d9567fa4b8180e$export$isNegativePattern;

function $20b053220c9c357e10d9567fa4b8180e$var$isPositivePattern(pattern) {
  return !$20b053220c9c357e10d9567fa4b8180e$var$isNegativePattern(pattern);
}

var $20b053220c9c357e10d9567fa4b8180e$export$isPositivePattern = $20b053220c9c357e10d9567fa4b8180e$var$isPositivePattern;
$20b053220c9c357e10d9567fa4b8180e$exports.isPositivePattern = $20b053220c9c357e10d9567fa4b8180e$export$isPositivePattern;

function $20b053220c9c357e10d9567fa4b8180e$var$getNegativePatterns(patterns) {
  return patterns.filter($20b053220c9c357e10d9567fa4b8180e$var$isNegativePattern);
}

var $20b053220c9c357e10d9567fa4b8180e$export$getNegativePatterns = $20b053220c9c357e10d9567fa4b8180e$var$getNegativePatterns;
$20b053220c9c357e10d9567fa4b8180e$exports.getNegativePatterns = $20b053220c9c357e10d9567fa4b8180e$export$getNegativePatterns;

function $20b053220c9c357e10d9567fa4b8180e$var$getPositivePatterns(patterns) {
  return patterns.filter($20b053220c9c357e10d9567fa4b8180e$var$isPositivePattern);
}

var $20b053220c9c357e10d9567fa4b8180e$export$getPositivePatterns = $20b053220c9c357e10d9567fa4b8180e$var$getPositivePatterns;
$20b053220c9c357e10d9567fa4b8180e$exports.getPositivePatterns = $20b053220c9c357e10d9567fa4b8180e$export$getPositivePatterns;

function $20b053220c9c357e10d9567fa4b8180e$var$getBaseDirectory(pattern) {
  return $b778aad7b2c19dcc45d928022bed0ca6$exports(pattern, {
    flipBackslashes: false
  });
}

var $20b053220c9c357e10d9567fa4b8180e$export$getBaseDirectory = $20b053220c9c357e10d9567fa4b8180e$var$getBaseDirectory;
$20b053220c9c357e10d9567fa4b8180e$exports.getBaseDirectory = $20b053220c9c357e10d9567fa4b8180e$export$getBaseDirectory;

function $20b053220c9c357e10d9567fa4b8180e$var$hasGlobStar(pattern) {
  return pattern.includes($20b053220c9c357e10d9567fa4b8180e$var$GLOBSTAR);
}

var $20b053220c9c357e10d9567fa4b8180e$export$hasGlobStar = $20b053220c9c357e10d9567fa4b8180e$var$hasGlobStar;
$20b053220c9c357e10d9567fa4b8180e$exports.hasGlobStar = $20b053220c9c357e10d9567fa4b8180e$export$hasGlobStar;

function $20b053220c9c357e10d9567fa4b8180e$var$endsWithSlashGlobStar(pattern) {
  return pattern.endsWith('/' + $20b053220c9c357e10d9567fa4b8180e$var$GLOBSTAR);
}

var $20b053220c9c357e10d9567fa4b8180e$export$endsWithSlashGlobStar = $20b053220c9c357e10d9567fa4b8180e$var$endsWithSlashGlobStar;
$20b053220c9c357e10d9567fa4b8180e$exports.endsWithSlashGlobStar = $20b053220c9c357e10d9567fa4b8180e$export$endsWithSlashGlobStar;

function $20b053220c9c357e10d9567fa4b8180e$var$isAffectDepthOfReadingPattern(pattern) {
  const basename = $20b053220c9c357e10d9567fa4b8180e$var$path.basename(pattern);
  return $20b053220c9c357e10d9567fa4b8180e$var$endsWithSlashGlobStar(pattern) || $20b053220c9c357e10d9567fa4b8180e$var$isStaticPattern(basename);
}

var $20b053220c9c357e10d9567fa4b8180e$export$isAffectDepthOfReadingPattern = $20b053220c9c357e10d9567fa4b8180e$var$isAffectDepthOfReadingPattern;
$20b053220c9c357e10d9567fa4b8180e$exports.isAffectDepthOfReadingPattern = $20b053220c9c357e10d9567fa4b8180e$export$isAffectDepthOfReadingPattern;

function $20b053220c9c357e10d9567fa4b8180e$var$expandPatternsWithBraceExpansion(patterns) {
  return patterns.reduce((collection, pattern) => {
    return collection.concat($20b053220c9c357e10d9567fa4b8180e$var$expandBraceExpansion(pattern));
  }, []);
}

var $20b053220c9c357e10d9567fa4b8180e$export$expandPatternsWithBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$var$expandPatternsWithBraceExpansion;
$20b053220c9c357e10d9567fa4b8180e$exports.expandPatternsWithBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$export$expandPatternsWithBraceExpansion;

function $20b053220c9c357e10d9567fa4b8180e$var$expandBraceExpansion(pattern) {
  return $c8e139b8ad76c5430a20f7d24c8c66b6$exports.braces(pattern, {
    expand: true,
    nodupes: true
  });
}

var $20b053220c9c357e10d9567fa4b8180e$export$expandBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$var$expandBraceExpansion;
$20b053220c9c357e10d9567fa4b8180e$exports.expandBraceExpansion = $20b053220c9c357e10d9567fa4b8180e$export$expandBraceExpansion;

function $20b053220c9c357e10d9567fa4b8180e$var$getPatternParts(pattern, options) {
  let {
    parts
  } = $e317ddf903547cedea8a0a0c15ed75d8$exports.scan(pattern, Object.assign(Object.assign({}, options), {
    parts: true
  }));
  /**
   * The scan method returns an empty array in some cases.
   * See micromatch/picomatch#58 for more details.
   */

  /**
   * The scan method returns an empty array in some cases.
   * See micromatch/picomatch#58 for more details.
   */
  if (parts.length === 0) {
    parts = [pattern];
  }
  /**
   * The scan method does not return an empty part for the pattern with a forward slash.
   * This is another part of micromatch/picomatch#58.
   */


  /**
   * The scan method does not return an empty part for the pattern with a forward slash.
   * This is another part of micromatch/picomatch#58.
   */
  if (parts[0].startsWith('/')) {
    parts[0] = parts[0].slice(1);
    parts.unshift('');
  }

  return parts;
}

var $20b053220c9c357e10d9567fa4b8180e$export$getPatternParts = $20b053220c9c357e10d9567fa4b8180e$var$getPatternParts;
$20b053220c9c357e10d9567fa4b8180e$exports.getPatternParts = $20b053220c9c357e10d9567fa4b8180e$export$getPatternParts;

function $20b053220c9c357e10d9567fa4b8180e$var$makeRe(pattern, options) {
  return $c8e139b8ad76c5430a20f7d24c8c66b6$exports.makeRe(pattern, options);
}

var $20b053220c9c357e10d9567fa4b8180e$export$makeRe = $20b053220c9c357e10d9567fa4b8180e$var$makeRe;
$20b053220c9c357e10d9567fa4b8180e$exports.makeRe = $20b053220c9c357e10d9567fa4b8180e$export$makeRe;

function $20b053220c9c357e10d9567fa4b8180e$var$convertPatternsToRe(patterns, options) {
  return patterns.map(pattern => $20b053220c9c357e10d9567fa4b8180e$var$makeRe(pattern, options));
}

var $20b053220c9c357e10d9567fa4b8180e$export$convertPatternsToRe = $20b053220c9c357e10d9567fa4b8180e$var$convertPatternsToRe;
$20b053220c9c357e10d9567fa4b8180e$exports.convertPatternsToRe = $20b053220c9c357e10d9567fa4b8180e$export$convertPatternsToRe;

function $20b053220c9c357e10d9567fa4b8180e$var$matchAny(entry, patternsRe) {
  return patternsRe.some(patternRe => patternRe.test(entry));
}

$20b053220c9c357e10d9567fa4b8180e$export$matchAny = $20b053220c9c357e10d9567fa4b8180e$var$matchAny;
$20b053220c9c357e10d9567fa4b8180e$exports.matchAny = $20b053220c9c357e10d9567fa4b8180e$export$matchAny;
var $6bda9691bfa358c458d88d7e26adea34$export$pattern = $20b053220c9c357e10d9567fa4b8180e$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.pattern = $20b053220c9c357e10d9567fa4b8180e$exports;
// ASSET: node_modules/fast-glob/out/utils/stream.js
var $27fc062ac4c52bcac67d54194b00e015$exports = {};
Object.defineProperty($27fc062ac4c52bcac67d54194b00e015$exports, "__esModule", {
  value: true
});
var $27fc062ac4c52bcac67d54194b00e015$export$merge = void 0;
$27fc062ac4c52bcac67d54194b00e015$exports.merge = $27fc062ac4c52bcac67d54194b00e015$export$merge;

function $27fc062ac4c52bcac67d54194b00e015$var$merge(streams) {
  const mergedStream = $fb8bb4f965dec78b60bb9e0acdcfcbfe$exports(streams);
  streams.forEach(stream => {
    stream.once('error', error => mergedStream.emit('error', error));
  });
  mergedStream.once('close', () => $27fc062ac4c52bcac67d54194b00e015$var$propagateCloseEventToSources(streams));
  mergedStream.once('end', () => $27fc062ac4c52bcac67d54194b00e015$var$propagateCloseEventToSources(streams));
  return mergedStream;
}

$27fc062ac4c52bcac67d54194b00e015$export$merge = $27fc062ac4c52bcac67d54194b00e015$var$merge;
$27fc062ac4c52bcac67d54194b00e015$exports.merge = $27fc062ac4c52bcac67d54194b00e015$export$merge;

function $27fc062ac4c52bcac67d54194b00e015$var$propagateCloseEventToSources(streams) {
  streams.forEach(stream => stream.emit('close'));
}

var $6bda9691bfa358c458d88d7e26adea34$export$stream = $27fc062ac4c52bcac67d54194b00e015$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.stream = $27fc062ac4c52bcac67d54194b00e015$exports;
// ASSET: node_modules/fast-glob/out/utils/string.js
var $00617f24e92ba3b6122ed2c7a60b09a5$exports = {};
Object.defineProperty($00617f24e92ba3b6122ed2c7a60b09a5$exports, "__esModule", {
  value: true
});
var $00617f24e92ba3b6122ed2c7a60b09a5$export$isEmpty = ($00617f24e92ba3b6122ed2c7a60b09a5$export$isString = void 0, $00617f24e92ba3b6122ed2c7a60b09a5$exports.isString = $00617f24e92ba3b6122ed2c7a60b09a5$export$isString);
$00617f24e92ba3b6122ed2c7a60b09a5$exports.isEmpty = $00617f24e92ba3b6122ed2c7a60b09a5$export$isEmpty;

function $00617f24e92ba3b6122ed2c7a60b09a5$var$isString(input) {
  return typeof input === 'string';
}

var $00617f24e92ba3b6122ed2c7a60b09a5$export$isString = $00617f24e92ba3b6122ed2c7a60b09a5$var$isString;
$00617f24e92ba3b6122ed2c7a60b09a5$exports.isString = $00617f24e92ba3b6122ed2c7a60b09a5$export$isString;

function $00617f24e92ba3b6122ed2c7a60b09a5$var$isEmpty(input) {
  return input === '';
}

$00617f24e92ba3b6122ed2c7a60b09a5$export$isEmpty = $00617f24e92ba3b6122ed2c7a60b09a5$var$isEmpty;
$00617f24e92ba3b6122ed2c7a60b09a5$exports.isEmpty = $00617f24e92ba3b6122ed2c7a60b09a5$export$isEmpty;
$6bda9691bfa358c458d88d7e26adea34$export$string = $00617f24e92ba3b6122ed2c7a60b09a5$exports;
$6bda9691bfa358c458d88d7e26adea34$exports.string = $6bda9691bfa358c458d88d7e26adea34$export$string;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$generate(patterns, settings) {
  const positivePatterns = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getPositivePatterns(patterns);
  const negativePatterns = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getNegativePatternsAsPositive(patterns, settings.ignore);
  const staticPatterns = positivePatterns.filter(pattern => $6bda9691bfa358c458d88d7e26adea34$exports.pattern.isStaticPattern(pattern, settings));
  const dynamicPatterns = positivePatterns.filter(pattern => $6bda9691bfa358c458d88d7e26adea34$exports.pattern.isDynamicPattern(pattern, settings));
  const staticTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternsToTasks(staticPatterns, negativePatterns,
  /* dynamic */
  false);
  const dynamicTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternsToTasks(dynamicPatterns, negativePatterns,
  /* dynamic */
  true);
  return staticTasks.concat(dynamicTasks);
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$generate = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$generate;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.generate = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$generate;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternsToTasks(positive, negative, dynamic) {
  const positivePatternsGroup = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$groupPatternsByBaseDirectory(positive); // When we have a global group  there is no reason to divide the patterns into independent tasks.
  // In this case, the global task covers the rest.

  // When we have a global group  there is no reason to divide the patterns into independent tasks.
  // In this case, the global task covers the rest.
  if ('.' in positivePatternsGroup) {
    const task = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupToTask('.', positive, negative, dynamic);
    return [task];
  }

  return $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternsToTasks;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternsToTasks;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getPositivePatterns(patterns) {
  return $6bda9691bfa358c458d88d7e26adea34$exports.pattern.getPositivePatterns(patterns);
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getPositivePatterns = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getPositivePatterns;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.getPositivePatterns = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getPositivePatterns;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getNegativePatternsAsPositive(patterns, ignore) {
  const negative = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.getNegativePatterns(patterns).concat(ignore);
  const positive = negative.map($6bda9691bfa358c458d88d7e26adea34$exports.pattern.convertToPositivePattern);
  return positive;
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getNegativePatternsAsPositive = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$getNegativePatternsAsPositive;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.getNegativePatternsAsPositive = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$getNegativePatternsAsPositive;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$groupPatternsByBaseDirectory(patterns) {
  const group = {};
  return patterns.reduce((collection, pattern) => {
    const base = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.getBaseDirectory(pattern);

    if (base in collection) {
      collection[base].push(pattern);
    } else {
      collection[base] = [pattern];
    }

    return collection;
  }, group);
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$groupPatternsByBaseDirectory = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$groupPatternsByBaseDirectory;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.groupPatternsByBaseDirectory = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$groupPatternsByBaseDirectory;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map(base => {
    return $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupToTask(base, positive[base], negative, dynamic);
  });
}

var $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupsToTasks;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternGroupsToTasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupsToTasks;

function $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupToTask(base, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base,
    patterns: [].concat(positive, negative.map($6bda9691bfa358c458d88d7e26adea34$exports.pattern.convertToNegativePattern))
  };
}

$8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupToTask = $8e74aa6f5c2e1dabadcc8fa176ea0322$var$convertPatternGroupToTask;
$8e74aa6f5c2e1dabadcc8fa176ea0322$exports.convertPatternGroupToTask = $8e74aa6f5c2e1dabadcc8fa176ea0322$export$convertPatternGroupToTask;
// ASSET: node_modules/fast-glob/out/providers/async.js
var $0ea17b8dac5d932ee9b5a8756d3c8826$exports = {};
Object.defineProperty($0ea17b8dac5d932ee9b5a8756d3c8826$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/fast-glob/out/readers/stream.js
var $8ecc1965905bd95a37821c967f47854c$exports = {};
Object.defineProperty($8ecc1965905bd95a37821c967f47854c$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.stat/out/index.js
var $f190d447ca3d50622d6d44c24e2f7654$exports = {};
Object.defineProperty($f190d447ca3d50622d6d44c24e2f7654$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.stat/out/providers/async.js
var $e0751a5436a1317f5d6f5acf1b76b413$exports = {};
Object.defineProperty($e0751a5436a1317f5d6f5acf1b76b413$exports, "__esModule", {
  value: true
});

function $e0751a5436a1317f5d6f5acf1b76b413$var$read(path, settings, callback) {
  settings.fs.lstat(path, (lstatError, lstat) => {
    if (lstatError !== null) {
      return $e0751a5436a1317f5d6f5acf1b76b413$var$callFailureCallback(callback, lstatError);
    }

    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return $e0751a5436a1317f5d6f5acf1b76b413$var$callSuccessCallback(callback, lstat);
    }

    settings.fs.stat(path, (statError, stat) => {
      if (statError !== null) {
        if (settings.throwErrorOnBrokenSymbolicLink) {
          return $e0751a5436a1317f5d6f5acf1b76b413$var$callFailureCallback(callback, statError);
        }

        return $e0751a5436a1317f5d6f5acf1b76b413$var$callSuccessCallback(callback, lstat);
      }

      if (settings.markSymbolicLink) {
        stat.isSymbolicLink = () => true;
      }

      $e0751a5436a1317f5d6f5acf1b76b413$var$callSuccessCallback(callback, stat);
    });
  });
}

var $e0751a5436a1317f5d6f5acf1b76b413$export$read = $e0751a5436a1317f5d6f5acf1b76b413$var$read;
$e0751a5436a1317f5d6f5acf1b76b413$exports.read = $e0751a5436a1317f5d6f5acf1b76b413$export$read;

function $e0751a5436a1317f5d6f5acf1b76b413$var$callFailureCallback(callback, error) {
  callback(error);
}

function $e0751a5436a1317f5d6f5acf1b76b413$var$callSuccessCallback(callback, result) {
  callback(null, result);
}

// ASSET: node_modules/@nodelib/fs.stat/out/providers/sync.js
var $ca7eddf943a3fa0daad9d6fb66610c9c$exports = {};
Object.defineProperty($ca7eddf943a3fa0daad9d6fb66610c9c$exports, "__esModule", {
  value: true
});

function $ca7eddf943a3fa0daad9d6fb66610c9c$var$read(path, settings) {
  const lstat = settings.fs.lstatSync(path);

  if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
    return lstat;
  }

  try {
    const stat = settings.fs.statSync(path);

    if (settings.markSymbolicLink) {
      stat.isSymbolicLink = () => true;
    }

    return stat;
  } catch (error) {
    if (!settings.throwErrorOnBrokenSymbolicLink) {
      return lstat;
    }

    throw error;
  }
}

var $ca7eddf943a3fa0daad9d6fb66610c9c$export$read = $ca7eddf943a3fa0daad9d6fb66610c9c$var$read;
$ca7eddf943a3fa0daad9d6fb66610c9c$exports.read = $ca7eddf943a3fa0daad9d6fb66610c9c$export$read;
// ASSET: node_modules/@nodelib/fs.stat/out/settings.js
var $3be198b5aa3f9ecf456a4a426ed3ee8d$exports = {};
Object.defineProperty($3be198b5aa3f9ecf456a4a426ed3ee8d$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.stat/out/adapters/fs.js
var $29eba5e898781e4ee26b451ccc96b946$exports = {};
Object.defineProperty($29eba5e898781e4ee26b451ccc96b946$exports, "__esModule", {
  value: true
});
const $29eba5e898781e4ee26b451ccc96b946$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
var $29eba5e898781e4ee26b451ccc96b946$export$FILE_SYSTEM_ADAPTER = {
  lstat: $29eba5e898781e4ee26b451ccc96b946$var$fs.lstat,
  stat: $29eba5e898781e4ee26b451ccc96b946$var$fs.stat,
  lstatSync: $29eba5e898781e4ee26b451ccc96b946$var$fs.lstatSync,
  statSync: $29eba5e898781e4ee26b451ccc96b946$var$fs.statSync
};
$29eba5e898781e4ee26b451ccc96b946$exports.FILE_SYSTEM_ADAPTER = $29eba5e898781e4ee26b451ccc96b946$export$FILE_SYSTEM_ADAPTER;

function $29eba5e898781e4ee26b451ccc96b946$var$createFileSystemAdapter(fsMethods) {
  if (fsMethods === undefined) {
    return $29eba5e898781e4ee26b451ccc96b946$exports.FILE_SYSTEM_ADAPTER;
  }

  return Object.assign(Object.assign({}, $29eba5e898781e4ee26b451ccc96b946$exports.FILE_SYSTEM_ADAPTER), fsMethods);
}

var $29eba5e898781e4ee26b451ccc96b946$export$createFileSystemAdapter = $29eba5e898781e4ee26b451ccc96b946$var$createFileSystemAdapter;
$29eba5e898781e4ee26b451ccc96b946$exports.createFileSystemAdapter = $29eba5e898781e4ee26b451ccc96b946$export$createFileSystemAdapter;

class $3be198b5aa3f9ecf456a4a426ed3ee8d$var$Settings {
  constructor(_options = {}) {
    this._options = _options;
    this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
    this.fs = $29eba5e898781e4ee26b451ccc96b946$exports.createFileSystemAdapter(this._options.fs);
    this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
  }

  _getValue(option, value) {
    return option === undefined ? value : option;
  }

}

var $3be198b5aa3f9ecf456a4a426ed3ee8d$export$default = $3be198b5aa3f9ecf456a4a426ed3ee8d$var$Settings;
$3be198b5aa3f9ecf456a4a426ed3ee8d$exports.default = $3be198b5aa3f9ecf456a4a426ed3ee8d$export$default;
var $f190d447ca3d50622d6d44c24e2f7654$export$Settings = $3be198b5aa3f9ecf456a4a426ed3ee8d$exports.default;
$f190d447ca3d50622d6d44c24e2f7654$exports.Settings = $f190d447ca3d50622d6d44c24e2f7654$export$Settings;

function $f190d447ca3d50622d6d44c24e2f7654$var$stat(path, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === 'function') {
    return $e0751a5436a1317f5d6f5acf1b76b413$exports.read(path, $f190d447ca3d50622d6d44c24e2f7654$var$getSettings(), optionsOrSettingsOrCallback);
  }

  $e0751a5436a1317f5d6f5acf1b76b413$exports.read(path, $f190d447ca3d50622d6d44c24e2f7654$var$getSettings(optionsOrSettingsOrCallback), callback);
}

var $f190d447ca3d50622d6d44c24e2f7654$export$stat = $f190d447ca3d50622d6d44c24e2f7654$var$stat;
$f190d447ca3d50622d6d44c24e2f7654$exports.stat = $f190d447ca3d50622d6d44c24e2f7654$export$stat;

function $f190d447ca3d50622d6d44c24e2f7654$var$statSync(path, optionsOrSettings) {
  const settings = $f190d447ca3d50622d6d44c24e2f7654$var$getSettings(optionsOrSettings);
  return $ca7eddf943a3fa0daad9d6fb66610c9c$exports.read(path, settings);
}

var $f190d447ca3d50622d6d44c24e2f7654$export$statSync = $f190d447ca3d50622d6d44c24e2f7654$var$statSync;
$f190d447ca3d50622d6d44c24e2f7654$exports.statSync = $f190d447ca3d50622d6d44c24e2f7654$export$statSync;

function $f190d447ca3d50622d6d44c24e2f7654$var$getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof $3be198b5aa3f9ecf456a4a426ed3ee8d$exports.default) {
    return settingsOrOptions;
  }

  return new $3be198b5aa3f9ecf456a4a426ed3ee8d$exports.default(settingsOrOptions);
}

// ASSET: node_modules/@nodelib/fs.walk/out/index.js
var $aa82bc7f9592d7cc32e1bede0cc5f087$exports = {};
Object.defineProperty($aa82bc7f9592d7cc32e1bede0cc5f087$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.walk/out/providers/async.js
var $23acf26ef897acdbcfa49656420ae06a$exports = {};
Object.defineProperty($23acf26ef897acdbcfa49656420ae06a$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.walk/out/readers/async.js
var $3e98f0ee406436c9b594a910a70f900b$exports = {};
Object.defineProperty($3e98f0ee406436c9b594a910a70f900b$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.scandir/out/index.js
var $2f21d9a8cef1d90caf936325d9e2db4e$exports = {};
Object.defineProperty($2f21d9a8cef1d90caf936325d9e2db4e$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.scandir/out/providers/async.js
var $b62d8649983144ab59e15e4da921ad52$exports = {};
Object.defineProperty($b62d8649983144ab59e15e4da921ad52$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/run-parallel/index.js
var $bd8686af2f2957b0710169c2912e0b35$exports = {};
var $bd8686af2f2957b0710169c2912e0b35$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
$bd8686af2f2957b0710169c2912e0b35$exports = $bd8686af2f2957b0710169c2912e0b35$var$runParallel;

function $bd8686af2f2957b0710169c2912e0b35$var$runParallel(tasks, cb) {
  var results, pending, keys;
  var isSync = true;

  if (Array.isArray(tasks)) {
    results = [];
    pending = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = keys.length;
  }

  function done(err) {
    function end() {
      if (cb) cb(err, results);
      cb = null;
    }

    if (isSync) $bd8686af2f2957b0710169c2912e0b35$var$process.nextTick(end);else end();
  }

  function each(i, err, result) {
    results[i] = result;

    if (--pending === 0 || err) {
      done(err);
    }
  }

  if (!pending) {
    // empty
    done(null);
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) {
        each(key, err, result);
      });
    });
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) {
        each(i, err, result);
      });
    });
  }

  isSync = false;
}

// ASSET: node_modules/@nodelib/fs.scandir/out/constants.js
var $2d8b701e6772c649104998fb27e2361f$exports = {};
Object.defineProperty($2d8b701e6772c649104998fb27e2361f$exports, "__esModule", {
  value: true
});
/**
 * IS `true` for Node.js 10.10 and greater.
 */

var $2d8b701e6772c649104998fb27e2361f$export$IS_SUPPORT_READDIR_WITH_FILE_TYPES = true;

/**
 * IS `true` for Node.js 10.10 and greater.
 */
$2d8b701e6772c649104998fb27e2361f$exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = $2d8b701e6772c649104998fb27e2361f$export$IS_SUPPORT_READDIR_WITH_FILE_TYPES;
// ASSET: node_modules/@nodelib/fs.scandir/out/utils/index.js
var $1631170044c80d34fb17bef701b3b12d$exports = {};
Object.defineProperty($1631170044c80d34fb17bef701b3b12d$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.scandir/out/utils/fs.js
var $ec96ab2e74250d9043232a87cb60bbd1$exports = {};
Object.defineProperty($ec96ab2e74250d9043232a87cb60bbd1$exports, "__esModule", {
  value: true
});

class $ec96ab2e74250d9043232a87cb60bbd1$var$DirentFromStats {
  constructor(name, stats) {
    this.name = name;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }

}

function $ec96ab2e74250d9043232a87cb60bbd1$var$createDirentFromStats(name, stats) {
  return new $ec96ab2e74250d9043232a87cb60bbd1$var$DirentFromStats(name, stats);
}

var $ec96ab2e74250d9043232a87cb60bbd1$export$createDirentFromStats = $ec96ab2e74250d9043232a87cb60bbd1$var$createDirentFromStats;
$ec96ab2e74250d9043232a87cb60bbd1$exports.createDirentFromStats = $ec96ab2e74250d9043232a87cb60bbd1$export$createDirentFromStats;
$1631170044c80d34fb17bef701b3b12d$exports.fs = $ec96ab2e74250d9043232a87cb60bbd1$exports;

function $b62d8649983144ab59e15e4da921ad52$var$read(directory, settings, callback) {
  if (!settings.stats && $2d8b701e6772c649104998fb27e2361f$exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return $b62d8649983144ab59e15e4da921ad52$var$readdirWithFileTypes(directory, settings, callback);
  }

  return $b62d8649983144ab59e15e4da921ad52$var$readdir(directory, settings, callback);
}

var $b62d8649983144ab59e15e4da921ad52$export$read = $b62d8649983144ab59e15e4da921ad52$var$read;
$b62d8649983144ab59e15e4da921ad52$exports.read = $b62d8649983144ab59e15e4da921ad52$export$read;

function $b62d8649983144ab59e15e4da921ad52$var$readdirWithFileTypes(directory, settings, callback) {
  settings.fs.readdir(directory, {
    withFileTypes: true
  }, (readdirError, dirents) => {
    if (readdirError !== null) {
      return $b62d8649983144ab59e15e4da921ad52$var$callFailureCallback(callback, readdirError);
    }

    const entries = dirents.map(dirent => ({
      dirent,
      name: dirent.name,
      path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
    }));

    if (!settings.followSymbolicLinks) {
      return $b62d8649983144ab59e15e4da921ad52$var$callSuccessCallback(callback, entries);
    }

    const tasks = entries.map(entry => $b62d8649983144ab59e15e4da921ad52$var$makeRplTaskEntry(entry, settings));
    $bd8686af2f2957b0710169c2912e0b35$exports(tasks, (rplError, rplEntries) => {
      if (rplError !== null) {
        return $b62d8649983144ab59e15e4da921ad52$var$callFailureCallback(callback, rplError);
      }

      $b62d8649983144ab59e15e4da921ad52$var$callSuccessCallback(callback, rplEntries);
    });
  });
}

var $b62d8649983144ab59e15e4da921ad52$export$readdirWithFileTypes = $b62d8649983144ab59e15e4da921ad52$var$readdirWithFileTypes;
$b62d8649983144ab59e15e4da921ad52$exports.readdirWithFileTypes = $b62d8649983144ab59e15e4da921ad52$export$readdirWithFileTypes;

function $b62d8649983144ab59e15e4da921ad52$var$makeRplTaskEntry(entry, settings) {
  return done => {
    if (!entry.dirent.isSymbolicLink()) {
      return done(null, entry);
    }

    settings.fs.stat(entry.path, (statError, stats) => {
      if (statError !== null) {
        if (settings.throwErrorOnBrokenSymbolicLink) {
          return done(statError);
        }

        return done(null, entry);
      }

      entry.dirent = $1631170044c80d34fb17bef701b3b12d$exports.fs.createDirentFromStats(entry.name, stats);
      return done(null, entry);
    });
  };
}

function $b62d8649983144ab59e15e4da921ad52$var$readdir(directory, settings, callback) {
  settings.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      return $b62d8649983144ab59e15e4da921ad52$var$callFailureCallback(callback, readdirError);
    }

    const filepaths = names.map(name => `${directory}${settings.pathSegmentSeparator}${name}`);
    const tasks = filepaths.map(filepath => {
      return done => $f190d447ca3d50622d6d44c24e2f7654$exports.stat(filepath, settings.fsStatSettings, done);
    });
    $bd8686af2f2957b0710169c2912e0b35$exports(tasks, (rplError, results) => {
      if (rplError !== null) {
        return $b62d8649983144ab59e15e4da921ad52$var$callFailureCallback(callback, rplError);
      }

      const entries = [];
      names.forEach((name, index) => {
        const stats = results[index];
        const entry = {
          name,
          path: filepaths[index],
          dirent: $1631170044c80d34fb17bef701b3b12d$exports.fs.createDirentFromStats(name, stats)
        };

        if (settings.stats) {
          entry.stats = stats;
        }

        entries.push(entry);
      });
      $b62d8649983144ab59e15e4da921ad52$var$callSuccessCallback(callback, entries);
    });
  });
}

var $b62d8649983144ab59e15e4da921ad52$export$readdir = $b62d8649983144ab59e15e4da921ad52$var$readdir;
$b62d8649983144ab59e15e4da921ad52$exports.readdir = $b62d8649983144ab59e15e4da921ad52$export$readdir;

function $b62d8649983144ab59e15e4da921ad52$var$callFailureCallback(callback, error) {
  callback(error);
}

function $b62d8649983144ab59e15e4da921ad52$var$callSuccessCallback(callback, result) {
  callback(null, result);
}

// ASSET: node_modules/@nodelib/fs.scandir/out/providers/sync.js
var $faa21bc7098fda7360ff077926f537fb$exports = {};
Object.defineProperty($faa21bc7098fda7360ff077926f537fb$exports, "__esModule", {
  value: true
});

function $faa21bc7098fda7360ff077926f537fb$var$read(directory, settings) {
  if (!settings.stats && $2d8b701e6772c649104998fb27e2361f$exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return $faa21bc7098fda7360ff077926f537fb$var$readdirWithFileTypes(directory, settings);
  }

  return $faa21bc7098fda7360ff077926f537fb$var$readdir(directory, settings);
}

var $faa21bc7098fda7360ff077926f537fb$export$read = $faa21bc7098fda7360ff077926f537fb$var$read;
$faa21bc7098fda7360ff077926f537fb$exports.read = $faa21bc7098fda7360ff077926f537fb$export$read;

function $faa21bc7098fda7360ff077926f537fb$var$readdirWithFileTypes(directory, settings) {
  const dirents = settings.fs.readdirSync(directory, {
    withFileTypes: true
  });
  return dirents.map(dirent => {
    const entry = {
      dirent,
      name: dirent.name,
      path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
    };

    if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
      try {
        const stats = settings.fs.statSync(entry.path);
        entry.dirent = $1631170044c80d34fb17bef701b3b12d$exports.fs.createDirentFromStats(entry.name, stats);
      } catch (error) {
        if (settings.throwErrorOnBrokenSymbolicLink) {
          throw error;
        }
      }
    }

    return entry;
  });
}

var $faa21bc7098fda7360ff077926f537fb$export$readdirWithFileTypes = $faa21bc7098fda7360ff077926f537fb$var$readdirWithFileTypes;
$faa21bc7098fda7360ff077926f537fb$exports.readdirWithFileTypes = $faa21bc7098fda7360ff077926f537fb$export$readdirWithFileTypes;

function $faa21bc7098fda7360ff077926f537fb$var$readdir(directory, settings) {
  const names = settings.fs.readdirSync(directory);
  return names.map(name => {
    const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;
    const stats = $f190d447ca3d50622d6d44c24e2f7654$exports.statSync(entryPath, settings.fsStatSettings);
    const entry = {
      name,
      path: entryPath,
      dirent: $1631170044c80d34fb17bef701b3b12d$exports.fs.createDirentFromStats(name, stats)
    };

    if (settings.stats) {
      entry.stats = stats;
    }

    return entry;
  });
}

var $faa21bc7098fda7360ff077926f537fb$export$readdir = $faa21bc7098fda7360ff077926f537fb$var$readdir;
$faa21bc7098fda7360ff077926f537fb$exports.readdir = $faa21bc7098fda7360ff077926f537fb$export$readdir;
// ASSET: node_modules/@nodelib/fs.scandir/out/settings.js
var $67d74cd852a99a48de7b1060ad61147d$exports = {};
Object.defineProperty($67d74cd852a99a48de7b1060ad61147d$exports, "__esModule", {
  value: true
});
const $67d74cd852a99a48de7b1060ad61147d$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var $cf2a35dc4f135de7c556569ee2d11524$exports = {};
Object.defineProperty($cf2a35dc4f135de7c556569ee2d11524$exports, "__esModule", {
  value: true
});
const $cf2a35dc4f135de7c556569ee2d11524$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
var $cf2a35dc4f135de7c556569ee2d11524$export$FILE_SYSTEM_ADAPTER = {
  lstat: $cf2a35dc4f135de7c556569ee2d11524$var$fs.lstat,
  stat: $cf2a35dc4f135de7c556569ee2d11524$var$fs.stat,
  lstatSync: $cf2a35dc4f135de7c556569ee2d11524$var$fs.lstatSync,
  statSync: $cf2a35dc4f135de7c556569ee2d11524$var$fs.statSync,
  readdir: $cf2a35dc4f135de7c556569ee2d11524$var$fs.readdir,
  readdirSync: $cf2a35dc4f135de7c556569ee2d11524$var$fs.readdirSync
};
$cf2a35dc4f135de7c556569ee2d11524$exports.FILE_SYSTEM_ADAPTER = $cf2a35dc4f135de7c556569ee2d11524$export$FILE_SYSTEM_ADAPTER;

function $cf2a35dc4f135de7c556569ee2d11524$var$createFileSystemAdapter(fsMethods) {
  if (fsMethods === undefined) {
    return $cf2a35dc4f135de7c556569ee2d11524$exports.FILE_SYSTEM_ADAPTER;
  }

  return Object.assign(Object.assign({}, $cf2a35dc4f135de7c556569ee2d11524$exports.FILE_SYSTEM_ADAPTER), fsMethods);
}

var $cf2a35dc4f135de7c556569ee2d11524$export$createFileSystemAdapter = $cf2a35dc4f135de7c556569ee2d11524$var$createFileSystemAdapter;
$cf2a35dc4f135de7c556569ee2d11524$exports.createFileSystemAdapter = $cf2a35dc4f135de7c556569ee2d11524$export$createFileSystemAdapter;

class $67d74cd852a99a48de7b1060ad61147d$var$Settings {
  constructor(_options = {}) {
    this._options = _options;
    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
    this.fs = $cf2a35dc4f135de7c556569ee2d11524$exports.createFileSystemAdapter(this._options.fs);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, $67d74cd852a99a48de7b1060ad61147d$var$path.sep);
    this.stats = this._getValue(this._options.stats, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    this.fsStatSettings = new $f190d447ca3d50622d6d44c24e2f7654$exports.Settings({
      followSymbolicLink: this.followSymbolicLinks,
      fs: this.fs,
      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
    });
  }

  _getValue(option, value) {
    return option === undefined ? value : option;
  }

}

var $67d74cd852a99a48de7b1060ad61147d$export$default = $67d74cd852a99a48de7b1060ad61147d$var$Settings;
$67d74cd852a99a48de7b1060ad61147d$exports.default = $67d74cd852a99a48de7b1060ad61147d$export$default;
var $2f21d9a8cef1d90caf936325d9e2db4e$export$Settings = $67d74cd852a99a48de7b1060ad61147d$exports.default;
$2f21d9a8cef1d90caf936325d9e2db4e$exports.Settings = $2f21d9a8cef1d90caf936325d9e2db4e$export$Settings;

function $2f21d9a8cef1d90caf936325d9e2db4e$var$scandir(path, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === 'function') {
    return $b62d8649983144ab59e15e4da921ad52$exports.read(path, $2f21d9a8cef1d90caf936325d9e2db4e$var$getSettings(), optionsOrSettingsOrCallback);
  }

  $b62d8649983144ab59e15e4da921ad52$exports.read(path, $2f21d9a8cef1d90caf936325d9e2db4e$var$getSettings(optionsOrSettingsOrCallback), callback);
}

var $2f21d9a8cef1d90caf936325d9e2db4e$export$scandir = $2f21d9a8cef1d90caf936325d9e2db4e$var$scandir;
$2f21d9a8cef1d90caf936325d9e2db4e$exports.scandir = $2f21d9a8cef1d90caf936325d9e2db4e$export$scandir;

function $2f21d9a8cef1d90caf936325d9e2db4e$var$scandirSync(path, optionsOrSettings) {
  const settings = $2f21d9a8cef1d90caf936325d9e2db4e$var$getSettings(optionsOrSettings);
  return $faa21bc7098fda7360ff077926f537fb$exports.read(path, settings);
}

var $2f21d9a8cef1d90caf936325d9e2db4e$export$scandirSync = $2f21d9a8cef1d90caf936325d9e2db4e$var$scandirSync;
$2f21d9a8cef1d90caf936325d9e2db4e$exports.scandirSync = $2f21d9a8cef1d90caf936325d9e2db4e$export$scandirSync;

function $2f21d9a8cef1d90caf936325d9e2db4e$var$getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof $67d74cd852a99a48de7b1060ad61147d$exports.default) {
    return settingsOrOptions;
  }

  return new $67d74cd852a99a48de7b1060ad61147d$exports.default(settingsOrOptions);
}

// ASSET: node_modules/fastq/queue.js
var $923a64f5aafa4784cda880e5d88424ef$exports = {};
// ASSET: node_modules/reusify/reusify.js
var $3041d5df76705393605b2b0715941a84$exports = {};

function $3041d5df76705393605b2b0715941a84$var$reusify(Constructor) {
  var head = new Constructor();
  var tail = head;

  function get() {
    var current = head;

    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }

    current.next = null;
    return current;
  }

  function release(obj) {
    tail.next = obj;
    tail = obj;
  }

  return {
    get: get,
    release: release
  };
}

$3041d5df76705393605b2b0715941a84$exports = $3041d5df76705393605b2b0715941a84$var$reusify;

function $923a64f5aafa4784cda880e5d88424ef$var$fastqueue(context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  var cache = $3041d5df76705393605b2b0715941a84$exports($923a64f5aafa4784cda880e5d88424ef$var$Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self = {
    push: push,
    drain: $923a64f5aafa4784cda880e5d88424ef$var$noop,
    saturated: $923a64f5aafa4784cda880e5d88424ef$var$noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: $923a64f5aafa4784cda880e5d88424ef$var$noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  };
  return self;

  function running() {
    return _running;
  }

  function pause() {
    self.paused = true;
  }

  function length() {
    var current = queueHead;
    var counter = 0;

    while (current) {
      current = current.next;
      counter++;
    }

    return counter;
  }

  function getQueue() {
    var current = queueHead;
    var tasks = [];

    while (current) {
      tasks.push(current.value);
      current = current.next;
    }

    return tasks;
  }

  function resume() {
    if (!self.paused) return;
    self.paused = false;

    for (var i = 0; i < self.concurrency; i++) {
      _running++;
      release();
    }
  }

  function idle() {
    return _running === 0 && self.length() === 0;
  }

  function push(value, done) {
    var current = cache.get();
    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || $923a64f5aafa4784cda880e5d88424ef$var$noop;
    current.errorHandler = errorHandler;

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function unshift(value, done) {
    var current = cache.get();
    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || $923a64f5aafa4784cda880e5d88424ef$var$noop;

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function release(holder) {
    if (holder) {
      cache.release(holder);
    }

    var next = queueHead;

    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }

        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);

        if (queueTail === null) {
          self.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self.drain();
    }
  }

  function kill() {
    queueHead = null;
    queueTail = null;
    self.drain = $923a64f5aafa4784cda880e5d88424ef$var$noop;
  }

  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self.drain();
    self.drain = $923a64f5aafa4784cda880e5d88424ef$var$noop;
  }

  function error(handler) {
    errorHandler = handler;
  }
}

function $923a64f5aafa4784cda880e5d88424ef$var$noop() {}

function $923a64f5aafa4784cda880e5d88424ef$var$Task() {
  this.value = null;
  this.callback = $923a64f5aafa4784cda880e5d88424ef$var$noop;
  this.next = null;
  this.release = $923a64f5aafa4784cda880e5d88424ef$var$noop;
  this.context = null;
  this.errorHandler = null;
  var self = this;

  this.worked = function worked(err, result) {
    var callback = self.callback;
    var errorHandler = self.errorHandler;
    var val = self.value;
    self.value = null;
    self.callback = $923a64f5aafa4784cda880e5d88424ef$var$noop;

    if (self.errorHandler) {
      errorHandler(err, val);
    }

    callback.call(self.context, err, result);
    self.release(self);
  };
}

$923a64f5aafa4784cda880e5d88424ef$exports = $923a64f5aafa4784cda880e5d88424ef$var$fastqueue;
// ASSET: node_modules/@nodelib/fs.walk/out/readers/common.js
var $a3fcac2816d380a5cbd4ce962104c687$exports = {};
Object.defineProperty($a3fcac2816d380a5cbd4ce962104c687$exports, "__esModule", {
  value: true
});

function $a3fcac2816d380a5cbd4ce962104c687$var$isFatalError(settings, error) {
  if (settings.errorFilter === null) {
    return true;
  }

  return !settings.errorFilter(error);
}

var $a3fcac2816d380a5cbd4ce962104c687$export$isFatalError = $a3fcac2816d380a5cbd4ce962104c687$var$isFatalError;
$a3fcac2816d380a5cbd4ce962104c687$exports.isFatalError = $a3fcac2816d380a5cbd4ce962104c687$export$isFatalError;

function $a3fcac2816d380a5cbd4ce962104c687$var$isAppliedFilter(filter, value) {
  return filter === null || filter(value);
}

var $a3fcac2816d380a5cbd4ce962104c687$export$isAppliedFilter = $a3fcac2816d380a5cbd4ce962104c687$var$isAppliedFilter;
$a3fcac2816d380a5cbd4ce962104c687$exports.isAppliedFilter = $a3fcac2816d380a5cbd4ce962104c687$export$isAppliedFilter;

function $a3fcac2816d380a5cbd4ce962104c687$var$replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[\\/]/).join(separator);
}

var $a3fcac2816d380a5cbd4ce962104c687$export$replacePathSegmentSeparator = $a3fcac2816d380a5cbd4ce962104c687$var$replacePathSegmentSeparator;
$a3fcac2816d380a5cbd4ce962104c687$exports.replacePathSegmentSeparator = $a3fcac2816d380a5cbd4ce962104c687$export$replacePathSegmentSeparator;

function $a3fcac2816d380a5cbd4ce962104c687$var$joinPathSegments(a, b, separator) {
  if (a === '') {
    return b;
  }

  return a + separator + b;
}

var $a3fcac2816d380a5cbd4ce962104c687$export$joinPathSegments = $a3fcac2816d380a5cbd4ce962104c687$var$joinPathSegments;
$a3fcac2816d380a5cbd4ce962104c687$exports.joinPathSegments = $a3fcac2816d380a5cbd4ce962104c687$export$joinPathSegments;
// ASSET: node_modules/@nodelib/fs.walk/out/readers/reader.js
var $5b27f4fd2bde3783d9e0055c4d6dff38$exports = {};
Object.defineProperty($5b27f4fd2bde3783d9e0055c4d6dff38$exports, "__esModule", {
  value: true
});

class $5b27f4fd2bde3783d9e0055c4d6dff38$var$Reader {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._root = $a3fcac2816d380a5cbd4ce962104c687$exports.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
  }

}

var $5b27f4fd2bde3783d9e0055c4d6dff38$export$default = $5b27f4fd2bde3783d9e0055c4d6dff38$var$Reader;
$5b27f4fd2bde3783d9e0055c4d6dff38$exports.default = $5b27f4fd2bde3783d9e0055c4d6dff38$export$default;

class $3e98f0ee406436c9b594a910a70f900b$var$AsyncReader extends $5b27f4fd2bde3783d9e0055c4d6dff38$exports.default {
  constructor(_root, _settings) {
    super(_root, _settings);
    this._settings = _settings;
    this._scandir = $2f21d9a8cef1d90caf936325d9e2db4e$exports.scandir;
    this._emitter = new $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter();
    this._queue = $923a64f5aafa4784cda880e5d88424ef$exports(this._worker.bind(this), this._settings.concurrency);
    this._isFatalError = false;
    this._isDestroyed = false;

    this._queue.drain = () => {
      if (!this._isFatalError) {
        this._emitter.emit('end');
      }
    };
  }

  read() {
    this._isFatalError = false;
    this._isDestroyed = false;
    setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    });
    return this._emitter;
  }

  destroy() {
    if (this._isDestroyed) {
      throw new Error('The reader is already destroyed');
    }

    this._isDestroyed = true;

    this._queue.killAndDrain();
  }

  onEntry(callback) {
    this._emitter.on('entry', callback);
  }

  onError(callback) {
    this._emitter.once('error', callback);
  }

  onEnd(callback) {
    this._emitter.once('end', callback);
  }

  _pushToQueue(directory, base) {
    const queueItem = {
      directory,
      base
    };

    this._queue.push(queueItem, error => {
      if (error !== null) {
        this._handleError(error);
      }
    });
  }

  _worker(item, done) {
    this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
      if (error !== null) {
        return done(error, undefined);
      }

      for (const entry of entries) {
        this._handleEntry(entry, item.base);
      }

      done(null, undefined);
    });
  }

  _handleError(error) {
    if (!$a3fcac2816d380a5cbd4ce962104c687$exports.isFatalError(this._settings, error)) {
      return;
    }

    this._isFatalError = true;
    this._isDestroyed = true;

    this._emitter.emit('error', error);
  }

  _handleEntry(entry, base) {
    if (this._isDestroyed || this._isFatalError) {
      return;
    }

    const fullpath = entry.path;

    if (base !== undefined) {
      entry.path = $a3fcac2816d380a5cbd4ce962104c687$exports.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
    }

    if ($a3fcac2816d380a5cbd4ce962104c687$exports.isAppliedFilter(this._settings.entryFilter, entry)) {
      this._emitEntry(entry);
    }

    if (entry.dirent.isDirectory() && $a3fcac2816d380a5cbd4ce962104c687$exports.isAppliedFilter(this._settings.deepFilter, entry)) {
      this._pushToQueue(fullpath, entry.path);
    }
  }

  _emitEntry(entry) {
    this._emitter.emit('entry', entry);
  }

}

var $3e98f0ee406436c9b594a910a70f900b$export$default = $3e98f0ee406436c9b594a910a70f900b$var$AsyncReader;
$3e98f0ee406436c9b594a910a70f900b$exports.default = $3e98f0ee406436c9b594a910a70f900b$export$default;

class $23acf26ef897acdbcfa49656420ae06a$var$AsyncProvider {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new $3e98f0ee406436c9b594a910a70f900b$exports.default(this._root, this._settings);
    this._storage = new Set();
  }

  read(callback) {
    this._reader.onError(error => {
      $23acf26ef897acdbcfa49656420ae06a$var$callFailureCallback(callback, error);
    });

    this._reader.onEntry(entry => {
      this._storage.add(entry);
    });

    this._reader.onEnd(() => {
      $23acf26ef897acdbcfa49656420ae06a$var$callSuccessCallback(callback, [...this._storage]);
    });

    this._reader.read();
  }

}

var $23acf26ef897acdbcfa49656420ae06a$export$default = $23acf26ef897acdbcfa49656420ae06a$var$AsyncProvider;
$23acf26ef897acdbcfa49656420ae06a$exports.default = $23acf26ef897acdbcfa49656420ae06a$export$default;

function $23acf26ef897acdbcfa49656420ae06a$var$callFailureCallback(callback, error) {
  callback(error);
}

function $23acf26ef897acdbcfa49656420ae06a$var$callSuccessCallback(callback, entries) {
  callback(null, entries);
}

// ASSET: node_modules/@nodelib/fs.walk/out/providers/stream.js
var $188806a3edf789708d9e5a30be444a42$exports = {};
Object.defineProperty($188806a3edf789708d9e5a30be444a42$exports, "__esModule", {
  value: true
});

class $188806a3edf789708d9e5a30be444a42$var$StreamProvider {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new $3e98f0ee406436c9b594a910a70f900b$exports.default(this._root, this._settings);
    this._stream = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable({
      objectMode: true,
      read: () => {},
      destroy: this._reader.destroy.bind(this._reader)
    });
  }

  read() {
    this._reader.onError(error => {
      this._stream.emit('error', error);
    });

    this._reader.onEntry(entry => {
      this._stream.push(entry);
    });

    this._reader.onEnd(() => {
      this._stream.push(null);
    });

    this._reader.read();

    return this._stream;
  }

}

var $188806a3edf789708d9e5a30be444a42$export$default = $188806a3edf789708d9e5a30be444a42$var$StreamProvider;
$188806a3edf789708d9e5a30be444a42$exports.default = $188806a3edf789708d9e5a30be444a42$export$default;
// ASSET: node_modules/@nodelib/fs.walk/out/providers/sync.js
var $8ea9421df10c86c62b0c73a27cb388e5$exports = {};
Object.defineProperty($8ea9421df10c86c62b0c73a27cb388e5$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/@nodelib/fs.walk/out/readers/sync.js
var $29654297e6ce62db4b86225e802e5e04$exports = {};
Object.defineProperty($29654297e6ce62db4b86225e802e5e04$exports, "__esModule", {
  value: true
});

class $29654297e6ce62db4b86225e802e5e04$var$SyncReader extends $5b27f4fd2bde3783d9e0055c4d6dff38$exports.default {
  constructor() {
    super(...arguments);
    this._scandir = $2f21d9a8cef1d90caf936325d9e2db4e$exports.scandirSync;
    this._storage = new Set();
    this._queue = new Set();
  }

  read() {
    this._pushToQueue(this._root, this._settings.basePath);

    this._handleQueue();

    return [...this._storage];
  }

  _pushToQueue(directory, base) {
    this._queue.add({
      directory,
      base
    });
  }

  _handleQueue() {
    for (const item of this._queue.values()) {
      this._handleDirectory(item.directory, item.base);
    }
  }

  _handleDirectory(directory, base) {
    try {
      const entries = this._scandir(directory, this._settings.fsScandirSettings);

      for (const entry of entries) {
        this._handleEntry(entry, base);
      }
    } catch (error) {
      this._handleError(error);
    }
  }

  _handleError(error) {
    if (!$a3fcac2816d380a5cbd4ce962104c687$exports.isFatalError(this._settings, error)) {
      return;
    }

    throw error;
  }

  _handleEntry(entry, base) {
    const fullpath = entry.path;

    if (base !== undefined) {
      entry.path = $a3fcac2816d380a5cbd4ce962104c687$exports.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
    }

    if ($a3fcac2816d380a5cbd4ce962104c687$exports.isAppliedFilter(this._settings.entryFilter, entry)) {
      this._pushToStorage(entry);
    }

    if (entry.dirent.isDirectory() && $a3fcac2816d380a5cbd4ce962104c687$exports.isAppliedFilter(this._settings.deepFilter, entry)) {
      this._pushToQueue(fullpath, entry.path);
    }
  }

  _pushToStorage(entry) {
    this._storage.add(entry);
  }

}

var $29654297e6ce62db4b86225e802e5e04$export$default = $29654297e6ce62db4b86225e802e5e04$var$SyncReader;
$29654297e6ce62db4b86225e802e5e04$exports.default = $29654297e6ce62db4b86225e802e5e04$export$default;

class $8ea9421df10c86c62b0c73a27cb388e5$var$SyncProvider {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new $29654297e6ce62db4b86225e802e5e04$exports.default(this._root, this._settings);
  }

  read() {
    return this._reader.read();
  }

}

var $8ea9421df10c86c62b0c73a27cb388e5$export$default = $8ea9421df10c86c62b0c73a27cb388e5$var$SyncProvider;
$8ea9421df10c86c62b0c73a27cb388e5$exports.default = $8ea9421df10c86c62b0c73a27cb388e5$export$default;
// ASSET: node_modules/@nodelib/fs.walk/out/settings.js
var $f9b74f95777f1cd4de02b5917e4c7bfb$exports = {};
Object.defineProperty($f9b74f95777f1cd4de02b5917e4c7bfb$exports, "__esModule", {
  value: true
});
const $f9b74f95777f1cd4de02b5917e4c7bfb$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();

class $f9b74f95777f1cd4de02b5917e4c7bfb$var$Settings {
  constructor(_options = {}) {
    this._options = _options;
    this.basePath = this._getValue(this._options.basePath, undefined);
    this.concurrency = this._getValue(this._options.concurrency, Infinity);
    this.deepFilter = this._getValue(this._options.deepFilter, null);
    this.entryFilter = this._getValue(this._options.entryFilter, null);
    this.errorFilter = this._getValue(this._options.errorFilter, null);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, $f9b74f95777f1cd4de02b5917e4c7bfb$var$path.sep);
    this.fsScandirSettings = new $2f21d9a8cef1d90caf936325d9e2db4e$exports.Settings({
      followSymbolicLinks: this._options.followSymbolicLinks,
      fs: this._options.fs,
      pathSegmentSeparator: this._options.pathSegmentSeparator,
      stats: this._options.stats,
      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
    });
  }

  _getValue(option, value) {
    return option === undefined ? value : option;
  }

}

var $f9b74f95777f1cd4de02b5917e4c7bfb$export$default = $f9b74f95777f1cd4de02b5917e4c7bfb$var$Settings;
$f9b74f95777f1cd4de02b5917e4c7bfb$exports.default = $f9b74f95777f1cd4de02b5917e4c7bfb$export$default;
var $aa82bc7f9592d7cc32e1bede0cc5f087$export$Settings = $f9b74f95777f1cd4de02b5917e4c7bfb$exports.default;
$aa82bc7f9592d7cc32e1bede0cc5f087$exports.Settings = $aa82bc7f9592d7cc32e1bede0cc5f087$export$Settings;

function $aa82bc7f9592d7cc32e1bede0cc5f087$var$walk(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === 'function') {
    return new $23acf26ef897acdbcfa49656420ae06a$exports.default(directory, $aa82bc7f9592d7cc32e1bede0cc5f087$var$getSettings()).read(optionsOrSettingsOrCallback);
  }

  new $23acf26ef897acdbcfa49656420ae06a$exports.default(directory, $aa82bc7f9592d7cc32e1bede0cc5f087$var$getSettings(optionsOrSettingsOrCallback)).read(callback);
}

var $aa82bc7f9592d7cc32e1bede0cc5f087$export$walk = $aa82bc7f9592d7cc32e1bede0cc5f087$var$walk;
$aa82bc7f9592d7cc32e1bede0cc5f087$exports.walk = $aa82bc7f9592d7cc32e1bede0cc5f087$export$walk;

function $aa82bc7f9592d7cc32e1bede0cc5f087$var$walkSync(directory, optionsOrSettings) {
  const settings = $aa82bc7f9592d7cc32e1bede0cc5f087$var$getSettings(optionsOrSettings);
  const provider = new $8ea9421df10c86c62b0c73a27cb388e5$exports.default(directory, settings);
  return provider.read();
}

var $aa82bc7f9592d7cc32e1bede0cc5f087$export$walkSync = $aa82bc7f9592d7cc32e1bede0cc5f087$var$walkSync;
$aa82bc7f9592d7cc32e1bede0cc5f087$exports.walkSync = $aa82bc7f9592d7cc32e1bede0cc5f087$export$walkSync;

function $aa82bc7f9592d7cc32e1bede0cc5f087$var$walkStream(directory, optionsOrSettings) {
  const settings = $aa82bc7f9592d7cc32e1bede0cc5f087$var$getSettings(optionsOrSettings);
  const provider = new $188806a3edf789708d9e5a30be444a42$exports.default(directory, settings);
  return provider.read();
}

var $aa82bc7f9592d7cc32e1bede0cc5f087$export$walkStream = $aa82bc7f9592d7cc32e1bede0cc5f087$var$walkStream;
$aa82bc7f9592d7cc32e1bede0cc5f087$exports.walkStream = $aa82bc7f9592d7cc32e1bede0cc5f087$export$walkStream;

function $aa82bc7f9592d7cc32e1bede0cc5f087$var$getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof $f9b74f95777f1cd4de02b5917e4c7bfb$exports.default) {
    return settingsOrOptions;
  }

  return new $f9b74f95777f1cd4de02b5917e4c7bfb$exports.default(settingsOrOptions);
}

// ASSET: node_modules/fast-glob/out/readers/reader.js
var $4d3ee53ca0ed5fa39e2de39a8eb49d40$exports = {};
Object.defineProperty($4d3ee53ca0ed5fa39e2de39a8eb49d40$exports, "__esModule", {
  value: true
});
const $4d3ee53ca0ed5fa39e2de39a8eb49d40$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();

class $4d3ee53ca0ed5fa39e2de39a8eb49d40$var$Reader {
  constructor(_settings) {
    this._settings = _settings;
    this._fsStatSettings = new $f190d447ca3d50622d6d44c24e2f7654$exports.Settings({
      followSymbolicLink: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
    });
  }

  _getFullEntryPath(filepath) {
    return $4d3ee53ca0ed5fa39e2de39a8eb49d40$var$path.resolve(this._settings.cwd, filepath);
  }

  _makeEntry(stats, pattern) {
    const entry = {
      name: pattern,
      path: pattern,
      dirent: $6bda9691bfa358c458d88d7e26adea34$exports.fs.createDirentFromStats(pattern, stats)
    };

    if (this._settings.stats) {
      entry.stats = stats;
    }

    return entry;
  }

  _isFatalError(error) {
    return !$6bda9691bfa358c458d88d7e26adea34$exports.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
  }

}

var $4d3ee53ca0ed5fa39e2de39a8eb49d40$export$default = $4d3ee53ca0ed5fa39e2de39a8eb49d40$var$Reader;
$4d3ee53ca0ed5fa39e2de39a8eb49d40$exports.default = $4d3ee53ca0ed5fa39e2de39a8eb49d40$export$default;

class $8ecc1965905bd95a37821c967f47854c$var$ReaderStream extends $4d3ee53ca0ed5fa39e2de39a8eb49d40$exports.default {
  constructor() {
    super(...arguments);
    this._walkStream = $aa82bc7f9592d7cc32e1bede0cc5f087$exports.walkStream;
    this._stat = $f190d447ca3d50622d6d44c24e2f7654$exports.stat;
  }

  dynamic(root, options) {
    return this._walkStream(root, options);
  }

  static(patterns, options) {
    const filepaths = patterns.map(this._getFullEntryPath, this);
    const stream = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough({
      objectMode: true
    });

    stream._write = (index, _enc, done) => {
      return this._getEntry(filepaths[index], patterns[index], options).then(entry => {
        if (entry !== null && options.entryFilter(entry)) {
          stream.push(entry);
        }

        if (index === filepaths.length - 1) {
          stream.end();
        }

        done();
      }).catch(done);
    };

    for (let i = 0; i < filepaths.length; i++) {
      stream.write(i);
    }

    return stream;
  }

  _getEntry(filepath, pattern, options) {
    return this._getStat(filepath).then(stats => this._makeEntry(stats, pattern)).catch(error => {
      if (options.errorFilter(error)) {
        return null;
      }

      throw error;
    });
  }

  _getStat(filepath) {
    return new Promise((resolve, reject) => {
      this._stat(filepath, this._fsStatSettings, (error, stats) => {
        return error === null ? resolve(stats) : reject(error);
      });
    });
  }

}

var $8ecc1965905bd95a37821c967f47854c$export$default = $8ecc1965905bd95a37821c967f47854c$var$ReaderStream;
$8ecc1965905bd95a37821c967f47854c$exports.default = $8ecc1965905bd95a37821c967f47854c$export$default;
// ASSET: node_modules/fast-glob/out/providers/provider.js
var $0040988f9a2398218ab373d2f6767695$exports = {};
Object.defineProperty($0040988f9a2398218ab373d2f6767695$exports, "__esModule", {
  value: true
});
const $0040988f9a2398218ab373d2f6767695$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/fast-glob/out/providers/filters/deep.js
var $cc1ec7969b111d77b9d40c4e03a99159$exports = {};
Object.defineProperty($cc1ec7969b111d77b9d40c4e03a99159$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/fast-glob/out/providers/matchers/partial.js
var $a4c343ee4251fbb07b43a2aacecef002$exports = {};
Object.defineProperty($a4c343ee4251fbb07b43a2aacecef002$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/fast-glob/out/providers/matchers/matcher.js
var $04e82c5f7330f1c0b0e712b329759153$exports = {};
Object.defineProperty($04e82c5f7330f1c0b0e712b329759153$exports, "__esModule", {
  value: true
});

class $04e82c5f7330f1c0b0e712b329759153$var$Matcher {
  constructor(_patterns, _settings, _micromatchOptions) {
    this._patterns = _patterns;
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this._storage = [];

    this._fillStorage();
  }

  _fillStorage() {
    /**
     * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
     * So, before expand patterns with brace expansion into separated patterns.
     */
    const patterns = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.expandPatternsWithBraceExpansion(this._patterns);

    for (const pattern of patterns) {
      const segments = this._getPatternSegments(pattern);

      const sections = this._splitSegmentsIntoSections(segments);

      this._storage.push({
        complete: sections.length <= 1,
        pattern,
        segments,
        sections
      });
    }
  }

  _getPatternSegments(pattern) {
    const parts = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.getPatternParts(pattern, this._micromatchOptions);
    return parts.map(part => {
      const dynamic = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.isDynamicPattern(part, this._settings);

      if (!dynamic) {
        return {
          dynamic: false,
          pattern: part
        };
      }

      return {
        dynamic: true,
        pattern: part,
        patternRe: $6bda9691bfa358c458d88d7e26adea34$exports.pattern.makeRe(part, this._micromatchOptions)
      };
    });
  }

  _splitSegmentsIntoSections(segments) {
    return $6bda9691bfa358c458d88d7e26adea34$exports.array.splitWhen(segments, segment => segment.dynamic && $6bda9691bfa358c458d88d7e26adea34$exports.pattern.hasGlobStar(segment.pattern));
  }

}

var $04e82c5f7330f1c0b0e712b329759153$export$default = $04e82c5f7330f1c0b0e712b329759153$var$Matcher;
$04e82c5f7330f1c0b0e712b329759153$exports.default = $04e82c5f7330f1c0b0e712b329759153$export$default;

class $a4c343ee4251fbb07b43a2aacecef002$var$PartialMatcher extends $04e82c5f7330f1c0b0e712b329759153$exports.default {
  match(filepath) {
    const parts = filepath.split('/');
    const levels = parts.length;

    const patterns = this._storage.filter(info => !info.complete || info.segments.length > levels);

    for (const pattern of patterns) {
      const section = pattern.sections[0];
      /**
       * In this case, the pattern has a globstar and we must read all directories unconditionally,
       * but only if the level has reached the end of the first group.
       *
       * fixtures/{a,b}/**
       *  ^ true/false  ^ always true
      */

      /**
       * In this case, the pattern has a globstar and we must read all directories unconditionally,
       * but only if the level has reached the end of the first group.
       *
       * fixtures/{a,b}/**
       *  ^ true/false  ^ always true
      */
      if (!pattern.complete && levels > section.length) {
        return true;
      }

      const match = parts.every((part, index) => {
        const segment = pattern.segments[index];

        if (segment.dynamic && segment.patternRe.test(part)) {
          return true;
        }

        if (!segment.dynamic && segment.pattern === part) {
          return true;
        }

        return false;
      });

      if (match) {
        return true;
      }
    }

    return false;
  }

}

var $a4c343ee4251fbb07b43a2aacecef002$export$default = $a4c343ee4251fbb07b43a2aacecef002$var$PartialMatcher;
$a4c343ee4251fbb07b43a2aacecef002$exports.default = $a4c343ee4251fbb07b43a2aacecef002$export$default;

class $cc1ec7969b111d77b9d40c4e03a99159$var$DeepFilter {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
  }

  getFilter(basePath, positive, negative) {
    const matcher = this._getMatcher(positive);

    const negativeRe = this._getNegativePatternsRe(negative);

    return entry => this._filter(basePath, entry, matcher, negativeRe);
  }

  _getMatcher(patterns) {
    return new $a4c343ee4251fbb07b43a2aacecef002$exports.default(patterns, this._settings, this._micromatchOptions);
  }

  _getNegativePatternsRe(patterns) {
    const affectDepthOfReadingPatterns = patterns.filter($6bda9691bfa358c458d88d7e26adea34$exports.pattern.isAffectDepthOfReadingPattern);
    return $6bda9691bfa358c458d88d7e26adea34$exports.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
  }

  _filter(basePath, entry, matcher, negativeRe) {
    if (this._isSkippedByDeep(basePath, entry.path)) {
      return false;
    }

    if (this._isSkippedSymbolicLink(entry)) {
      return false;
    }

    const filepath = $6bda9691bfa358c458d88d7e26adea34$exports.path.removeLeadingDotSegment(entry.path);

    if (this._isSkippedByPositivePatterns(filepath, matcher)) {
      return false;
    }

    return this._isSkippedByNegativePatterns(filepath, negativeRe);
  }

  _isSkippedByDeep(basePath, entryPath) {
    /**
     * Avoid unnecessary depth calculations when it doesn't matter.
     */
    if (this._settings.deep === Infinity) {
      return false;
    }

    return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
  }

  _getEntryLevel(basePath, entryPath) {
    const entryPathDepth = entryPath.split('/').length;

    if (basePath === '') {
      return entryPathDepth;
    }

    const basePathDepth = basePath.split('/').length;
    return entryPathDepth - basePathDepth;
  }

  _isSkippedSymbolicLink(entry) {
    return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
  }

  _isSkippedByPositivePatterns(entryPath, matcher) {
    return !this._settings.baseNameMatch && !matcher.match(entryPath);
  }

  _isSkippedByNegativePatterns(entryPath, patternsRe) {
    return !$6bda9691bfa358c458d88d7e26adea34$exports.pattern.matchAny(entryPath, patternsRe);
  }

}

var $cc1ec7969b111d77b9d40c4e03a99159$export$default = $cc1ec7969b111d77b9d40c4e03a99159$var$DeepFilter;
$cc1ec7969b111d77b9d40c4e03a99159$exports.default = $cc1ec7969b111d77b9d40c4e03a99159$export$default;
// ASSET: node_modules/fast-glob/out/providers/filters/entry.js
var $e0388eee6acd7d094fd0fccdbac3d16e$exports = {};
Object.defineProperty($e0388eee6acd7d094fd0fccdbac3d16e$exports, "__esModule", {
  value: true
});

class $e0388eee6acd7d094fd0fccdbac3d16e$var$EntryFilter {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this.index = new Map();
  }

  getFilter(positive, negative) {
    const positiveRe = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.convertPatternsToRe(positive, this._micromatchOptions);
    const negativeRe = $6bda9691bfa358c458d88d7e26adea34$exports.pattern.convertPatternsToRe(negative, this._micromatchOptions);
    return entry => this._filter(entry, positiveRe, negativeRe);
  }

  _filter(entry, positiveRe, negativeRe) {
    if (this._settings.unique && this._isDuplicateEntry(entry)) {
      return false;
    }

    if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
      return false;
    }

    if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
      return false;
    }

    const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
    const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);

    if (this._settings.unique && isMatched) {
      this._createIndexRecord(entry);
    }

    return isMatched;
  }

  _isDuplicateEntry(entry) {
    return this.index.has(entry.path);
  }

  _createIndexRecord(entry) {
    this.index.set(entry.path, undefined);
  }

  _onlyFileFilter(entry) {
    return this._settings.onlyFiles && !entry.dirent.isFile();
  }

  _onlyDirectoryFilter(entry) {
    return this._settings.onlyDirectories && !entry.dirent.isDirectory();
  }

  _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
    if (!this._settings.absolute) {
      return false;
    }

    const fullpath = $6bda9691bfa358c458d88d7e26adea34$exports.path.makeAbsolute(this._settings.cwd, entryPath);
    return $6bda9691bfa358c458d88d7e26adea34$exports.pattern.matchAny(fullpath, patternsRe);
  }

  _isMatchToPatterns(entryPath, patternsRe) {
    const filepath = $6bda9691bfa358c458d88d7e26adea34$exports.path.removeLeadingDotSegment(entryPath);
    return $6bda9691bfa358c458d88d7e26adea34$exports.pattern.matchAny(filepath, patternsRe);
  }

}

var $e0388eee6acd7d094fd0fccdbac3d16e$export$default = $e0388eee6acd7d094fd0fccdbac3d16e$var$EntryFilter;
$e0388eee6acd7d094fd0fccdbac3d16e$exports.default = $e0388eee6acd7d094fd0fccdbac3d16e$export$default;
// ASSET: node_modules/fast-glob/out/providers/filters/error.js
var $49a274fddbc4ac6c6a8b77800cc26805$exports = {};
Object.defineProperty($49a274fddbc4ac6c6a8b77800cc26805$exports, "__esModule", {
  value: true
});

class $49a274fddbc4ac6c6a8b77800cc26805$var$ErrorFilter {
  constructor(_settings) {
    this._settings = _settings;
  }

  getFilter() {
    return error => this._isNonFatalError(error);
  }

  _isNonFatalError(error) {
    return $6bda9691bfa358c458d88d7e26adea34$exports.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
  }

}

var $49a274fddbc4ac6c6a8b77800cc26805$export$default = $49a274fddbc4ac6c6a8b77800cc26805$var$ErrorFilter;
$49a274fddbc4ac6c6a8b77800cc26805$exports.default = $49a274fddbc4ac6c6a8b77800cc26805$export$default;
// ASSET: node_modules/fast-glob/out/providers/transformers/entry.js
var $017117d1e53c1b3f682938fad71c90fc$exports = {};
Object.defineProperty($017117d1e53c1b3f682938fad71c90fc$exports, "__esModule", {
  value: true
});

class $017117d1e53c1b3f682938fad71c90fc$var$EntryTransformer {
  constructor(_settings) {
    this._settings = _settings;
  }

  getTransformer() {
    return entry => this._transform(entry);
  }

  _transform(entry) {
    let filepath = entry.path;

    if (this._settings.absolute) {
      filepath = $6bda9691bfa358c458d88d7e26adea34$exports.path.makeAbsolute(this._settings.cwd, filepath);
      filepath = $6bda9691bfa358c458d88d7e26adea34$exports.path.unixify(filepath);
    }

    if (this._settings.markDirectories && entry.dirent.isDirectory()) {
      filepath += '/';
    }

    if (!this._settings.objectMode) {
      return filepath;
    }

    return Object.assign(Object.assign({}, entry), {
      path: filepath
    });
  }

}

var $017117d1e53c1b3f682938fad71c90fc$export$default = $017117d1e53c1b3f682938fad71c90fc$var$EntryTransformer;
$017117d1e53c1b3f682938fad71c90fc$exports.default = $017117d1e53c1b3f682938fad71c90fc$export$default;

class $0040988f9a2398218ab373d2f6767695$var$Provider {
  constructor(_settings) {
    this._settings = _settings;
    this.errorFilter = new $49a274fddbc4ac6c6a8b77800cc26805$exports.default(this._settings);
    this.entryFilter = new $e0388eee6acd7d094fd0fccdbac3d16e$exports.default(this._settings, this._getMicromatchOptions());
    this.deepFilter = new $cc1ec7969b111d77b9d40c4e03a99159$exports.default(this._settings, this._getMicromatchOptions());
    this.entryTransformer = new $017117d1e53c1b3f682938fad71c90fc$exports.default(this._settings);
  }

  _getRootDirectory(task) {
    return $0040988f9a2398218ab373d2f6767695$var$path.resolve(this._settings.cwd, task.base);
  }

  _getReaderOptions(task) {
    const basePath = task.base === '.' ? '' : task.base;
    return {
      basePath,
      pathSegmentSeparator: '/',
      concurrency: this._settings.concurrency,
      deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
      entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
      errorFilter: this.errorFilter.getFilter(),
      followSymbolicLinks: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      stats: this._settings.stats,
      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
      transform: this.entryTransformer.getTransformer()
    };
  }

  _getMicromatchOptions() {
    return {
      dot: this._settings.dot,
      matchBase: this._settings.baseNameMatch,
      nobrace: !this._settings.braceExpansion,
      nocase: !this._settings.caseSensitiveMatch,
      noext: !this._settings.extglob,
      noglobstar: !this._settings.globstar,
      posix: true,
      strictSlashes: false
    };
  }

}

var $0040988f9a2398218ab373d2f6767695$export$default = $0040988f9a2398218ab373d2f6767695$var$Provider;
$0040988f9a2398218ab373d2f6767695$exports.default = $0040988f9a2398218ab373d2f6767695$export$default;

class $0ea17b8dac5d932ee9b5a8756d3c8826$var$ProviderAsync extends $0040988f9a2398218ab373d2f6767695$exports.default {
  constructor() {
    super(...arguments);
    this._reader = new $8ecc1965905bd95a37821c967f47854c$exports.default(this._settings);
  }

  read(task) {
    const root = this._getRootDirectory(task);

    const options = this._getReaderOptions(task);

    const entries = [];
    return new Promise((resolve, reject) => {
      const stream = this.api(root, task, options);
      stream.once('error', reject);
      stream.on('data', entry => entries.push(options.transform(entry)));
      stream.once('end', () => resolve(entries));
    });
  }

  api(root, task, options) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options);
    }

    return this._reader.static(task.patterns, options);
  }

}

var $0ea17b8dac5d932ee9b5a8756d3c8826$export$default = $0ea17b8dac5d932ee9b5a8756d3c8826$var$ProviderAsync;
$0ea17b8dac5d932ee9b5a8756d3c8826$exports.default = $0ea17b8dac5d932ee9b5a8756d3c8826$export$default;
// ASSET: node_modules/fast-glob/out/providers/stream.js
var $00443d627b5c20b405e379f96442fea7$exports = {};
Object.defineProperty($00443d627b5c20b405e379f96442fea7$exports, "__esModule", {
  value: true
});

class $00443d627b5c20b405e379f96442fea7$var$ProviderStream extends $0040988f9a2398218ab373d2f6767695$exports.default {
  constructor() {
    super(...arguments);
    this._reader = new $8ecc1965905bd95a37821c967f47854c$exports.default(this._settings);
  }

  read(task) {
    const root = this._getRootDirectory(task);

    const options = this._getReaderOptions(task);

    const source = this.api(root, task, options);
    const destination = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable({
      objectMode: true,
      read: () => {}
    });
    source.once('error', error => destination.emit('error', error)).on('data', entry => destination.emit('data', options.transform(entry))).once('end', () => destination.emit('end'));
    destination.once('close', () => source.destroy());
    return destination;
  }

  api(root, task, options) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options);
    }

    return this._reader.static(task.patterns, options);
  }

}

var $00443d627b5c20b405e379f96442fea7$export$default = $00443d627b5c20b405e379f96442fea7$var$ProviderStream;
$00443d627b5c20b405e379f96442fea7$exports.default = $00443d627b5c20b405e379f96442fea7$export$default;
// ASSET: node_modules/fast-glob/out/providers/sync.js
var $054844509c8799cf5bc121219a8e4e03$exports = {};
Object.defineProperty($054844509c8799cf5bc121219a8e4e03$exports, "__esModule", {
  value: true
});
// ASSET: node_modules/fast-glob/out/readers/sync.js
var $501c40e0d8d076784f71560ca82c338b$exports = {};
Object.defineProperty($501c40e0d8d076784f71560ca82c338b$exports, "__esModule", {
  value: true
});

class $501c40e0d8d076784f71560ca82c338b$var$ReaderSync extends $4d3ee53ca0ed5fa39e2de39a8eb49d40$exports.default {
  constructor() {
    super(...arguments);
    this._walkSync = $aa82bc7f9592d7cc32e1bede0cc5f087$exports.walkSync;
    this._statSync = $f190d447ca3d50622d6d44c24e2f7654$exports.statSync;
  }

  dynamic(root, options) {
    return this._walkSync(root, options);
  }

  static(patterns, options) {
    const entries = [];

    for (const pattern of patterns) {
      const filepath = this._getFullEntryPath(pattern);

      const entry = this._getEntry(filepath, pattern, options);

      if (entry === null || !options.entryFilter(entry)) {
        continue;
      }

      entries.push(entry);
    }

    return entries;
  }

  _getEntry(filepath, pattern, options) {
    try {
      const stats = this._getStat(filepath);

      return this._makeEntry(stats, pattern);
    } catch (error) {
      if (options.errorFilter(error)) {
        return null;
      }

      throw error;
    }
  }

  _getStat(filepath) {
    return this._statSync(filepath, this._fsStatSettings);
  }

}

var $501c40e0d8d076784f71560ca82c338b$export$default = $501c40e0d8d076784f71560ca82c338b$var$ReaderSync;
$501c40e0d8d076784f71560ca82c338b$exports.default = $501c40e0d8d076784f71560ca82c338b$export$default;

class $054844509c8799cf5bc121219a8e4e03$var$ProviderSync extends $0040988f9a2398218ab373d2f6767695$exports.default {
  constructor() {
    super(...arguments);
    this._reader = new $501c40e0d8d076784f71560ca82c338b$exports.default(this._settings);
  }

  read(task) {
    const root = this._getRootDirectory(task);

    const options = this._getReaderOptions(task);

    const entries = this.api(root, task, options);
    return entries.map(options.transform);
  }

  api(root, task, options) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options);
    }

    return this._reader.static(task.patterns, options);
  }

}

var $054844509c8799cf5bc121219a8e4e03$export$default = $054844509c8799cf5bc121219a8e4e03$var$ProviderSync;
$054844509c8799cf5bc121219a8e4e03$exports.default = $054844509c8799cf5bc121219a8e4e03$export$default;
// ASSET: node_modules/fast-glob/out/settings.js
var $20cc78f18a27929a62bf44a243ca9c9e$exports = {};
var $20cc78f18a27929a62bf44a243ca9c9e$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($20cc78f18a27929a62bf44a243ca9c9e$exports, "__esModule", {
  value: true
});
var $20cc78f18a27929a62bf44a243ca9c9e$export$DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
$20cc78f18a27929a62bf44a243ca9c9e$exports.DEFAULT_FILE_SYSTEM_ADAPTER = $20cc78f18a27929a62bf44a243ca9c9e$export$DEFAULT_FILE_SYSTEM_ADAPTER;
const $20cc78f18a27929a62bf44a243ca9c9e$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
const $20cc78f18a27929a62bf44a243ca9c9e$var$CPU_COUNT = $0bbf89852e2ec8b574a90d9f54bf96d7$export$cpus().length;
$20cc78f18a27929a62bf44a243ca9c9e$export$DEFAULT_FILE_SYSTEM_ADAPTER = {
  lstat: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.lstat,
  lstatSync: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.lstatSync,
  stat: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.stat,
  statSync: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.statSync,
  readdir: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.readdir,
  readdirSync: $20cc78f18a27929a62bf44a243ca9c9e$var$fs.readdirSync
};
$20cc78f18a27929a62bf44a243ca9c9e$exports.DEFAULT_FILE_SYSTEM_ADAPTER = $20cc78f18a27929a62bf44a243ca9c9e$export$DEFAULT_FILE_SYSTEM_ADAPTER;

class $20cc78f18a27929a62bf44a243ca9c9e$var$Settings {
  constructor(_options = {}) {
    this._options = _options;
    this.absolute = this._getValue(this._options.absolute, false);
    this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
    this.braceExpansion = this._getValue(this._options.braceExpansion, true);
    this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
    this.concurrency = this._getValue(this._options.concurrency, $20cc78f18a27929a62bf44a243ca9c9e$var$CPU_COUNT);
    this.cwd = this._getValue(this._options.cwd, $20cc78f18a27929a62bf44a243ca9c9e$var$process.cwd());
    this.deep = this._getValue(this._options.deep, Infinity);
    this.dot = this._getValue(this._options.dot, false);
    this.extglob = this._getValue(this._options.extglob, true);
    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
    this.fs = this._getFileSystemMethods(this._options.fs);
    this.globstar = this._getValue(this._options.globstar, true);
    this.ignore = this._getValue(this._options.ignore, []);
    this.markDirectories = this._getValue(this._options.markDirectories, false);
    this.objectMode = this._getValue(this._options.objectMode, false);
    this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
    this.onlyFiles = this._getValue(this._options.onlyFiles, true);
    this.stats = this._getValue(this._options.stats, false);
    this.suppressErrors = this._getValue(this._options.suppressErrors, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
    this.unique = this._getValue(this._options.unique, true);

    if (this.onlyDirectories) {
      this.onlyFiles = false;
    }

    if (this.stats) {
      this.objectMode = true;
    }
  }

  _getValue(option, value) {
    return option === undefined ? value : option;
  }

  _getFileSystemMethods(methods = {}) {
    return Object.assign(Object.assign({}, $20cc78f18a27929a62bf44a243ca9c9e$exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
  }

}

var $20cc78f18a27929a62bf44a243ca9c9e$export$default = $20cc78f18a27929a62bf44a243ca9c9e$var$Settings;
$20cc78f18a27929a62bf44a243ca9c9e$exports.default = $20cc78f18a27929a62bf44a243ca9c9e$export$default;

async function $61dab73f6a7235989c6f2f871d1403c3$var$FastGlob(source, options) {
  $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
  const works = $61dab73f6a7235989c6f2f871d1403c3$var$getWorks(source, $0ea17b8dac5d932ee9b5a8756d3c8826$exports.default, options);
  const result = await Promise.all(works);
  return $6bda9691bfa358c458d88d7e26adea34$exports.array.flatten(result);
} // https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare


// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
  function sync(source, options) {
    $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
    const works = $61dab73f6a7235989c6f2f871d1403c3$var$getWorks(source, $054844509c8799cf5bc121219a8e4e03$exports.default, options);
    return $6bda9691bfa358c458d88d7e26adea34$exports.array.flatten(works);
  }

  FastGlob.sync = sync;

  function stream(source, options) {
    $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
    const works = $61dab73f6a7235989c6f2f871d1403c3$var$getWorks(source, $00443d627b5c20b405e379f96442fea7$exports.default, options);
    /**
     * The stream returned by the provider cannot work with an asynchronous iterator.
     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
     * This affects performance (+25%). I don't see best solution right now.
     */

    /**
     * The stream returned by the provider cannot work with an asynchronous iterator.
     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
     * This affects performance (+25%). I don't see best solution right now.
     */
    return $6bda9691bfa358c458d88d7e26adea34$exports.stream.merge(works);
  }

  FastGlob.stream = stream;

  function generateTasks(source, options) {
    $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
    const patterns = [].concat(source);
    const settings = new $20cc78f18a27929a62bf44a243ca9c9e$exports.default(options);
    return $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.generate(patterns, settings);
  }

  FastGlob.generateTasks = generateTasks;

  function isDynamicPattern(source, options) {
    $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
    const settings = new $20cc78f18a27929a62bf44a243ca9c9e$exports.default(options);
    return $6bda9691bfa358c458d88d7e26adea34$exports.pattern.isDynamicPattern(source, settings);
  }

  FastGlob.isDynamicPattern = isDynamicPattern;

  function escapePath(source) {
    $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(source);
    return $6bda9691bfa358c458d88d7e26adea34$exports.path.escape(source);
  }

  FastGlob.escapePath = escapePath;
})($61dab73f6a7235989c6f2f871d1403c3$var$FastGlob || ($61dab73f6a7235989c6f2f871d1403c3$var$FastGlob = {}));

function $61dab73f6a7235989c6f2f871d1403c3$var$getWorks(source, _Provider, options) {
  const patterns = [].concat(source);
  const settings = new $20cc78f18a27929a62bf44a243ca9c9e$exports.default(options);
  const tasks = $8e74aa6f5c2e1dabadcc8fa176ea0322$exports.generate(patterns, settings);
  const provider = new _Provider(settings);
  return tasks.map(provider.read, provider);
}

function $61dab73f6a7235989c6f2f871d1403c3$var$assertPatternsInput(input) {
  const source = [].concat(input);
  const isValidSource = source.every(item => $6bda9691bfa358c458d88d7e26adea34$exports.string.isString(item) && !$6bda9691bfa358c458d88d7e26adea34$exports.string.isEmpty(item));

  if (!isValidSource) {
    throw new TypeError('Patterns must be a string (non empty) or an array of strings');
  }
}

$61dab73f6a7235989c6f2f871d1403c3$exports = $61dab73f6a7235989c6f2f871d1403c3$var$FastGlob;
// ASSET: node_modules/dir-glob/index.js
var $931d520e30117cc4ce79d0d22a9cbc83$exports = {};
var $931d520e30117cc4ce79d0d22a9cbc83$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $931d520e30117cc4ce79d0d22a9cbc83$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const {
  promisify: $e201398dd0a2fca7b4d23678a92fcd1b$var$promisify
} = $69678d3e0618202337016e1b4ed76965$init();
const $e201398dd0a2fca7b4d23678a92fcd1b$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();

async function $e201398dd0a2fca7b4d23678a92fcd1b$var$isType(fsStatType, statsMethodName, filePath) {
  if (typeof filePath !== 'string') {
    throw new TypeError(`Expected a string, got ${typeof filePath}`);
  }

  try {
    const stats = await $e201398dd0a2fca7b4d23678a92fcd1b$var$promisify($e201398dd0a2fca7b4d23678a92fcd1b$var$fs[fsStatType])(filePath);
    return stats[statsMethodName]();
  } catch (error) {
    if (error.code === 'ENOENT') {
      return false;
    }

    throw error;
  }
}

function $e201398dd0a2fca7b4d23678a92fcd1b$var$isTypeSync(fsStatType, statsMethodName, filePath) {
  if (typeof filePath !== 'string') {
    throw new TypeError(`Expected a string, got ${typeof filePath}`);
  }

  try {
    return $e201398dd0a2fca7b4d23678a92fcd1b$var$fs[fsStatType](filePath)[statsMethodName]();
  } catch (error) {
    if (error.code === 'ENOENT') {
      return false;
    }

    throw error;
  }
}

var $e201398dd0a2fca7b4d23678a92fcd1b$export$isFile = $e201398dd0a2fca7b4d23678a92fcd1b$var$isType.bind(null, 'stat', 'isFile');
var $e201398dd0a2fca7b4d23678a92fcd1b$export$isDirectory = $e201398dd0a2fca7b4d23678a92fcd1b$var$isType.bind(null, 'stat', 'isDirectory');
var $e201398dd0a2fca7b4d23678a92fcd1b$export$isSymlink = $e201398dd0a2fca7b4d23678a92fcd1b$var$isType.bind(null, 'lstat', 'isSymbolicLink');
var $e201398dd0a2fca7b4d23678a92fcd1b$export$isFileSync = $e201398dd0a2fca7b4d23678a92fcd1b$var$isTypeSync.bind(null, 'statSync', 'isFile');
var $e201398dd0a2fca7b4d23678a92fcd1b$export$isDirectorySync = $e201398dd0a2fca7b4d23678a92fcd1b$var$isTypeSync.bind(null, 'statSync', 'isDirectory');
var $e201398dd0a2fca7b4d23678a92fcd1b$export$isSymlinkSync = $e201398dd0a2fca7b4d23678a92fcd1b$var$isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');

const $931d520e30117cc4ce79d0d22a9cbc83$var$getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];

const $931d520e30117cc4ce79d0d22a9cbc83$var$getPath = (filepath, cwd) => {
  const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
  return $931d520e30117cc4ce79d0d22a9cbc83$var$path.isAbsolute(pth) ? pth : $931d520e30117cc4ce79d0d22a9cbc83$var$path.join(cwd, pth);
};

const $931d520e30117cc4ce79d0d22a9cbc83$var$addExtensions = (file, extensions) => {
  if ($931d520e30117cc4ce79d0d22a9cbc83$var$path.extname(file)) {
    return `**/${file}`;
  }

  return `**/${file}.${$931d520e30117cc4ce79d0d22a9cbc83$var$getExtensions(extensions)}`;
};

const $931d520e30117cc4ce79d0d22a9cbc83$var$getGlob = (directory, options) => {
  if (options.files && !Array.isArray(options.files)) {
    throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
  }

  if (options.extensions && !Array.isArray(options.extensions)) {
    throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
  }

  if (options.files && options.extensions) {
    return options.files.map(x => $931d520e30117cc4ce79d0d22a9cbc83$var$path.posix.join(directory, $931d520e30117cc4ce79d0d22a9cbc83$var$addExtensions(x, options.extensions)));
  }

  if (options.files) {
    return options.files.map(x => $931d520e30117cc4ce79d0d22a9cbc83$var$path.posix.join(directory, `**/${x}`));
  }

  if (options.extensions) {
    return [$931d520e30117cc4ce79d0d22a9cbc83$var$path.posix.join(directory, `**/*.${$931d520e30117cc4ce79d0d22a9cbc83$var$getExtensions(options.extensions)}`)];
  }

  return [$931d520e30117cc4ce79d0d22a9cbc83$var$path.posix.join(directory, '**')];
};

$931d520e30117cc4ce79d0d22a9cbc83$exports = async (input, options) => {
  options = {
    cwd: $931d520e30117cc4ce79d0d22a9cbc83$var$process.cwd(),
    ...options
  };

  if (typeof options.cwd !== 'string') {
    throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
  }

  const globs = await Promise.all([].concat(input).map(async x => {
    const isDirectory = await $e201398dd0a2fca7b4d23678a92fcd1b$export$isDirectory($931d520e30117cc4ce79d0d22a9cbc83$var$getPath(x, options.cwd));
    return isDirectory ? $931d520e30117cc4ce79d0d22a9cbc83$var$getGlob(x, options) : x;
  }));
  return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};

var $931d520e30117cc4ce79d0d22a9cbc83$export$sync = (input, options) => {
  options = {
    cwd: $931d520e30117cc4ce79d0d22a9cbc83$var$process.cwd(),
    ...options
  };

  if (typeof options.cwd !== 'string') {
    throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
  }

  const globs = [].concat(input).map(x => $e201398dd0a2fca7b4d23678a92fcd1b$export$isDirectorySync($931d520e30117cc4ce79d0d22a9cbc83$var$getPath(x, options.cwd)) ? $931d520e30117cc4ce79d0d22a9cbc83$var$getGlob(x, options) : x);
  return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};

$931d520e30117cc4ce79d0d22a9cbc83$exports.sync = $931d520e30117cc4ce79d0d22a9cbc83$export$sync;
// ASSET: node_modules/globby/gitignore.js
var $f6cbe116cb0084037518012b0fa09ede$exports = {};
var $f6cbe116cb0084037518012b0fa09ede$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const {
  promisify: $f6cbe116cb0084037518012b0fa09ede$var$promisify
} = $69678d3e0618202337016e1b4ed76965$init();
const $f6cbe116cb0084037518012b0fa09ede$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
const $f6cbe116cb0084037518012b0fa09ede$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/ignore/index.js
var $1de314a37ff0e4c89ae2b852cc7dfdc1$exports = {};
var $1de314a37ff0e4c89ae2b852cc7dfdc1$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

// A simple implementation of make-array
function $1de314a37ff0e4c89ae2b852cc7dfdc1$var$makeArray(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$EMPTY = '';
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$SPACE = ' ';
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$ESCAPE = '\\';
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_TEST_BLANK_LINE = /^\s+$/;
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_SPLITALL_CRLF = /\r?\n/g; // /foo,
// ./foo,
// ../foo,
// .
// ..

// /foo,
// ./foo,
// ../foo,
// .
// ..
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$SLASH = '/';
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
/* istanbul ignore next */
:
/* istanbul ignore next */
'node-ignore';

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$define = (object, key, value) => Object.defineProperty(object, key, {
  value
});

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g; // Sanitize the range of a regular expression
// The cases are complicated, see test cases for details

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$sanitizeRange = range => range.replace($1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but
//   fatal for JavaScript regular expression, so eliminate it.
: // Invalid range (out of order) which is ok for gitignore rules but
//   fatal for JavaScript regular expression, so eliminate it.
$1de314a37ff0e4c89ae2b852cc7dfdc1$var$EMPTY); // See fixtures #59


// See fixtures #59
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$cleanRangeBackSlash = slashes => {
  const {
    length
  } = slashes;
  return slashes.slice(0, length - length % 2);
}; // > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'


// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash ("\")
[// (a\ ) -> (a )
// (a  ) -> (a)
// (a \ ) -> (a  )
/\\?\s+$/, match => match.indexOf('\\') === 0 ? $1de314a37ff0e4c89ae2b852cc7dfdc1$var$SPACE : $1de314a37ff0e4c89ae2b852cc7dfdc1$var$EMPTY], // replace (\ ) with ' '
[/\\\s/g, () => $1de314a37ff0e4c89ae2b852cc7dfdc1$var$SPACE], // Escape metacharacters
// which is written down by users but means special for regular expressions.
// > There are 12 characters with special meanings:
// > - the backslash \,
// > - the caret ^,
// > - the dollar sign $,
// > - the period or dot .,
// > - the vertical bar or pipe symbol |,
// > - the question mark ?,
// > - the asterisk or star *,
// > - the plus sign +,
// > - the opening parenthesis (,
// > - the closing parenthesis ),
// > - and the opening square bracket [,
// > - the opening curly brace {,
// > These special characters are often called "metacharacters".
[/[\\$.|*+(){^]/g, match => `\\${match}`], [// > a question mark (?) matches a single character
/(?!\\)\?/g, () => '[^/]'], // leading slash
[// > A leading slash matches the beginning of the pathname.
// > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
// A leading slash matches the beginning of the pathname
/^\//, () => '^'], // replace special metacharacter slash after the leading slash
[/\//g, () => '\\/'], [// > A leading "**" followed by a slash means match in all directories.
// > For example, "**/foo" matches file or directory "foo" anywhere,
// > the same as pattern "foo".
// > "**/foo/bar" matches file or directory "bar" anywhere that is directly
// >   under directory "foo".
// Notice that the '*'s have been replaced as '\\*'
/^\^*\\\*\\\*\\\//, // '**/foo' <-> 'foo'
() => '^(?:.*\\/)?'], // starting
[// there will be no leading '/'
//   (which has been replaced by section "leading slash")
// If starts with '**', adding a '^' to the regular expression also works
/^(?=[^^])/, function startingReplacer() {
  // If has a slash `/` at the beginning or middle
  return !/\/(?!$)/.test(this) // > Prior to 2.22.1
  // > If the pattern does not contain a slash /,
  // >   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern
  // After 2.22.1 (compatible but clearer)
  // > If there is a separator at the beginning or middle (or both)
  // > of the pattern, then the pattern is relative to the directory
  // > level of the particular .gitignore file itself.
  // > Otherwise the pattern may also match at any level below
  // > the .gitignore level.
  ? // > Prior to 2.22.1
  // > If the pattern does not contain a slash /,
  // >   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern
  // After 2.22.1 (compatible but clearer)
  // > If there is a separator at the beginning or middle (or both)
  // > of the pattern, then the pattern is relative to the directory
  // > level of the particular .gitignore file itself.
  // > Otherwise the pattern may also match at any level below
  // > the .gitignore level.
  '(?:^|\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for
  // >   consumption by fnmatch(3)
  : // > Otherwise, Git treats the pattern as a shell glob suitable for
  // >   consumption by fnmatch(3)
  '^';
}], // two globstars
[// Use lookahead assertions so that we could match more than one `'/**'`
/\\\/\\\*\\\*(?=\\\/|$)/g, // Zero, one or several directories
// should not use '*', or it will be replaced by the next replacer
// Check if it is not the last `'/**'`
(_, index, str) => index + 6 < str.length // case: /**/
// > A slash followed by two consecutive asterisks then a slash matches
// >   zero or more directories.
// > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
// '/**/'
? // case: /**/
// > A slash followed by two consecutive asterisks then a slash matches
// >   zero or more directories.
// > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
// '/**/'
'(?:\\/[^\\/]+)*' // case: /**
// > A trailing `"/**"` matches everything inside.
// #21: everything inside but it should not include the current folder
: // case: /**
// > A trailing `"/**"` matches everything inside.
// #21: everything inside but it should not include the current folder
'\\/.+'], // intermediate wildcards
[// Never replace escaped '*'
// ignore rule '\*' will match the path '*'
// 'abc.*/' -> go
// 'abc.*'  -> skip this rule
/(^|[^\\]+)\\\*(?=.+)/g, // '*.js' matches '.js'
// '*.js' doesn't match 'abc'
(_, p1) => `${p1}[^\\/]*`], [// unescape, revert step 3 except for back slash
// For example, if a user escape a '\\*',
// after step 3, the result will be '\\\\\\*'
/\\\\\\(?=[$.|*+(){^])/g, () => $1de314a37ff0e4c89ae2b852cc7dfdc1$var$ESCAPE], [// '\\\\' -> '\\'
/\\\\/g, () => $1de314a37ff0e4c89ae2b852cc7dfdc1$var$ESCAPE], [// > The range notation, e.g. [a-zA-Z],
// > can be used to match one of the characters in a range.
// `\` is escaped by step 3
/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === $1de314a37ff0e4c89ae2b852cc7dfdc1$var$ESCAPE // '\\[bar]' -> '\\\\[bar\\]'
? // '\\[bar]' -> '\\\\[bar\\]'
`\\[${range}${$1de314a37ff0e4c89ae2b852cc7dfdc1$var$cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation
// '[bar]'
// '[bar\\\\]'
? // A normal case, and it is a range notation
// '[bar]'
// '[bar\\\\]'
`[${$1de314a37ff0e4c89ae2b852cc7dfdc1$var$sanitizeRange(range)}${endEscape}]` // Invalid range notaton
// '[bar\\]' -> '[bar\\\\]'
: // Invalid range notaton
// '[bar\\]' -> '[bar\\\\]'
'[]' : '[]'], // ending
[// 'js' will not match 'js.'
// 'ab' will not match 'abc'
/(?:[^*])$/, // WTF!
// https://git-scm.com/docs/gitignore
// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
// which re-fixes #24, #38
// > If there is a separator at the end of the pattern then the pattern
// > will only match directories, otherwise the pattern can match both
// > files and directories.
// 'js*' will not match 'a.js'
// 'js/' will not match 'a.js'
// 'js' will match 'a.js' and 'a.js/'
match => /\/$/.test(match) // foo/ will not match 'foo'
? // foo/ will not match 'foo'
`${match}$` // foo matches 'foo' and 'foo/'
: // foo matches 'foo' and 'foo/'
`${match}(?=$|\\/$)`], // trailing wildcard
[/(\^|\\\/)?\\\*$/, (_, p1) => {
  const prefix = p1 // '\^':
  // '/*' does not match EMPTY
  // '/*' does not match everything
  // '\\\/':
  // 'abc/*' does not match 'abc/'
  ? // '\^':
  // '/*' does not match EMPTY
  // '/*' does not match everything
  // '\\\/':
  // 'abc/*' does not match 'abc/'
  `${p1}[^/]+` // 'a*' matches 'a'
  // 'a*' matches 'aa'
  : // 'a*' matches 'a'
  // 'a*' matches 'aa'
  '[^/]*';
  return `${prefix}(?=$|\\/$)`;
}]]; // A simple cache, because an ignore rule only has only one certain meaning

// A simple cache, because an ignore rule only has only one certain meaning
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$regexCache = Object.create(null); // @param {pattern}

// @param {pattern}
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$makeRegex = (pattern, negative, ignorecase) => {
  const r = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$regexCache[pattern];

  if (r) {
    return r;
  } // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS


  // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS
  const source = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
  return $1de314a37ff0e4c89ae2b852cc7dfdc1$var$regexCache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);
};

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isString = subject => typeof subject === 'string'; // > A blank line matches no files, so it can serve as a separator for readability.


// > A blank line matches no files, so it can serve as a separator for readability.
const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPattern = pattern => pattern && $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isString(pattern) && !$1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.
&& // > A line starting with # serves as a comment.
pattern.indexOf('#') !== 0;

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$splitPattern = pattern => pattern.split($1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_SPLITALL_CRLF);

class $1de314a37ff0e4c89ae2b852cc7dfdc1$var$IgnoreRule {
  constructor(origin, pattern, negative, regex) {
    this.origin = origin;
    this.pattern = pattern;
    this.negative = negative;
    this.regex = regex;
  }

}

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$createRule = (pattern, ignorecase) => {
  const origin = pattern;
  let negative = false; // > An optional prefix "!" which negates the pattern;

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  . // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  replace($1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  . // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  replace($1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
  const regex = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$makeRegex(pattern, negative, ignorecase);
  return new $1de314a37ff0e4c89ae2b852cc7dfdc1$var$IgnoreRule(origin, pattern, negative, regex);
};

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$throwError = (message, Ctor) => {
  throw new Ctor(message);
};

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath = (path, originalPath, doThrow) => {
  if (!$1de314a37ff0e4c89ae2b852cc7dfdc1$var$isString(path)) {
    return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
  } // We don't know if we should ignore EMPTY, so throw


  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError);
  } // Check if it is a relative path


  // Check if it is a relative path
  if ($1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d';
    return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
  }

  return true;
};

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isNotRelative = path => $1de314a37ff0e4c89ae2b852cc7dfdc1$var$REGEX_TEST_INVALID_PATH.test(path);

$1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.isNotRelative = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isNotRelative;

$1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.convert = p => p;

class $1de314a37ff0e4c89ae2b852cc7dfdc1$var$Ignore {
  constructor({
    ignorecase = true
  } = {}) {
    this._rules = [];
    this._ignorecase = ignorecase;
    $1de314a37ff0e4c89ae2b852cc7dfdc1$var$define(this, $1de314a37ff0e4c89ae2b852cc7dfdc1$var$KEY_IGNORE, true);

    this._initCache();
  }

  _initCache() {
    this._ignoreCache = Object.create(null);
    this._testCache = Object.create(null);
  }

  _addPattern(pattern) {
    // #32
    if (pattern && pattern[$1de314a37ff0e4c89ae2b852cc7dfdc1$var$KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules);
      this._added = true;
      return;
    }

    if ($1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPattern(pattern)) {
      const rule = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$createRule(pattern, this._ignorecase);
      this._added = true;

      this._rules.push(rule);
    }
  } // @param {Array<string> | string | Ignore} pattern


  // @param {Array<string> | string | Ignore} pattern
  add(pattern) {
    this._added = false;
    $1de314a37ff0e4c89ae2b852cc7dfdc1$var$makeArray($1de314a37ff0e4c89ae2b852cc7dfdc1$var$isString(pattern) ? $1de314a37ff0e4c89ae2b852cc7dfdc1$var$splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,
    // making the behavior changed.

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache();
    }

    return this;
  } // legacy


  // legacy
  addPattern(pattern) {
    return this.add(pattern);
  } //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X
  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen
  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.
  // @returns {TestResult} true if a file is ignored


  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X
  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen
  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.
  // @returns {TestResult} true if a file is ignored
  _testOne(path, checkUnignored) {
    let ignored = false;
    let unignored = false;

    this._rules.forEach(rule => {
      const {
        negative
      } = rule;

      if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
        return;
      }

      const matched = rule.regex.test(path);

      if (matched) {
        ignored = !negative;
        unignored = negative;
      }
    });

    return {
      ignored,
      unignored
    };
  } // @returns {TestResult}


  // @returns {TestResult}
  _test(originalPath, cache, checkUnignored, slices) {
    const path = originalPath // Supports nullable path
    && // Supports nullable path
    $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.convert(originalPath);
    $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath(path, originalPath, $1de314a37ff0e4c89ae2b852cc7dfdc1$var$throwError);
    return this._t(path, cache, checkUnignored, slices);
  }

  _t(path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path];
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split($1de314a37ff0e4c89ae2b852cc7dfdc1$var$SLASH);
    }

    slices.pop(); // If the path has no parent directory, just test it

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored);
    }

    const parent = this._t(slices.join($1de314a37ff0e4c89ae2b852cc7dfdc1$var$SLASH) + $1de314a37ff0e4c89ae2b852cc7dfdc1$var$SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first


    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of
    // >   that file is excluded.
    ? // > It is not possible to re-include a file if a parent directory of
    // >   that file is excluded.
    parent : this._testOne(path, checkUnignored);
  }

  ignores(path) {
    return this._test(path, this._ignoreCache, false).ignored;
  }

  createFilter() {
    return path => !this.ignores(path);
  }

  filter(paths) {
    return $1de314a37ff0e4c89ae2b852cc7dfdc1$var$makeArray(paths).filter(this.createFilter());
  } // @returns {TestResult}


  // @returns {TestResult}
  test(path) {
    return this._test(path, this._testCache, true);
  }

}

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$factory = options => new $1de314a37ff0e4c89ae2b852cc7dfdc1$var$Ignore(options);

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$returnFalse = () => false;

const $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isPathValid = path => $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath(path && $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.convert(path), path, $1de314a37ff0e4c89ae2b852cc7dfdc1$var$returnFalse);

$1de314a37ff0e4c89ae2b852cc7dfdc1$var$factory.isPathValid = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isPathValid; // Fixes typescript

// Fixes typescript
$1de314a37ff0e4c89ae2b852cc7dfdc1$var$factory.default = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$factory;
$1de314a37ff0e4c89ae2b852cc7dfdc1$exports = $1de314a37ff0e4c89ae2b852cc7dfdc1$var$factory; // Windows
// --------------------------------------------------------------

/* istanbul ignore if  */

// Windows
// --------------------------------------------------------------

/* istanbul ignore if  */
if ( // Detect `process` so that it can run in browsers.
typeof $1de314a37ff0e4c89ae2b852cc7dfdc1$var$process !== 'undefined' && ($1de314a37ff0e4c89ae2b852cc7dfdc1$var$process.env && undefined || $1de314a37ff0e4c89ae2b852cc7dfdc1$var$process.platform === 'win32')) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, '/');

  $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.convert = makePosix; // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;

  $1de314a37ff0e4c89ae2b852cc7dfdc1$var$checkPath.isNotRelative = path => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || $1de314a37ff0e4c89ae2b852cc7dfdc1$var$isNotRelative(path);
}

// ASSET: node_modules/globby/node_modules/slash/index.js
var $f609ce3c2a57ed66b1f307bf79f20daf$exports = {};

$f609ce3c2a57ed66b1f307bf79f20daf$exports = path => {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

  // eslint-disable-line no-control-regex
  if (isExtendedLengthPath || hasNonAscii) {
    return path;
  }

  return path.replace(/\\/g, '/');
};

const $f6cbe116cb0084037518012b0fa09ede$var$DEFAULT_IGNORE = ['**/node_modules/**', '**/flow-typed/**', '**/coverage/**', '**/.git'];
const $f6cbe116cb0084037518012b0fa09ede$var$readFileP = $f6cbe116cb0084037518012b0fa09ede$var$promisify($f6cbe116cb0084037518012b0fa09ede$var$fs.readFile);

const $f6cbe116cb0084037518012b0fa09ede$var$mapGitIgnorePatternTo = base => ignore => {
  if (ignore.startsWith('!')) {
    return '!' + $f6cbe116cb0084037518012b0fa09ede$var$path.posix.join(base, ignore.slice(1));
  }

  return $f6cbe116cb0084037518012b0fa09ede$var$path.posix.join(base, ignore);
};

const $f6cbe116cb0084037518012b0fa09ede$var$parseGitIgnore = (content, options) => {
  const base = $f609ce3c2a57ed66b1f307bf79f20daf$exports($f6cbe116cb0084037518012b0fa09ede$var$path.relative(options.cwd, $f6cbe116cb0084037518012b0fa09ede$var$path.dirname(options.fileName)));
  return content.split(/\r?\n/).filter(Boolean).filter(line => !line.startsWith('#')).map($f6cbe116cb0084037518012b0fa09ede$var$mapGitIgnorePatternTo(base));
};

const $f6cbe116cb0084037518012b0fa09ede$var$reduceIgnore = files => {
  return files.reduce((ignores, file) => {
    ignores.add($f6cbe116cb0084037518012b0fa09ede$var$parseGitIgnore(file.content, {
      cwd: file.cwd,
      fileName: file.filePath
    }));
    return ignores;
  }, $1de314a37ff0e4c89ae2b852cc7dfdc1$exports());
};

const $f6cbe116cb0084037518012b0fa09ede$var$ensureAbsolutePathForCwd = (cwd, p) => {
  cwd = $f609ce3c2a57ed66b1f307bf79f20daf$exports(cwd);

  if ($f6cbe116cb0084037518012b0fa09ede$var$path.isAbsolute(p)) {
    if (p.startsWith(cwd)) {
      return p;
    }

    throw new Error(`Path ${p} is not in cwd ${cwd}`);
  }

  return $f6cbe116cb0084037518012b0fa09ede$var$path.join(cwd, p);
};

const $f6cbe116cb0084037518012b0fa09ede$var$getIsIgnoredPredecate = (ignores, cwd) => {
  return p => ignores.ignores($f609ce3c2a57ed66b1f307bf79f20daf$exports($f6cbe116cb0084037518012b0fa09ede$var$path.relative(cwd, $f6cbe116cb0084037518012b0fa09ede$var$ensureAbsolutePathForCwd(cwd, p))));
};

const $f6cbe116cb0084037518012b0fa09ede$var$getFile = async (file, cwd) => {
  const filePath = $f6cbe116cb0084037518012b0fa09ede$var$path.join(cwd, file);
  const content = await $f6cbe116cb0084037518012b0fa09ede$var$readFileP(filePath, 'utf8');
  return {
    cwd,
    filePath,
    content
  };
};

const $f6cbe116cb0084037518012b0fa09ede$var$getFileSync = (file, cwd) => {
  const filePath = $f6cbe116cb0084037518012b0fa09ede$var$path.join(cwd, file);
  const content = $f6cbe116cb0084037518012b0fa09ede$var$fs.readFileSync(filePath, 'utf8');
  return {
    cwd,
    filePath,
    content
  };
};

const $f6cbe116cb0084037518012b0fa09ede$var$normalizeOptions = ({
  ignore = [],
  cwd = $f609ce3c2a57ed66b1f307bf79f20daf$exports($f6cbe116cb0084037518012b0fa09ede$var$process.cwd())
} = {}) => {
  return {
    ignore,
    cwd
  };
};

$f6cbe116cb0084037518012b0fa09ede$exports = async options => {
  options = $f6cbe116cb0084037518012b0fa09ede$var$normalizeOptions(options);
  const paths = await $61dab73f6a7235989c6f2f871d1403c3$exports('**/.gitignore', {
    ignore: $f6cbe116cb0084037518012b0fa09ede$var$DEFAULT_IGNORE.concat(options.ignore),
    cwd: options.cwd
  });
  const files = await Promise.all(paths.map(file => $f6cbe116cb0084037518012b0fa09ede$var$getFile(file, options.cwd)));
  const ignores = $f6cbe116cb0084037518012b0fa09ede$var$reduceIgnore(files);
  return $f6cbe116cb0084037518012b0fa09ede$var$getIsIgnoredPredecate(ignores, options.cwd);
};

var $f6cbe116cb0084037518012b0fa09ede$export$sync = options => {
  options = $f6cbe116cb0084037518012b0fa09ede$var$normalizeOptions(options);
  const paths = $61dab73f6a7235989c6f2f871d1403c3$exports.sync('**/.gitignore', {
    ignore: $f6cbe116cb0084037518012b0fa09ede$var$DEFAULT_IGNORE.concat(options.ignore),
    cwd: options.cwd
  });
  const files = paths.map(file => $f6cbe116cb0084037518012b0fa09ede$var$getFileSync(file, options.cwd));
  const ignores = $f6cbe116cb0084037518012b0fa09ede$var$reduceIgnore(files);
  return $f6cbe116cb0084037518012b0fa09ede$var$getIsIgnoredPredecate(ignores, options.cwd);
};

$f6cbe116cb0084037518012b0fa09ede$exports.sync = $f6cbe116cb0084037518012b0fa09ede$export$sync;
// ASSET: node_modules/globby/stream-utils.js
var $1ca05e254cf4c708910674ce5f662740$exports = {};
const {
  Transform: $1ca05e254cf4c708910674ce5f662740$var$Transform
} = $77f1f3b73e58a1193c01fee8e7b8ba28$exports;

class $1ca05e254cf4c708910674ce5f662740$var$ObjectTransform extends $1ca05e254cf4c708910674ce5f662740$var$Transform {
  constructor() {
    super({
      objectMode: true
    });
  }

}

class $1ca05e254cf4c708910674ce5f662740$var$FilterStream extends $1ca05e254cf4c708910674ce5f662740$var$ObjectTransform {
  constructor(filter) {
    super();
    this._filter = filter;
  }

  _transform(data, encoding, callback) {
    if (this._filter(data)) {
      this.push(data);
    }

    callback();
  }

}

class $1ca05e254cf4c708910674ce5f662740$var$UniqueStream extends $1ca05e254cf4c708910674ce5f662740$var$ObjectTransform {
  constructor() {
    super();
    this._pushed = new Set();
  }

  _transform(data, encoding, callback) {
    if (!this._pushed.has(data)) {
      this.push(data);

      this._pushed.add(data);
    }

    callback();
  }

}

$1ca05e254cf4c708910674ce5f662740$exports = {
  FilterStream: $1ca05e254cf4c708910674ce5f662740$var$FilterStream,
  UniqueStream: $1ca05e254cf4c708910674ce5f662740$var$UniqueStream
};
const {
  FilterStream: $c4246b2a105057577586469a990ffddf$var$FilterStream,
  UniqueStream: $c4246b2a105057577586469a990ffddf$var$UniqueStream
} = $1ca05e254cf4c708910674ce5f662740$exports;

const $c4246b2a105057577586469a990ffddf$var$DEFAULT_FILTER = () => false;

const $c4246b2a105057577586469a990ffddf$var$isNegative = pattern => pattern[0] === '!';

const $c4246b2a105057577586469a990ffddf$var$assertPatternsInput = patterns => {
  if (!patterns.every(pattern => typeof pattern === 'string')) {
    throw new TypeError('Patterns must be a string or an array of strings');
  }
};

const $c4246b2a105057577586469a990ffddf$var$checkCwdOption = (options = {}) => {
  if (!options.cwd) {
    return;
  }

  let stat;

  try {
    stat = $c4246b2a105057577586469a990ffddf$var$fs.statSync(options.cwd);
  } catch (_) {
    return;
  }

  if (!stat.isDirectory()) {
    throw new Error('The `cwd` option must be a path to a directory');
  }
};

const $c4246b2a105057577586469a990ffddf$var$getPathString = p => p.stats instanceof $c4246b2a105057577586469a990ffddf$var$fs.Stats ? p.path : p;

const $c4246b2a105057577586469a990ffddf$var$generateGlobTasks = (patterns, taskOptions) => {
  patterns = $3fb7f4205b5db761498fc45e442147b5$exports([].concat(patterns));
  $c4246b2a105057577586469a990ffddf$var$assertPatternsInput(patterns);
  $c4246b2a105057577586469a990ffddf$var$checkCwdOption(taskOptions);
  const globTasks = [];
  taskOptions = {
    ignore: [],
    expandDirectories: true,
    ...taskOptions
  };

  for (const [index, pattern] of patterns.entries()) {
    if ($c4246b2a105057577586469a990ffddf$var$isNegative(pattern)) {
      continue;
    }

    const ignore = patterns.slice(index).filter($c4246b2a105057577586469a990ffddf$var$isNegative).map(pattern => pattern.slice(1));
    const options = { ...taskOptions,
      ignore: taskOptions.ignore.concat(ignore)
    };
    globTasks.push({
      pattern,
      options
    });
  }

  return globTasks;
};

const $c4246b2a105057577586469a990ffddf$var$globDirs = (task, fn) => {
  let options = {};

  if (task.options.cwd) {
    options.cwd = task.options.cwd;
  }

  if (Array.isArray(task.options.expandDirectories)) {
    options = { ...options,
      files: task.options.expandDirectories
    };
  } else if (typeof task.options.expandDirectories === 'object') {
    options = { ...options,
      ...task.options.expandDirectories
    };
  }

  return fn(task.pattern, options);
};

const $c4246b2a105057577586469a990ffddf$var$getPattern = (task, fn) => task.options.expandDirectories ? $c4246b2a105057577586469a990ffddf$var$globDirs(task, fn) : [task.pattern];

const $c4246b2a105057577586469a990ffddf$var$getFilterSync = options => {
  return options && options.gitignore ? $f6cbe116cb0084037518012b0fa09ede$export$sync({
    cwd: options.cwd,
    ignore: options.ignore
  }) : $c4246b2a105057577586469a990ffddf$var$DEFAULT_FILTER;
};

const $c4246b2a105057577586469a990ffddf$var$globToTask = task => glob => {
  const {
    options
  } = task;

  if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
    options.ignore = $931d520e30117cc4ce79d0d22a9cbc83$export$sync(options.ignore);
  }

  return {
    pattern: glob,
    options
  };
};

$c4246b2a105057577586469a990ffddf$exports = async (patterns, options) => {
  const globTasks = $c4246b2a105057577586469a990ffddf$var$generateGlobTasks(patterns, options);

  const getFilter = async () => {
    return options && options.gitignore ? $f6cbe116cb0084037518012b0fa09ede$exports({
      cwd: options.cwd,
      ignore: options.ignore
    }) : $c4246b2a105057577586469a990ffddf$var$DEFAULT_FILTER;
  };

  const getTasks = async () => {
    const tasks = await Promise.all(globTasks.map(async task => {
      const globs = await $c4246b2a105057577586469a990ffddf$var$getPattern(task, $931d520e30117cc4ce79d0d22a9cbc83$exports);
      return Promise.all(globs.map($c4246b2a105057577586469a990ffddf$var$globToTask(task)));
    }));
    return $3fb7f4205b5db761498fc45e442147b5$exports(...tasks);
  };

  const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
  const paths = await Promise.all(tasks.map(task => $61dab73f6a7235989c6f2f871d1403c3$exports(task.pattern, task.options)));
  return $3fb7f4205b5db761498fc45e442147b5$exports(...paths).filter(path_ => !filter($c4246b2a105057577586469a990ffddf$var$getPathString(path_)));
};

var $c4246b2a105057577586469a990ffddf$export$sync = (patterns, options) => {
  const globTasks = $c4246b2a105057577586469a990ffddf$var$generateGlobTasks(patterns, options);
  const tasks = globTasks.reduce((tasks, task) => {
    const newTask = $c4246b2a105057577586469a990ffddf$var$getPattern(task, $931d520e30117cc4ce79d0d22a9cbc83$export$sync).map($c4246b2a105057577586469a990ffddf$var$globToTask(task));
    return tasks.concat(newTask);
  }, []);
  const filter = $c4246b2a105057577586469a990ffddf$var$getFilterSync(options);
  return tasks.reduce((matches, task) => $3fb7f4205b5db761498fc45e442147b5$exports(matches, $61dab73f6a7235989c6f2f871d1403c3$exports.sync(task.pattern, task.options)), []).filter(path_ => !filter(path_));
};

$c4246b2a105057577586469a990ffddf$exports.sync = $c4246b2a105057577586469a990ffddf$export$sync;

var $c4246b2a105057577586469a990ffddf$export$stream = (patterns, options) => {
  const globTasks = $c4246b2a105057577586469a990ffddf$var$generateGlobTasks(patterns, options);
  const tasks = globTasks.reduce((tasks, task) => {
    const newTask = $c4246b2a105057577586469a990ffddf$var$getPattern(task, $931d520e30117cc4ce79d0d22a9cbc83$export$sync).map($c4246b2a105057577586469a990ffddf$var$globToTask(task));
    return tasks.concat(newTask);
  }, []);
  const filter = $c4246b2a105057577586469a990ffddf$var$getFilterSync(options);
  const filterStream = new $c4246b2a105057577586469a990ffddf$var$FilterStream(p => !filter(p));
  const uniqueStream = new $c4246b2a105057577586469a990ffddf$var$UniqueStream();
  return $fb8bb4f965dec78b60bb9e0acdcfcbfe$exports(tasks.map(task => $61dab73f6a7235989c6f2f871d1403c3$exports.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
};

$c4246b2a105057577586469a990ffddf$exports.stream = $c4246b2a105057577586469a990ffddf$export$stream;
var $c4246b2a105057577586469a990ffddf$export$generateGlobTasks = $c4246b2a105057577586469a990ffddf$var$generateGlobTasks;
$c4246b2a105057577586469a990ffddf$exports.generateGlobTasks = $c4246b2a105057577586469a990ffddf$export$generateGlobTasks;

var $c4246b2a105057577586469a990ffddf$export$hasMagic = (patterns, options) => [].concat(patterns).some(pattern => $61dab73f6a7235989c6f2f871d1403c3$exports.isDynamicPattern(pattern, options));

$c4246b2a105057577586469a990ffddf$exports.hasMagic = $c4246b2a105057577586469a990ffddf$export$hasMagic;
$c4246b2a105057577586469a990ffddf$exports.gitignore = $f6cbe116cb0084037518012b0fa09ede$exports;
const $d8692e28e950b48ea4715ab19e9bf9a1$var$globby_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($c4246b2a105057577586469a990ffddf$exports);

function $d8692e28e950b48ea4715ab19e9bf9a1$var$makeHash(...args) {
  const hash = $d8692e28e950b48ea4715ab19e9bf9a1$var$crypto_1.createHash(`sha512`);

  for (const arg of args) hash.update(arg ? arg : ``);

  return hash.digest(`hex`);
}

var $d8692e28e950b48ea4715ab19e9bf9a1$export$makeHash = $d8692e28e950b48ea4715ab19e9bf9a1$var$makeHash;
$d8692e28e950b48ea4715ab19e9bf9a1$exports.makeHash = $d8692e28e950b48ea4715ab19e9bf9a1$export$makeHash;

function $d8692e28e950b48ea4715ab19e9bf9a1$var$checksumFile(path) {
  return new Promise((resolve, reject) => {
    const hash = $d8692e28e950b48ea4715ab19e9bf9a1$var$crypto_1.createHash(`sha512`);
    const stream = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.createReadStream(path);
    stream.on(`data`, chunk => {
      hash.update(chunk);
    });
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`end`, () => {
      resolve(hash.digest(`hex`));
    });
  });
}

var $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumFile = $d8692e28e950b48ea4715ab19e9bf9a1$var$checksumFile;
$d8692e28e950b48ea4715ab19e9bf9a1$exports.checksumFile = $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumFile;

async function $d8692e28e950b48ea4715ab19e9bf9a1$var$checksumPattern(pattern, {
  cwd
}) {
  // Note: We use a two-pass glob instead of using the expandDirectories option
  // from globby, because the native implementation is broken.
  //
  // Ref: https://github.com/sindresorhus/globby/issues/147
  const dirListing = await $d8692e28e950b48ea4715ab19e9bf9a1$var$globby_1.default(pattern, {
    cwd: $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyDirectories: true,
    unique: true
  });
  const dirPatterns = dirListing.map(entry => {
    return `${entry}/**/*`;
  });
  const listing = await $d8692e28e950b48ea4715ab19e9bf9a1$var$globby_1.default([pattern, ...dirPatterns], {
    cwd: $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyFiles: false,
    unique: true
  });
  listing.sort();
  const hashes = await Promise.all(listing.map(async entry => {
    const parts = [$d8692e28e950b48ea4715ab19e9bf9a1$var$Buffer.from(entry)];
    const p = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(entry);
    const stat = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.lstatPromise(p);
    if (stat.isSymbolicLink()) parts.push($d8692e28e950b48ea4715ab19e9bf9a1$var$Buffer.from(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readlinkPromise(p)));else if (stat.isFile()) parts.push(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(p));
    return parts.join(`\u0000`);
  }));
  const hash = $d8692e28e950b48ea4715ab19e9bf9a1$var$crypto_1.createHash(`sha512`);

  for (const sub of hashes) hash.update(sub);

  return hash.digest(`hex`);
}

$d8692e28e950b48ea4715ab19e9bf9a1$export$checksumPattern = $d8692e28e950b48ea4715ab19e9bf9a1$var$checksumPattern;
$d8692e28e950b48ea4715ab19e9bf9a1$exports.checksumPattern = $d8692e28e950b48ea4715ab19e9bf9a1$export$checksumPattern;
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$hashUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($d8692e28e950b48ea4715ab19e9bf9a1$exports);
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_PROTOCOL = `virtual:`;
const $1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_ABBREVIATE = 5;
/**
 * Creates a package ident.
 *
 * @param scope The package scope without the `@` prefix (eg. `types`)
 * @param name The name of the package
 */

/**
 * Creates a package ident.
 *
 * @param scope The package scope without the `@` prefix (eg. `types`)
 * @param name The name of the package
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeIdent(scope, name) {
  if (scope === null || scope === void 0 ? void 0 : scope.startsWith(`@`)) throw new Error(`Invalid scope: don't prefix it with '@'`);
  return {
    identHash: $1cd0a18ca6ebf8e9e9c7770e206c865e$var$hashUtils.makeHash(scope, name),
    scope,
    name
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeIdent;
/**
 * Creates a package descriptor.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The range to attach (eg. `^1.0.0`)
 */

/**
 * Creates a package descriptor.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The range to attach (eg. `^1.0.0`)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor(ident, range) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    descriptorHash: $1cd0a18ca6ebf8e9e9c7770e206c865e$var$hashUtils.makeHash(ident.identHash, range),
    range
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeDescriptor;
/**
 * Creates a package locator.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The reference to attach (eg. `1.0.0`)
 */

/**
 * Creates a package locator.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The reference to attach (eg. `1.0.0`)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator(ident, reference) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    locatorHash: $1cd0a18ca6ebf8e9e9c7770e206c865e$var$hashUtils.makeHash(ident.identHash, reference),
    reference
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeLocator;
/**
 * Turns a compatible source to an ident. You won't really have to use this
 * function since by virtue of structural inheritance all descriptors and
 * locators are already valid idents.
 *
 * This function is only useful if you absolutely need to remove the non-ident
 * fields from a structure before storing it somewhere.
 *
 * @param source The data structure to convert into an ident.
 */

/**
 * Turns a compatible source to an ident. You won't really have to use this
 * function since by virtue of structural inheritance all descriptors and
 * locators are already valid idents.
 *
 * This function is only useful if you absolutely need to remove the non-ident
 * fields from a structure before storing it somewhere.
 *
 * @param source The data structure to convert into an ident.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertToIdent(source) {
  return {
    identHash: source.identHash,
    scope: source.scope,
    name: source.name
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertToIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertToIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToIdent;
/**
 * Turns a descriptor into a locator.
 *
 * Note that this process may be unsafe, as descriptors may reference multiple
 * packages, putting them at odd with locators' expected semantic. Only makes
 * sense when used with single-resolution protocols, for instance `file:`.
 *
 * @param descriptor The descriptor to convert into a locator.
 */

/**
 * Turns a descriptor into a locator.
 *
 * Note that this process may be unsafe, as descriptors may reference multiple
 * packages, putting them at odd with locators' expected semantic. Only makes
 * sense when used with single-resolution protocols, for instance `file:`.
 *
 * @param descriptor The descriptor to convert into a locator.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertDescriptorToLocator(descriptor) {
  return {
    identHash: descriptor.identHash,
    scope: descriptor.scope,
    name: descriptor.name,
    locatorHash: descriptor.descriptorHash,
    reference: descriptor.range
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertDescriptorToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertDescriptorToLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertDescriptorToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertDescriptorToLocator;
/**
 * Turns a locator into a descriptor.
 *
 * This should be safe to do regardless of the locator, since all locator
 * references are expected to be valid descriptor ranges.
 *
 * @param locator The locator to convert into a descriptor.
 */

/**
 * Turns a locator into a descriptor.
 *
 * This should be safe to do regardless of the locator, since all locator
 * references are expected to be valid descriptor ranges.
 *
 * @param locator The locator to convert into a descriptor.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertLocatorToDescriptor(locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    descriptorHash: locator.locatorHash,
    range: locator.reference
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertLocatorToDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertLocatorToDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertLocatorToDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertLocatorToDescriptor;
/**
 * Turns a package structure into a simple locator. You won't often need to
 * call this function since packages are already valid locators by virtue of
 * structural inheritance.
 *
 * This function is only useful if you absolutely need to remove the
 * non-locator fields from a structure before storing it somewhere.
 *
 * @param pkg The package to convert into a locator.
 */

/**
 * Turns a package structure into a simple locator. You won't often need to
 * call this function since packages are already valid locators by virtue of
 * structural inheritance.
 *
 * This function is only useful if you absolutely need to remove the
 * non-locator fields from a structure before storing it somewhere.
 *
 * @param pkg The package to convert into a locator.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertPackageToLocator(pkg) {
  return {
    identHash: pkg.identHash,
    scope: pkg.scope,
    name: pkg.name,
    locatorHash: pkg.locatorHash,
    reference: pkg.reference
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertPackageToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertPackageToLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertPackageToLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertPackageToLocator;
/**
 * Deep copies a package then change its locator to something else.
 *
 * @param pkg The source package
 * @param locator Its new new locator
 */

/**
 * Deep copies a package then change its locator to something else.
 *
 * @param pkg The source package
 * @param locator Its new new locator
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$renamePackage(pkg, locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    locatorHash: locator.locatorHash,
    reference: locator.reference,
    version: pkg.version,
    languageName: pkg.languageName,
    linkType: pkg.linkType,
    dependencies: new Map(pkg.dependencies),
    peerDependencies: new Map(pkg.peerDependencies),
    dependenciesMeta: new Map(pkg.dependenciesMeta),
    peerDependenciesMeta: new Map(pkg.peerDependenciesMeta),
    bin: new Map(pkg.bin)
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$renamePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$renamePackage;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.renamePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$renamePackage;
/**
 * Deep copies a package. The copy will share the same locator as the original.
 *
 * @param pkg The source package
 */

/**
 * Deep copies a package. The copy will share the same locator as the original.
 *
 * @param pkg The source package
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$copyPackage(pkg) {
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$renamePackage(pkg, pkg);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$copyPackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$copyPackage;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.copyPackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$copyPackage;
/**
 * Creates a new virtual descriptor from a non virtual one.
 *
 * @param descriptor The descriptor to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized descriptor (normally a locator hash)
 */

/**
 * Creates a new virtual descriptor from a non virtual one.
 *
 * @param descriptor The descriptor to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized descriptor (normally a locator hash)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$virtualizeDescriptor(descriptor, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor(descriptor, `virtual:${entropy}#${descriptor.range}`);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$virtualizeDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.virtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizeDescriptor;
/**
 * Creates a new virtual package from a non virtual one.
 *
 * @param pkg The package to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized package (normally a locator hash)
 */

/**
 * Creates a new virtual package from a non virtual one.
 *
 * @param pkg The package to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized package (normally a locator hash)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$virtualizePackage(pkg, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$renamePackage(pkg, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator(pkg, `virtual:${entropy}#${pkg.reference}`));
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$virtualizePackage;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.virtualizePackage = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$virtualizePackage;
/**
 * Returns `true` if the descriptor is virtual.
 */

/**
 * Returns `true` if the descriptor is virtual.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualDescriptor(descriptor) {
  return descriptor.range.startsWith($1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_PROTOCOL);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.isVirtualDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualDescriptor;
/**
 * Returns `true` if the locator is virtual.
 */

/**
 * Returns `true` if the locator is virtual.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualLocator(locator) {
  return locator.reference.startsWith($1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_PROTOCOL);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.isVirtualLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$isVirtualLocator;
/**
 * Returns a new devirtualized descriptor based on a virtualized descriptor
 */

/**
 * Returns a new devirtualized descriptor based on a virtualized descriptor
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$devirtualizeDescriptor(descriptor) {
  if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualDescriptor(descriptor)) throw new Error(`Not a virtual descriptor`);
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor(descriptor, descriptor.range.replace(/^[^#]*#/, ``));
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$devirtualizeDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.devirtualizeDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeDescriptor;
/**
 * Returns a new devirtualized locator based on a virtualized locator
 * @param locator the locator
 */

/**
 * Returns a new devirtualized locator based on a virtualized locator
 * @param locator the locator
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$devirtualizeLocator(locator) {
  if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualLocator(locator)) throw new Error(`Not a virtual descriptor`);
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator(locator, locator.reference.replace(/^[^#]*#/, ``));
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$devirtualizeLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.devirtualizeLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$devirtualizeLocator;
/**
 * Some descriptors only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` ranges, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * descriptor, but only if it didn't get bound before (important to handle the
 * case where we replace a descriptor by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param descriptor The original descriptor
 * @param params The parameters to encode in the range
 */

/**
 * Some descriptors only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` ranges, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * descriptor, but only if it didn't get bound before (important to handle the
 * case where we replace a descriptor by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param descriptor The original descriptor
 * @param params The parameters to encode in the range
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$bindDescriptor(descriptor, params) {
  if (descriptor.range.includes(`::`)) return descriptor;
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor(descriptor, `${descriptor.range}::${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1.default.stringify(params)}`);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$bindDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.bindDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindDescriptor;
/**
 * Some locators only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` references, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * locator, but only if it didn't get bound before (important to handle the
 * case where we replace a locator by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param locator The original locator
 * @param params The parameters to encode in the reference
 */

/**
 * Some locators only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` references, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * locator, but only if it didn't get bound before (important to handle the
 * case where we replace a locator by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param locator The original locator
 * @param params The parameters to encode in the reference
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$bindLocator(locator, params) {
  if (locator.reference.includes(`::`)) return locator;
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator(locator, `${locator.reference}::${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1.default.stringify(params)}`);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$bindLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.bindLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$bindLocator;
/**
 * Returns `true` if the idents are equal
 */

/**
 * Returns `true` if the idents are equal
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areIdentsEqual(a, b) {
  return a.identHash === b.identHash;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areIdentsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areIdentsEqual;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areIdentsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areIdentsEqual;
/**
 * Returns `true` if the descriptors are equal
 */

/**
 * Returns `true` if the descriptors are equal
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areDescriptorsEqual(a, b) {
  return a.descriptorHash === b.descriptorHash;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areDescriptorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areDescriptorsEqual;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areDescriptorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areDescriptorsEqual;
/**
 * Returns `true` if the locators are equal
 */

/**
 * Returns `true` if the locators are equal
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areLocatorsEqual(a, b) {
  return a.locatorHash === b.locatorHash;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areLocatorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areLocatorsEqual;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areLocatorsEqual = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areLocatorsEqual;
/**
 * Virtual packages are considered equivalent when they belong to the same
 * package identity and have the same dependencies. Note that equivalence
 * is not the same as equality, as the references may be different.
 */

/**
 * Virtual packages are considered equivalent when they belong to the same
 * package identity and have the same dependencies. Note that equivalence
 * is not the same as equality, as the references may be different.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areVirtualPackagesEquivalent(a, b) {
  if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualLocator(a)) throw new Error(`Invalid package type`);
  if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualLocator(b)) throw new Error(`Invalid package type`);
  if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$areIdentsEqual(a, b)) return false;
  if (a.dependencies.size !== b.dependencies.size) return false;

  for (const dependencyDescriptorA of a.dependencies.values()) {
    const dependencyDescriptorB = b.dependencies.get(dependencyDescriptorA.identHash);
    if (!dependencyDescriptorB) return false;

    if (!$1cd0a18ca6ebf8e9e9c7770e206c865e$var$areDescriptorsEqual(dependencyDescriptorA, dependencyDescriptorB)) {
      return false;
    }
  }

  return true;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areVirtualPackagesEquivalent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$areVirtualPackagesEquivalent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.areVirtualPackagesEquivalent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$areVirtualPackagesEquivalent;
/**
 * Parses a string into an ident.
 *
 * Throws an error if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */

/**
 * Parses a string into an ident.
 *
 * Throws an error if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseIdent(string) {
  const ident = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseIdent(string);
  if (!ident) throw new Error(`Invalid ident (${string})`);
  return ident;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseIdent;
/**
 * Parses a string into an ident.
 *
 * Returns `null` if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */

/**
 * Parses a string into an ident.
 *
 * Returns `null` if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseIdent(string) {
  const match = string.match(/^(?:@([^/]+?)\/)?([^/]+)$/);
  if (!match) return null;
  const [, scope, name] = match;
  const realScope = typeof scope !== `undefined` ? scope : null;
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeIdent(realScope, name);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseIdent;
/**
 * Parses a `string` into a descriptor
 *
 * Throws an error if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */

/**
 * Parses a `string` into a descriptor
 *
 * Throws an error if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseDescriptor(string, strict = false) {
  const descriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseDescriptor(string, strict);
  if (!descriptor) throw new Error(`Invalid descriptor (${string})`);
  return descriptor;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseDescriptor;
/**
 * Parses a `string` into a descriptor
 *
 * Returns `null` if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */

/**
 * Parses a `string` into a descriptor
 *
 * Returns `null` if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseDescriptor(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, range] = match;
  if (range === `unknown`) throw new Error(`Invalid range (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realRange = typeof range !== `undefined` ? range : `unknown`;
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeDescriptor($1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeIdent(realScope, name), realRange);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseDescriptor;
/**
 * Parses a `string` into a locator
 *
 * Throws an error if the locator cannot be parsed.
 *
 * @param string The locator `string` (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */

/**
 * Parses a `string` into a locator
 *
 * Throws an error if the locator cannot be parsed.
 *
 * @param string The locator `string` (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseLocator(string, strict = false) {
  const locator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseLocator(string, strict);
  if (!locator) throw new Error(`Invalid locator (${string})`);
  return locator;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseLocator;
/**
 * Parses a `string` into a locator
 *
 * Returns `null` if the locator cannot be parsed.
 *
 * @param string The locator string (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */

/**
 * Parses a `string` into a locator
 *
 * Returns `null` if the locator cannot be parsed.
 *
 * @param string The locator string (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseLocator(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, reference] = match;
  if (reference === `unknown`) throw new Error(`Invalid reference (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realReference = typeof reference !== `undefined` ? reference : `unknown`;
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeLocator($1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeIdent(realScope, name), realReference);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$tryParseLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.tryParseLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$tryParseLocator;
/**
 * Parses a range into its constituents. Ranges typically follow these forms,
 * with both `protocol` and `bindings` being optionals:
 *
 * <protocol>:<selector>::<bindings>
 * <protocol>:<source>#<selector>::<bindings>
 *
 * The selector is intended to "refine" the source, and is required. The source
 * itself is optional (for instance we don't need it for npm packages, but we
 * do for git dependencies).
 */

/**
 * Parses a range into its constituents. Ranges typically follow these forms,
 * with both `protocol` and `bindings` being optionals:
 *
 * <protocol>:<selector>::<bindings>
 * <protocol>:<source>#<selector>::<bindings>
 *
 * The selector is intended to "refine" the source, and is required. The source
 * itself is optional (for instance we don't need it for npm packages, but we
 * do for git dependencies).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseRange(range, opts) {
  const match = range.match(/^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$/);
  if (match === null) throw new Error(`Invalid range (${range})`);
  const protocol = typeof match[1] !== `undefined` ? match[1] : null;
  if (typeof (opts === null || opts === void 0 ? void 0 : opts.requireProtocol) === `string` && protocol !== opts.requireProtocol) throw new Error(`Invalid protocol (${protocol})`);else if ((opts === null || opts === void 0 ? void 0 : opts.requireProtocol) && protocol === null) throw new Error(`Missing protocol (${protocol})`);
  const source = typeof match[3] !== `undefined` ? decodeURIComponent(match[2]) : null;
  if ((opts === null || opts === void 0 ? void 0 : opts.requireSource) && source === null) throw new Error(`Missing source (${range})`);
  const rawSelector = typeof match[3] !== `undefined` ? decodeURIComponent(match[3]) : decodeURIComponent(match[2]);
  const selector = (opts === null || opts === void 0 ? void 0 : opts.parseSelector) ? $1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1.default.parse(rawSelector) : rawSelector;
  const params = typeof match[4] !== `undefined` ? $1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1.default.parse(match[4]) : null;
  return {
    // @ts-expect-error
    protocol,
    // @ts-expect-error
    source,
    // @ts-expect-error
    selector,
    // @ts-expect-error
    params
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseRange;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseRange;
/**
 * File-style ranges are bound to a parent locators that we need in order to
 * resolve relative paths to the location of their parent packages. This
 * function wraps `parseRange` to automatically extract the parent locator
 * from the bindings and return it along with the selector.
 */

/**
 * File-style ranges are bound to a parent locators that we need in order to
 * resolve relative paths to the location of their parent packages. This
 * function wraps `parseRange` to automatically extract the parent locator
 * from the bindings and return it along with the selector.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseFileStyleRange(range, {
  protocol
}) {
  const {
    selector,
    params
  } = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseRange(range, {
    requireProtocol: protocol,
    requireBindings: true
  });
  if (typeof params.locator !== `string`) throw new Error(`Assertion failed: Invalid bindings for ${range}`);
  const parentLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseLocator(params.locator, true);
  const path = selector;
  return {
    parentLocator,
    path
  };
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseFileStyleRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseFileStyleRange;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.parseFileStyleRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$parseFileStyleRange;

function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$encodeUnsafeCharacters(str) {
  str = str.replace(/%/g, `%25`);
  str = str.replace(/:/g, `%3A`);
  str = str.replace(/#/g, `%23`);
  return str;
}

function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$hasParams(params) {
  if (params === null) return false;
  return Object.entries(params).length > 0;
}
/**
 * Turn the components returned by `parseRange` back into a string. Check
 * `parseRange` for more details.
 */


/**
 * Turn the components returned by `parseRange` back into a string. Check
 * `parseRange` for more details.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeRange({
  protocol,
  source,
  selector,
  params
}) {
  let range = ``;
  if (protocol !== null) range += `${protocol}`;
  if (source !== null) range += `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$encodeUnsafeCharacters(source)}#`;
  range += $1cd0a18ca6ebf8e9e9c7770e206c865e$var$encodeUnsafeCharacters(selector);
  if ($1cd0a18ca6ebf8e9e9c7770e206c865e$var$hasParams(params)) range += `::${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$querystring_1.default.stringify(params)}`;
  return range;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeRange;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.makeRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$makeRange;
/**
 * Some bindings are internal-only and not meant to be displayed anywhere (for
 * instance that's the case with the parent locator bound to the `file:` ranges).
 *
 * this function strips them from a range.
 */

/**
 * Some bindings are internal-only and not meant to be displayed anywhere (for
 * instance that's the case with the parent locator bound to the `file:` ranges).
 *
 * this function strips them from a range.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertToManifestRange(range) {
  const {
    params,
    protocol,
    source,
    selector
  } = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseRange(range);

  for (const name in params) if (name.startsWith(`__`)) delete params[name];

  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$makeRange({
    protocol,
    source,
    params,
    selector
  });
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToManifestRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$convertToManifestRange;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.convertToManifestRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$convertToManifestRange;
/**
 * @deprecated Prefer using `stringifyIdent`
 */

/**
 * @deprecated Prefer using `stringifyIdent`
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$requirableIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$requirableIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$requirableIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.requirableIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$requirableIdent;
/**
 * Returns a string from an ident (eg. `@types/lodash`).
 */

/**
 * Returns a string from an ident (eg. `@types/lodash`).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyIdent;
/**
 * Returns a string from a descriptor (eg. `@types/lodash@^1.0.0`).
 */

/**
 * Returns a string from a descriptor (eg. `@types/lodash@^1.0.0`).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyDescriptor(descriptor) {
  if (descriptor.scope) {
    return `@${descriptor.scope}/${descriptor.name}@${descriptor.range}`;
  } else {
    return `${descriptor.name}@${descriptor.range}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyDescriptor;
/**
 * Returns a string from a descriptor (eg. `@types/lodash@1.0.0`).
 */

/**
 * Returns a string from a descriptor (eg. `@types/lodash@1.0.0`).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyLocator(locator) {
  if (locator.scope) {
    return `@${locator.scope}/${locator.name}@${locator.reference}`;
  } else {
    return `${locator.name}@${locator.reference}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.stringifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$stringifyLocator;
/**
 * Returns a string from an ident, formatted as a slug (eg. `@types-lodash`).
 */

/**
 * Returns a string from an ident, formatted as a slug (eg. `@types-lodash`).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyIdent(ident) {
  if (ident.scope !== null) {
    return `@${ident.scope}-${ident.name}`;
  } else {
    return ident.name;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.slugifyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyIdent;
/**
 * Returns a string from a locator, formatted as a slug (eg. `@types-lodash-npm-1.0.0-abcdef1234`).
 */

/**
 * Returns a string from a locator, formatted as a slug (eg. `@types-lodash-npm-1.0.0-abcdef1234`).
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyLocator(locator) {
  const {
    protocol,
    selector
  } = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$parseRange(locator.reference);
  const humanProtocol = protocol !== null ? protocol.replace(/:$/, ``) : `exotic`;
  const humanVersion = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$semver_1.default.valid(selector);
  const humanReference = humanVersion !== null ? `${humanProtocol}-${humanVersion}` : `${humanProtocol}`; // 10 hex characters means that 47 different entries have 10^-9 chances of
  // causing a hash collision. Since this hash is joined with the package name
  // (making it highly unlikely you'll have more than a handful of instances
  // of any single package), this should provide a good enough guard in most
  // cases.
  //
  // Also note that eCryptfs eats some bytes, so the theoretical maximum for a
  // file size is around 140 bytes (but we don't need as much, as explained).

  // 10 hex characters means that 47 different entries have 10^-9 chances of
  // causing a hash collision. Since this hash is joined with the package name
  // (making it highly unlikely you'll have more than a handful of instances
  // of any single package), this should provide a good enough guard in most
  // cases.
  //
  // Also note that eCryptfs eats some bytes, so the theoretical maximum for a
  // file size is around 140 bytes (but we don't need as much, as explained).
  const hashTruncate = 10;
  const slug = locator.scope ? `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}` : `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`;
  return $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(slug);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$slugifyLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.slugifyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$slugifyLocator;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The ident to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The ident to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyIdent(configuration, ident) {
  if (ident.scope) {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, `@${ident.scope}/`, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.SCOPE)}${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, ident.name, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.NAME)}`;
  } else {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, ident.name, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.NAME)}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyIdent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyIdent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyIdent;

function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRangeNoColors(range) {
  if (range.startsWith($1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_PROTOCOL)) {
    const nested = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRangeNoColors(range.substr(range.indexOf(`#`) + 1));
    const abbrev = range.substr($1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_PROTOCOL.length, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$VIRTUAL_ABBREVIATE); // I'm not satisfied of how the virtual packages appear in the output
    // eslint-disable-next-line no-constant-condition

    // I'm not satisfied of how the virtual packages appear in the output
    // eslint-disable-next-line no-constant-condition
    return false ? `${nested} (virtual:${abbrev})` : `${nested} [${abbrev}]`;
  } else {
    return range.replace(/\?.*/, `?[...]`);
  }
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The range to pretty print
 */


/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The range to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRange(configuration, range) {
  return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRangeNoColors(range), $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.RANGE)}`;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRange;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyRange = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyRange;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyDescriptor(configuration, descriptor) {
  return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyIdent(configuration, descriptor)}${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, `@`, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.RANGE)}${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRange(configuration, descriptor.range)}`;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyDescriptor;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDescriptor;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param reference The reference to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param reference The reference to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyReference(configuration, reference) {
  return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRangeNoColors(reference), $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.REFERENCE)}`;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyReference = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyReference;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyReference = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyReference;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocator(configuration, locator) {
  return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyIdent(configuration, locator)}${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.pretty(configuration, `@`, $1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.Type.REFERENCE)}${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyReference(configuration, locator.reference)}`;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocator;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyLocator = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocator;
/**
 * Returns a string that is suitable to be printed to stdout. It will never
 * be colored.
 *
 * @param locator The locator to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. It will never
 * be colored.
 *
 * @param locator The locator to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocatorNoColors(locator) {
  return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyIdent(locator)}@${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyRangeNoColors(locator.reference)}`;
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocatorNoColors = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocatorNoColors;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyLocatorNoColors = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyLocatorNoColors;
/**
 * Sorts a list of descriptors, first by their idents then by their ranges.
 */

/**
 * Sorts a list of descriptors, first by their idents then by their ranges.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$sortDescriptors(descriptors) {
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$miscUtils.sortMap(descriptors, [descriptor => $1cd0a18ca6ebf8e9e9c7770e206c865e$var$stringifyIdent(descriptor), descriptor => descriptor.range]);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$sortDescriptors = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$sortDescriptors;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.sortDescriptors = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$sortDescriptors;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param workspace The workspace to pretty print
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param workspace The workspace to pretty print
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyWorkspace(configuration, workspace) {
  return $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyIdent(configuration, workspace.locator);
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyWorkspace = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyWorkspace;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyWorkspace = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyWorkspace;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 * @param locator The locator is resolves to
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 * @param locator The locator is resolves to
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyResolution(configuration, descriptor, locator) {
  const devirtualizedDescriptor = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$isVirtualDescriptor(descriptor) ? $1cd0a18ca6ebf8e9e9c7770e206c865e$var$devirtualizeDescriptor(descriptor) : descriptor;

  if (locator === null) {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$structUtils.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$formatUtils.mark(configuration).Cross}`;
  } else if (devirtualizedDescriptor.identHash === locator.identHash) {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$structUtils.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyReference(configuration, locator.reference)}`;
  } else {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$structUtils.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocator(configuration, locator)}`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyResolution = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyResolution;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyResolution = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyResolution;
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 * @param descriptor The descriptor that depends on it
 */

/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 * @param descriptor The descriptor that depends on it
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyDependent(configuration, locator, descriptor) {
  if (descriptor === null) {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocator(configuration, locator)}`;
  } else {
    return `${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyLocator(configuration, locator)} (via ${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$structUtils.prettyRange(configuration, descriptor.range)})`;
  }
}

var $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDependent = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$prettyDependent;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.prettyDependent = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$prettyDependent;
/**
 * The presence of a `node_modules` directory in the path is extremely common
 * in the JavaScript ecosystem to denote whether a path belongs to a vendor
 * or not. I considered using a more generic path for packages that aren't
 * always JS-only (such as when using the Git fetcher), but that unfortunately
 * caused various JS apps to start showing errors when working with git repos.
 *
 * As a result, all packages from all languages will follow this convention. At
 * least it'll be consistent, and linkers will always have the ability to remap
 * them to a different location if that's a critical requirement.
 */

/**
 * The presence of a `node_modules` directory in the path is extremely common
 * in the JavaScript ecosystem to denote whether a path belongs to a vendor
 * or not. I considered using a more generic path for packages that aren't
 * always JS-only (such as when using the Git fetcher), but that unfortunately
 * caused various JS apps to start showing errors when working with git repos.
 *
 * As a result, all packages from all languages will follow this convention. At
 * least it'll be consistent, and linkers will always have the ability to remap
 * them to a different location if that's a critical requirement.
 */
function $1cd0a18ca6ebf8e9e9c7770e206c865e$var$getIdentVendorPath(ident) {
  return `node_modules/${$1cd0a18ca6ebf8e9e9c7770e206c865e$var$requirableIdent(ident)}`;
}

$1cd0a18ca6ebf8e9e9c7770e206c865e$export$getIdentVendorPath = $1cd0a18ca6ebf8e9e9c7770e206c865e$var$getIdentVendorPath;
$1cd0a18ca6ebf8e9e9c7770e206c865e$exports.getIdentVendorPath = $1cd0a18ca6ebf8e9e9c7770e206c865e$export$getIdentVendorPath;
const $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
// ASSET: node_modules/@yarnpkg/core/lib/types.js
var $f987e6a0bb0b2110da898bacaa7fa048$export$LinkType,
    $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionType,
    $f987e6a0bb0b2110da898bacaa7fa048$exports = {};
Object.defineProperty($f987e6a0bb0b2110da898bacaa7fa048$exports, "__esModule", {
  value: true
});
var $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionStatus = ($f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionType = ($f987e6a0bb0b2110da898bacaa7fa048$export$LinkType = void 0, $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType = $f987e6a0bb0b2110da898bacaa7fa048$export$LinkType), $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType = $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionType);
$f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus = $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionStatus;
/**
 * Describes in which capacity the linkers can manipulate the package sources.
 */

/**
 * Describes in which capacity the linkers can manipulate the package sources.
 */
var $f987e6a0bb0b2110da898bacaa7fa048$var$LinkType;

(function (LinkType) {
  /**
   * The package manager owns the location (typically things within the cache)
   * and can transform it at will (for instance the PnP linker may decide to
   * unplug those packages).
   */
  LinkType["HARD"] = "HARD";
  /**
   * The package manager doesn't own the location (symlinks, workspaces, etc),
   * so the linkers aren't allowed to do anything with them except use them as
   * they are.
   */

  /**
   * The package manager doesn't own the location (symlinks, workspaces, etc),
   * so the linkers aren't allowed to do anything with them except use them as
   * they are.
   */
  LinkType["SOFT"] = "SOFT";
})($f987e6a0bb0b2110da898bacaa7fa048$var$LinkType = $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType || ($f987e6a0bb0b2110da898bacaa7fa048$export$LinkType = {}, $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType = $f987e6a0bb0b2110da898bacaa7fa048$export$LinkType));

var $f987e6a0bb0b2110da898bacaa7fa048$var$PackageExtensionType;

(function (PackageExtensionType) {
  PackageExtensionType["Dependency"] = "Dependency";
  PackageExtensionType["PeerDependency"] = "PeerDependency";
  PackageExtensionType["PeerDependencyMeta"] = "PeerDependencyMeta";
})($f987e6a0bb0b2110da898bacaa7fa048$var$PackageExtensionType = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType || ($f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionType = {}, $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType = $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionType));

var $f987e6a0bb0b2110da898bacaa7fa048$var$PackageExtensionStatus;

(function (PackageExtensionStatus) {
  PackageExtensionStatus["Inactive"] = "inactive";
  PackageExtensionStatus["Redundant"] = "redundant";
  PackageExtensionStatus["Active"] = "active";
})($f987e6a0bb0b2110da898bacaa7fa048$var$PackageExtensionStatus = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus || ($f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionStatus = {}, $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus = $f987e6a0bb0b2110da898bacaa7fa048$export$PackageExtensionStatus));

var $b0a0c0c8655104e8248dfbd97bf5098e$var$Type;

(function (Type) {
  Type["NO_HINT"] = "NO_HINT";
  Type["NULL"] = "NULL";
  Type["SCOPE"] = "SCOPE";
  Type["NAME"] = "NAME";
  Type["RANGE"] = "RANGE";
  Type["REFERENCE"] = "REFERENCE";
  Type["NUMBER"] = "NUMBER";
  Type["PATH"] = "PATH";
  Type["URL"] = "URL";
  Type["ADDED"] = "ADDED";
  Type["REMOVED"] = "REMOVED";
  Type["CODE"] = "CODE";
  Type["DURATION"] = "DURATION";
  Type["SIZE"] = "SIZE";
  Type["IDENT"] = "IDENT";
  Type["DESCRIPTOR"] = "DESCRIPTOR";
  Type["LOCATOR"] = "LOCATOR";
  Type["RESOLUTION"] = "RESOLUTION";
  Type["DEPENDENT"] = "DEPENDENT";
  Type["PACKAGE_EXTENSION"] = "PACKAGE_EXTENSION";
})($b0a0c0c8655104e8248dfbd97bf5098e$var$Type = $b0a0c0c8655104e8248dfbd97bf5098e$exports.Type || ($b0a0c0c8655104e8248dfbd97bf5098e$export$Type = {}, $b0a0c0c8655104e8248dfbd97bf5098e$exports.Type = $b0a0c0c8655104e8248dfbd97bf5098e$export$Type));

var $b0a0c0c8655104e8248dfbd97bf5098e$var$Style;

(function (Style) {
  Style[Style["BOLD"] = 2] = "BOLD";
})($b0a0c0c8655104e8248dfbd97bf5098e$var$Style = $b0a0c0c8655104e8248dfbd97bf5098e$exports.Style || ($b0a0c0c8655104e8248dfbd97bf5098e$export$Style = {}, $b0a0c0c8655104e8248dfbd97bf5098e$exports.Style = $b0a0c0c8655104e8248dfbd97bf5098e$export$Style));

const $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkOptions = undefined ? {
  level: 2
} : $b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1.default.supportsColor ? {
  level: $b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1.default.supportsColor.level
} : {
  level: 0
};
var $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsColor = $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkOptions.level !== 0;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.supportsColor = $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsColor;
var $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsHyperlinks = $b0a0c0c8655104e8248dfbd97bf5098e$exports.supportsColor && !undefined;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.supportsHyperlinks = $b0a0c0c8655104e8248dfbd97bf5098e$export$supportsHyperlinks;
const $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkInstance = new $b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1.default.Instance($b0a0c0c8655104e8248dfbd97bf5098e$var$chalkOptions);
const $b0a0c0c8655104e8248dfbd97bf5098e$var$colors = new Map([[$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NO_HINT, null], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NULL, [`#a853b5`, 129]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.SCOPE, [`#d75f00`, 166]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NAME, [`#d7875f`, 173]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.RANGE, [`#00afaf`, 37]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.REFERENCE, [`#87afff`, 111]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NUMBER, [`#ffd700`, 220]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.PATH, [`#d75fd7`, 170]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.URL, [`#d75fd7`, 170]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.ADDED, [`#5faf00`, 70]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.REMOVED, [`#d70000`, 160]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.CODE, [`#87afff`, 111]], [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.SIZE, [`#ffd700`, 220]]]); // Just to make sure that the individual fields of the transform map have
// compatible parameter types, without upcasting the map to a too generic type
//
// We also take the opportunity to downcast the configuration into `any`,
// otherwise TypeScript will detect a circular reference and won't allow us to
// properly type the `format` method from Configuration. Since transforms are
// internal to this file, it should be fine.

// Just to make sure that the individual fields of the transform map have
// compatible parameter types, without upcasting the map to a too generic type
//
// We also take the opportunity to downcast the configuration into `any`,
// otherwise TypeScript will detect a circular reference and won't allow us to
// properly type the `format` method from Configuration. Since transforms are
// internal to this file, it should be fine.
const $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform = spec => spec;

const $b0a0c0c8655104e8248dfbd97bf5098e$var$transforms = {
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NUMBER]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, value) => {
      return `${value}`;
    },
    json: value => {
      return value;
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.IDENT]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, ident) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, ident);
    },
    json: ident => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(ident);
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.LOCATOR]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, locator) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyLocator(configuration, locator);
    },
    json: locator => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyLocator(locator);
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.DESCRIPTOR]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, descriptor) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyDescriptor(configuration, descriptor);
    },
    json: descriptor => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyDescriptor(descriptor);
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.RESOLUTION]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, {
      descriptor,
      locator
    }) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyResolution(configuration, descriptor, locator);
    },
    json: ({
      descriptor,
      locator
    }) => {
      return {
        descriptor: $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyDescriptor(descriptor),
        locator: locator !== null ? $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyLocator(locator) : null
      };
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.DEPENDENT]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, {
      locator,
      descriptor
    }) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyDependent(configuration, locator, descriptor);
    },
    json: ({
      locator,
      descriptor
    }) => {
      return {
        locator: $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyLocator(locator),
        descriptor: $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyDescriptor(descriptor)
      };
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.PACKAGE_EXTENSION]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, packageExtension) => {
      switch (packageExtension.type) {
        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.Dependency:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `dependencies`, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.CODE)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, packageExtension.descriptor)}`;

        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependency:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `peerDependencies`, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.CODE)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, packageExtension.descriptor)}`;

        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependencyMeta:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `peerDependenciesMeta`, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.CODE)}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.prettyIdent(configuration, $b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.parseIdent(packageExtension.selector))}  ${$b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, packageExtension.key, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.CODE)}`;

        default:
          throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
      }
    },
    json: packageExtension => {
      switch (packageExtension.type) {
        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.Dependency:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(packageExtension.parentDescriptor)} > ${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(packageExtension.descriptor)}`;

        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependency:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(packageExtension.parentDescriptor)} >> ${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(packageExtension.descriptor)}`;

        case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependencyMeta:
          return `${$b0a0c0c8655104e8248dfbd97bf5098e$var$structUtils.stringifyIdent(packageExtension.parentDescriptor)} >> ${packageExtension.selector} / ${packageExtension.key}`;

        default:
          throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
      }
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.DURATION]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, duration) => {
      if (duration > 1000 * 60) {
        const minutes = Math.floor(duration / 1000 / 60);
        const seconds = Math.ceil((duration - minutes * 60 * 1000) / 1000);
        return seconds === 0 ? `${minutes}m` : `${minutes}m ${seconds}s`;
      } else {
        const seconds = Math.floor(duration / 1000);
        const milliseconds = duration - seconds * 1000;
        return milliseconds === 0 ? `${seconds}s` : `${seconds}s ${milliseconds}ms`;
      }
    },
    json: duration => {
      return duration;
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.SIZE]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, size) => {
      const thresholds = [`KB`, `MB`, `GB`, `TB`];
      let power = thresholds.length;

      while (power > 1 && size < 1024 ** power) power -= 1;

      const factor = 1024 ** power;
      const value = Math.floor(size * 100 / factor) / 100;
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `${value} ${thresholds[power - 1]}`, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NUMBER);
    },
    json: size => {
      return size;
    }
  }),
  [$b0a0c0c8655104e8248dfbd97bf5098e$var$Type.PATH]: $b0a0c0c8655104e8248dfbd97bf5098e$var$validateTransform({
    pretty: (configuration, filePath) => {
      return $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(filePath), $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.PATH);
    },
    json: filePath => {
      return $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(filePath);
    }
  })
};

function $b0a0c0c8655104e8248dfbd97bf5098e$var$tuple(formatType, value) {
  return [value, formatType];
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$tuple = $b0a0c0c8655104e8248dfbd97bf5098e$var$tuple;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.tuple = $b0a0c0c8655104e8248dfbd97bf5098e$export$tuple;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$applyStyle(configuration, text, flags) {
  if (!configuration.get(`enableColors`)) return text;
  if (flags & $b0a0c0c8655104e8248dfbd97bf5098e$var$Style.BOLD) text = $b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1.default.bold(text);
  return text;
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$applyStyle = $b0a0c0c8655104e8248dfbd97bf5098e$var$applyStyle;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.applyStyle = $b0a0c0c8655104e8248dfbd97bf5098e$export$applyStyle;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, value, formatType) {
  if (!configuration.get(`enableColors`)) return value;
  const colorSpec = $b0a0c0c8655104e8248dfbd97bf5098e$var$colors.get(formatType);
  if (colorSpec === null) return value;
  const color = typeof colorSpec === `undefined` ? formatType : $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkOptions.level >= 3 ? colorSpec[0] : colorSpec[1];
  const fn = typeof color === `number` ? $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkInstance.ansi256(color) : color.startsWith(`#`) ? $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkInstance.hex(color) : $b0a0c0c8655104e8248dfbd97bf5098e$var$chalkInstance[color];
  if (typeof fn !== `function`) throw new Error(`Invalid format type ${color}`);
  return fn(value);
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$applyColor = $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.applyColor = $b0a0c0c8655104e8248dfbd97bf5098e$export$applyColor;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$pretty(configuration, value, formatType) {
  if (value === null) return $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `null`, $b0a0c0c8655104e8248dfbd97bf5098e$var$Type.NULL);

  if (Object.prototype.hasOwnProperty.call($b0a0c0c8655104e8248dfbd97bf5098e$var$transforms, formatType)) {
    const transform = $b0a0c0c8655104e8248dfbd97bf5098e$var$transforms[formatType];
    const typedTransform = transform;
    return typedTransform.pretty(configuration, value);
  }

  if (typeof value !== `string`) throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
  return $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, value, formatType);
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$pretty = $b0a0c0c8655104e8248dfbd97bf5098e$var$pretty;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.pretty = $b0a0c0c8655104e8248dfbd97bf5098e$export$pretty;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$prettyList(configuration, values, formatType, {
  separator = `, `
} = {}) {
  return [...values].map(value => $b0a0c0c8655104e8248dfbd97bf5098e$var$pretty(configuration, value, formatType)).join(separator);
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$prettyList = $b0a0c0c8655104e8248dfbd97bf5098e$var$prettyList;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.prettyList = $b0a0c0c8655104e8248dfbd97bf5098e$export$prettyList;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$json(value, formatType) {
  if (value === null) return null;

  if (Object.prototype.hasOwnProperty.call($b0a0c0c8655104e8248dfbd97bf5098e$var$transforms, formatType)) {
    $b0a0c0c8655104e8248dfbd97bf5098e$var$miscUtils.overrideType(formatType);
    return $b0a0c0c8655104e8248dfbd97bf5098e$var$transforms[formatType].json(value);
  }

  if (typeof value !== `string`) throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
  return value;
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$json = $b0a0c0c8655104e8248dfbd97bf5098e$var$json;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.json = $b0a0c0c8655104e8248dfbd97bf5098e$export$json;

function $b0a0c0c8655104e8248dfbd97bf5098e$var$mark(configuration) {
  return {
    Check: $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, ``, `green`),
    Cross: $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, ``, `red`),
    Question: $b0a0c0c8655104e8248dfbd97bf5098e$var$applyColor(configuration, `?`, `cyan`)
  };
}

var $b0a0c0c8655104e8248dfbd97bf5098e$export$mark = $b0a0c0c8655104e8248dfbd97bf5098e$var$mark;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.mark = $b0a0c0c8655104e8248dfbd97bf5098e$export$mark;
var $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel;

(function (LogLevel) {
  LogLevel["Error"] = "error";
  LogLevel["Warning"] = "warning";
  LogLevel["Info"] = "info";
  LogLevel["Discard"] = "discard";
})($b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel = $b0a0c0c8655104e8248dfbd97bf5098e$exports.LogLevel || ($b0a0c0c8655104e8248dfbd97bf5098e$export$LogLevel = {}, $b0a0c0c8655104e8248dfbd97bf5098e$exports.LogLevel = $b0a0c0c8655104e8248dfbd97bf5098e$export$LogLevel));
/**
 * Add support support for the `logFilters` setting to the specified Report
 * instance.
 */


/**
 * Add support support for the `logFilters` setting to the specified Report
 * instance.
 */
function $b0a0c0c8655104e8248dfbd97bf5098e$var$addLogFilterSupport(report, {
  configuration
}) {
  const logFilters = configuration.get(`logFilters`);
  const logFiltersByCode = new Map();
  const logFiltersByText = new Map();

  for (const filter of logFilters) {
    const level = filter.get(`level`);
    if (typeof level === `undefined`) continue;
    const code = filter.get(`code`);
    if (typeof code !== `undefined`) logFiltersByCode.set(code, level);
    const text = filter.get(`text`);

    if (typeof text !== `undefined`) {
      logFiltersByText.set(text, level);
    }
  }

  const findLogLevel = (name, text, defaultLevel) => {
    if (name === null || name === $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED) return defaultLevel;

    if (logFiltersByText.size > 0) {
      const level = logFiltersByText.get($b0a0c0c8655104e8248dfbd97bf5098e$var$chalk_1.default.reset(text));

      if (typeof level !== `undefined`) {
        return level !== null && level !== void 0 ? level : defaultLevel;
      }
    }

    if (logFiltersByCode.size > 0) {
      const level = logFiltersByCode.get($3d67898ffca54ab381ec6b3d32821fc7$exports.stringifyMessageName(name));

      if (typeof level !== `undefined`) {
        return level !== null && level !== void 0 ? level : defaultLevel;
      }
    }

    return defaultLevel;
  };

  const reportInfo = report.reportInfo;
  const reportWarning = report.reportWarning;
  const reportError = report.reportError;

  const routeMessage = function (report, name, text, level) {
    switch (findLogLevel(name, text, level)) {
      case $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Info:
        {
          reportInfo.call(report, name, text);
        }
        break;

      case $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Warning:
        {
          reportWarning.call(report, name !== null && name !== void 0 ? name : $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, text);
        }
        break;

      case $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Error:
        {
          reportError.call(report, name !== null && name !== void 0 ? name : $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, text);
        }
        break;
    }
  };

  report.reportInfo = function (...args) {
    return routeMessage(this, ...args, $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Info);
  };

  report.reportWarning = function (...args) {
    return routeMessage(this, ...args, $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Warning);
  };

  report.reportError = function (...args) {
    return routeMessage(this, ...args, $b0a0c0c8655104e8248dfbd97bf5098e$var$LogLevel.Error);
  };
}

$b0a0c0c8655104e8248dfbd97bf5098e$export$addLogFilterSupport = $b0a0c0c8655104e8248dfbd97bf5098e$var$addLogFilterSupport;
$b0a0c0c8655104e8248dfbd97bf5098e$exports.addLogFilterSupport = $b0a0c0c8655104e8248dfbd97bf5098e$export$addLogFilterSupport;
const $b0ffa420366ed37c7cf8ff798018d16e$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$formatUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$formatUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.formatUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$formatUtils;
const $b0ffa420366ed37c7cf8ff798018d16e$var$hashUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($d8692e28e950b48ea4715ab19e9bf9a1$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$hashUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$hashUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.hashUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$hashUtils;
// ASSET: node_modules/@yarnpkg/core/lib/httpUtils.js
var $c3e5d886185f7e0081994c42f78051e1$export$Method,
    $c3e5d886185f7e0081994c42f78051e1$exports = {};
var $c3e5d886185f7e0081994c42f78051e1$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($c3e5d886185f7e0081994c42f78051e1$exports, "__esModule", {
  value: true
});
var $c3e5d886185f7e0081994c42f78051e1$export$del = ($c3e5d886185f7e0081994c42f78051e1$export$post = ($c3e5d886185f7e0081994c42f78051e1$export$put = ($c3e5d886185f7e0081994c42f78051e1$export$get = ($c3e5d886185f7e0081994c42f78051e1$export$request = ($c3e5d886185f7e0081994c42f78051e1$export$Method = ($c3e5d886185f7e0081994c42f78051e1$export$getNetworkSettings = void 0, $c3e5d886185f7e0081994c42f78051e1$exports.getNetworkSettings = $c3e5d886185f7e0081994c42f78051e1$export$getNetworkSettings), $c3e5d886185f7e0081994c42f78051e1$exports.Method = $c3e5d886185f7e0081994c42f78051e1$export$Method), $c3e5d886185f7e0081994c42f78051e1$exports.request = $c3e5d886185f7e0081994c42f78051e1$export$request), $c3e5d886185f7e0081994c42f78051e1$exports.get = $c3e5d886185f7e0081994c42f78051e1$export$get), $c3e5d886185f7e0081994c42f78051e1$exports.put = $c3e5d886185f7e0081994c42f78051e1$export$put), $c3e5d886185f7e0081994c42f78051e1$exports.post = $c3e5d886185f7e0081994c42f78051e1$export$post);
$c3e5d886185f7e0081994c42f78051e1$exports.del = $c3e5d886185f7e0081994c42f78051e1$export$del;
// ASSET: node_modules/https-browserify/index.js
var $bda4231524fb9a1f0125f35dc87f459b$exports = {};
// ASSET: node_modules/stream-http/index.js
var $1921c9c2cca6a0568a1b152add32ce45$exports = {};
// ASSET: node_modules/stream-http/lib/request.js
var $a4eb1c70dd5831c0aed43022f65599be$exports = {};
var $a4eb1c70dd5831c0aed43022f65599be$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $a4eb1c70dd5831c0aed43022f65599be$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $5b0b546210b3fae93efcb9e47cdc62ca$export$fetch = $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction($parcel$global.fetch) && $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction($parcel$global.ReadableStream);
var $5b0b546210b3fae93efcb9e47cdc62ca$export$writableStream = $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction($parcel$global.WritableStream);
var $5b0b546210b3fae93efcb9e47cdc62ca$export$abortController = $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction($parcel$global.AbortController);
// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr;

function $5b0b546210b3fae93efcb9e47cdc62ca$var$getXHR() {
  // Cache the xhr value
  if ($5b0b546210b3fae93efcb9e47cdc62ca$var$xhr !== undefined) return $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr;

  if ($parcel$global.XMLHttpRequest) {
    $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr = new $parcel$global.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work
    // cross domain), use the page location. Otherwise use example.com
    // Note: this doesn't actually make an http request.

    // If XDomainRequest is available (ie only, where xhr might not work
    // cross domain), use the page location. Otherwise use example.com
    // Note: this doesn't actually make an http request.
    try {
      $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr.open('GET', $parcel$global.XDomainRequest ? '/' : 'https://example.com');
    } catch (e) {
      $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr = null;
    }
  } else {
    // Service workers don't have XHR
    $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr = null;
  }

  return $5b0b546210b3fae93efcb9e47cdc62ca$var$xhr;
}

function $5b0b546210b3fae93efcb9e47cdc62ca$var$checkTypeSupport(type) {
  var xhr = $5b0b546210b3fae93efcb9e47cdc62ca$var$getXHR();
  if (!xhr) return false;

  try {
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {}

  return false;
} // If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().


var $5b0b546210b3fae93efcb9e47cdc62ca$export$arraybuffer = $5b0b546210b3fae93efcb9e47cdc62ca$export$fetch || $5b0b546210b3fae93efcb9e47cdc62ca$var$checkTypeSupport('arraybuffer');
var $5b0b546210b3fae93efcb9e47cdc62ca$export$msstream = !$5b0b546210b3fae93efcb9e47cdc62ca$export$fetch && $5b0b546210b3fae93efcb9e47cdc62ca$var$checkTypeSupport('ms-stream');
var $5b0b546210b3fae93efcb9e47cdc62ca$export$mozchunkedarraybuffer = !$5b0b546210b3fae93efcb9e47cdc62ca$export$fetch && $5b0b546210b3fae93efcb9e47cdc62ca$var$checkTypeSupport('moz-chunked-arraybuffer');
var $5b0b546210b3fae93efcb9e47cdc62ca$export$overrideMimeType = $5b0b546210b3fae93efcb9e47cdc62ca$export$fetch || ($5b0b546210b3fae93efcb9e47cdc62ca$var$getXHR() ? $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction($5b0b546210b3fae93efcb9e47cdc62ca$var$getXHR().overrideMimeType) : false);

function $5b0b546210b3fae93efcb9e47cdc62ca$var$isFunction(value) {
  return typeof value === 'function';
}

$5b0b546210b3fae93efcb9e47cdc62ca$var$xhr = null; // Help gc

var $a4eb1c70dd5831c0aed43022f65599be$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/stream-http/lib/response.js
var $a16613f064f0224d9321f0e41442dfb0$export$readyStates, $a16613f064f0224d9321f0e41442dfb0$export$IncomingMessage;
var $a16613f064f0224d9321f0e41442dfb0$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $a16613f064f0224d9321f0e41442dfb0$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $a16613f064f0224d9321f0e41442dfb0$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $a16613f064f0224d9321f0e41442dfb0$var$rStates = ($a16613f064f0224d9321f0e41442dfb0$export$readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
}, $a16613f064f0224d9321f0e41442dfb0$export$readyStates);
var $a16613f064f0224d9321f0e41442dfb0$var$IncomingMessage = ($a16613f064f0224d9321f0e41442dfb0$export$IncomingMessage = function (xhr, response, mode, fetchTimer) {
  var self = this;
  $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable.call(self);
  self._mode = mode;
  self.headers = {};
  self.rawHeaders = [];
  self.trailers = {};
  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires

  // Fake the 'close' event, but only once 'end' fires
  self.on('end', function () {
    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
    $a16613f064f0224d9321f0e41442dfb0$var$process.nextTick(function () {
      self.emit('close');
    });
  });

  if (mode === 'fetch') {
    self._fetchResponse = response;
    self.url = response.url;
    self.statusCode = response.status;
    self.statusMessage = response.statusText;
    response.headers.forEach(function (header, key) {
      self.headers[key.toLowerCase()] = header;
      self.rawHeaders.push(key, header);
    });

    if ($5b0b546210b3fae93efcb9e47cdc62ca$export$writableStream) {
      var writable = new WritableStream({
        write: function (chunk) {
          return new Promise(function (resolve, reject) {
            if (self._destroyed) {
              reject();
            } else if (self.push($a16613f064f0224d9321f0e41442dfb0$var$Buffer.from(chunk))) {
              resolve();
            } else {
              self._resumeFetch = resolve;
            }
          });
        },
        close: function () {
          $parcel$global.clearTimeout(fetchTimer);
          if (!self._destroyed) self.push(null);
        },
        abort: function (err) {
          if (!self._destroyed) self.emit('error', err);
        }
      });

      try {
        response.body.pipeTo(writable).catch(function (err) {
          $parcel$global.clearTimeout(fetchTimer);
          if (!self._destroyed) self.emit('error', err);
        });
        return;
      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this

    } // fallback for when writableStream or pipeTo aren't available


    // fallback for when writableStream or pipeTo aren't available
    var reader = response.body.getReader();

    function read() {
      reader.read().then(function (result) {
        if (self._destroyed) return;

        if (result.done) {
          $parcel$global.clearTimeout(fetchTimer);
          self.push(null);
          return;
        }

        self.push($a16613f064f0224d9321f0e41442dfb0$var$Buffer.from(result.value));
        read();
      }).catch(function (err) {
        $parcel$global.clearTimeout(fetchTimer);
        if (!self._destroyed) self.emit('error', err);
      });
    }

    read();
  } else {
    self._xhr = xhr;
    self._pos = 0;
    self.url = xhr.responseURL;
    self.statusCode = xhr.status;
    self.statusMessage = xhr.statusText;
    var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function (header) {
      var matches = header.match(/^([^:]+):\s*(.*)/);

      if (matches) {
        var key = matches[1].toLowerCase();

        if (key === 'set-cookie') {
          if (self.headers[key] === undefined) {
            self.headers[key] = [];
          }

          self.headers[key].push(matches[2]);
        } else if (self.headers[key] !== undefined) {
          self.headers[key] += ', ' + matches[2];
        } else {
          self.headers[key] = matches[2];
        }

        self.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self._charset = 'x-user-defined';

    if (!$5b0b546210b3fae93efcb9e47cdc62ca$export$overrideMimeType) {
      var mimeType = self.rawHeaders['mime-type'];

      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);

        if (charsetMatch) {
          self._charset = charsetMatch[1].toLowerCase();
        }
      }

      if (!self._charset) self._charset = 'utf-8'; // best guess
    }
  }
}, $a16613f064f0224d9321f0e41442dfb0$export$IncomingMessage);
$a16613f064f0224d9321f0e41442dfb0$var$inherits($a16613f064f0224d9321f0e41442dfb0$var$IncomingMessage, $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable);

$a16613f064f0224d9321f0e41442dfb0$var$IncomingMessage.prototype._read = function () {
  var self = this;
  var resolve = self._resumeFetch;

  if (resolve) {
    self._resumeFetch = null;
    resolve();
  }
};

$a16613f064f0224d9321f0e41442dfb0$var$IncomingMessage.prototype._onXHRProgress = function () {
  var self = this;
  var xhr = self._xhr;
  var response = null;

  switch (self._mode) {
    case 'text':
      response = xhr.responseText;

      if (response.length > self._pos) {
        var newData = response.substr(self._pos);

        if (self._charset === 'x-user-defined') {
          var buffer = $a16613f064f0224d9321f0e41442dfb0$var$Buffer.alloc(newData.length);

          for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;

          self.push(buffer);
        } else {
          self.push(newData, self._charset);
        }

        self._pos = response.length;
      }

      break;

    case 'arraybuffer':
      if (xhr.readyState !== $a16613f064f0224d9321f0e41442dfb0$var$rStates.DONE || !xhr.response) break;
      response = xhr.response;
      self.push($a16613f064f0224d9321f0e41442dfb0$var$Buffer.from(new Uint8Array(response)));
      break;

    case 'moz-chunked-arraybuffer':
      // take whole
      response = xhr.response;
      if (xhr.readyState !== $a16613f064f0224d9321f0e41442dfb0$var$rStates.LOADING || !response) break;
      self.push($a16613f064f0224d9321f0e41442dfb0$var$Buffer.from(new Uint8Array(response)));
      break;

    case 'ms-stream':
      response = xhr.response;
      if (xhr.readyState !== $a16613f064f0224d9321f0e41442dfb0$var$rStates.LOADING) break;
      var reader = new $parcel$global.MSStreamReader();

      reader.onprogress = function () {
        if (reader.result.byteLength > self._pos) {
          self.push($a16613f064f0224d9321f0e41442dfb0$var$Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
          self._pos = reader.result.byteLength;
        }
      };

      reader.onload = function () {
        self.push(null);
      }; // reader.onerror = ??? // TODO: this


      // reader.onerror = ??? // TODO: this
      reader.readAsArrayBuffer(response);
      break;
  } // The ms-stream case handles end separately in reader.onload()


  // The ms-stream case handles end separately in reader.onload()
  if (self._xhr.readyState === $a16613f064f0224d9321f0e41442dfb0$var$rStates.DONE && self._mode !== 'ms-stream') {
    self.push(null);
  }
};

var $a4eb1c70dd5831c0aed43022f65599be$var$IncomingMessage = $a16613f064f0224d9321f0e41442dfb0$export$IncomingMessage;
var $a4eb1c70dd5831c0aed43022f65599be$var$rStates = $a16613f064f0224d9321f0e41442dfb0$export$readyStates;

function $a4eb1c70dd5831c0aed43022f65599be$var$decideMode(preferBinary, useFetch) {
  if ($5b0b546210b3fae93efcb9e47cdc62ca$export$fetch && useFetch) {
    return 'fetch';
  } else if ($5b0b546210b3fae93efcb9e47cdc62ca$export$mozchunkedarraybuffer) {
    return 'moz-chunked-arraybuffer';
  } else if ($5b0b546210b3fae93efcb9e47cdc62ca$export$msstream) {
    return 'ms-stream';
  } else if ($5b0b546210b3fae93efcb9e47cdc62ca$export$arraybuffer && preferBinary) {
    return 'arraybuffer';
  } else {
    return 'text';
  }
}

var $a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest = $a4eb1c70dd5831c0aed43022f65599be$exports = function (opts) {
  var self = this;
  $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable.call(self);
  self._opts = opts;
  self._body = [];
  self._headers = {};
  if (opts.auth) self.setHeader('Authorization', 'Basic ' + $a4eb1c70dd5831c0aed43022f65599be$var$Buffer.from(opts.auth).toString('base64'));
  Object.keys(opts.headers).forEach(function (name) {
    self.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;

  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !$5b0b546210b3fae93efcb9e47cdc62ca$export$abortController) {
    // If the use of XHR should be preferred. Not typically needed.
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === 'prefer-streaming') {
    // If streaming is a high priority but binary compatibility and
    // the accuracy of the 'content-type' header aren't
    preferBinary = false;
  } else if (opts.mode === 'allow-wrong-content-type') {
    // If streaming is more important than preserving the 'content-type' header
    preferBinary = !$5b0b546210b3fae93efcb9e47cdc62ca$export$overrideMimeType;
  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
    // Use binary if text streaming may corrupt data or the content-type header, or for speed
    preferBinary = true;
  } else {
    throw new Error('Invalid value for opts.mode');
  }

  self._mode = $a4eb1c70dd5831c0aed43022f65599be$var$decideMode(preferBinary, useFetch);
  self._fetchTimer = null;
  self.on('finish', function () {
    self._onFinish();
  });
};

$a4eb1c70dd5831c0aed43022f65599be$var$inherits($a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest, $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable);

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.setHeader = function (name, value) {
  var self = this;
  var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe
  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
  // http-browserify did it, so I will too.

  // This check is not necessary, but it prevents warnings from browsers about setting unsafe
  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
  // http-browserify did it, so I will too.
  if ($a4eb1c70dd5831c0aed43022f65599be$var$unsafeHeaders.indexOf(lowerName) !== -1) return;
  self._headers[lowerName] = {
    name: name,
    value: value
  };
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.getHeader = function (name) {
  var header = this._headers[name.toLowerCase()];

  if (header) return header.value;
  return null;
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.removeHeader = function (name) {
  var self = this;
  delete self._headers[name.toLowerCase()];
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype._onFinish = function () {
  var self = this;
  if (self._destroyed) return;
  var opts = self._opts;
  var headersObj = self._headers;
  var body = null;

  if (opts.method !== 'GET' && opts.method !== 'HEAD') {
    body = new Blob(self._body, {
      type: (headersObj['content-type'] || {}).value || ''
    });
  } // create flattened list of headers


  // create flattened list of headers
  var headersList = [];
  Object.keys(headersObj).forEach(function (keyName) {
    var name = headersObj[keyName].name;
    var value = headersObj[keyName].value;

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        headersList.push([name, v]);
      });
    } else {
      headersList.push([name, value]);
    }
  });

  if (self._mode === 'fetch') {
    var signal = null;

    if ($5b0b546210b3fae93efcb9e47cdc62ca$export$abortController) {
      var controller = new AbortController();
      signal = controller.signal;
      self._fetchAbortController = controller;

      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
        self._fetchTimer = $parcel$global.setTimeout(function () {
          self.emit('requestTimeout');
          if (self._fetchAbortController) self._fetchAbortController.abort();
        }, opts.requestTimeout);
      }
    }

    $parcel$global.fetch(self._opts.url, {
      method: self._opts.method,
      headers: headersList,
      body: body || undefined,
      mode: 'cors',
      credentials: opts.withCredentials ? 'include' : 'same-origin',
      signal: signal
    }).then(function (response) {
      self._fetchResponse = response;

      self._connect();
    }, function (reason) {
      $parcel$global.clearTimeout(self._fetchTimer);
      if (!self._destroyed) self.emit('error', reason);
    });
  } else {
    var xhr = self._xhr = new $parcel$global.XMLHttpRequest();

    try {
      xhr.open(self._opts.method, self._opts.url, true);
    } catch (err) {
      $a4eb1c70dd5831c0aed43022f65599be$var$process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    } // Can't set responseType on really old browsers


    // Can't set responseType on really old browsers
    if ('responseType' in xhr) xhr.responseType = self._mode;
    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;
    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

    if ('requestTimeout' in opts) {
      xhr.timeout = opts.requestTimeout;

      xhr.ontimeout = function () {
        self.emit('requestTimeout');
      };
    }

    headersList.forEach(function (header) {
      xhr.setRequestHeader(header[0], header[1]);
    });
    self._response = null;

    xhr.onreadystatechange = function () {
      switch (xhr.readyState) {
        case $a4eb1c70dd5831c0aed43022f65599be$var$rStates.LOADING:
        case $a4eb1c70dd5831c0aed43022f65599be$var$rStates.DONE:
          self._onXHRProgress();

          break;
      }
    }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined
    // in onprogress, not in onreadystatechange with xhr.readyState = 3


    // Necessary for streaming in Firefox, since xhr.response is ONLY defined
    // in onprogress, not in onreadystatechange with xhr.readyState = 3
    if (self._mode === 'moz-chunked-arraybuffer') {
      xhr.onprogress = function () {
        self._onXHRProgress();
      };
    }

    xhr.onerror = function () {
      if (self._destroyed) return;
      self.emit('error', new Error('XHR error'));
    };

    try {
      xhr.send(body);
    } catch (err) {
      $a4eb1c70dd5831c0aed43022f65599be$var$process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    }
  }
};
/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */


/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function $a4eb1c70dd5831c0aed43022f65599be$var$statusValid(xhr) {
  try {
    var status = xhr.status;
    return status !== null && status !== 0;
  } catch (e) {
    return false;
  }
}

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype._onXHRProgress = function () {
  var self = this;
  if (!$a4eb1c70dd5831c0aed43022f65599be$var$statusValid(self._xhr) || self._destroyed) return;
  if (!self._response) self._connect();

  self._response._onXHRProgress();
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype._connect = function () {
  var self = this;
  if (self._destroyed) return;
  self._response = new $a4eb1c70dd5831c0aed43022f65599be$var$IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);

  self._response.on('error', function (err) {
    self.emit('error', err);
  });

  self.emit('response', self._response);
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype._write = function (chunk, encoding, cb) {
  var self = this;

  self._body.push(chunk);

  cb();
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.abort = $a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.destroy = function () {
  var self = this;
  self._destroyed = true;
  $parcel$global.clearTimeout(self._fetchTimer);
  if (self._response) self._response._destroyed = true;
  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.end = function (data, encoding, cb) {
  var self = this;

  if (typeof data === 'function') {
    cb = data;
    data = undefined;
  }

  $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable.prototype.end.call(self, data, encoding, cb);
};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.flushHeaders = function () {};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.setTimeout = function () {};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.setNoDelay = function () {};

$a4eb1c70dd5831c0aed43022f65599be$var$ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method


// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var $a4eb1c70dd5831c0aed43022f65599be$var$unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];
// ASSET: node_modules/xtend/immutable.js
var $ee65a243a82ea2729bccdd7431248ed3$exports = {};
$ee65a243a82ea2729bccdd7431248ed3$exports = $ee65a243a82ea2729bccdd7431248ed3$var$extend;
var $ee65a243a82ea2729bccdd7431248ed3$var$hasOwnProperty = Object.prototype.hasOwnProperty;

function $ee65a243a82ea2729bccdd7431248ed3$var$extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if ($ee65a243a82ea2729bccdd7431248ed3$var$hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

// ASSET: node_modules/builtin-status-codes/browser.js
var $e1b2443ce680100348c69e1223c8bff1$exports = {};
$e1b2443ce680100348c69e1223c8bff1$exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
// ASSET: polyfills/url.js
var $01fe9125d93857b2c37f913e6e158a9e$exports,
    $01fe9125d93857b2c37f913e6e158a9e$var$url,
    $01fe9125d93857b2c37f913e6e158a9e$executed = false;

function $01fe9125d93857b2c37f913e6e158a9e$exec() {
  $01fe9125d93857b2c37f913e6e158a9e$exports = {};
  $01fe9125d93857b2c37f913e6e158a9e$var$url = $01fe9125d93857b2c37f913e6e158a9e$init();
  $01fe9125d93857b2c37f913e6e158a9e$exports = { ...$01fe9125d93857b2c37f913e6e158a9e$var$url,
    URL
  };
}

function $01fe9125d93857b2c37f913e6e158a9e$init() {
  if (!$01fe9125d93857b2c37f913e6e158a9e$executed) {
    $01fe9125d93857b2c37f913e6e158a9e$executed = true;
    $01fe9125d93857b2c37f913e6e158a9e$exec();
  }

  return $01fe9125d93857b2c37f913e6e158a9e$exports;
}

var $1921c9c2cca6a0568a1b152add32ce45$var$url = $01fe9125d93857b2c37f913e6e158a9e$init();

$1921c9c2cca6a0568a1b152add32ce45$exports.request = function (opts, cb) {
  if (typeof opts === 'string') opts = $1921c9c2cca6a0568a1b152add32ce45$var$url.parse(opts);else opts = $ee65a243a82ea2729bccdd7431248ed3$exports(opts); // Normally, the page is loaded from http or https, so not specifying a protocol
  // will result in a (valid) protocol-relative url. However, this won't work if
  // the protocol is something else, like 'file:'

  // Normally, the page is loaded from http or https, so not specifying a protocol
  // will result in a (valid) protocol-relative url. However, this won't work if
  // the protocol is something else, like 'file:'
  var defaultProtocol = $parcel$global.location && $parcel$global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || '/'; // Necessary for IPv6 addresses

  // Necessary for IPv6 addresses
  if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.

  // This may be a relative url. The browser should always be able to interpret it correctly.
  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
  opts.method = (opts.method || 'GET').toUpperCase();
  opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode

  // Also valid opts.auth, opts.mode
  var req = new $a4eb1c70dd5831c0aed43022f65599be$exports(opts);
  if (cb) req.on('response', cb);
  return req;
};

$1921c9c2cca6a0568a1b152add32ce45$exports.get = function get(opts, cb) {
  var req = $1921c9c2cca6a0568a1b152add32ce45$exports.request(opts, cb);
  req.end();
  return req;
};

$1921c9c2cca6a0568a1b152add32ce45$exports.ClientRequest = $a4eb1c70dd5831c0aed43022f65599be$exports;
$1921c9c2cca6a0568a1b152add32ce45$exports.IncomingMessage = $a16613f064f0224d9321f0e41442dfb0$export$IncomingMessage;

$1921c9c2cca6a0568a1b152add32ce45$exports.Agent = function () {};

$1921c9c2cca6a0568a1b152add32ce45$exports.Agent.defaultMaxSockets = 4;
$1921c9c2cca6a0568a1b152add32ce45$exports.globalAgent = new $1921c9c2cca6a0568a1b152add32ce45$exports.Agent();
$1921c9c2cca6a0568a1b152add32ce45$exports.STATUS_CODES = $e1b2443ce680100348c69e1223c8bff1$exports;
$1921c9c2cca6a0568a1b152add32ce45$exports.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];
var $bda4231524fb9a1f0125f35dc87f459b$var$url = $01fe9125d93857b2c37f913e6e158a9e$init();

for (var $bda4231524fb9a1f0125f35dc87f459b$var$key in $1921c9c2cca6a0568a1b152add32ce45$exports) {
  if ($1921c9c2cca6a0568a1b152add32ce45$exports.hasOwnProperty($bda4231524fb9a1f0125f35dc87f459b$var$key)) $bda4231524fb9a1f0125f35dc87f459b$exports[$bda4231524fb9a1f0125f35dc87f459b$var$key] = $1921c9c2cca6a0568a1b152add32ce45$exports[$bda4231524fb9a1f0125f35dc87f459b$var$key];
}

$bda4231524fb9a1f0125f35dc87f459b$exports.request = function (params, cb) {
  params = $bda4231524fb9a1f0125f35dc87f459b$var$validateParams(params);
  return $1921c9c2cca6a0568a1b152add32ce45$exports.request.call(this, params, cb);
};

$bda4231524fb9a1f0125f35dc87f459b$exports.get = function (params, cb) {
  params = $bda4231524fb9a1f0125f35dc87f459b$var$validateParams(params);
  return $1921c9c2cca6a0568a1b152add32ce45$exports.get.call(this, params, cb);
};

function $bda4231524fb9a1f0125f35dc87f459b$var$validateParams(params) {
  if (typeof params === 'string') {
    params = $bda4231524fb9a1f0125f35dc87f459b$var$url.parse(params);
  }

  if (!params.protocol) {
    params.protocol = 'https:';
  }

  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
  }

  return params;
}

const $c3e5d886185f7e0081994c42f78051e1$var$micromatch_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($c8e139b8ad76c5430a20f7d24c8c66b6$exports);
// ASSET: node_modules/tunnel/index.js
var $cb3f3ca7828de11699e59d46688ee46f$exports = {};
// ASSET: node_modules/tunnel/lib/tunnel.js
var $c9d7d853bd3c8bdbc2a601659e567599$exports = {};
var $c9d7d853bd3c8bdbc2a601659e567599$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $c9d7d853bd3c8bdbc2a601659e567599$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $c9d7d853bd3c8bdbc2a601659e567599$var$tls = {};
var $c9d7d853bd3c8bdbc2a601659e567599$var$assert = $034bb26d820f8530f21df3dfc0306a11$init();
var $c9d7d853bd3c8bdbc2a601659e567599$var$util = $69678d3e0618202337016e1b4ed76965$init();
var $c9d7d853bd3c8bdbc2a601659e567599$export$httpOverHttp = $c9d7d853bd3c8bdbc2a601659e567599$var$httpOverHttp;
$c9d7d853bd3c8bdbc2a601659e567599$exports.httpOverHttp = $c9d7d853bd3c8bdbc2a601659e567599$export$httpOverHttp;
var $c9d7d853bd3c8bdbc2a601659e567599$export$httpsOverHttp = $c9d7d853bd3c8bdbc2a601659e567599$var$httpsOverHttp;
$c9d7d853bd3c8bdbc2a601659e567599$exports.httpsOverHttp = $c9d7d853bd3c8bdbc2a601659e567599$export$httpsOverHttp;
var $c9d7d853bd3c8bdbc2a601659e567599$export$httpOverHttps = $c9d7d853bd3c8bdbc2a601659e567599$var$httpOverHttps;
$c9d7d853bd3c8bdbc2a601659e567599$exports.httpOverHttps = $c9d7d853bd3c8bdbc2a601659e567599$export$httpOverHttps;
var $c9d7d853bd3c8bdbc2a601659e567599$export$httpsOverHttps = $c9d7d853bd3c8bdbc2a601659e567599$var$httpsOverHttps;
$c9d7d853bd3c8bdbc2a601659e567599$exports.httpsOverHttps = $c9d7d853bd3c8bdbc2a601659e567599$export$httpsOverHttps;

function $c9d7d853bd3c8bdbc2a601659e567599$var$httpOverHttp(options) {
  var agent = new $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent(options);
  agent.request = $1921c9c2cca6a0568a1b152add32ce45$exports.request;
  return agent;
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$httpsOverHttp(options) {
  var agent = new $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent(options);
  agent.request = $1921c9c2cca6a0568a1b152add32ce45$exports.request;
  agent.createSocket = $c9d7d853bd3c8bdbc2a601659e567599$var$createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$httpOverHttps(options) {
  var agent = new $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent(options);
  agent.request = $bda4231524fb9a1f0125f35dc87f459b$exports.request;
  return agent;
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$httpsOverHttps(options) {
  var agent = new $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent(options);
  agent.request = $bda4231524fb9a1f0125f35dc87f459b$exports.request;
  agent.createSocket = $c9d7d853bd3c8bdbc2a601659e567599$var$createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || $1921c9c2cca6a0568a1b152add32ce45$exports.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];
  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = $c9d7d853bd3c8bdbc2a601659e567599$var$toOptions(host, port, localAddress);

    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];

      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }

    socket.destroy();
    self.removeSocket(socket);
  });
}

$c9d7d853bd3c8bdbc2a601659e567599$var$util.inherits($c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent, $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter);

$c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = $c9d7d853bd3c8bdbc2a601659e567599$var$mergeOptions({
    request: req
  }, self.options, $c9d7d853bd3c8bdbc2a601659e567599$var$toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  } // If we are under maxSockets create a new one.


  // If we are under maxSockets create a new one.
  self.createSocket(options, function (socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

$c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);
  var connectOptions = $c9d7d853bd3c8bdbc2a601659e567599$var$mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });

  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }

  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new $c9d7d853bd3c8bdbc2a601659e567599$var$Buffer(connectOptions.proxyAuth).toString('base64');
  }

  $c9d7d853bd3c8bdbc2a601659e567599$var$debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6

  // for v0.6
  connectReq.once('response', onResponse); // for v0.6

  // for v0.6
  connectReq.once('upgrade', onUpgrade); // for v0.6

  // for v0.6
  connectReq.once('connect', onConnect); // for v0.7 or later

  // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    $c9d7d853bd3c8bdbc2a601659e567599$var$process.nextTick(function () {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      $c9d7d853bd3c8bdbc2a601659e567599$var$debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }

    if (head.length > 0) {
      $c9d7d853bd3c8bdbc2a601659e567599$var$debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }

    $c9d7d853bd3c8bdbc2a601659e567599$var$debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();
    $c9d7d853bd3c8bdbc2a601659e567599$var$debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

$c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket);

  if (pos === -1) {
    return;
  }

  this.sockets.splice(pos, 1);
  var pending = this.requests.shift();

  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function (socket) {
      pending.request.onSocket(socket);
    });
  }
};

function $c9d7d853bd3c8bdbc2a601659e567599$var$createSecureSocket(options, cb) {
  var self = this;
  $c9d7d853bd3c8bdbc2a601659e567599$var$TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = $c9d7d853bd3c8bdbc2a601659e567599$var$mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    }); // 0 is dummy port for v0.6

    // 0 is dummy port for v0.6
    var secureSocket = $c9d7d853bd3c8bdbc2a601659e567599$var$tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$toOptions(host, port, localAddress) {
  if (typeof host === 'string') {
    // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }

  return host; // for v0.11 or later
}

function $c9d7d853bd3c8bdbc2a601659e567599$var$mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];

    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);

      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];

        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }

  return target;
}

var $c9d7d853bd3c8bdbc2a601659e567599$var$debug;

if (undefined && /\btunnel\b/.test(undefined)) {
  $c9d7d853bd3c8bdbc2a601659e567599$var$debug = function () {
    var args = Array.prototype.slice.call(arguments);

    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }

    console.error.apply(console, args);
  };
} else {
  $c9d7d853bd3c8bdbc2a601659e567599$var$debug = function () {};
}

var $c9d7d853bd3c8bdbc2a601659e567599$export$debug = $c9d7d853bd3c8bdbc2a601659e567599$var$debug;
$c9d7d853bd3c8bdbc2a601659e567599$exports.debug = $c9d7d853bd3c8bdbc2a601659e567599$export$debug; // for test

$cb3f3ca7828de11699e59d46688ee46f$exports = $c9d7d853bd3c8bdbc2a601659e567599$exports;
const $c3e5d886185f7e0081994c42f78051e1$var$tunnel_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($cb3f3ca7828de11699e59d46688ee46f$exports);
const $c3e5d886185f7e0081994c42f78051e1$var$url_1 = $01fe9125d93857b2c37f913e6e158a9e$init();
const $c3e5d886185f7e0081994c42f78051e1$var$cache = new Map();
const $c3e5d886185f7e0081994c42f78051e1$var$certCache = new Map();
const $c3e5d886185f7e0081994c42f78051e1$var$globalHttpAgent = new $1921c9c2cca6a0568a1b152add32ce45$exports.Agent({
  keepAlive: true
});
const $c3e5d886185f7e0081994c42f78051e1$var$globalHttpsAgent = new $bda4231524fb9a1f0125f35dc87f459b$exports.Agent({
  keepAlive: true
});

function $c3e5d886185f7e0081994c42f78051e1$var$parseProxy(specifier) {
  const url = new $c3e5d886185f7e0081994c42f78051e1$var$url_1.URL(specifier);
  const proxy = {
    host: url.hostname,
    headers: {}
  };
  if (url.port) proxy.port = Number(url.port);
  return {
    proxy
  };
}

async function $c3e5d886185f7e0081994c42f78051e1$var$getCachedCertificate(caFilePath) {
  let certificate = $c3e5d886185f7e0081994c42f78051e1$var$certCache.get(caFilePath);

  if (!certificate) {
    certificate = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(caFilePath).then(cert => {
      $c3e5d886185f7e0081994c42f78051e1$var$certCache.set(caFilePath, cert);
      return cert;
    });
    $c3e5d886185f7e0081994c42f78051e1$var$certCache.set(caFilePath, certificate);
  }

  return certificate;
}
/**
 * Searches through networkSettings and returns the most specific match
 */


/**
 * Searches through networkSettings and returns the most specific match
 */
function $c3e5d886185f7e0081994c42f78051e1$var$getNetworkSettings(target, opts) {
  // Sort the config by key length to match on the most specific pattern
  const networkSettings = [...opts.configuration.get(`networkSettings`)].sort(([keyA], [keyB]) => {
    return keyB.length - keyA.length;
  });
  const mergedNetworkSettings = {
    enableNetwork: undefined,
    caFilePath: undefined,
    httpProxy: undefined,
    httpsProxy: undefined
  };
  const mergableKeys = Object.keys(mergedNetworkSettings);
  const url = new $c3e5d886185f7e0081994c42f78051e1$var$url_1.URL(target);

  for (const [glob, config] of networkSettings) {
    if ($c3e5d886185f7e0081994c42f78051e1$var$micromatch_1.default.isMatch(url.hostname, glob)) {
      for (const key of mergableKeys) {
        const setting = config.get(key);

        if (setting !== null && typeof mergedNetworkSettings[key] === `undefined`) {
          mergedNetworkSettings[key] = setting;
        }
      }
    }
  } // Apply defaults


  // Apply defaults
  for (const key of mergableKeys) {
    if (typeof mergedNetworkSettings[key] === `undefined`) {
      mergedNetworkSettings[key] = opts.configuration.get(key);
    }
  }

  return mergedNetworkSettings;
}

var $c3e5d886185f7e0081994c42f78051e1$export$getNetworkSettings = $c3e5d886185f7e0081994c42f78051e1$var$getNetworkSettings;
$c3e5d886185f7e0081994c42f78051e1$exports.getNetworkSettings = $c3e5d886185f7e0081994c42f78051e1$export$getNetworkSettings;
// ASSET: polyfills/got.js
var $b1922c2a723c91ba566558ef852a9896$exports = {};
const {
  Buffer: $b1922c2a723c91ba566558ef852a9896$var$Buffer
} = $4bb8553ea3f2a3c18bc67044f716b1cc$init();

function $b1922c2a723c91ba566558ef852a9896$var$fetchWithTimeout(timeoutDuration, url, options) {
  if (timeoutDuration == null || timeoutDuration === 0) {
    return fetch(url, options);
  }

  const controller = new AbortController();
  const signal = controller.signal;
  const timeout = setTimeout(() => {
    controller.abort();
  }, timeoutDuration);
  return fetch(url, { ...options,
    signal
  }).then(res => (clearTimeout(timeout), res), res => (clearTimeout(timeout), res));
}

let $b1922c2a723c91ba566558ef852a9896$var$registry;

function $b1922c2a723c91ba566558ef852a9896$export$__setRegistry(r) {
  $b1922c2a723c91ba566558ef852a9896$var$registry = r;
}

$parcel$export($b1922c2a723c91ba566558ef852a9896$exports, "__setRegistry", function () {
  return $b1922c2a723c91ba566558ef852a9896$export$__setRegistry;
});

function $b1922c2a723c91ba566558ef852a9896$export$extend(options) {
  var _options$timeout, _options$responseType;

  let timeoutDuration = options === null || options === void 0 ? void 0 : (_options$timeout = options.timeout) === null || _options$timeout === void 0 ? void 0 : _options$timeout.socket;
  let responseType = (_options$responseType = options === null || options === void 0 ? void 0 : options.responseType) !== null && _options$responseType !== void 0 ? _options$responseType : "text";
  let fetchOptions = {
    method: options.method
  };
  return url => $b1922c2a723c91ba566558ef852a9896$var$fetchWithTimeout(timeoutDuration, url.replace("registry.npmjs.org", $b1922c2a723c91ba566558ef852a9896$var$registry), fetchOptions).then(res => {
    if (!res.ok) {
      throw res;
    } else {
      return res;
    }
  }).then(async res => {
    let body;

    if (responseType === "buffer") {
      body = $b1922c2a723c91ba566558ef852a9896$var$Buffer.from(await res.arrayBuffer());
    } else if (responseType === "text") {
      body = await res.text();
    } else if (responseType === "json") {
      body = await res.json();
    }

    return {
      body
    };
  });
}

$parcel$export($b1922c2a723c91ba566558ef852a9896$exports, "extend", function () {
  return $b1922c2a723c91ba566558ef852a9896$export$extend;
});
var $c3e5d886185f7e0081994c42f78051e1$var$got_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b1922c2a723c91ba566558ef852a9896$exports);
var $c3e5d886185f7e0081994c42f78051e1$var$Method;

(function (Method) {
  Method["GET"] = "GET";
  Method["PUT"] = "PUT";
  Method["POST"] = "POST";
  Method["DELETE"] = "DELETE";
})($c3e5d886185f7e0081994c42f78051e1$var$Method = $c3e5d886185f7e0081994c42f78051e1$exports.Method || ($c3e5d886185f7e0081994c42f78051e1$export$Method = {}, $c3e5d886185f7e0081994c42f78051e1$exports.Method = $c3e5d886185f7e0081994c42f78051e1$export$Method));

async function $c3e5d886185f7e0081994c42f78051e1$var$request(target, body, {
  configuration,
  headers,
  json,
  jsonRequest = json,
  jsonResponse = json,
  method = $c3e5d886185f7e0081994c42f78051e1$var$Method.GET
}) {
  const networkConfig = $c3e5d886185f7e0081994c42f78051e1$var$getNetworkSettings(target, {
    configuration
  });
  if (networkConfig.enableNetwork === false) throw new Error(`Request to '${target}' has been blocked because of your configuration settings`);
  const url = new $c3e5d886185f7e0081994c42f78051e1$var$url_1.URL(target);
  if (url.protocol === `http:` && !$c3e5d886185f7e0081994c42f78051e1$var$micromatch_1.default.isMatch(url.hostname, configuration.get(`unsafeHttpWhitelist`))) throw new Error(`Unsafe http requests must be explicitly whitelisted in your configuration (${url.hostname})`);
  const agent = {
    http: networkConfig.httpProxy ? $c3e5d886185f7e0081994c42f78051e1$var$tunnel_1.default.httpOverHttp($c3e5d886185f7e0081994c42f78051e1$var$parseProxy(networkConfig.httpProxy)) : $c3e5d886185f7e0081994c42f78051e1$var$globalHttpAgent,
    https: networkConfig.httpsProxy ? $c3e5d886185f7e0081994c42f78051e1$var$tunnel_1.default.httpsOverHttp($c3e5d886185f7e0081994c42f78051e1$var$parseProxy(networkConfig.httpsProxy)) : $c3e5d886185f7e0081994c42f78051e1$var$globalHttpsAgent
  };
  const gotOptions = {
    agent,
    headers,
    method
  };
  gotOptions.responseType = jsonResponse ? `json` : `buffer`;

  if (body !== null) {
    if ($c3e5d886185f7e0081994c42f78051e1$var$Buffer.isBuffer(body) || !jsonRequest && typeof body === `string`) {
      gotOptions.body = body;
    } else {
      // @ts-expect-error: The got types only allow an object, but got can stringify any valid JSON
      gotOptions.json = body;
    }
  }

  const socketTimeout = configuration.get(`httpTimeout`);
  const retry = configuration.get(`httpRetry`);
  const rejectUnauthorized = configuration.get(`enableStrictSsl`);
  const caFilePath = networkConfig.caFilePath;
  const {
    default: got
  } = $c3e5d886185f7e0081994c42f78051e1$var$got_1;
  const certificateAuthority = caFilePath ? await $c3e5d886185f7e0081994c42f78051e1$var$getCachedCertificate(caFilePath) : undefined;
  const gotClient = got.extend({
    timeout: {
      socket: socketTimeout
    },
    retry,
    https: {
      rejectUnauthorized,
      certificateAuthority
    },
    ...gotOptions
  });
  return configuration.getLimit(`networkConcurrency`)(() => {
    return gotClient(target);
  });
}

var $c3e5d886185f7e0081994c42f78051e1$export$request = $c3e5d886185f7e0081994c42f78051e1$var$request;
$c3e5d886185f7e0081994c42f78051e1$exports.request = $c3e5d886185f7e0081994c42f78051e1$export$request;

async function $c3e5d886185f7e0081994c42f78051e1$var$get(target, {
  configuration,
  json,
  jsonResponse = json,
  ...rest
}) {
  let entry = $c3e5d886185f7e0081994c42f78051e1$var$cache.get(target);

  if (!entry) {
    entry = $c3e5d886185f7e0081994c42f78051e1$var$request(target, null, {
      configuration,
      ...rest
    }).then(response => {
      $c3e5d886185f7e0081994c42f78051e1$var$cache.set(target, response.body);
      return response.body;
    });
    $c3e5d886185f7e0081994c42f78051e1$var$cache.set(target, entry);
  }

  if ($c3e5d886185f7e0081994c42f78051e1$var$Buffer.isBuffer(entry) === false) entry = await entry;

  if (jsonResponse) {
    return JSON.parse(entry.toString());
  } else {
    return entry;
  }
}

var $c3e5d886185f7e0081994c42f78051e1$export$get = $c3e5d886185f7e0081994c42f78051e1$var$get;
$c3e5d886185f7e0081994c42f78051e1$exports.get = $c3e5d886185f7e0081994c42f78051e1$export$get;

async function $c3e5d886185f7e0081994c42f78051e1$var$put(target, body, options) {
  const response = await $c3e5d886185f7e0081994c42f78051e1$var$request(target, body, { ...options,
    method: $c3e5d886185f7e0081994c42f78051e1$var$Method.PUT
  });
  return response.body;
}

var $c3e5d886185f7e0081994c42f78051e1$export$put = $c3e5d886185f7e0081994c42f78051e1$var$put;
$c3e5d886185f7e0081994c42f78051e1$exports.put = $c3e5d886185f7e0081994c42f78051e1$export$put;

async function $c3e5d886185f7e0081994c42f78051e1$var$post(target, body, options) {
  const response = await $c3e5d886185f7e0081994c42f78051e1$var$request(target, body, { ...options,
    method: $c3e5d886185f7e0081994c42f78051e1$var$Method.POST
  });
  return response.body;
}

var $c3e5d886185f7e0081994c42f78051e1$export$post = $c3e5d886185f7e0081994c42f78051e1$var$post;
$c3e5d886185f7e0081994c42f78051e1$exports.post = $c3e5d886185f7e0081994c42f78051e1$export$post;

async function $c3e5d886185f7e0081994c42f78051e1$var$del(target, options) {
  const response = await $c3e5d886185f7e0081994c42f78051e1$var$request(target, null, { ...options,
    method: $c3e5d886185f7e0081994c42f78051e1$var$Method.DELETE
  });
  return response.body;
}

$c3e5d886185f7e0081994c42f78051e1$export$del = $c3e5d886185f7e0081994c42f78051e1$var$del;
$c3e5d886185f7e0081994c42f78051e1$exports.del = $c3e5d886185f7e0081994c42f78051e1$export$del;
const $b0ffa420366ed37c7cf8ff798018d16e$var$httpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($c3e5d886185f7e0081994c42f78051e1$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$httpUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$httpUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$httpUtils;
const $b0ffa420366ed37c7cf8ff798018d16e$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$miscUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$miscUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$miscUtils;
// ASSET: node_modules/@yarnpkg/core/lib/scriptUtils.js
var $6881e9a961a5fe3922a1e41f40f331a3$exports = {};
var $6881e9a961a5fe3922a1e41f40f331a3$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($6881e9a961a5fe3922a1e41f40f331a3$exports, "__esModule", {
  value: true
});
var $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceAccessibleBinary = ($6881e9a961a5fe3922a1e41f40f331a3$export$executePackageAccessibleBinary = ($6881e9a961a5fe3922a1e41f40f331a3$export$getWorkspaceAccessibleBinaries = ($6881e9a961a5fe3922a1e41f40f331a3$export$getPackageAccessibleBinaries = ($6881e9a961a5fe3922a1e41f40f331a3$export$maybeExecuteWorkspaceLifecycleScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceLifecycleScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$hasWorkspaceScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$executePackageShellcode = ($6881e9a961a5fe3922a1e41f40f331a3$export$executePackageScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$hasPackageScript = ($6881e9a961a5fe3922a1e41f40f331a3$export$prepareExternalProject = ($6881e9a961a5fe3922a1e41f40f331a3$export$makeScriptEnv = void 0, $6881e9a961a5fe3922a1e41f40f331a3$exports.makeScriptEnv = $6881e9a961a5fe3922a1e41f40f331a3$export$makeScriptEnv), $6881e9a961a5fe3922a1e41f40f331a3$exports.prepareExternalProject = $6881e9a961a5fe3922a1e41f40f331a3$export$prepareExternalProject), $6881e9a961a5fe3922a1e41f40f331a3$exports.hasPackageScript = $6881e9a961a5fe3922a1e41f40f331a3$export$hasPackageScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageShellcode = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageShellcode), $6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.hasWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$export$hasWorkspaceScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceLifecycleScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.maybeExecuteWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$export$maybeExecuteWorkspaceLifecycleScript), $6881e9a961a5fe3922a1e41f40f331a3$exports.getPackageAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$export$getPackageAccessibleBinaries), $6881e9a961a5fe3922a1e41f40f331a3$exports.getWorkspaceAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$export$getWorkspaceAccessibleBinaries), $6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageAccessibleBinary);
$6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceAccessibleBinary;
// ASSET: node_modules/@yarnpkg/libzip/lib/libzipAsync.js
var $1b7420e6729c607d8a3cbf589616cbdf$exports,
    $1b7420e6729c607d8a3cbf589616cbdf$executed = false;

function $1b7420e6729c607d8a3cbf589616cbdf$exec() {
  $1b7420e6729c607d8a3cbf589616cbdf$exports = function () {
    var exports = this;
    var module = {
      exports: this
    };
    var __dirname = "/home/yann/yarn-browser/node_modules/@yarnpkg/libzip/lib";
    var process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
    var Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
    var frozenFs = Object.assign({}, $4b4b2ca65c544aeebbd8703f9d50bd90$init());
    var Module = typeof Module !== "undefined" ? Module : {};
    var moduleOverrides = {};
    var key;

    for (key in Module) {
      if (Module.hasOwnProperty(key)) {
        moduleOverrides[key] = Module[key];
      }
    }

    var arguments_ = [];
    var thisProgram = "./this.program";

    var quit_ = function (status, toThrow) {
      throw toThrow;
    };

    var ENVIRONMENT_IS_WEB = false;
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = true;
    var scriptDirectory = "";

    function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      }

      return scriptDirectory + path;
    }

    var read_, readBinary;
    var nodeFS;
    var nodePath;

    if (ENVIRONMENT_IS_NODE) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = $0111874a9358ffa1d71ad8eb9f6f16f8$init().dirname(scriptDirectory) + "/";
      } else {
        scriptDirectory = __dirname + "/";
      }

      read_ = function shell_read(filename, binary) {
        var ret = tryParseAsDataURI(filename);

        if (ret) {
          return binary ? ret : ret.toString();
        }

        if (!nodeFS) nodeFS = frozenFs;
        if (!nodePath) nodePath = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
        filename = nodePath["normalize"](filename);
        return nodeFS["readFileSync"](filename, binary ? null : "utf8");
      };

      readBinary = function readBinary(filename) {
        var ret = read_(filename, true);

        if (!ret.buffer) {
          ret = new Uint8Array(ret);
        }

        assert(ret.buffer);
        return ret;
      };

      if (process["argv"].length > 1) {
        thisProgram = process["argv"][1].replace(/\\/g, "/");
      }

      arguments_ = process["argv"].slice(2);

      if (typeof module !== "undefined") {
        module["exports"] = Module;
      }

      quit_ = function (status) {
        process["exit"](status);
      };

      Module["inspect"] = function () {
        return "[Emscripten Module object]";
      };
    } else {}

    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.warn.bind(console);

    for (key in moduleOverrides) {
      if (moduleOverrides.hasOwnProperty(key)) {
        Module[key] = moduleOverrides[key];
      }
    }

    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    if (Module["quit"]) quit_ = Module["quit"];
    var STACK_ALIGN = 16;

    function alignMemory(size, factor) {
      if (!factor) factor = STACK_ALIGN;
      return Math.ceil(size / factor) * factor;
    }

    var tempRet0 = 0;

    var setTempRet0 = function (value) {
      tempRet0 = value;
    };

    var wasmBinary;
    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
    var noExitRuntime;
    if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];

    if (typeof WebAssembly !== "object") {
      abort("no native wasm support detected");
    }

    function getValue(ptr, type, noSafe) {
      type = type || "i8";
      if (type.charAt(type.length - 1) === "*") type = "i32";

      switch (type) {
        case "i1":
          return HEAP8[ptr >> 0];

        case "i8":
          return HEAP8[ptr >> 0];

        case "i16":
          return HEAP16[ptr >> 1];

        case "i32":
          return HEAP32[ptr >> 2];

        case "i64":
          return HEAP32[ptr >> 2];

        case "float":
          return HEAPF32[ptr >> 2];

        case "double":
          return HEAPF64[ptr >> 3];

        default:
          abort("invalid type for getValue: " + type);
      }

      return null;
    }

    var wasmMemory;
    var wasmTable = new WebAssembly.Table({
      initial: 31,
      maximum: 31,
      element: "anyfunc"
    });
    var ABORT = false;
    var EXITSTATUS = 0;

    function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed: " + text);
      }
    }

    function getCFunc(ident) {
      var func = Module["_" + ident];
      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
      return func;
    }

    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = {
        string: function (str) {
          var ret = 0;

          if (str !== null && str !== undefined && str !== 0) {
            var len = (str.length << 2) + 1;
            ret = stackAlloc(len);
            stringToUTF8(str, ret, len);
          }

          return ret;
        },
        array: function (arr) {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };

      function convertReturnValue(ret) {
        if (returnType === "string") return UTF8ToString(ret);
        if (returnType === "boolean") return Boolean(ret);
        return ret;
      }

      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;

      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];

          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }

      var ret = func.apply(null, cArgs);
      ret = convertReturnValue(ret);
      if (stack !== 0) stackRestore(stack);
      return ret;
    }

    function cwrap(ident, returnType, argTypes, opts) {
      argTypes = argTypes || [];
      var numericArgs = argTypes.every(function (type) {
        return type === "number";
      });
      var numericRet = returnType !== "string";

      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }

      return function () {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }

    var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

    function UTF8ArrayToString(heap, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;

      while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(heap.subarray(idx, endPtr));
      } else {
        var str = "";

        while (idx < endPtr) {
          var u0 = heap[idx++];

          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }

          var u1 = heap[idx++] & 63;

          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }

          var u2 = heap[idx++] & 63;

          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
          }

          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
      }

      return str;
    }

    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }

    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;

      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);

        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }

        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }

      heap[outIdx] = 0;
      return outIdx - startIdx;
    }

    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }

    function lengthBytesUTF8(str) {
      var len = 0;

      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;
      }

      return len;
    }

    function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;

      var ret = _malloc(size);

      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }

    function writeArrayToMemory(array, buffer) {
      HEAP8.set(array, buffer);
    }

    var WASM_PAGE_SIZE = 65536;

    function alignUp(x, multiple) {
      if (x % multiple > 0) {
        x += multiple - x % multiple;
      }

      return x;
    }

    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }

    var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
        maximum: 2147483648 / WASM_PAGE_SIZE
      });
    }

    if (wasmMemory) {
      buffer = wasmMemory.buffer;
    }

    INITIAL_INITIAL_MEMORY = buffer.byteLength;
    updateGlobalBufferAndViews(buffer);
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;

    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];

        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }

      callRuntimeCallbacks(__ATPRERUN__);
    }

    function initRuntime() {
      runtimeInitialized = true;
      if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }

    function preMain() {
      FS.ignorePermissions = false;
      callRuntimeCallbacks(__ATMAIN__);
    }

    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];

        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }

      callRuntimeCallbacks(__ATPOSTRUN__);
    }

    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }

    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }

    var Math_abs = Math.abs;
    var Math_ceil = Math.ceil;
    var Math_floor = Math.floor;
    var Math_min = Math.min;
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;

    function getUniqueRunDependency(id) {
      return id;
    }

    function addRunDependency(id) {
      runDependencies++;

      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }

    function removeRunDependency(id) {
      runDependencies--;

      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }

      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }

        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }

    Module["preloadedImages"] = {};
    Module["preloadedAudios"] = {};

    function abort(what) {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }

      what += "";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
      var e = new WebAssembly.RuntimeError(what);
      throw e;
    }

    function hasPrefix(str, prefix) {
      return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
    }

    var dataURIPrefix = "data:application/octet-stream;base64,";

    function isDataURI(filename) {
      return hasPrefix(filename, dataURIPrefix);
    }

    var wasmBinaryFile = "data:application/octet-stream;base64,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AkEgaiQAC4sDAQF/IwBBMGsiAyQAIAMgADYCJCADIAE2AiAgAyACNwMYAkAgAygCJC0AKEEBcQRAIANCfzcDKAwBCwJAAkAgAygCJCgCIEEATQ0AIAMpAxhC////////////AFYNACADKQMYQgBYDQEgAygCIA0BCyADKAIkQQxqQRJBABAVIANCfzcDKAwBCyADKAIkLQA1QQFxBEAgA0J/NwMoDAELAn8jAEEQayIAIAMoAiQ2AgwgACgCDC0ANEEBcQsEQCADQgA3AygMAQsgAykDGFAEQCADQgA3AygMAQsgA0IANwMQA0AgAykDECADKQMYVARAIAMgAygCJCADKAIgIAMpAxCnaiADKQMYIAMpAxB9QQEQIiICNwMIIAJCAFMEQCADKAIkQQE6ADUgAykDEFAEQCADQn83AygMBAsgAyADKQMQNwMoDAMLIAMpAwhQBEAgAygCJEEBOgA0BSADIAMpAwggAykDEHw3AxAMAgsLCyADIAMpAxA3AygLIAMpAyghAiADQTBqJAAgAgs2AQF/IwBBEGsiASAANgIMAn4gASgCDC0AAEEBcQRAIAEoAgwpAwggASgCDCkDEH0MAQtCAAsLsgECAX8BfiMAQRBrIgEkACABIAA2AgQgASABKAIEQggQHzYCAAJAIAEoAgBFBEAgAUIANwMIDAELIAEgASgCAC0AAK0gASgCAC0AB61COIYgASgCAC0ABq1CMIZ8IAEoAgAtAAWtQiiGfCABKAIALQAErUIghnwgASgCAC0AA61CGIZ8IAEoAgAtAAKtQhCGfCABKAIALQABrUIIhnx8NwMICyABKQMIIQIgAUEQaiQAIAILqAEBAX8jAEEQayIBJAAgASAANgIIAkAgASgCCCgCIEEATQRAIAEoAghBDGpBEkEAEBUgAUF/NgIMDAELIAEoAggiACAAKAIgQX9qNgIgIAEoAggoAiBFBEAgASgCCEEAQgBBAhAiGiABKAIIKAIABEAgASgCCCgCABAyQQBIBEAgASgCCEEMakEUQQAQFQsLCyABQQA2AgwLIAEoAgwhACABQRBqJAAgAAvxAgICfwF+AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiAB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ECwQMwsgASgCDCgCVBAWIAEoAgxBADYCVAsgAUEQaiQAC/EBAQF/IwBBEGsiASAANgIMIAEoAgxBADYCACABKAIMQQA6AAQgASgCDEEAOgAFIAEoAgxBAToABiABKAIMQb8GOwEIIAEoAgxBCjsBCiABKAIMQQA7AQwgASgCDEF/NgIQIAEoAgxBADYCFCABKAIMQQA2AhggASgCDEIANwMgIAEoAgxCADcDKCABKAIMQQA2AjAgASgCDEEANgI0IAEoAgxBADYCOCABKAIMQQA2AjwgASgCDEEAOwFAIAEoAgxBgIDYjXg2AkQgASgCDEIANwNIIAEoAgxBADsBUCABKAIMQQA7AVIgASgCDEEANgJUC9oTAQF/IwBBsAFrIgMkACADIAA2AqgBIAMgATYCpAEgAyACNgKgASADQQA2ApABIAMgAygCpAEoAjBBABA7NgKUASADIAMoAqQBKAI4QQAQOzYCmAECQAJAAkACQCADKAKUAUECRgRAIAMoApgBQQFGDQELIAMoApQBQQFGBEAgAygCmAFBAkYNAQsgAygClAFBAkcNASADKAKYAUECRw0BCyADKAKkASIAIAAvAQxBgBByOwEMDAELIAMoAqQBIgAgAC8BDEH/7wNxOwEMIAMoApQBQQJGBEAgA0H14AEgAygCpAEoAjAgAygCqAFBCGoQxAE2ApABIAMoApABRQRAIANBfzYCrAEMAwsLAkAgAygCoAFBgAJxDQAgAygCmAFBAkcNACADQfXGASADKAKkASgCOCADKAKoAUEIahDEATYCSCADKAJIRQRAIAMoApABECQgA0F/NgKsAQwDCyADKAJIIAMoApABNgIAIAMgAygCSDYCkAELCwJAIAMoAqQBLwFSRQRAIAMoAqQBIgAgAC8BDEH+/wNxOwEMDAELIAMoAqQBIgAgAC8BDEEBcjsBDAsgAyADKAKkASADKAKgARCAAUEBcToAhgEgAyADKAKgAUGACnFBgApHBH8gAy0AhgEFQQELQQFxOgCHASADAn9BASADKAKkAS8BUkGBAkYNABpBASADKAKkAS8BUkGCAkYNABogAygCpAEvAVJBgwJGC0EBcToAhQEgAy0AhwFBAXEEQCADIANBIGpCHBAqNgIcIAMoAhxFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAILAkAgAygCoAFBgAJxBEACQCADKAKgAUGACHENACADKAKkASkDIEL/////D1YNACADKAKkASkDKEL/////D1gNAgsgAygCHCADKAKkASkDKBAuIAMoAhwgAygCpAEpAyAQLgwBCwJAAkAgAygCoAFBgAhxDQAgAygCpAEpAyBC/////w9WDQAgAygCpAEpAyhC/////w9WDQAgAygCpAEpA0hC/////w9YDQELIAMoAqQBKQMoQv////8PWgRAIAMoAhwgAygCpAEpAygQLgsgAygCpAEpAyBC/////w9aBEAgAygCHCADKAKkASkDIBAuCyADKAKkASkDSEL/////D1oEQCADKAIcIAMoAqQBKQNIEC4LCwsCfyMAQRBrIgAgAygCHDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAIcEBcgAygCkAEQJCADQX82AqwBDAILIANBAQJ/IwBBEGsiACADKAIcNgIMAn4gACgCDC0AAEEBcQRAIAAoAgwpAxAMAQtCAAunQf//A3ELIANBIGpBgAYQUDYCjAEgAygCHBAXIAMoAowBIAMoApABNgIAIAMgAygCjAE2ApABCyADLQCFAUEBcQRAIAMgA0EVakIHECo2AhAgAygCEEUEQCADKAKoAUEIakEOQQAQFSADKAKQARAkIANBfzYCrAEMAgsgAygCEEECECAgAygCEEHP0wBBAhBAIAMoAhAgAygCpAEvAVJB/wFxEIoBIAMoAhAgAygCpAEoAhBB//8DcRAgAn8jAEEQayIAIAMoAhA2AgwgACgCDC0AAEEBcUULBEAgAygCqAFBCGpBFEEAEBUgAygCEBAXIAMoApABECQgA0F/NgKsAQwCCyADQYGyAkEHIANBFWpBgAYQUDYCDCADKAIQEBcgAygCDCADKAKQATYCACADIAMoAgw2ApABCyADIANB0ABqQi4QKiIANgJMIABFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAELIAMoAkxBxdMAQcrTACADKAKgAUGAAnEbQQQQQCADKAKgAUGAAnFFBEAgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQgLQf//A3EQIAsgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQoLQf//A3EQICADKAJMIAMoAqQBLwEMECACQCADLQCFAUEBcQRAIAMoAkxB4wAQIAwBCyADKAJMIAMoAqQBKAIQQf//A3EQIAsgAygCpAEoAhQgA0GeAWogA0GcAWoQwwEgAygCTCADLwGeARAgIAMoAkwgAy8BnAEQIAJAAkAgAy0AhQFBAXFFDQAgAygCpAEpAyhCFFoNACADKAJMQQAQIQwBCyADKAJMIAMoAqQBKAIYECELAkACQCADKAKgAUGAAnFBgAJHDQAgAygCpAEpAyBC/////w9UBEAgAygCpAEpAyhC/////w9UDQELIAMoAkxBfxAhIAMoAkxBfxAhDAELAkAgAygCpAEpAyBC/////w9UBEAgAygCTCADKAKkASkDIKcQIQwBCyADKAJMQX8QIQsCQCADKAKkASkDKEL/////D1QEQCADKAJMIAMoAqQBKQMopxAhDAELIAMoAkxBfxAhCwsgAygCTCADKAKkASgCMBBSQf//A3EQICADIAMoAqQBKAI0IAMoAqABEIIBQf//A3EgAygCkAFBgAYQggFB//8DcWo2AogBIAMoAkwgAygCiAFB//8DcRAgIAMoAqABQYACcUUEQCADKAJMIAMoAqQBKAI4EFJB//8DcRAgIAMoAkwgAygCpAEoAjxB//8DcRAgIAMoAkwgAygCpAEvAUAQICADKAJMIAMoAqQBKAJEECECQCADKAKkASkDSEL/////D1QEQCADKAJMIAMoAqQBKQNIpxAhDAELIAMoAkxBfxAhCwsCfyMAQRBrIgAgAygCTDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAJMEBcgAygCkAEQJCADQX82AqwBDAELIAMoAqgBIANB0ABqAn4jAEEQayIAIAMoAkw2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IACwsQNkEASARAIAMoAkwQFyADKAKQARAkIANBfzYCrAEMAQsgAygCTBAXIAMoAqQBKAIwBEAgAygCqAEgAygCpAEoAjAQhgFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABBEAgAygCqAEgAygCkAFBgAYQgQFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABECQgAygCpAEoAjQEQCADKAKoASADKAKkASgCNCADKAKgARCBAUEASARAIANBfzYC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IAMoAoABKAIAIAMpA3CnQQR0aigCACADEPEBBEAgAygCfEEVQQAQFSADEFwgA0J/NwOIAQwDBSADKAKAASgCACADKQNwp0EEdGooAgAoAjQgAygCNBCFASEAIAMoAoABKAIAIAMpA3CnQQR0aigCACAANgI0IAMoAoABKAIAIAMpA3CnQQR0aigCAEEBOgAEIANBADYCNCADEFwgAyADKQNwQgF8NwNwDAILAAsLIAMCfiADKQNgIAMpA2h9Qv///////////wBUBEAgAykDYCADKQNofQwBC0L///////////8ACzcDiAELIAMpA4gBIQQgA0GQAWokACAEC6YBAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgAygCEBD6ASIANgIMAkAgAEUEQCADQQA2AhwMAQsgAygCDCADKAIYNgIAIAMoAgwgAygCFDYCBCADKAIUQRBxBEAgAygCDCIAIAAoAhRBAnI2AhQgAygCDCIAIAAoAhhBAnI2AhgLIAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC9UBAQF/IwBBIGsiBCQAIAQgADYCGCAEIAE3AxAgBCACNgIMIAQgAzYCCAJAAkAgBCkDEEL///////////8AVwRAIAQpAxBCgICAgICAgICAf1kNAQsgBCgCCEEEQT0QFSAEQX82AhwMAQsCfyAEKQMQIQEgBCgCDCEAIAQoAhgiAigCTEF/TARAIAIgASAAEJYBDAELIAIgASAAEJYBC0EASARAIAQoAghBBEG0nAEoAgAQFSAEQX82AhwMAQsgBEEANgIcCyAEKAIcIQAgBEEgaiQAIAALJwACf0EAQQAgABAFIgAgAEEbRhsiAEUNABpBtJwBIAA2AgBBAAsaC14BAX8jAEEQayIDJAAgAyABQcCAgAJxBH8gAyACQQRqNgIMIAIoAgAFQQALNgIAIAAgAUGAgAJyIAMQESIAQYFgTwRAQbScAUEAIABrNgIAQX8hAAsgA0EQaiQAIAALVQEBfyMAQRBrIgEkACABIAA2AgwCQAJAIAEoAgwoAiRBAUYNACABKAIMKAIkQQJGDQAMAQsgASgCDEEAQgBBChAiGiABKAIMQQA2AiQLIAFBEGokAAszAQF/An8gABAGIgFBYUYEQCAAEBIhAQsgAUGBYE8LBH9BtJwBQQAgAWs2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IEUNACABKAIIKAIkDQELIAFBATYCDAwBCyABIAEoAggoAhw2AgQCQAJAIAEoAgRFDQAgASgCBCgCACABKAIIRw0AIAEoAgQoAgRBKkYNASABKAIEKAIEQTlGDQEgASgCBCgCBEHFAEYNASABKAIEKAIEQckARg0BIAEoAgQoAgRB2wBGDQEgASgCBCgCBEHnAEYNASABKAIEKAIEQfEARg0BIAEoAgQoAgRBmgVGDQELIAFBATYCDAwBCyABQQA2AgwLIAEoAgwL0gQBAX8jAEEgayIDIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhxB3BZqIAMoAhRBAnRqKAIANgIQIAMgAygCFEEBdDYCDANAAkAgAygCDCADKAIcKALQKEoNAAJAIAMoAgwgAygCHCgC0ChODQAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBOBEAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBHDQEgAygCHCADKAIMQQJ0akHgFmooAgAgAygCHEHYKGpqLQAAIAMoAhxB3BZqIAMoAgxBAnRqKAIAIAMoAhxB2Chqai0AAEoNAQsgAyADKAIMQQFqNgIMCyADKAIYIAMoAhBBAnRqLwEAIAMoAhggAygCHEHcFmogAygCDEECdGooAgBBAnRqLwEASA0AAkAgAygCGCADKAIQQQJ0ai8BACADKAIYIAMoAhxB3BZqIAMoAgxBAnRqKAIAQQJ0ai8BAEcNACADKAIQIAMoAhxB2Chqai0AACADKAIcQdwWaiADKAIMQQJ0aigCACADKAIcQdgoamotAABKDQAMAQsgAygCHEHcFmogAygCFEECdGogAygCHEHcFmogAygCDEECdGooAgA2AgAgAyADKAIMNgIUIAMgAygCDEEBdDYCDAwBCwsgAygCHEHcFmogAygCFEECdGogAygCEDYCAAvnCAEDfyMAQTBrIgIkACACIAA2AiwgAiABNgIoIAIgAigCKCgCADYCJCACIAIoAigoAggoAgA2AiAgAiACKAIoKAIIKAIMNgIcIAJBfzYCECACKAIsQQA2AtAoIAIoAixBvQQ2AtQoIAJBADYCGANAIAIoAhggAigCHE5FBEACQCACKAIkIAIoAhhBAnRqLwEABEAgAiACKAIYIgE2AhAgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQAgBCAANgLQKCAAQQJ0IANqIAE2AgAgAigCGCACKAIsQdgoampBADoAAAwBCyACKAIkIAIoAhhBAnRqQQA7AQILIAIgAigCGEEBajYCGAwBCwsDQCACKAIsKALQKEECSARAAkAgAigCEEECSARAIAIgAigCEEEBaiIANgIQDAELQQAhAAsgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQEgBCABNgLQKCABQQJ0IANqIAA2AgAgAiAANgIMIAIoAiQgAigCDEECdGpBATsBACACKAIMIAIoAixB2ChqakEAOgAAIAIoAiwiACAAKAKoLUF/ajYCqC0gAigCIARAIAIoAiwiACAAKAKsLSACKAIgIAIoAgxBAnRqLwECazYCrC0LDAELCyACKAIoIAIoAhA2AgQgAiACKAIsKALQKEECbTYCGANAIAIoAhhBAUhFBEAgAigCLCACKAIkIAIoAhgQdSACIAIoAhhBf2o2AhgMAQsLIAIgAigCHDYCDANAIAIgAigCLCgC4BY2AhggAigCLEHcFmohASACKAIsIgMoAtAoIQAgAyAAQX9qNgLQKCACKAIsIABBAnQgAWooAgA2AuAWIAIoAiwgAigCJEEBEHUgAiACKAIsKALgFjYCFCACKAIYIQEgAigCLEHcFmohAyACKAIsIgQoAtQoQX9qIQAgBCAANgLUKCAAQQJ0IANqIAE2AgAgAigCFCEBIAIoAixB3BZqIQMgAigCLCIEKALUKEF/aiEAIAQgADYC1CggAEECdCADaiABNgIAIAIoAiQgAigCDEECdGogAigCJCACKAIYQQJ0ai8BACACKAIkIAIoAhRBAnRqLwEAajsBACACKAIMIAIoAixB2ChqagJ/IAIoAhggAigCLEHYKGpqLQAAIAIoAhQgAigCLEHYKGpqLQAATgRAIAIoAhggAigCLEHYKGpqLQAADAELIAIoAhQgAigCLEHYKGpqLQAAC0EBajoAACACKAIkIAIoAhRBAnRqIAIoAgwiADsBAiACKAIkIAIoAhhBAnRqIAA7AQIgAiACKAIMIgBBAWo2AgwgAigCLCAANgLgFiACKAIs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AykDKCEBIANBMGokACABC3cBAX8jAEEQayICIAA2AgggAiABNgIEAkACQAJAIAIoAggpAyhC/////w9aDQAgAigCCCkDIEL/////D1oNACACKAIEQYAEcUUNASACKAIIKQNIQv////8PVA0BCyACQQE6AA8MAQsgAkEAOgAPCyACLQAPQQFxC9kCAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgA0EMakIEECo2AggCQCADKAIIRQRAIANBfzYCHAwBCwNAIAMoAhQEQCADKAIUKAIEIAMoAhBxQYAGcQRAIAMoAghCABAtGiADKAIIIAMoAhQvAQgQICADKAIIIAMoAhQvAQoQIAJ/IwBBEGsiACADKAIINgIMIAAoAgwtAABBAXFFCwRAIAMoAhhBCGpBFEEAEBUgAygCCBAXIANBfzYCHAwECyADKAIYIANBDGpCBBA2QQBIBEAgAygCCBAXIANBfzYCHAwECyADKAIULwEKQQBKBEAgAygCGCADKAIUKAIMIAMoAhQvAQqtEDZBAEgEQCADKAIIEBcgA0F/NgIcDAULCwsgAyADKAIUKAIANgIUDAELCyADKAIIEBcgA0EANgIcCyADKAIcIQAgA0EgaiQAIAALaAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEAOwEGA0AgAigCDARAIAIoAgwoAgQgAigCCHFBgAZxBEAgAiACKAIMLwEKIAIvAQZBBGpqOwEGCyACIAIoAgwoAgA2AgwMAQsLIAIvAQYL8AEBAX8jAEEQayIBJAAgASAANgIMIAEgASgCDDYCCCABQQA2AgQDQCABKAIMBEACQAJAIAEoAgwvAQhB9cYBRg0AIAEoAgwvAQhB9eABRg0AIAEoAgwvAQhBgbICRg0AIAEoAgwvAQhBAUcNAQsgASABKAIMKAIANgIAIAEoAgggASgCDEYEQCABIAEoAgA2AggLIAEoAgxBADYCACABKAIMECQgASgCBARAIAEoAgQgASgCADYCAAsgASABKAIANgIMDAILIAEgASgCDDYCBCABIAEoAgwoAgA2AgwMAQsLIAEoAgghACABQRBqJAAgAAuzBAEBfyMAQUBqIgUkACAFIAA2AjggBSABOwE2IAUgAjYCMCAFIAM2AiwgBSAENgIoIAUgBSgCOCAFLwE2rRAqIgA2AiQC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ACgCDCgCBDYCAAsLIAIoAgwEQCACKAIMIAIoAgQ2AgALIAJBEGokAAuVAQEBfyMAQRBrIgEkACABIAA2AggCQAJ/IwBBEGsiACABKAIINgIMIAAoAgwpAxhCgIAQg1ALBEAgASgCCCgCAARAIAEgASgCCCgCABCUAUEBcToADwwCCyABQQE6AA8MAQsgASABKAIIQQBCAEESECI+AgQgASABKAIEQQBHOgAPCyABLQAPQQFxIQAgAUEQaiQAIAALfwEBfyMAQSBrIgMkACADIAA2AhggAyABNwMQIANBADYCDCADIAI2AggCQCADKQMQQv///////////wBWBEAgAygCCEEEQT0QFSADQX82AhwMAQsgAyADKAIYIAMpAxAgAygCDCADKAIIEGc2AhwLIAMoAhwhACADQSBqJAAgAAt9ACACQQFGBEAgASAAKAIIIAAoAgRrrH0hAQsCQCAAKAIUIAAoAhxLBEAgAEEAQQAgACgCJBEBABogACgCFEUNAQsgAEEANgIcIABCADcDECAAIAEgAiAAKAIoERAAQgBTDQAgAEIANwIEIAAgACgCAEFvcTYCAEEADwtBfwviAgECfyMAQSBrIgMkAAJ/AkACQEH0lwEgASwAABCYAUUEQEG0nAFBHDYCAAwBC0GYCRAZIgINAQtBAAwBCyACQQBBkAEQMyABQSsQmAFFBEAgAkEIQQQgAS0AAEHyAEYbNgIACwJAIAEtAABB4QBHBEAgAigCACEBDAELIABBA0EAEAQiAUGACHFFBEAgAyABQYAIcjYCECAAQQQgA0EQahAEGgsgAiACKAIAQYABciIBNgIACyACQf8BOgBLIAJBgAg2AjAgAiAANgI8IAIgAkGYAWo2AiwCQCABQQhxDQAgAyADQRhqNgIAIABBk6gBIAMQDg0AIAJBCjoASwsgAkEaNgIoIAJBGzYCJCACQRw2AiAgAkEdNgIMQdygASgCAEUEQCACQX82AkwLIAJBsKEBKAIANgI4QbChASgCACIABEAgACACNgI0C0GwoQEgAjYCACACCyEAIANBIGokACAACxoAIAAgARCFAiIAQQAgAC0AACABQf8BcUYbCxgAIAAoAkxBf0wEQCAAEJoBDwsgABCaAQtgAgJ/AX4gACgCKCEBQQEhAiAAQgAgAC0AAEGAAXEEf0ECQQEgACgCFCAAKAIc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KAIYKQMwWgRAIAIoAhhBCGpBEkEAEBUgAkF/NgIcDAELIAIoAhgoAhhBAnEEQCACKAIYQQhqQRlBABAVIAJBfzYCHAwBCyACIAIoAhggAikDEEEAIAIoAhhBCGoQTyIANgIMIABFBEAgAkF/NgIcDAELIAIoAhgoAlAgAigCDCACKAIYQQhqEFlBAXFFBEAgAkF/NgIcDAELIAIoAhggAikDEBCgAgRAIAJBfzYCHAwBCyACKAIYKAJAIAIpAxCnQQR0akEBOgAMIAJBADYCHAsgAigCHCEAIAJBIGokACAAC5gCAAJAAkAgAUEUSw0AAkACQAJAAkACQAJAAkACQCABQXdqDgoAAQIJAwQFBgkHCAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQRYRBAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0oBA38gACgCACwAAEFQakEKSQRAA0AgACgCACIBLAAAIQMgACABQQFqNgIAIAMgAkEKbGpBUGohAiABLAABQVBqQQpJDQALCyACC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEKQBIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABELQCC+UBAQJ/IAJBAEchAwJAAkACQCACRQ0AIABBA3FFDQAgAUH/AXEhBANAIAAtAAAgBEYNAiAAQQFqIQAgAkF/aiICQQBHIQMgAkUNASAAQQNxDQALCyADRQ0BCwJAIAAtAAAgAUH/AXFGDQAgAkEESQ0AIAFB/wFxQYGChAhsIQMDQCAAKAIAIANzIgRBf3MgBEH//ft3anFBgIGChHhxDQEgAEEEaiEAIAJB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HAvkAQEBfyMAQSBrIgMkACADIAA6ABsgAyABNgIUIAMgAjYCECADQcgAEBkiADYCDAJAIABFBEAgAygCEEEBQbScASgCABAVIANBADYCHAwBCyADKAIMIAMoAhA2AgAgAygCDCADLQAbQQFxOgAEIAMoAgwgAygCFDYCCAJAIAMoAgwoAghBAU4EQCADKAIMKAIIQQlMDQELIAMoAgxBCTYCCAsgAygCDEEAOgAMIAMoAgxBADYCMCADKAIMQQA2AjQgAygCDEEANgI4IAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC+MIAQF/IwBBQGoiAiAANgI4IAIgATYCNCACIAIoAjgoAnw2AjAgAiACKAI4KAI4IAIoAjgoAmxqNgIsIAIgAigCOCgCeDYCICACIAIoAjgoApABNgIcIAICfyACKAI4KAJsIAIoAjgoAixBhgJrSwRAIAIoAjgoAmwgAigCOCgCLEGGAmtrDAELQQALNgIYIAIgAigCOCgCQDYCFCACIAIoAjgoAjQ2AhAgAiACKAI4KAI4IAIoAjgoAmxqQYICajYCDCACIAIoAiwgAigCIEEBa2otAAA6AAsgAiACKAIsIAIoAiBqLQAAOgAKIAIoAjgoAnggAigCOCgCjAFPBEAgAiACKAIwQQJ2NgIwCyACKAIcIAIoAjgoAnRLBEAgAiACKAI4KAJ0NgIcCwNAAkAgAiACKAI4KAI4IAIoAjRqNgIoAkAgAigCKCACKAIgai0AACACLQAKRw0AIAIoAiggAigCIEEBa2otAAAgAi0AC0cNACACKAIoLQAAIAIoAiwtAABHDQAgAiACKAIoIgBBAWo2AiggAC0AASACKAIsLQABRwRADAELIAIgAigCLEECajYCLCACIAIoAihBAWo2AigDQCACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AigCf0EAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACKAIsIAIoAgxJC0EBcQ0ACyACQYICIAIoAgwgAigCLGtrNgIkIAIgAigCDEH+fWo2AiwgAigCJCACKAIgSgRAIAIoAjggAigCNDYCcCACIAIoAiQ2AiAgAigCJCACKAIcTg0CIAIgAigCLCACKAIgQQFrai0AADoACyACIAIoAiwgAigCIGotAAA6AAoLCyACIAIoAhQgAigCNCACKAIQcUEBdGovAQAiATYCNEEAIQAgASACKAIYSwR/IAIgAigCMEF/aiIANgIwIABBAEcFQQALQQFxDQELCwJAIAIoAiAgAigCOCgCdE0EQCACIAIoAiA2AjwMAQsgAiACKAI4KAJ0NgI8CyACKAI8C5gQAQF/IwBBMGsiAiQAIAIgADYCKCACIAE2AiQgAgJ/IAIoAigoAgxBBWsgAigCKCgCLEsEQCACKAIoKAIsDAELIAIoAigoAgxBBWsLNgIgIAJBADYCECACIAIoAigoAgAoAgQ2AgwDQAJAIAJB//8DNgIcIAIgAigCKCgCvC1BKmpBA3U2AhQgAigCKCgCACgCECACKAIUSQ0AIAIgAigCKCgCACgCECACKAIUazYCFCACIAIoAigoAmwgAigCKCgCXGs2AhggAigCHCACKAIYIAIoAigoAgAoAgRqSwRAIAIgAigCGCACKAIoKAIAKAIEajYCHAsgAigCHCACKAIUSwRAIAIgAigCFDYCHAsCQCACKAIcIAIoAiBPDQACQCACKAIcRQRAIAIoAiRBBEcNAQsgAigCJEUNACACKAIcIAIoAhggAigCKCgCACgCBGpGDQELDAELQQAhACACIAIoAiRBBEYEfyACKAIcIAIoAhggAigCKCgCACgCBGpGBUEAC0EBcUVFNgIQIAIoAihBAEEAIAIoAhAQVyACKAIoKAIIIAIoAigoAhRBBGtqIAIoAhw6AAAgAigCKCgCCCACKAIoKAIUQQNraiACKAIcQQh2OgAAIAIoAigoAgggAigCKCgCFEECa2ogAigCHEF/czoAACACKAIoKAIIIAIoAigoAhRBAWtqIAIoAhxBf3NBCHY6AAAgAigCKCgCABAdIAIoAhgEQCACKAIYIAIoAhxLBEAgAiACKAIcNgIYCyACKAIoKAIAKAIMIAIoAigoAjggAigCKCgCXGogAigCGBAaGiACKAIoKAIAIgAgAigCGCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIYazYCECACKAIoKAIAIgAgAigCGCAAKAIUajYCFCACKAIoIgAgAigCGCAAKAJcajYCXCACIAIoAhwgAigCGGs2AhwLIAIoAhwEQCACKAIoKAIAIAIoAigoAgAoAgwgAigCHBBzGiACKAIoKAIAIgAgAigCHCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIcazYCECACKAIoKAIAIgAgAigCHCAAKAIUajYCFAsgAigCEEUNAQsLIAIgAigCDCACKAIoKAIAKAIEazYCDCACKAIMBEACQCACKAIMIAIoAigoAixPBEAgAigCKEECNgKwLSACKAIoKAI4IAIoAigoAgAoAgAgAigCKCgCLGsgAigCKCgCLBAaGiACKAIoIAIoAigoAiw2AmwMAQsgAigCKCgCPCACKAIoKAJsayACKAIMTQRAIAIoAigiACAAKAJsIAIoAigoAixrNgJsIAIoAigoAjggAigCKCgCOCACKAIoKAIsaiACKAIoKAJsEBoaIAIoAigoArAtQQJJBEAgAigCKCIAIAAoArAtQQFqNgKwLQsLIAIoAigoAjggAigCKCgCbGogAigCKCgCACgCACACKAIMayACKAIMEBoaIAIoAigiACACKAIMIAAoAmxqNgJsCyACKAIoIAIoAigoAmw2AlwgAigCKCIBAn8gAigCDCACKAIoKAIsIAIoAigoArQta0sEQCACKAIoKAIsIAIoAigoArQtawwBCyACKAIMCyABKAK0LWo2ArQtCyACKAIoKALALSACKAIoKAJsSQRAIAIoAiggAigCKCgCbDYCwC0LAkAgAigCEARAIAJBAzYCLAwBCwJAIAIoAiRFDQAgAigCJEEERg0AIAIoAigoAgAoAgQNACACKAIoKAJsIAIoAigoAlxHDQAgAkEBNgIsDAELIAIgAigCKCgCPCACKAIoKAJsa0EBazYCFAJAIAIoAigoAgAoAgQgAigCFE0NACACKAIoKAJcIAIoAigoAixIDQAgAigCKCIAIAAoAlwgAigCKCgCLGs2AlwgAigCKCIAIAAoAmwgAigCKCgCLGs2AmwgAigCKCgCOCACKAIoKAI4IAIoAigoAixqIAIoAigoAmwQGhogAigCKCgCsC1BAkkEQCACKAIoIgAgACgCsC1BAWo2ArAtCyACIAIoAigoAiwgAigCFGo2AhQLIAIoAhQgAigCKCgCACgCBEsEQCACIAIoAigoAgAoAgQ2AhQLIAIoAhQEQCACKAIoKAIAIAIoAigoAjggAigCKCgCbGogAigCFBBzGiACKAIoIgAgAigCFCAAKAJsajYCbAsgAigCKCgCwC0gAigCKCgCbEkEQCACKAIoIAIoAigoAmw2AsAtCyACIAIoAigoArwtQSpqQQN1NgIUIAICf0H//wMgAigCKCgCDCACKAIUa0H//wNLDQAaIAIoAigoAgwgAigCFGsLNgIUIAICfyACKAIUIAIoAigoAixLBEAgAigCKCgCLAwBCyACKAIUCzYCICACIAIoAigoAmwgAigCKCgCXGs2AhgCQCACKAIYIAIoAiBJBEAgAigCGEUEQCACKAIkQQRHDQILIAIoAiRFDQEgAigCKCgCACgCBA0BIAIoAhggAigCFEsNAQsgAgJ/IAIoAhggAigCFEsEQCACKAIUDAELIAIoAhgLNgIcIAICf0EAIAIoAiRBBEcNABpBACACKAIoKAIAKAIEDQAaIAIoAhwgAigCGEYLQQFxRUU2AhAgAigCKCACKAIoKAI4IAIoAigoAlxqIAIoAhwgAigCEBBXIAIoAigiACACKAIcIAAoAlxqNgJcIAIoAigoAgAQHQsgAkECQQAgAigCEBs2AiwLIAIoAiwhACACQTBqJAAgAAuyAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHQEQCABQX42AgwMAQsgASABKAIIKAIcKAIENgIEIAEoAggoAhwoAggEQCABKAIIKAIoIAEoAggoAhwoAgggASgCCCgCJBEEAAsgASgCCCgCHCgCRARAIAEoAggoAiggASgCCCgCHCgCRCABKAIIKAIkEQQACyABKAIIKAIcKAJABEAgASgCCCgCKCAB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A0hCGnxBABAoQQBIBEAgAigCKEEIaiACKAIoKAIAEBggAkF/NgIsDAELIAIgAigCKCgCAEIEIAJBGGogAigCKEEIahBBIgA2AhQgAEUEQCACQX82AiwMAQsgAiACKAIUEB47ARIgAiACKAIUEB47ARAgAigCFBBIQQFxRQRAIAIoAhQQFyACKAIoQQhqQRRBABAVIAJBfzYCLAwBCyACKAIUEBcgAi8BEEEASgRAIAIoAigoAgAgAi8BEq1BARAoQQBIBEAgAigCKEEIakEEQbScASgCABAVIAJBfzYCLAwCCyACQQAgAigCKCgCACACLwEQQQAgAigCKEEIahBgNgIIIAIoAghFBEAgAkF/NgIsDAILIAIoAgggAi8BEEGAAiACQQxqIAIoAihBCGoQhAFBAXFFBEAgAigCCBAWIAJBfzYCLAwCCyACKAIIEBYgAigCDARAIAIgAigCDBCDATYCDCACKAIcKAIAKAI0IAIoAgwQhQEhACACKAIcKAIAIAA2AjQLCyACKAIcKAIAQQE6AAQCQCACKAIcKAIERQ0AIAIoAhwoAgQtAARBAXENACACKAIcKAIEIAIoAhwoAgAoAjQ2AjQgAigCHCgCBEEBOgAECyACQQA2AiwLIAIoAiwhACACQTBqJAAgAAsHACAAKAIAC4wBAQF/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQgAkEANgIQAkAgAigCFEUEQCACQQA2AhwMAQsgAiACKAIUEBk2AgwgAigCDEUEQCACKAIQQQ5BABAVIAJBADYCHAwBCyACKAIMIAIoAhggAigCFBAaGiACIAIoAgw2AhwLIAIoAhwhACACQSBqJAAgAAsYAEGonAFCADcCAEGwnAFBADYCAEGonAELiAEBAX8jAEEgayIDJAAgAyAANgIUIAMgATYCECADIAI3AwgCQAJAIAMoAhQoAiRBAUYEQCADKQMIQv///////////wBYDQELIAMoAhRBDGpBEkEAEBUgA0J/NwMYDAELIAMgAygCFCADKAIQIAMpAwhBCxAiNwMYCyADKQMYIQIgA0EgaiQAIAILcwEBfyMAQSBrIgEkACABIAA2AhggAUIINwMQIAEgASgCGCkDECABKQMQfDcDCAJAIAEpAwggASgCGCkDEFQEQCABKAIYQQA6AAAgAUF/NgIcDAELIAEgASgCGCAB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IAIgADYCSCACIAE2AkQgAkEIaiIAEDwCQCACKAJIIAAQOQRAIwBBEGsiACACKAJINgIMIAIgACgCDEEMajYCBCMAQRBrIgAgAigCBDYCDAJAIAAoAgwoAgBBBUcNACMAQRBrIgAgAigCBDYCDCAAKAIMKAIEQSxHDQAgAkEANgJMDAILIAIoAkQgAigCBBBEIAJBfzYCTAwBCyACQQE2AkwLIAIoAkwhACACQdAAaiQAIAAL6gEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI2AiAjAEEQayIAIANBCGoiATYCDCAAKAIMQQA2AgAgACgCDEEANgIEIAAoAgxBADYCCCADIAMoAiggARD7ASIANgIYAkAgAEUEQCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIAMgAygCGCADKAIkIANBCGoQkgEiADYCHCAARQRAIAMoAhgQHCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIANBCGoQOCADIAMoAhw2AiwLIAMoAiwhACADQTBqJAAgAAvIAgEBfyMAQRBrIgEkACABIAA2AgggAUHYABAZNgIEAkAgASgCBEUEQCABKAIIQQ5BABAVIAFBADYCDAwBCyABKAIIEIEDIQAgASgCBCAANgJQIABFBEAgASgCBBAWIAFBADYCDAwBCyABKAIEQQA2AgAgASgCBEEANgIEIwBBEGsiACABKAIEQQhqNgIMIAAoAgxBADYCACAAKAIMQQA2AgQgACgCDEEANgIIIAEoAgRBADYCGCABKAIEQQA2AhQgASgCBEEANgIcIAEoAgRBADYCJCABKAIEQQA2AiAgASgCBEEAOgAoIAEoAgRCADcDOCABKAIEQgA3AzAgASgCBEEANgJAIAEoAgRBADYCSCABKAIEQQA2AkQgASgCBEEANgJMIAEoAgRBADYCVCABIAEoAgQ2AgwLIAEoAgwhACABQRBqJAAgAAuBAQEBfyMAQSBrIgIkACACIAA2AhggAkIANwMQIAJCfzcDCCACIAE2AgQCQAJAIAIoAhgEQCACKQMIQn9ZDQELIAIoAgRBEkEAEBUgAkEANgIcDAELIAIgAigCGCACKQMQIAIpAwggAigCBBD/ATYCHAsgAigCHCEAIAJBIGokACAAC80BAQJ/IwBBIGsiASQAIAEgADYCGCAB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CyAAIAFBf2oiAWoiAi0AAEEvRw0ACyACC6kBAQN/AkAgAC0AACICRQ0AA0AgAS0AACIERQRAIAIhAwwCCwJAIAIgBEYNACACQSByIAIgAkG/f2pBGkkbIAEtAAAiAkEgciACIAJBv39qQRpJG0YNACAALQAAIQMMAgsgAUEBaiEBIAAtAAEhAiAAQQFqIQAgAg0ACwsgA0H/AXEiAEEgciAAIABBv39qQRpJGyABLQAAIgBBIHIgACAAQb9/akEaSRtrC+gDAQN/IwBBsAFrIgEkACABIAA2AqgBIAEoAqgBEDgCQAJAIAEoAqgBKAIAQQBOBEAgASgCqAEoAgBBoA4oAgBIDQELIAEgASgCqAEoAgA2AhAgAUEgakG8lwEgAUEQahBvIAFBADYCpAEgASABQSBqNgKgAQwBCyABIAEoAqgBKAIAQQJ0QaANaigCADYCpAECQAJAAkACQCABKAKoASgCAEECdEGwDmooAgBBf2oOAgABAgsgASABKAKoASgCBEGQmgEoAgAQpAI2AqABDAILIwBBEGsiACABKAKoASgCBDYCDCABQQAgACgCDGtBAnRB2NQAaigCADYCoAEMAQsgAUEANgKgAQsLAkAgASgCoAFFBEAgASABKAKkATYCrAEMAQsgASABKAKgARAsAn8gASgCpAEEQCABKAKkARAsQQJqDAELQQALakEBahAZIgA2AhwgAEUEQCABQdgNKAIANgKsAQwBCyABKAIcIQACfyABKAKkAQRAIAEoAqQBDAELQdSXAQshAkHVlwFB1JcBIAEoAqQBGyEDIAEgASgCoAE2AgggASADNgIEIAEgAjYCACAAQc2XASABEG8gASgCqAEgASgCHDYCCCABIAEoAhw2AqwBCyABKAKsASEAIAFBsAFqJAAgAAtxAQN/AkACQANAIAAgAkHQiAFqLQAARwRAQdcAIQMgAkEBaiICQdcARw0BDAILCyACIgMNAEGwiQEhAAwBC0GwiQEhAgNAIAItAAAhBCACQQFqIgAhAiAEDQAgACECIANBf2oiAw0ACwsgASgCFBogAAszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQGhogACAAKAIUIAFqNgIUIAILigEBAn8jAEGgAWsiAyQAIANBCGpBuIcBQZABEBoaIAMgADYCNCADIAA2AhwgA0F+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QQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACwYAQaShAQsGAEGgoQELBgBBmKEBC9kDAgJ/An4jAEEgayICJAACQCABQv///////////wCDIgVCgICAgICAwP9DfCAFQoCAgICAgMCAvH98VARAIAFCBIYgAEI8iIQhBCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCEEDAILIARCgICAgICAgIBAfSEEIABCgICAgICAgIAIhUIAUg0BIARCAYMgBHwhBAwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQQMAQtCgICAgICAgPj/ACEEIAVC////////v//DAFYNAEIAIQQgBUIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qELMCIAIgACAEQYH4ACADaxCyAiACKQMIQgSGIAIpAwAiAEI8iIQhBCACKQMQIAIpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIARCAXwhBAwBCyAAQoCAgICAgICACIVCAFINACAEQgGDIAR8IQQLIAJBIGokACAEIAFCgICAgICAgICAf4OEvwtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAuLAgACQCAABH8gAUH/AE0NAQJAQZCaASgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAg8LIAFBgLADT0EAIAFBgEBxQYDAA0cbRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCAfGpB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0G0nAFBGTYCAEF/BUEBCw8LIAAgAToAAEEBC74CAQF/IwBBwMAAayIDJAAgAyAANgK4QCADIAE2ArRAIAMgAjcDqEACQCADKAK0QBBJQQBIBEAgAygCuEBBCGogAygCtEAQGCADQX82ArxADAELIANBADYCDCADQgA3AxADQAJAIAMgAygCtEAgA0EgakKAwAAQLyICNwMYIAJCAFcNACADKAK4QCADQSBqIAMpAxgQNkEASARAIANBfzYCDAUgAykDGEKAwABSDQIgAygCuEAoAlRFDQIgAykDqEBCAFcNAiADIAMpAxggAykDEHw3AxAgAygCuEAoAlQgAykDELkgAykDqEC5oxBYDAILCwsgAykDGEIAUwRAIAMoArhAQQhqIAMoArRAEBggA0F/NgIMCyADKAK0QBAyGiADIAMoAgw2ArxACyADKAK8QCEAIANBwMAAaiQAIAALqgEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI3AxggAyADKAIoKAIAEDUiAjcDEAJAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoIAMoAiQgAykDGBCQAyICNwMAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoKAIAEDUiAjcDCCACQgBTBEAgA0F/NgIsDAELIANBADYCLAsgAygCLCEAIANBMGokACAAC/4BAQF/IwBBoMAAayICJAAgAiAANgKYQCACIAE3A5BAIAIgAikDkEC6OQMAAkADQCACKQOQQEIAVgRAIAICfkKAwAAgAikDkEBCgMAAVg0AGiACKQOQQAs+AgwgAigCmEAoAgAgAkEQaiACKAIMrSACKAKYQEEIahBhQQBIBEAgAkF/NgKcQAwDCyACKAKYQCACQRBqIAIoAgytEDZBAEgEQCACQX82ApxADAMFIAIgAikDkEAgAjUCDH03A5BAIAIoAphAKAJUIAIrAwAgAikDkEC6oSACKwMAoxBYDAILAAsLIAJBADYCnEALIAIoApxAIQAgAkGgwABqJAAgAAvnEQIBfwF+IwBBoAFrIgMkACADIAA2ApgBIAMgATYClAEgAyACNgKQAQJAIAMoApQBIANBOGoQOUEASARAIAMoApgBQQhqIAMoApQBEBggA0F/NgKcAQwBCyADKQM4QsAAg1AEQCADIAMpAzhCwACENwM4IANBADsBaAsCQAJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQsgAy8BaEUNACADKAKQASADLwFoNgIQDAELAkACQCADKAKQASgCEA0AIAMpAzhCBINQDQAgAyADKQM4QgiENwM4IAMgAykDUDcDWAwBCyADIAMpAzhC9////w+DNwM4CwsgAykDOEKAAYNQBEAgAyADKQM4QoABhDcDOCADQQA7AWoLIANBgAI2AiQCQCADKQM4QgSDUARAIAMgAygCJEGACHI2AiQgA0J/NwNwDAELIAMoApABIAMpA1A3AyggAyADKQNQNwNwAkAgAykDOEIIg1AEQAJAAkACQAJAAkACfwJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQtBCAwBCyADKAKQASgCEAtB//8DcQ4NAgMDAwMDAwMBAwMDAAMLIANClMLk8w83AxAMAwsgA0KDg7D/DzcDEAwCCyADQv////8PNwMQDAELIANCADcDEAsgAykDUCADKQMQVgRAIAMgAygCJEGACHI2AiQLDAELIAMoApABIAMpA1g3AyALCyADIAMoApgBKAIAEDUiBDcDiAEgBEIAUwRAIAMoApgBQQhqIAMoApgBKAIAEBggA0F/NgKcAQwBCyADKAKQASIAIAAvAQxB9/8DcTsBDCADIAMoApgBIAMoApABIAMoAiQQXiIANgIoIABBAEgEQCADQX82ApwBDAELIAMgAy8BaAJ/AkAgAygCkAEoAhBBf0cEQCADKAKQASgCEEF+Rw0BC0EIDAELIAMoApABKAIQC0H//wNxRzoAIiADIAMtACJBAXEEfyADLwFoQQBHBUEAC0EBcToAISADIAMvAWgEfyADLQAhBUEBC0EBcToAICADIAMtACJBAXEEfyADKAKQASgCEEEARwVBAAtBAXE6AB8gAwJ/QQEgAy0AIkEBcQ0AGkEBIAMoApABKAIAQYABcQ0AGiADKAKQAS8BUiADLwFqRwtBAXE6AB4gAyADLQAeQQFxBH8gAy8BakEARwVBAAtBAXE6AB0gAyADLQAeQQFxBH8gAygCkAEvAVJBAEcFQQALQQFxOgAcIAMgAygClAE2AjQjAEEQayIAIAMoAjQ2AgwgACgCDCIAIAAoAjBBAWo2AjAgAy0AHUEBcQRAIAMgAy8BakEAEHciADYCDCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADLwFqQQAgAygCmAEoAhwgAygCDBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAy0AIUEBcQRAIAMgAygCmAEgAygCNCADLwFoEKsBIgA2AjAgAEUEQCADKAI0EBwgA0F/NgKcAQwCCyADKAI0EBwgAyADKAIwNgI0CyADLQAgQQFxBEAgAyADKAKYASADKAI0QQAQqgEiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtAB9BAXEEQCADIAMoApgBIAMoAjQgAygCkAEoAhAgAygCkAEvAVAQwgIiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtABxBAXEEQCADQQA2AgQCQCADKAKQASgCVARAIAMgAygCkAEoAlQ2AgQMAQsgAygCmAEoAhwEQCADIAMoApgBKAIcNgIECwsgAyADKAKQAS8BUkEBEHciADYCCCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADKAKQAS8BUkEBIAMoAgQgAygCCBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAyADKAKYASgCABA1IgQ3A4ABIARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAyADKAKYASADKAI0IAMpA3AQtQI2AiwgAygCNCADQThqEDlBAEgEQCADKAKYAUEIaiADKAI0EBggA0F/NgIsCyADIAMoAjQQuwIiADoAIyAAQRh0QRh1QQBIBEAgAygCmAFBCGogAygCNBAYIANBfzYCLAsgAygCNBAcIAMoAixBAEgEQCADQX82ApwBDAELIAMgAygCmAEoAgAQNSIENwN4IARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAygCmAEoAgAgAykDiAEQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAykDOELkAINC5ABSBEAgAygCmAFBCGpBFEEAEBUgA0F/NgKcAQwBCyADKAKQASgCAEEgcUUEQAJAIAMpAzhCEINCAFIEQCADKAKQASADKAJgNgIUDAELIAMoApABQRRqEAEaCwsgAygCkAEgAy8BaDYCECADKAKQASADKAJkNgIYIAMoApABIAMpA1A3AyggAygCkAEgAykDeCADKQOAAX03AyAgAygCkAEgAygCkAEvAQxB+f8DcSADLQAjQQF0cjsBDCADKAKQASADKAIkQYAIcUEARxCKAyADIAMoApgBIAMoApABIAMoAiQQXiIANgIsIABBAEgEQCADQX82ApwBDAELIAMoAiggAygCLEcEQCADKAKYAUEIakEUQQAQFSADQX82ApwBDAELIAMoApgBKAIAIAMpA3gQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgA0EANgKcAQsgAygCnAEhACADQaABaiQAIAALrwIBAX8jAEEgayICIAA2AhwgAiABNgIYIAJBADYCFCACQgA3AwACQCACKAIcLQAoQQFxRQRAIAIoAhwoAhggAigCHCgCFEYNAQsgAkEBNgIUCyACQgA3AwgDQCACKQMIIAIoAhwpAzBUBEACQAJAIAIoAhwoAkAgAikDCKdBBHRqKAIIDQAgAigCHCgCQCACKQMIp0EEdGotAAxBAXENACACKAIcKAJAIAIpAwinQQR0aigCBEUNASACKAIcKAJAIAIpAwinQQR0aigCBCgCAEUNAQsgAkEBNgIUCyACKAIcKAJAIAIpAwinQQR0ai0ADEEBcUUEQCACIAIpAwBCAXw3AwALIAIgAikDCEIBfDcDCAwBCwsgAigCGARAIAIoAhggAikDADcDAAsgAigCFAuMEAMCfwF+AXwjAEHgAGsiASQAIAEgADYCWAJAIAEoAlhFBEAgAUF/NgJcDAELIAEgASgCWCABQUBrELkCNgIkIAEpA0BQBEACQCABKAJYKAIEQQhxRQRAIAEoAiRFDQELIAEoAlgoAgAQhAJBAEgEQAJAAn8jAEEQayICIAEoAlgoAgA2AgwjAEEQayIAIAIoAgxBDGo2AgwgACgCDCgCAEEWRgsEQCMAQRBrIgIgASgC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NgI8IAEoAlAgASgCODYCQCABKAJYIAEoAjAQ1gIgASABKAJYKAIMNgJIIAEgASgCWCgCEDYCQCABIAEoAlgoAgA2AkwgASABKAJYKAIENgJEIAEgASgCUCgCPDYCPCABIAEoAlAoAkA2AjggASgCUCgCBEG//gBGBEAgASgCUEF/NgLINwsMDQsgASgCUEEANgLINwNAAkAgASABKAJQKAJQIAEoAjxBASABKAJQKAJYdEEBa3FBAnRqKAEANgEgIAEtACEgASgCOE0NACABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCwJAIAEtACBFDQAgAS0AIEHwAXENACABIAEoASA2ARgDQAJAIAEgASgCUCgCUCABLwEaIAEoAjxBASABLQAZIAEtABhqdEEBa3EgAS0AGXZqQQJ0aigBADYBICABLQAZIAEtACFqIAEoAjhNDQAgASgCREUNDiABIAEoAkRBf2o2AkQgASABKAJMIgBBAWo2AkwgASABKAI8IAAtAAAgASgCOHRqNgI8IAEgASgCOEEIajYCOAwBCwsgASABKAI8IAEtABl2NgI8IAEgASgCOCABLQAZazYCOCABKAJQIgAgAS0AGSAAKALIN2o2Asg3CyABIAEoAjwgAS0AIXY2AjwgASABKAI4IAEtACFrNgI4IAEoAlAiACABLQAhIAAoAsg3ajYCyDcgASgCUCABLwEiNgJEIAEtACBFBEAgASgCUEHN/gA2AgQMDQsgAS0AIEEgcQRAIAEoAlBBfzYCyDcgASgCUEG//gA2AgQMDQsgAS0AIEHAAHEEQCABKAJYQYfxADYCGCABKAJQQdH+ADYCBAwNCyABKAJQIAEtACBBD3E2AkwgASgCUEHJ/gA2AgQLIAEoAlAoAkwEQANAIAEoAjggASgCUCgCTEkEQCABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCyABKAJQIgAgACgCRCABKAI8QQEgASgCUCgCTHRBAWtxajYCRCABIAEoAjwgASgCUCgCTHY2AjwgASABKAI4IAEoAlAoAkxrNgI4IAEoAlAiACAB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KAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AiggAigCKCACKAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AigLCyACIAIoAgQgAigCLEEBIAIoAgx0QQFrcWo2AgQgAiACKAIsIAIoAgx2NgIsIAIgAigCKCACKAIMazYCKCACIAIoAkggAigCRGs2AgwCQCACKAIEIAIoAgxLBEAgAiACKAIEIAIoAgxrNgIMIAIoAgwgAigCOEsEQCACKAJUKALENwRAIAIoAlxBsO0ANgIYIAIoAlRB0f4ANgIEDAoLCyACIAIoAjA2AgACQCACKAI0RQRAIAIgAigCACACKAI8IAIoAgxrajYCACACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCSCACKAIEazYCAAsMAQsCQCACKAI0IAIoAgxJBEAgAiACKAIAIAIoAjwgAigCNGogAigCDGtqNgIAIAIgAigCDCACKAI0azYCDCACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCMDYCACACKAI0IAIoAghJBEAgAiACKAI0NgIMIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwwBCyACIAIoAgAgAigCNCACKAIMa2o2AgAgAigCDCACKAIISQRAIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwsDQCACKAIIQQJNRQRAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCCEEDazYCCAwBCwsMAQsgAiACKAJIIAIoAgRrNgIAA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIIQQNrNgIIIAIoAghBAksNAAsLIAIoAggEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIoAghBAUsEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAACwsMAgsgAigCDEHAAHFFBEAgAkEQaiACKAIgIAIvARIgAigCLEEBIAIoAgx0QQFrcWpBAnRqKAEANgEADAELCyACKAJcQc7tADYCGCACKAJUQdH+ADYCBAwECwwCCyACKAIMQcAAcUUEQCACQRBqIAIoAiQgAi8BEiACKAIsQQEgAigCDHRBAWtxakECdGooAQA2AQAMAQsLIAIoAgxBIHEEQCACKAJUQb/+ADYCBAwCCyACKAJcQeTtADYCGCACKAJUQdH+ADYCBAwBC0EAIQAgAigCUCACKAJMSQR/IAIoAkggAigCQEkFQQALQQFxDQELCyACIAIoAihBA3Y2AgggAiACKAJQIAIoAghrNgJQIAIgAigCKCACKAIIQQN0azYCKCACIAIoAixBASACKAIodEEBa3E2AiwgAigCXCACKAJQNgIAIAIoAlwgAigCSDYCDCACKAJcAn8gAigCUCACKAJMSQRAIAIoAkwgAigCUGtBBWoMAQtBBSACKAJQIAIoAkxraws2AgQgAigCXAJ/IAIoAkggAigCQEkEQCACKAJAIAIoAkhrQYECagwBC0GBAiACKAJIIAIoAkBraws2AhAgAigCVCACKAIsNgI8IAIoAlQgAigCKDYCQAvBEAECfyMAQSBrIgIk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LSAAKAKgLUEBdGogAi8BEDsBACACLQATIQEgAigCKCIAKAKYLSEDIAAgACgCoC0iAEEBajYCoC0gACADaiABOgAAIAIgAi8BEEF/ajsBECACKAIoIAItABNBgNkAai0AAEECdGpBmAlqIgAgAC8BAEEBajsBACACKAIoQYgTagJ/IAIvARBBgAJIBEAgAi8BEC0AgFUMAQsgAi8BEEEHdUGAAmotAIBVC0ECdGoiACAALwEAQQFqOwEAIAIgAigCKCgCoC0gAigCKCgCnC1BAWtGNgIgIAIoAigiACAAKAJ0IAIoAigoAmBrNgJ0IAIoAigiACACKAIoKAJgIAAoAmxqNgJsIAIoAihBADYCYAwBCyACIAIoAigiACgCOCAAKAJsai0AADoADyACKAIoIgAoAqQtIAAoAqAtQQF0akEAOwEAIAItAA8hASACKAIoIgAoApgtIQMgACAAKAKgLSIAQQFqNgKgLSAAIANqIAE6AAAgAigCKCACLQAPQQJ0aiIAIAAvAZQBQQFqOwGUASACIAIoAigoAqAtIAIoAigoApwtQQFrRjYCICACKAIoIgAgACgCdEF/ajYCdCACKAIoIgAgACgCbEEBajYCbAsgAigCIARAIAIoAigCfyACKAIoKAJcQQBOBEAgAigCKCgCOCACKAIoKAJcagwBC0EACyACKAIoKAJsIAIoAigoAlxrQQAQKSACKAIoIAIoAigoAmw2AlwgAigCKCgCABAdIAIoAigoAgAoAhBFBEAgAkEANgIsDAQLCwwBCwsgAigCKEEANgK0LSACKAIkQQRGBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBARApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQI2AiwMAgsgAkEDNgIsDAELIAIoAigoAqAtBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBABApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQA2AiwMAgsLIAJBATYCLAsgAigCLCEAIAJBMGokACAAC8AFAQJ/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQCQANAAkAgAigCGCgCdEUEQCACKAIYEFYgAigCGCgCdEUEQCACKAIURQRAIAJBADYCHAwFCwwCCwsgAigCGEEANgJgIAIgAigCGCIAKAI4IAAoAmxqLQAAOgAPIAIoAhgiACgCpC0gACgCoC1BAXRqQQA7AQAgAi0ADyEBIAIoAhgiACgCmC0hAyAAIAAoAqAtIgBBAWo2AqAtIAAgA2ogAToAACACKAIYIAItAA9BAnRqIgAgAC8BlAFBAWo7AZQBIAIgAigCGCgCoC0gAigCGCgCnC1BAWtGNgIQIAIoAhgiACAAKAJ0QX9qNgJ0IAIoAhgiACAAKAJsQQFqNgJsIAIoAhAEQCACKAIYAn8gAigCGCgCXEEATgRAIAIoAhgoAjggAigCGCgCXGoMAQtBAAsgAigCGCgCbCACKAIYKAJca0EAECkgAigCGCACKAIYKAJsNgJcIAIoAhgoAgAQHSACKAIYKAIAKAIQRQRAIAJBADYCHAwECwsMAQsLIAIoAhhBADYCtC0gAigCFEEERgRAIAIoAhgCfyACKAIYKAJcQQBOBEAgAigCGCgCOCACKAIYKAJcagwBC0EACyACKAIYKAJsIAIoAhgoAlxrQQEQKSACKAIYIAIoAhgoAmw2AlwgAigCGCgCABAdIAIoAhgoAgAoAhBFBEAgAkECNgIcDAILIAJBAzYCHAwBCyACKAIYKAKgLQRAIAIoAhgCfyACKAIYKAJcQQBOBEAgAigCGCgCOCACKAIYKAJcagwBC0EACyACKAIYKAJsIAIoAhgoAlxrQQAQKSACKAIYIAIoAhgoAmw2AlwgAigCGCgCABAdIAIoAhgoAgAoAhBFBEAgAkEANgIcDAILCyACQQE2AhwLIAIoAhwhACACQSBqJAAgAAuuJQEDfyMAQUBqIgIkACACIAA2AjggAiABNgI0AkACQAJAIAIoAjgQdA0AIAIoAjRBBUoNACACKAI0QQBODQELIAJBfjYCPAwBCyACIAIoAjgoAhw2AiwCQAJAIAIoAjgoAgxFDQAgAigCOCgCBARAIAIoAjgoAgBFDQELIAIoAiwoAgRBmgVHDQEgAigCNEEERg0BCyACKAI4QeDUACgCADYCGCACQX42AjwMAQsgAigCOCgCEEUEQCACKAI4QezUACgCADYCGCACQXs2AjwMAQsgAiACKAIsKAIoNgIwIAIoAiwgAigCNDYCKAJAIAIoAiwoAhQEQCACKAI4EB0gAigCOCgCEEUEQCACKAIsQX82AiggAkEANgI8DAMLDAELAkAgAigCOCgCBA0AIAIoAjRBAXRBCUEAIAIoAjRBBEobayACKAIwQQF0QQlBACACKAIwQQRKG2tKDQAgAigCNEEERg0AIAIoAjhB7NQAKAIANgIYIAJBezYCPAwCCwsCQCACKAIsKAIEQZoFRw0AIAIoAjgoAgRFDQAgAigCOEHs1AAoAgA2AhggAkF7NgI8DAELIAIoAiwoAgRBKkYEQCACIAIoAiwoAjBBBHRBiH9qQQh0NgIoAkACQCACKAIsKAKIAUECSARAIAIoAiwoAoQBQQJODQELIAJBADYCJAwBCwJAIAIoAiwoAoQBQQZIBEAgAkEBNgIkDAELAkAgAigCLCgChAFBBkYEQCACQQI2AiQMAQsgAkEDNgIkCwsLIAIgAigCKCACKAIkQQZ0cjYCKCACKAIsKAJsBEAgAiACKAIoQSByNgIoCyACIAIoAihBHyACKAIoQR9wa2o2AiggAigCLCACKAIoEEwgAigCLCgCbARAIAIoAiwgAigCOCgCMEEQdhBMIAIoAiwgAigCOCgCMEH//wNxEEwLQQBBAEEAED4hACACKAI4IAA2AjAgAigCLEHxADYCBCACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMAgsLIAIoAiwoAgRBOUYEQEEAQQBBABAbIQAgAigCOCAANgIwIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakEfOgAAIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakGLAToAACACKAIsKAIIIQEgAigCLCIDKAIUIQAgAyAAQQFqNgIUIAAgAWpBCDoAAAJAIAIoAiwoAhxFBEAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAACf0ECIAIoAiwoAoQBQQlGDQAaQQEhAEEEQQAgAigCLCgCiAFBAkgEfyACKAIsKAKEAUECSAVBAQtBAXEbCyEAIAIoAiwoAgghAyACKAIsIgQoAhQhASAEIAFBAWo2AhQgASADaiAAOgAAIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakEDOgAAIAIoAixB8QA2AgQgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAQLDAELIAIoAiwoAhwoAgBFRUECQQAgAigCLCgCHCgCLBtqQQRBACACKAIsKAIcKAIQG2pBCEEAIAIoAiwoAhwoAhwbakEQQQAgAigCLCgCHCgCJBtqIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCLCgCHCgCBEH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAIsKAIcKAIEQQh2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAgRBEHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCLCgCHCgCBEEYdiEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAAn9BAiACKAIsKAKEAUEJRg0AGkEBIQBBBEEAIAIoAiwoAogBQQJIBH8gAigCLCgChAFBAkgFQQELQQFxGwshACACKAIsKAIIIQMgAigCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogADoAACACKAIsKAIcKAIMQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAhAEQCACKAIsKAIcKAIUQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAhRBCHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAALIAIoAiwoAhwoAiwEQCACKAI4KAIwIAIoAiwoAgggAigCLCgCFBAbIQAgAigCOCAANgIwCyACKAIsQQA2AiAgAigCLEHFADYCBAsLIAIoAiwoAgRBxQBGBEAgAigCLCgCHCgCEARAIAIgAigCLCgCFDYCICACIAIoAiwoAhwoAhRB//8DcSACKAIsKAIgazYCHANAIAIoAiwoAhQgAigCHGogAigCLCgCDEsEQCACIAIoAiwoAgwgAigCLCgCFGs2AhggAigCLCgCCCACKAIsKAIUaiACKAIsKAIcKAIQIAIoAiwoAiBqIAIoAhgQGhogAigCLCACKAIsKAIMNgIUAkAgAigCLCgCHCgCLEUNACACKAIsKAIUIAIoAiBNDQAgAigCOCgCMCACKAIsKAIIIAIoAiBqIAIoAiwoAhQgAigCIGsQGyEAIAIoAjggADYCMAsgAigCLCIAIAIoAhggACgCIGo2AiAgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAUFIAJBADYCICACIAIoAhwgAigCGGs2AhwMAgsACwsgAigCLCgCCCACKAIsKAIUaiACKAIsKAIcKAIQIAIoAiwoAiBqIAIoAhwQGhogAigCLCIAIAIoAhwgACgCFGo2AhQCQCACKAIsKAIcKAIsRQ0AIAIoAiwoAhQgAigCIE0NACACKAI4KAIwIAIoAiwoAgggAigCIGogAigCLCgCFCACKAIgaxAbIQAgAigCOCAANgIwCyACKAIsQQA2AiALIAIoAixByQA2AgQLIAIoAiwoAgRByQBGBEAgAigCLCgCHCgCHARAIAIgAigCLCgCFDYCFANAIAIoAiwoAhQgAigCLCgCDEYEQAJAIAIoAiwoAhwoAixFDQAgAigCLCgCFCACKAIUTQ0AIAIoAjgoAjAgAigCLCgCCCACKAIUaiACKAIsKAIUIAIoAhRrEBshACACKAI4IAA2AjALIAIoAjgQHSACKAIsKAIUBEAgAigCLEF/NgIoIAJBADYCPAwFCyACQQA2AhQLIAIoAiwoAhwoAhwhASACKAIsIgMoAiAhACADIABBAWo2AiAgAiAAIAFqLQAANgIQIAIoAhAhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAIQDQALAkAgAigCLCgCHCgCLEUNACACKAIsKAIUIAIoAhRNDQAgAigCOCgCMCACKAIsKAIIIAIoAhRqIAIoAiwoAhQgAigCFGsQGyEAIAIoAjggADYCMAsgAigCLEEANgIgCyACKAIsQdsANgIECyACKAIsKAIEQdsARgRAIAIoAiwoAhwoAiQEQCACIAIoAiwoAhQ2AgwDQCACKAIsKAIUIAIoAiwoAgxGBEACQCACKAIsKAIcKAIsRQ0AIAIoAiwoAhQgAigCDE0NACACKAI4KAIwIAIoAiwoAgggAigCDGogAigCLCgCFCACKAIMaxAbIQAgAigCOCAANgIwCyACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMBQsgAkEANgIMCyACKAIsKAIcKAIkIQEgAigCLCIDKAIgIQAgAyAAQQFqNgIgIAIgACABai0AADYCCCACKAIIIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCCA0ACwJAIAIoAiwoAhwoAixFDQAgAigCLCgCFCACKAIMTQ0AIAIoAjgoAjAgAigCLCgCCCACKAIMaiACKAIsKAIUIAIoAgxrEBshACACKAI4IAA2AjALCyACKAIsQecANgIECyACKAIsKAIEQecARgRAIAIoAiwoAhwoAiwEQCACKAIsKAIUQQJqIAIoAiwoAgxLBEAgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAQLCyACKAI4KAIwQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAjBBCHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AABBAEEAQQAQGyEAIAIoAjggADYCMAsgAigCLEHxADYCBCACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMAgsLAkACQCACKAI4KAIEDQAgAigCLCgCdA0AIAIoAjRFDQEgAigCLCgCBEGaBUYNAQsgAgJ/IAIoAiwoAoQBRQRAIAIoAiwgAigCNBCxAQwBCwJ/IAIoAiwoAogBQQJGBEAgAigCLCACKAI0ENoCDAELAn8gAigCLCgCiAFBA0YEQCACKAIsIAIoAjQQ2QIMAQsgAigCLCACKAI0IAIoAiwoAoQBQQxsQbDqAGooAggRAgALCws2AgQCQCACKAIEQQJHBEAgAigCBEEDRw0BCyACKAIsQZoFNgIECwJAIAIoAgQEQCACKAIEQQJHDQELIAIoAjgoAhBFBEAgAigCLEF/NgIoCyACQQA2AjwMAgsgAigCBEEBRgRAAkAgAigCNEEBRgRAIAIoAiwQ6AIMAQsgAigCNEEFRwRAIAIoAixBAEEAQQAQVyACKAI0QQNGBEAgAigCLCgCRCACKAIsKAJMQQFrQQF0akEAOwEAIAIoAiwoAkRBACACKAIsKAJMQQFrQQF0EDMgAigCLCgCdEUEQCACKAIsQQA2AmwgAigCLEEANgJcIAIoAixBADYCtC0LCwsLIAIoAjgQHSACKAI4KAIQRQRAIAIoAixBfzYCKCACQQA2AjwMAwsLCyACKAI0QQRHBEAgAkEANgI8DAELIAIoAiwoAhhBAEwEQCACQQE2AjwMAQsCQCACKAIsKAIYQQJGBEAgAigCOCgCMEH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAI4KAIwQQh2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAjBBEHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCOCgCMEEYdiEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAghB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCOCgCCEEIdkH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAI4KAIIQRB2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAghBGHYhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAAAwBCyACKAIsIAIoAjgoAjBBEHYQTCACKAIsIAIoAjgoAjBB//8DcRBMCyACKAI4EB0gAigCLCgCGEEASgRAIAIoAixBACACKAIsKAIYazYCGAsgAiACKAIsKAIURTYCPAsgAigCPCEAIAJBQGskACAAC44CAQF/IwBBIGsiASAANgIcIAEgASgCHCgCLDYCDCABIAEoAhwoAkw2AhggASABKAIcKAJEIAEoAhhBAXRqNgIQA0AgASABKAIQQX5qIgA2AhAgASAALwEANgIUIAEoAhACfyABKAIUIAEoAgxPBEAgASgCFCABKAIMawwBC0EACzsBACABIAEoAhhBf2oiADYCGCAADQALIAEgASgCDDYCGCABIAEoAhwoAkAgASgCGEEBdGo2AhADQCABIAEoAhBBfmoiADYCECABIAAvAQA2AhQgASgCEAJ/IAEoAhQgASgCDE8EQCABKAIUIAEoAgxrDAELQQALOwEAIAEgASgCGEF/aiIANgIYIAANAAsLRQBBoJwBQgA3AwBBmJwBQgA3AwBBkJwBQgA3AwBBiJwBQgA3AwBBgJwBQgA3AwBB+JsBQgA3AwBB8JsBQgA3AwBB8JsBC6gCAQF/IwBBEGsiASQAIAEgADYCDCABKAIMIAEoAgwoAixBAXQ2AjwgASgCDCgCRCABKAIMKAJMQQFrQQF0akEAOwEAIAEoAgwoAkRBACABKAIMKAJMQQFrQQF0EDMgASgCDCABKAIMKAKEAUEMbEGw6gBqLwECNgKAASABKAIMIAEoAgwoAoQBQQxsQbDqAGovAQA2AowBIAEoAgwgASgCDCgChAFBDGxBsOoAai8BBDYCkAEgASgCDCABKAIMKAKEAUEMbEGw6gBqLwEGNgJ8IAEoAgxBADYCbCABKAIMQQA2AlwgASgCDEEANgJ0IAEoAgxBADYCtC0gASgCDEECNgJ4IAEoAgxBAjYCYCABKAIMQQA2AmggASgCDEEANgJIIAFBEGokAAubAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHQEQCABQX42AgwMAQsgASgCCEEANgIUIAEoAghBADYCCCABKAIIQQA2AhggASgCCEECNgIsIAEgASgCCCgCHDYCBCABKAIEQQA2AhQgASgCBCABKAIEKAIINgIQIAEoAgQoAhhBAEgEQCABKAIEQQAgASgCBCgCGGs2AhgLIAEoAgQCf0E5IAEoAgQoAhhBAkYNABpBKkHxACABKAIEKAIYGws2AgQCfyABKAIEKAIYQQJGBEBBAEEAQQAQGwwBC0EAQQBBABA+CyEAIAEoAgggADYCMCABKAIEQQA2AiggASgCBBDqAiABQQA2AgwLIAEoAgwhACABQRBqJAAgAAtFAQF/IwBBEGsiASQAIAEgADYCDCABIAEoAgwQ3wI2AgggASgCCEUEQCABKAIMKAIcEN4CCyABKAIIIQAgAUEQaiQAIAAL4AgBAX8jAEEwayICJAAgAiAANgIoIAIgATYCJCACQQg2AiAgAkFxNgIcIAJBCTYCGCACQQA2AhQgAkGQgwE2AhAgAkE4NgIMIAJBATYCBAJAAkACQCACKAIQRQ0AIAIoAhAsAABBqOoALAAARw0AIAIoAgxBOEYNAQsgAkF6NgIsDAELIAIoAihFBEAgAkF+NgIsDAELIAIoAihBADYCGCACKAIoKAIgRQRAIAIoAihBBTYCICACKAIoQQA2AigLIAIoAigoAiRFBEAgAigCKEEGNgIkCyACKAIkQX9GBEAgAkEGNgIkCwJAIAIoAhxBAEgEQCACQQA2AgQgAkEAIAIoAhxrNgIcDAELIAIoAhxBD0oEQCACQQI2AgQgAiACKAIcQRBrNgIcCwsCQAJAIAIoAhhBAUgNACACKAIYQQlKDQAgAigCIEEIRw0AIAIoAhxBCEgNACACKAIcQQ9KDQAgAigCJEEASA0AIAIoAiRBCUoNACACKAIUQQBIDQAgAigCFEEESg0AIAIoAhxBCEcNASACKAIEQQFGDQELIAJBfjYCLAwBCyACKAIcQQhGBEAgAkEJNgIcCyACIAIoAigoAihBAUHELSACKAIoKAIgEQEANgIIIAIoAghFBEAgAkF8NgIsDAELIAIoAiggAigCCDYCHCACKAIIIAIoAig2AgAgAigCCEEqNgIEIAIoAgggAigCBDYCGCACKAIIQQA2AhwgAigCCCACKAIcNgIwIAIoAghBASACKAIIKAIwdDYCLCACKAIIIAIoAggoAixBAWs2AjQgAigCCCACKAIYQQdqNgJQIAIoAghBASACKAIIKAJQdDYCTCACKAIIIAIoAggoAkxBAWs2AlQgAigCCCACKAIIKAJQQQJqQQNuNgJYIAIoAigoAiggAigCCCgCLEECIAIoAigoAiARAQAhACACKAIIIAA2AjggAigCKCgCKCACKAIIKAIsQQIgAigCKCgCIBEBACEAIAIoAgggADYCQCACKAIoKAIoIAIoAggoAkxBAiACKAIoKAIgEQEAIQAgAigCCCAANgJEIAIoAghBADYCwC0gAigCCEEBIAIoAhhBBmp0NgKcLSACIAIoAigoAiggAigCCCgCnC1BBCACKAIoKAIgEQEANgIAIAIoAgggAigCADYCCCACKAIIIAIoAggoApwtQQJ0NgIMAkACQCACKAIIKAI4RQ0AIAIoAggoAkBFDQAgAigCCCgCREUNACACKAIIKAIIDQELIAIoAghBmgU2AgQgAigCKEHo1AAoAgA2AhggAigCKBCyARogAkF8NgIsDAELIAIoAgggAigCACACKAIIKAKcLUEBdkEBdGo2AqQtIAIoAgggAigCCCgCCCACKAIIKAKcLUEDbGo2ApgtIAIoAgggAigCJDYChAEgAigCCCACKAIUNgKIASACKAIIIAIoAiA6ACQgAiACKAIoEOACNgIsCyACKAIsIQAgAkEwaiQAIAALbAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEANgIEA0AgAiACKAIEIAIoAgxBAXFyNgIEIAIgAigCDEEBdjYCDCACIAIoAgRBAXQ2AgQgAiACKAIIQX9qIgA2AgggAEEASg0ACyACKAIEQQF2C5UCAQF/IwBBQGoiAyQAIAMgADYCPCADIAE2AjggAyACNgI0IANBADYCDCADQQE2AggDQCADKAIIQQ9KRQRAIAMgAygCDCADKAI0IAMoAghBAWtBAXRqLwEAakEBdDYCDCADQRBqIAMoAghBAXRqIAMoAgw7AQAgAyADKAIIQQFqNgIIDAELCyADQQA2AgQDQCADKAIEIAMoAjhMBEAgAyADKAI8IAMoAgRBAnRqLwECNgIAIAMoAgAEQCADQRBqIAMoAgBBAXRqIgEvAQAhACABIABBAWo7AQAgAEH//wNxIAMoAgAQ4gIhACADKAI8IAMoAgRBAnRqIAA7AQALIAMgAygCBEEBajYCBAwBCwsgA0FAayQAC4gIAQF/IwBBQGoiAiAANgI8IAIgATYCOCACIAIoAjgoAgA2AjQgAiACKAI4KAIENgIwIAIgAigCOCgCCCgCADYCLCACIAIoAjgoAggoAgQ2AiggAiACKAI4KAIIKAIINgIkIAIgAigCOCgCCCgCEDYCICACQQA2AgQgAkEANgIQA0AgAigCEEEPSkUEQCACKAI8QbwWaiACKAIQQQF0akEAOwEAIAIgAigCEEEBajYCEAwBCwsgAigCNCACKAI8QdwWaiACKAI8KALUKEECdGooAgBBAnRqQQA7AQIgAiACKAI8KALUKEEBajYCHANAIAIoAhxBvQRIBEAgAiACKAI8QdwWaiACKAIcQQJ0aigCADYCGCACIAIoAjQgAigCNCACKAIYQQJ0ai8BAkECdGovAQJBAWo2AhAgAigCECACKAIgSgRAIAIgAigCIDYCECACIAIoAgRBAWo2AgQLIAIoAjQgAigCGEECdGogAigCEDsBAiACKAIYIAIoAjBMBEAgAigCPCACKAIQQQF0akG8FmoiACAALwEAQQFqOwEAIAJBADYCDCACKAIYIAIoAiROBEAgAiACKAIoIAIoAhggAigCJGtBAnRqKAIANgIMCyACIAIoAjQgAigCGEECdGovAQA7AQogAigCPCIAIAAoAqgtIAIvAQogAigCECACKAIMamxqNgKoLSACKAIsBEAgAigCPCIAIAAoAqwtIAIvAQogAigCLCACKAIYQQJ0ai8BAiACKAIMamxqNgKsLQsLIAIgAigCHEEBajYCHAwBCwsCQCACKAIERQ0AA0AgAiACKAIgQQFrNgIQA0AgAigCPEG8FmogAigCEEEBdGovAQBFBEAgAiACKAIQQX9qNgIQDAELCyACKAI8IAIoAhBBAXRqQbwWaiIAIAAvAQBBf2o7AQAgAigCPCACKAIQQQF0akG+FmoiACAALwEAQQJqOwEAIAIoAjwgAigCIEEBdGpBvBZqIgAgAC8BAEF/ajsBACACIAIoAgRBAms2AgQgAigCBEEASg0ACyACIAIoAiA2AhADQCACKAIQRQ0BIAIgAigCPEG8FmogAigCEEEBdGovAQA2AhgDQCACKAIYBEAgAigCPEHcFmohACACIAIoAhxBf2oiATYCHCACIAFBAnQgAGooAgA2AhQgAigCFCACKAIwSg0BIAIoAjQgAigCFEECdGovAQIgAigCEEcEQCACKAI8IgAgACgCqC0gAigCNCACKAIUQQJ0ai8BACACKAIQIAIoAjQgAigCFEECdGovAQJrbGo2AqgtIAIoAjQgAigCFEECdGogAigCEDsBAgsgAiACKAIYQX9qNgIYDAELCyACIAIo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KAIMIAEoAgxB/BRqNgKwFiABKAIMQajbADYCuBYgASgCDEEAOwG4LSABKAIMQQA2ArwtIAEoAgwQuQEgAUEQaiQAC9cNAQF/IwBBIGsiAyAANgIYIAMgATYCFCADIAI2AhAgAyADKAIYQRB2NgIMIAMgAygCGEH//wNxNgIYAkAgAygCEEEBRgRAIAMgAygCFC0AACADKAIYajYCGCADKAIYQfH/A08EQCADIAMoAhhB8f8DazYCGAsgAyADKAIYIAMoAgxqNgIMIAMoAgxB8f8DTwRAIAMgAygCDEHx/wNrNgIMCyADIAMoAhggAygCDEEQdHI2AhwMAQsgAygCFEUEQCADQQE2AhwMAQsgAygCEEEQSQRAA0AgAyADKAIQIgBBf2o2AhAgAARAIAMgAygCFCIAQQFqNgIUIAMgAC0AACADKAIYajYCGCADIAMoAhggAygCDGo2AgwMAQsLIAMoAhhB8f8DTwRAIAMgAygCGEHx/wNrNgIYCyADIAMoAgxB8f8DcDYCDCADIAMoAhggAygCDEEQdHI2AhwMAQsDQCADKAIQQbArSUUEQCADIAMoAhBBsCtrNgIQIANB2wI2AggDQCADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFCADIAMoAghBf2oiADYCCCAADQALIAMgAygCGEHx/wNwNgIYIAMgAygCDEHx/wNwNgIMDAELCyADKAIQBEADQCADKAIQQRBJRQRAIAMgAygCEEEQazYCECADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFAwBCwsDQCADIAMoAhAiAEF/ajYCECAABEAgAyADKAIUIgBBAWo2AhQgAyAALQAAIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDAwBCwsgAyADKAIYQfH/A3A2AhggAyADKAIMQfH/A3A2AgwLIAMgAygC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KAIEDAELIAMoAgwoAgALQYAEEF4iADYCECAAQQBIBEAgA0J/NwO4AQwDCyADKAIQBEAgA0EBOgAXCyADIAMpAxhCAXw3AxgMAQsLIAMgAygCtAEoAgAQNSICNwMgIAJCAFMEQCADKAK0AUEIaiADKAK0ASgCABAYIANCfzcDuAEMAQsgAyADKQMgIAMpA6ABfTcDmAECQCADKQOgAUL/////D1gEQCADKQOoAUL//wNYDQELIANBAToAFwsgAyADQTBqQuIAECoiADYCLCAARQRAIAMoArQBQQhqQQ5BABAVIANCfzcDuAEMAQsgAy0AF0EBcQRAIAMoAixBttMAQQQQQCADKAIsQiwQLiADKAIsQS0QICADKAIsQS0QICADKAIsQQAQISADKAIsQQAQISADKAIsIAMpA6gBEC4gAygCLCADKQOoARAuIAMoAiwgAykDmAEQLiADKAIsIAMpA6ABEC4gAygCLEG70wBBBBBAIAMoAixBABAhIAMoAiwgAykDoAEgAykDmAF8EC4gAygCLEEBECELIAMoAixBwNMAQQQQQCADKAIsQQAQISADKAIsAn5C//8DIAMpA6gBQv//A1oNABogAykDqAELp0H//wNxECAgAygCLAJ+Qv//AyADKQOoAUL//wNaDQAaIAMpA6gBC6dB//8DcRAgIAMoAiwCf0F/IAMpA5gBQv////8PWg0AGiADKQOYAacLECEgAygCLAJ/QX8gAykDoAFC/////w9aDQAaIAMpA6ABpwsQISADAn8gAygCtAEtAChBAXEEQCADKAK0ASgCJAwBCyADKAK0ASgCIAs2ApQBIAMoAiwCfyADKAKUAQRAIAMoApQBLwEEDAELQQALQf//A3EQIAJ/IwBBEGsiACADKAIsNgIMIAAoAgwtAABBAXFFCwRAIAMoArQBQQhqQRRBABAVIAMoAiwQFyADQn83A7gBDAELIAMoArQBAn8jAEEQayIAIAMoAiw2AgwgACgCDCgCBAsCfiMAQRBrIgAgAygCLDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALCxA2QQBIBEAgAygCLBAXIANCfzcDuAEMAQsgAygCLBAXIAMoApQBBEAgAygCtAEgAygClAEoAgAgAygClAEvAQStEDZBAEgEQCADQn83A7gBDAILCyADIAMpA5gBNwO4AQsgAykDuAEhAiADQcABaiQAIAILBwAgACgCIAsIAEEBQTgQewsDAAELC/KNAScAQYAIC5QFTm8gZXJyb3IATXVsdGktZGlzayB6aXAgYXJjaGl2ZXMgbm90IHN1cHBvcnRlZABSZW5hbWluZyB0ZW1wb3JhcnkgZmlsZSBmYWlsZWQAQ2xvc2luZyB6aXAgYXJjaGl2ZSBmYWlsZWQAU2VlayBlcnJvcgBSZWFkIGVycm9yAFdyaXRlIGVycm9yAENSQyBlcnJvcgBDb250YWluaW5nIHppcCBhcmNoaXZlIHdhcyBjbG9zZWQATm8gc3VjaCBmaWxlAEZpbGUgYWxyZWFkeSBleGlzdHMAQ2FuJ3Qgb3BlbiBmaWxlAEZhaWx1cmUgdG8gY3JlYXRlIHRlbXBvcmFyeSBmaWxlAFpsaWIgZXJyb3IATWFsbG9jIGZhaWx1cmUARW50cnkgaGFzIGJlZW4gY2hhbmdlZABDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABQcmVtYXR1cmUgZW5kIG9mIGZpbGUASW52YWxpZCBhcmd1bWVudABOb3QgYSB6aXAgYXJjaGl2ZQBJbnRlcm5hbCBlcnJvcgBaaXAgYXJjaGl2ZSBpbmNvbnNpc3RlbnQAQ2FuJ3QgcmVtb3ZlIGZpbGUARW50cnkgaGFzIGJlZW4gZGVsZXRlZABFbmNyeXB0aW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkAFJlYWQtb25seSBhcmNoaXZlAE5vIHBhc3N3b3JkIHByb3ZpZGVkAFdyb25nIHBhc3N3b3JkIHByb3ZpZGVkAE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkAFJlc291cmNlIHN0aWxsIGluIHVzZQBUZWxsIGVycm9yAENvbXByZXNzZWQgZGF0YSBpbnZhbGlkAEGhDQuAAQQAAAkEAAAvBAAATgQAAGkEAAB0BAAAfwQAAIsEAACVBAAAtwQAAMQEAADYBAAA6AQAAAkFAAAUBQAAIwUAADoFAABbBQAAcQUAAIIFAACUBQAAowUAALwFAADOBQAA5QUAAAUGAAAXBgAALAYAAEQGAABcBgAAcgYAAH0GAAAgAEG4DgsRAQAAAAEAAAABAAAAAQAAAAEAQdwOCwkBAAAAAQAAAAIAQYgPCwEBAEGoDwsB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CAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYACAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgA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cnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAFVua25vd24gZXJyb3IgJWQAJXMlcyVzAAA6IAAvcHJvYy9zZWxmL2ZkLwAvZGV2L3VyYW5kb20AcndhACVzLlhYWFhYWAByK2IAcmIAUEsFBgBBkJgBC04KAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAARAAAAAQAAAAgAAAAQTAAAMEwAQZCaAQsCgFAAQciaAQsJHwAAAGRNAAADAEHkmgELjAEt9FFYz4yxwEb2tcspMQPHBFtwMLRd/SB4f4ua2FkpUGhIiaunVgNs/7fNiD/Ud7QrpaNw8brkqPxBg/3Zb+GKei8tdJYHHw0JXgN2LHD3QKUsp29XQaiqdN+gWGQDSsfEPFOur18YBBWx420ohqsMpL9D8OlQgTlXFlI3/////////////////////w==";

    if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
    }

    function getBinary() {
      try {
        if (wasmBinary) {
          return new Uint8Array(wasmBinary);
        }

        var binary = tryParseAsDataURI(wasmBinaryFile);

        if (binary) {
          return binary;
        }

        if (readBinary) {
          return readBinary(wasmBinaryFile);
        } else {
          throw "both async and sync fetching of the wasm failed";
        }
      } catch (err) {
        abort(err);
      }
    }

    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
        return fetch(wasmBinaryFile, {
          credentials: "same-origin"
        }).then(function (response) {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
          }

          return response["arrayBuffer"]();
        }).catch(function () {
          return getBinary();
        });
      }

      return Promise.resolve().then(getBinary);
    }

    function createWasm() {
      var info = {
        a: asmLibraryArg
      };

      function receiveInstance(instance, module) {
        var exports = instance.exports;
        Module["asm"] = exports;
        removeRunDependency("wasm-instantiate");
      }

      addRunDependency("wasm-instantiate");

      function receiveInstantiatedSource(output) {
        receiveInstance(output["instance"]);
      }

      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise().then(function (binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(receiver, function (reason) {
          err("failed to asynchronously prepare wasm: " + reason);
          abort(reason);
        });
      }

      function instantiateAsync() {
        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
          fetch(wasmBinaryFile, {
            credentials: "same-origin"
          }).then(function (response) {
            var result = WebAssembly.instantiateStreaming(response, info);
            return result.then(receiveInstantiatedSource, function (reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(receiveInstantiatedSource);
            });
          });
        } else {
          return instantiateArrayBuffer(receiveInstantiatedSource);
        }
      }

      if (Module["instantiateWasm"]) {
        try {
          var exports = Module["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          return false;
        }
      }

      return instantiateAsync();
    }

    var tempDouble;
    var tempI64;

    __ATINIT__.push({
      func: function () {
        ___wasm_call_ctors();
      }
    });

    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();

        if (typeof callback == "function") {
          callback(Module);
          continue;
        }

        var func = callback.func;

        if (typeof func === "number") {
          if (callback.arg === undefined) {
            wasmTable.get(func)();
          } else {
            wasmTable.get(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

    function demangle(func) {
      return func;
    }

    function demangleAll(text) {
      var regex = /\b_Z[\w\d_]+/g;
      return text.replace(regex, function (x) {
        var y = demangle(x);
        return x === y ? x : y + " [" + x + "]";
      });
    }

    function jsStackTrace() {
      var error = new Error();

      if (!error.stack) {
        try {
          throw new Error();
        } catch (e) {
          error = e;
        }

        if (!error.stack) {
          return "(no stack trace available)";
        }
      }

      return error.stack.toString();
    }

    function stackTrace() {
      var js = jsStackTrace();
      if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
      return demangleAll(js);
    }

    function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[time >> 2] * 1e3);
      HEAP32[tmPtr >> 2] = date.getUTCSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      HEAP32[tmPtr + 36 >> 2] = 0;
      HEAP32[tmPtr + 32 >> 2] = 0;
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      if (!_gmtime_r.GMTString) _gmtime_r.GMTString = allocateUTF8("GMT");
      HEAP32[tmPtr + 40 >> 2] = _gmtime_r.GMTString;
      return tmPtr;
    }

    function ___gmtime_r(a0, a1) {
      return _gmtime_r(a0, a1);
    }

    var PATH = {
      splitPath: function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: function (parts, allowAboveRoot) {
        var up = 0;

        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];

          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }

        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }

        return parts;
      },
      normalize: function (path) {
        var isAbsolute = path.charAt(0) === "/",
            trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter(function (p) {
          return !!p;
        }), !isAbsolute).join("/");

        if (!path && !isAbsolute) {
          path = ".";
        }

        if (path && trailingSlash) {
          path += "/";
        }

        return (isAbsolute ? "/" : "") + path;
      },
      dirname: function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];

        if (!root && !dir) {
          return ".";
        }

        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }

        return root + dir;
      },
      basename: function (path) {
        if (path === "/") return "/";
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      },
      extname: function (path) {
        return PATH.splitPath(path)[3];
      },
      join: function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      },
      join2: function (l, r) {
        return PATH.normalize(l + "/" + r);
      }
    };

    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }

    var PATH_FS = {
      resolve: function () {
        var resolvedPath = "",
            resolvedAbsolute = false;

        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();

          if (typeof path !== "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            return "";
          }

          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charAt(0) === "/";
        }

        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function (p) {
          return !!p;
        }), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: function (from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);

        function trim(arr) {
          var start = 0;

          for (; start < arr.length; start++) {
            if (arr[start] !== "") break;
          }

          var end = arr.length - 1;

          for (; end >= 0; end--) {
            if (arr[end] !== "") break;
          }

          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }

        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;

        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }

        var outputParts = [];

        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }

        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    var TTY = {
      ttys: [],
      init: function () {},
      shutdown: function () {},
      register: function (dev, ops) {
        TTY.ttys[dev] = {
          input: [],
          output: [],
          ops: ops
        };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function (stream) {
          var tty = TTY.ttys[stream.node.rdev];

          if (!tty) {
            throw new FS.ErrnoError(43);
          }

          stream.tty = tty;
          stream.seekable = false;
        },
        close: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        flush: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        read: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }

          var bytesRead = 0;

          for (var i = 0; i < length; i++) {
            var result;

            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }

            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }

            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset + i] = result;
          }

          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }

          return bytesRead;
        },
        write: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }

          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }

          if (length) {
            stream.node.timestamp = Date.now();
          }

          return i;
        }
      },
      default_tty_ops: {
        get_char: function (tty) {
          if (!tty.input.length) {
            var result = null;

            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;

              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().indexOf("EOF") != -1) bytesRead = 0;else throw e;
              }

              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");

              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();

              if (result !== null) {
                result += "\n";
              }
            }

            if (!result) {
              return null;
            }

            tty.input = intArrayFromString(result, true);
          }

          return tty.input.shift();
        },
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      },
      default_tty1_ops: {
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      }
    };
    var MEMFS = {
      ops_table: null,
      mount: function (mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode: function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }

        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }

        var node = FS.createNode(parent, name, mode, dev);

        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }

        node.timestamp = Date.now();

        if (parent) {
          parent.contents[name] = node;
        }

        return node;
      },
      getFileDataAsRegularArray: function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];

          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);

          return arr;
        }

        return node.contents;
      },
      getFileDataAsTypedArray: function (node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function (node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        return;
      },
      resizeFileStorage: function (node, newSize) {
        if (node.usedBytes == newSize) return;

        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
          return;
        }

        if (!node.contents || node.contents.subarray) {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);

          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }

          node.usedBytes = newSize;
          return;
        }

        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },
      node_ops: {
        getattr: function (node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;

          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }

          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }

          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }

          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function (parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function (old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;

            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}

            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }

          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },
        unlink: function (parent, name) {
          delete parent.contents[name];
        },
        rmdir: function (parent, name) {
          var node = FS.lookupNode(parent, name);

          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }

          delete parent.contents[name];
        },
        readdir: function (node) {
          var entries = [".", ".."];

          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }

            entries.push(key);
          }

          return entries;
        },
        symlink: function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }

          return node.link;
        }
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);

          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }

          return size;
        },
        write: function (stream, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }

          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();

          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }

          MEMFS.expandFileStorage(node, position + length);

          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }

          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function (stream, offset, whence) {
          var position = offset;

          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }

          if (position < 0) {
            throw new FS.ErrnoError(28);
          }

          return position;
        },
        allocate: function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
        mmap: function (stream, address, length, position, prot, flags) {
          assert(address === 0);

          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }

          var ptr;
          var allocated;
          var contents = stream.node.contents;

          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }

            allocated = true;
            ptr = FS.mmapAlloc(length);

            if (!ptr) {
              throw new FS.ErrnoError(48);
            }

            HEAP8.set(contents, ptr);
          }

          return {
            ptr: ptr,
            allocated: allocated
          };
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }

          if (mmapFlags & 2) {
            return 0;
          }

          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var ERRNO_CODES = {
      EPERM: 63,
      ENOENT: 44,
      ESRCH: 71,
      EINTR: 27,
      EIO: 29,
      ENXIO: 60,
      E2BIG: 1,
      ENOEXEC: 45,
      EBADF: 8,
      ECHILD: 12,
      EAGAIN: 6,
      EWOULDBLOCK: 6,
      ENOMEM: 48,
      EACCES: 2,
      EFAULT: 21,
      ENOTBLK: 105,
      EBUSY: 10,
      EEXIST: 20,
      EXDEV: 75,
      ENODEV: 43,
      ENOTDIR: 54,
      EISDIR: 31,
      EINVAL: 28,
      ENFILE: 41,
      EMFILE: 33,
      ENOTTY: 59,
      ETXTBSY: 74,
      EFBIG: 22,
      ENOSPC: 51,
      ESPIPE: 70,
      EROFS: 69,
      EMLINK: 34,
      EPIPE: 64,
      EDOM: 18,
      ERANGE: 68,
      ENOMSG: 49,
      EIDRM: 24,
      ECHRNG: 106,
      EL2NSYNC: 156,
      EL3HLT: 107,
      EL3RST: 108,
      ELNRNG: 109,
      EUNATCH: 110,
      ENOCSI: 111,
      EL2HLT: 112,
      EDEADLK: 16,
      ENOLCK: 46,
      EBADE: 113,
      EBADR: 114,
      EXFULL: 115,
      ENOANO: 104,
      EBADRQC: 103,
      EBADSLT: 102,
      EDEADLOCK: 16,
      EBFONT: 101,
      ENOSTR: 100,
      ENODATA: 116,
      ETIME: 117,
      ENOSR: 118,
      ENONET: 119,
      ENOPKG: 120,
      EREMOTE: 121,
      ENOLINK: 47,
      EADV: 122,
      ESRMNT: 123,
      ECOMM: 124,
      EPROTO: 65,
      EMULTIHOP: 36,
      EDOTDOT: 125,
      EBADMSG: 9,
      ENOTUNIQ: 126,
      EBADFD: 127,
      EREMCHG: 128,
      ELIBACC: 129,
      ELIBBAD: 130,
      ELIBSCN: 131,
      ELIBMAX: 132,
      ELIBEXEC: 133,
      ENOSYS: 52,
      ENOTEMPTY: 55,
      ENAMETOOLONG: 37,
      ELOOP: 32,
      EOPNOTSUPP: 138,
      EPFNOSUPPORT: 139,
      ECONNRESET: 15,
      ENOBUFS: 42,
      EAFNOSUPPORT: 5,
      EPROTOTYPE: 67,
      ENOTSOCK: 57,
      ENOPROTOOPT: 50,
      ESHUTDOWN: 140,
      ECONNREFUSED: 14,
      EADDRINUSE: 3,
      ECONNABORTED: 13,
      ENETUNREACH: 40,
      ENETDOWN: 38,
      ETIMEDOUT: 73,
      EHOSTDOWN: 142,
      EHOSTUNREACH: 23,
      EINPROGRESS: 26,
      EALREADY: 7,
      EDESTADDRREQ: 17,
      EMSGSIZE: 35,
      EPROTONOSUPPORT: 66,
      ESOCKTNOSUPPORT: 137,
      EADDRNOTAVAIL: 4,
      ENETRESET: 39,
      EISCONN: 30,
      ENOTCONN: 53,
      ETOOMANYREFS: 141,
      EUSERS: 136,
      EDQUOT: 19,
      ESTALE: 72,
      ENOTSUP: 138,
      ENOMEDIUM: 148,
      EILSEQ: 25,
      EOVERFLOW: 61,
      ECANCELED: 11,
      ENOTRECOVERABLE: 56,
      EOWNERDEAD: 62,
      ESTRPIPE: 135
    };
    var NODEFS = {
      isWindows: false,
      staticInit: function () {
        NODEFS.isWindows = false;
        var flags = {
          fs: fs.constants
        };

        if (flags["fs"]) {
          flags = flags["fs"];
        }

        NODEFS.flagsForNodeMap = {
          1024: flags["O_APPEND"],
          64: flags["O_CREAT"],
          128: flags["O_EXCL"],
          0: flags["O_RDONLY"],
          2: flags["O_RDWR"],
          4096: flags["O_SYNC"],
          512: flags["O_TRUNC"],
          1: flags["O_WRONLY"]
        };
      },
      bufferFrom: function (arrayBuffer) {
        return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
      },
      convertNodeCode: function (e) {
        var code = e.code;
        return ERRNO_CODES[code];
      },
      mount: function (mount) {
        return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
      },
      createNode: function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }

        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },
      getMode: function (path) {
        var stat;

        try {
          stat = fs.lstatSync(path);

          if (NODEFS.isWindows) {
            stat.mode = stat.mode | (stat.mode & 292) >> 2;
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }

        return stat.mode;
      },
      realPath: function (node) {
        var parts = [];

        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }

        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },
      flagsForNode: function (flags) {
        flags &= ~2097152;
        flags &= ~2048;
        flags &= ~32768;
        flags &= ~524288;
        var newFlags = 0;

        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }

        if (!flags) {
          return newFlags;
        } else {
          throw new FS.ErrnoError(28);
        }
      },
      node_ops: {
        getattr: function (node) {
          var path = NODEFS.realPath(node);
          var stat;

          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }

          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }

          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }

          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },
        setattr: function (node, attr) {
          var path = NODEFS.realPath(node);

          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              node.mode = attr.mode;
            }

            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }

            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        lookup: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },
        mknod: function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          var path = NODEFS.realPath(node);

          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, "", {
                mode: node.mode
              });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }

          return node;
        },
        rename: function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);

          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }

          oldNode.name = newName;
        },
        unlink: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);

          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        rmdir: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);

          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        readdir: function (node) {
          var path = NODEFS.realPath(node);

          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        symlink: function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);

          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        readlink: function (node) {
          var path = NODEFS.realPath(node);

          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }
      },
      stream_ops: {
        open: function (stream) {
          var path = NODEFS.realPath(stream.node);

          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        close: function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        read: function (stream, buffer, offset, length, position) {
          if (length === 0) return 0;

          try {
            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        write: function (stream, buffer, offset, length, position) {
          try {
            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        llseek: function (stream, offset, whence) {
          var position = offset;

          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }
          }

          if (position < 0) {
            throw new FS.ErrnoError(28);
          }

          return position;
        },
        mmap: function (stream, address, length, position, prot, flags) {
          assert(address === 0);

          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }

          var ptr = FS.mmapAlloc(length);
          NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
          return {
            ptr: ptr,
            allocated: true
          };
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }

          if (mmapFlags & 2) {
            return 0;
          }

          var bytesWritten = NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var NODERAWFS = {
      lookupPath: function (path) {
        return {
          path: path,
          node: {
            mode: NODEFS.getMode(path)
          }
        };
      },
      createStandardStreams: function () {
        FS.streams[0] = {
          fd: 0,
          nfd: 0,
          position: 0,
          path: "",
          flags: 0,
          tty: true,
          seekable: false
        };

        for (var i = 1; i < 3; i++) {
          FS.streams[i] = {
            fd: i,
            nfd: i,
            position: 0,
            path: "",
            flags: 577,
            tty: true,
            seekable: false
          };
        }
      },
      cwd: function () {
        return process.cwd();
      },
      chdir: function () {
        process.chdir.apply(void 0, arguments);
      },
      mknod: function (path, mode) {
        if (FS.isDir(path)) {
          fs.mkdirSync(path, mode);
        } else {
          fs.writeFileSync(path, "", {
            mode: mode
          });
        }
      },
      mkdir: function () {
        fs.mkdirSync.apply(void 0, arguments);
      },
      symlink: function () {
        fs.symlinkSync.apply(void 0, arguments);
      },
      rename: function () {
        fs.renameSync.apply(void 0, arguments);
      },
      rmdir: function () {
        fs.rmdirSync.apply(void 0, arguments);
      },
      readdir: function () {
        fs.readdirSync.apply(void 0, arguments);
      },
      unlink: function () {
        fs.unlinkSync.apply(void 0, arguments);
      },
      readlink: function () {
        return fs.readlinkSync.apply(void 0, arguments);
      },
      stat: function () {
        return fs.statSync.apply(void 0, arguments);
      },
      lstat: function () {
        return fs.lstatSync.apply(void 0, arguments);
      },
      chmod: function () {
        fs.chmodSync.apply(void 0, arguments);
      },
      fchmod: function () {
        fs.fchmodSync.apply(void 0, arguments);
      },
      chown: function () {
        fs.chownSync.apply(void 0, arguments);
      },
      fchown: function () {
        fs.fchownSync.apply(void 0, arguments);
      },
      truncate: function () {
        fs.truncateSync.apply(void 0, arguments);
      },
      ftruncate: function () {
        fs.ftruncateSync.apply(void 0, arguments);
      },
      utime: function () {
        fs.utimesSync.apply(void 0, arguments);
      },
      open: function (path, flags, mode, suggestFD) {
        if (typeof flags === "string") {
          flags = VFS.modeStringToFlags(flags);
        }

        var nfd = fs.openSync(path, NODEFS.flagsForNode(flags), mode);
        var fd = suggestFD != null ? suggestFD : FS.nextfd(nfd);
        var stream = {
          fd: fd,
          nfd: nfd,
          position: 0,
          path: path,
          flags: flags,
          seekable: true
        };
        FS.streams[fd] = stream;
        return stream;
      },
      close: function (stream) {
        if (!stream.stream_ops) {
          fs.closeSync(stream.nfd);
        }

        FS.closeStream(stream.fd);
      },
      llseek: function (stream, offset, whence) {
        if (stream.stream_ops) {
          return VFS.llseek(stream, offset, whence);
        }

        var position = offset;

        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          position += fs.fstatSync(stream.nfd).size;
        } else if (whence !== 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }

        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }

        stream.position = position;
        return position;
      },
      read: function (stream, buffer, offset, length, position) {
        if (stream.stream_ops) {
          return VFS.read(stream, buffer, offset, length, position);
        }

        var seeking = typeof position !== "undefined";
        if (!seeking && stream.seekable) position = stream.position;
        var bytesRead = fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write: function (stream, buffer, offset, length, position) {
        if (stream.stream_ops) {
          return VFS.write(stream, buffer, offset, length, position);
        }

        if (stream.flags & +"1024") {
          FS.llseek(stream, 0, +"2");
        }

        var seeking = typeof position !== "undefined";
        if (!seeking && stream.seekable) position = stream.position;
        var bytesWritten = fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: function () {
        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
      },
      mmap: function () {
        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
      },
      msync: function () {
        return 0;
      },
      munmap: function () {
        return 0;
      },
      ioctl: function () {
        throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
      }
    };
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      trackingDelegate: {},
      tracking: {
        openFlags: {
          READ: 1,
          WRITE: 2
        }
      },
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      handleFSError: function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
        return setErrNo(e.errno);
      },
      lookupPath: function (path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
        if (!path) return {
          path: "",
          node: null
        };
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };

        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }

        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }

        var parts = PATH.normalizeArray(path.split("/").filter(function (p) {
          return !!p;
        }), false);
        var current = FS.root;
        var current_path = "/";

        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;

          if (islast && opts.parent) {
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }

          if (!islast || opts.follow) {
            var count = 0;

            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count
              });
              current = lookup.node;

              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }

        return {
          path: current_path,
          node: current
        };
      },
      getPath: function (node) {
        var path;

        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
          }

          path = path ? node.name + "/" + path : node.name;
          node = node.parent;
        }
      },
      hashName: function (parentid, name) {
        var hash = 0;

        for (var i = 0; i < name.length; i++) {
          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
        }

        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode: function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: function (node) {
        var hash = FS.hashName(node.parent.id, node.name);

        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];

          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }

            current = current.name_next;
          }
        }
      },
      lookupNode: function (parent, name) {
        var errCode = FS.mayLookup(parent);

        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }

        var hash = FS.hashName(parent.id, name);

        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;

          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }

        return FS.lookup(parent, name);
      },
      createNode: function (parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode: function (node) {
        FS.hashRemoveNode(node);
      },
      isRoot: function (node) {
        return node === node.parent;
      },
      isMountpoint: function (node) {
        return !!node.mounted;
      },
      isFile: function (mode) {
        return (mode & 61440) === 32768;
      },
      isDir: function (mode) {
        return (mode & 61440) === 16384;
      },
      isLink: function (mode) {
        return (mode & 61440) === 40960;
      },
      isChrdev: function (mode) {
        return (mode & 61440) === 8192;
      },
      isBlkdev: function (mode) {
        return (mode & 61440) === 24576;
      },
      isFIFO: function (mode) {
        return (mode & 61440) === 4096;
      },
      isSocket: function (mode) {
        return (mode & 49152) === 49152;
      },
      flagModes: {
        r: 0,
        rs: 1052672,
        "r+": 2,
        w: 577,
        wx: 705,
        xw: 705,
        "w+": 578,
        "wx+": 706,
        "xw+": 706,
        a: 1089,
        ax: 1217,
        xa: 1217,
        "a+": 1090,
        "ax+": 1218,
        "xa+": 1218
      },
      modeStringToFlags: function (str) {
        var flags = FS.flagModes[str];

        if (typeof flags === "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }

        return flags;
      },
      flagsToPermissionString: function (flag) {
        var perms = ["r", "w", "rw"][flag & 3];

        if (flag & 512) {
          perms += "w";
        }

        return perms;
      },
      nodePermissions: function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }

        if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
          return 2;
        }

        return 0;
      },
      mayLookup: function (dir) {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
      mayCreate: function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {}

        return FS.nodePermissions(dir, "wx");
      },
      mayDelete: function (dir, name, isdir) {
        var node;

        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }

        var errCode = FS.nodePermissions(dir, "wx");

        if (errCode) {
          return errCode;
        }

        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }

          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }

        return 0;
      },
      mayOpen: function (node, flags) {
        if (!node) {
          return 44;
        }

        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }

        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;

        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }

        throw new FS.ErrnoError(33);
      },
      getStream: function (fd) {
        return FS.streams[fd];
      },
      createStream: function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function () {};

          FS.FSStream.prototype = {
            object: {
              get: function () {
                return this.node;
              },
              set: function (val) {
                this.node = val;
              }
            },
            isRead: {
              get: function () {
                return (this.flags & 2097155) !== 1;
              }
            },
            isWrite: {
              get: function () {
                return (this.flags & 2097155) !== 0;
              }
            },
            isAppend: {
              get: function () {
                return this.flags & 1024;
              }
            }
          };
        }

        var newStream = new FS.FSStream();

        for (var p in stream) {
          newStream[p] = stream[p];
        }

        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: function (fd) {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;

          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: function () {
          throw new FS.ErrnoError(70);
        }
      },
      major: function (dev) {
        return dev >> 8;
      },
      minor: function (dev) {
        return dev & 255;
      },
      makedev: function (ma, mi) {
        return ma << 8 | mi;
      },
      registerDevice: function (dev, ops) {
        FS.devices[dev] = {
          stream_ops: ops
        };
      },
      getDevice: function (dev) {
        return FS.devices[dev];
      },
      getMounts: function (mount) {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push.apply(check, m.mounts);
        }

        return mounts;
      },
      syncfs: function (populate, callback) {
        if (typeof populate === "function") {
          callback = populate;
          populate = false;
        }

        FS.syncFSRequests++;

        if (FS.syncFSRequests > 1) {
          err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }

        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }

            return;
          }

          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }

        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }

          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: function (type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, {
            follow_mount: false
          });
          mountpoint = lookup.path;
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;

          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },
      unmount: function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, {
          follow_mount: false
        });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }

        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: function (path, mode, dev) {
        var lookup = FS.lookupPath(path, {
          parent: true
        });
        var parent = lookup.node;
        var name = PATH.basename(path);

        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }

        var errCode = FS.mayCreate(parent, name);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }

        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: function (path, mode) {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
      mkdir: function (path, mode) {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
      mkdirTree: function (path, mode) {
        var dirs = path.split("/");
        var d = "";

        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += "/" + dirs[i];

          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      },
      mkdev: function (path, mode, dev) {
        if (typeof dev === "undefined") {
          dev = mode;
          mode = 438;
        }

        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
      symlink: function (oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }

        var lookup = FS.lookupPath(newpath, {
          parent: true
        });
        var parent = lookup.node;

        if (!parent) {
          throw new FS.ErrnoError(44);
        }

        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }

        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, {
          parent: true
        });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, {
          parent: true
        });
        new_dir = lookup.node;
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);

        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }

        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);

        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }

        relative = PATH_FS.relative(new_path, old_dirname);

        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }

        var new_node;

        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}

        if (old_node === new_node) {
          return;
        }

        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }

        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }

        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");

          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        try {
          if (FS.trackingDelegate["willMovePath"]) {
            FS.trackingDelegate["willMovePath"](old_path, new_path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }

        FS.hashRemoveNode(old_node);

        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }

        try {
          if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);
        } catch (e) {
          err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }
      },
      rmdir: function (path) {
        var lookup = FS.lookupPath(path, {
          parent: true
        });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }

        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }

        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }

        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);

        try {
          if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      },
      readdir: function (path) {
        var lookup = FS.lookupPath(path, {
          follow: true
        });
        var node = lookup.node;

        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }

        return node.node_ops.readdir(node);
      },
      unlink: function (path) {
        var lookup = FS.lookupPath(path, {
          parent: true
        });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }

        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }

        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }

        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);

        try {
          if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      },
      readlink: function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;

        if (!link) {
          throw new FS.ErrnoError(44);
        }

        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }

        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },
      stat: function (path, dontFollow) {
        var lookup = FS.lookupPath(path, {
          follow: !dontFollow
        });
        var node = lookup.node;

        if (!node) {
          throw new FS.ErrnoError(44);
        }

        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }

        return node.node_ops.getattr(node);
      },
      lstat: function (path) {
        return FS.stat(path, true);
      },
      chmod: function (path, mode, dontFollow) {
        var node;

        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {
            follow: !dontFollow
          });
          node = lookup.node;
        } else {
          node = path;
        }

        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }

        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod: function (path, mode) {
        FS.chmod(path, mode, true);
      },
      fchmod: function (fd, mode) {
        var stream = FS.getStream(fd);

        if (!stream) {
          throw new FS.ErrnoError(8);
        }

        FS.chmod(stream.node, mode);
      },
      chown: function (path, uid, gid, dontFollow) {
        var node;

        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {
            follow: !dontFollow
          });
          node = lookup.node;
        } else {
          node = path;
        }

        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }

        node.node_ops.setattr(node, {
          timestamp: Date.now()
        });
      },
      lchown: function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
      fchown: function (fd, uid, gid) {
        var stream = FS.getStream(fd);

        if (!stream) {
          throw new FS.ErrnoError(8);
        }

        FS.chown(stream.node, uid, gid);
      },
      truncate: function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }

        var node;

        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {
            follow: true
          });
          node = lookup.node;
        } else {
          node = path;
        }

        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }

        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }

        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }

        var errCode = FS.nodePermissions(node, "w");

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate: function (fd, len) {
        var stream = FS.getStream(fd);

        if (!stream) {
          throw new FS.ErrnoError(8);
        }

        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }

        FS.truncate(stream.node, len);
      },
      utime: function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, {
          follow: true
        });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open: function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }

        flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === "undefined" ? 438 : mode;

        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }

        var node;

        if (typeof path === "object") {
          node = path;
        } else {
          path = PATH.normalize(path);

          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {}
        }

        var created = false;

        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }

        if (!node) {
          throw new FS.ErrnoError(44);
        }

        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }

        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }

        if (!created) {
          var errCode = FS.mayOpen(node, flags);

          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }

        if (flags & 512) {
          FS.truncate(node, 0);
        }

        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        }, fd_start, fd_end);

        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }

        if (Module["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};

          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }

        try {
          if (FS.trackingDelegate["onOpenFile"]) {
            var trackingFlags = 0;

            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }

            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }

            FS.trackingDelegate["onOpenFile"](path, trackingFlags);
          }
        } catch (e) {
          err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
        }

        return stream;
      },
      close: function (stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }

        if (stream.getdents) stream.getdents = null;

        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }

        stream.fd = null;
      },
      isClosed: function (stream) {
        return stream.fd === null;
      },
      llseek: function (stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }

        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }

        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }

        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }

        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }

        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }

        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }

        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }

        var seeking = typeof position !== "undefined";

        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }

        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write: function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }

        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }

        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }

        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }

        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }

        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }

        var seeking = typeof position !== "undefined";

        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }

        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;

        try {
          if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);
        } catch (e) {
          err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
        }

        return bytesWritten;
      },
      allocate: function (stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }

        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }

        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }

        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }

        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }

        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: function (stream, address, length, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }

        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }

        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }

        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },
      msync: function (stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }

        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },
      munmap: function (stream) {
        return 0;
      },
      ioctl: function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }

        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "r";
        opts.encoding = opts.encoding || "binary";

        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }

        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);

        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }

        FS.close(stream);
        return ret;
      },
      writeFile: function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "w";
        var stream = FS.open(path, opts.flags, opts.mode);

        if (typeof data === "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }

        FS.close(stream);
      },
      cwd: function () {
        return FS.currentPath;
      },
      chdir: function (path) {
        var lookup = FS.lookupPath(path, {
          follow: true
        });

        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }

        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }

        var errCode = FS.nodePermissions(lookup.node, "x");

        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }

        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: function () {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices: function () {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: function () {
            return 0;
          },
          write: function (stream, buffer, offset, length, pos) {
            return length;
          }
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device;

        if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
          var randomBuffer = new Uint8Array(1);

          random_device = function () {
            crypto.getRandomValues(randomBuffer);
            return randomBuffer[0];
          };
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = $455b93f3205ad3b50df264ee7a92e43f$init();

            random_device = function () {
              return crypto_module["randomBytes"](1)[0];
            };
          } catch (e) {}
        } else {}

        if (!random_device) {
          random_device = function () {
            abort("random_device");
          };
        }

        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories: function () {
        FS.mkdir("/proc");
        FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({
          mount: function () {
            var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
            node.node_ops = {
              lookup: function (parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: {
                    mountpoint: "fake"
                  },
                  node_ops: {
                    readlink: function () {
                      return stream.path;
                    }
                  }
                };
                ret.parent = ret;
                return ret;
              }
            };
            return node;
          }
        }, {}, "/proc/self/fd");
      },
      createStandardStreams: function () {
        if (Module["stdin"]) {
          FS.createDevice("/dev", "stdin", Module["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }

        if (Module["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }

        if (Module["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }

        var stdin = FS.open("/dev/stdin", "r");
        var stdout = FS.open("/dev/stdout", "w");
        var stderr = FS.open("/dev/stderr", "w");
      },
      ensureErrnoError: function () {
        if (FS.ErrnoError) return;

        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;

          this.setErrno = function (errno) {
            this.errno = errno;
          };

          this.setErrno(errno);
          this.message = "FS error";
        };

        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach(function (code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      },
      staticInit: function () {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          MEMFS: MEMFS,
          NODEFS: NODEFS
        };
      },
      init: function (input, output, error) {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module["stdin"] = input || Module["stdin"];
        Module["stdout"] = output || Module["stdout"];
        Module["stderr"] = error || Module["stderr"];
        FS.createStandardStreams();
      },
      quit: function () {
        FS.init.initialized = false;
        var fflush = Module["_fflush"];
        if (fflush) fflush(0);

        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];

          if (!stream) {
            continue;
          }

          FS.close(stream);
        }
      },
      getMode: function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },
      joinPath: function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == "/") path = path.substr(1);
        return path;
      },
      absolutePath: function (relative, base) {
        return PATH_FS.resolve(base, relative);
      },
      standardizePath: function (path) {
        return PATH.normalize(path);
      },
      findObject: function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);

        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },
      analyzePath: function (path, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path, {
            follow: !dontResolveLastLink
          });
          path = lookup.path;
        } catch (e) {}

        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };

        try {
          var lookup = FS.lookupPath(path, {
            parent: true
          });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, {
            follow: !dontResolveLastLink
          });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }

        return ret;
      },
      createFolder: function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },
      createPath: function (parent, path, canRead, canWrite) {
        parent = typeof parent === "string" ? parent : FS.getPath(parent);
        var parts = path.split("/").reverse();

        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);

          try {
            FS.mkdir(current);
          } catch (e) {}

          parent = current;
        }

        return current;
      },
      createFile: function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
      createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);

        if (data) {
          if (typeof data === "string") {
            var arr = new Array(data.length);

            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);

            data = arr;
          }

          FS.chmod(node, mode | 146);
          var stream = FS.open(node, "w");
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }

        return node;
      },
      createDevice: function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: function (stream) {
            stream.seekable = false;
          },
          close: function (stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function (stream, buffer, offset, length, pos) {
            var bytesRead = 0;

            for (var i = 0; i < length; i++) {
              var result;

              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }

              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }

              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset + i] = result;
            }

            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }

            return bytesRead;
          },
          write: function (stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }

            if (length) {
              stream.node.timestamp = Date.now();
            }

            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
      createLink: function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },
      forceLoadFile: function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;

        if (typeof XMLHttpRequest !== "undefined") {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }

        if (!success) setErrNo(29);
        return success;
      },
      createLazyFile: function (parent, name, url, canRead, canWrite) {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }

        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return undefined;
          }

          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        };

        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };

        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing) chunkSize = datalength;

          var doXHR = function (from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
            if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";

            if (xhr.overrideMimeType) {
              xhr.overrideMimeType("text/plain; charset=x-user-defined");
            }

            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);

            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || "", true);
            }
          };

          var lazyArray = this;
          lazyArray.setDataGetter(function (chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);

            if (typeof lazyArray.chunks[chunkNum] === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }

            if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });

          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }

          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };

        if (typeof XMLHttpRequest !== "undefined") {
          if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }

                return this._length;
              }
            },
            chunkSize: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }

                return this._chunkSize;
              }
            }
          });
          var properties = {
            isDevice: false,
            contents: lazyArray
          };
        } else {
          var properties = {
            isDevice: false,
            url: url
          };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);

        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }

        Object.defineProperties(node, {
          usedBytes: {
            get: function () {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function (key) {
          var fn = node.stream_ops[key];

          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }

            return fn.apply(null, arguments);
          };
        });

        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }

          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size = Math.min(contents.length - position, length);

          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }

          return size;
        };

        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init();
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);

        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();

            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }

            if (onload) onload();
            removeRunDependency(dep);
          }

          var handled = false;
          Module["preloadPlugins"].forEach(function (plugin) {
            if (handled) return;

            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, function () {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }

        addRunDependency(dep);

        if (typeof url == "string") {
          Browser.asyncLoad(url, function (byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },
      DB_NAME: function () {
        return "EM_FS_" + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: "FILE_DATA",
      saveFilesToDB: function (paths, onload, onerror) {
        onload = onload || function () {};

        onerror = onerror || function () {};

        var indexedDB = FS.indexedDB();

        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }

        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };

        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
              fail = 0,
              total = paths.length;

          function finish() {
            if (fail == 0) onload();else onerror();
          }

          paths.forEach(function (path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);

            putRequest.onsuccess = function putRequest_onsuccess() {
              ok++;
              if (ok + fail == total) finish();
            };

            putRequest.onerror = function putRequest_onerror() {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };

        openRequest.onerror = onerror;
      },
      loadFilesFromDB: function (paths, onload, onerror) {
        onload = onload || function () {};

        onerror = onerror || function () {};

        var indexedDB = FS.indexedDB();

        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }

        openRequest.onupgradeneeded = onerror;

        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;

          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e) {
            onerror(e);
            return;
          }

          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
              fail = 0,
              total = paths.length;

          function finish() {
            if (fail == 0) onload();else onerror();
          }

          paths.forEach(function (path) {
            var getRequest = files.get(path);

            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }

              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };

            getRequest.onerror = function getRequest_onerror() {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };

        openRequest.onerror = onerror;
      },
      mmapAlloc: function (size) {
        var alignedSize = alignMemory(size, 16384);

        var ptr = _malloc(alignedSize);

        while (size < alignedSize) HEAP8[ptr + size++] = 0;

        return ptr;
      }
    };
    var SYSCALLS = {
      mappings: {},
      DEFAULT_POLLMASK: 5,
      umask: 511,
      calculateAt: function (dirfd, path) {
        if (path[0] !== "/") {
          var dir;

          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }

          path = PATH.join2(dir, path);
        }

        return path;
      },
      doStat: function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            return -54;
          }

          throw e;
        }

        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = 0;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAP32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        HEAP32[buf + 32 >> 2] = 0;
        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAP32[buf + 48 >> 2] = 4096;
        HEAP32[buf + 52 >> 2] = stat.blocks;
        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
        HEAP32[buf + 60 >> 2] = 0;
        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
        HEAP32[buf + 68 >> 2] = 0;
        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
        HEAP32[buf + 76 >> 2] = 0;
        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
        return 0;
      },
      doMsync: function (addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      doMkdir: function (path, mode) {
        path = PATH.normalize(path);
        if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      },
      doMknod: function (path, mode, dev) {
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;

          default:
            return -28;
        }

        FS.mknod(path, mode, dev);
        return 0;
      },
      doReadlink: function (path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      },
      doAccess: function (path, amode) {
        if (amode & ~7) {
          return -28;
        }

        var node;
        var lookup = FS.lookupPath(path, {
          follow: true
        });
        node = lookup.node;

        if (!node) {
          return -44;
        }

        var perms = "";
        if (amode & 4) perms += "r";
        if (amode & 2) perms += "w";
        if (amode & 1) perms += "x";

        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }

        return 0;
      },
      doDup: function (path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },
      doReadv: function (stream, iov, iovcnt, offset) {
        var ret = 0;

        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.read(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break;
        }

        return ret;
      },
      doWritev: function (stream, iov, iovcnt, offset) {
        var ret = 0;

        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.write(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }

        return ret;
      },
      varargs: undefined,
      get: function () {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      },
      getStr: function (ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function (fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },
      get64: function (low, high) {
        return low;
      }
    };

    function ___sys_chmod(path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        FS.chmod(path, mode);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;

      try {
        var stream = SYSCALLS.getStreamFromFD(fd);

        switch (cmd) {
          case 0:
            {
              var arg = SYSCALLS.get();

              if (arg < 0) {
                return -28;
              }

              var newStream;
              newStream = FS.open(stream.path, stream.flags, 0, arg);
              return newStream.fd;
            }

          case 1:
          case 2:
            return 0;

          case 3:
            return stream.flags;

          case 4:
            {
              var arg = SYSCALLS.get();
              stream.flags |= arg;
              return 0;
            }

          case 12:
            {
              var arg = SYSCALLS.get();
              var offset = 0;
              HEAP16[arg + offset >> 1] = 2;
              return 0;
            }

          case 13:
          case 14:
            return 0;

          case 16:
          case 8:
            return -28;

          case 9:
            setErrNo(28);
            return -1;

          default:
            {
              return -28;
            }
        }
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;

      try {
        var stream = SYSCALLS.getStreamFromFD(fd);

        switch (op) {
          case 21509:
          case 21505:
            {
              if (!stream.tty) return -59;
              return 0;
            }

          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508:
            {
              if (!stream.tty) return -59;
              return 0;
            }

          case 21519:
            {
              if (!stream.tty) return -59;
              var argp = SYSCALLS.get();
              HEAP32[argp >> 2] = 0;
              return 0;
            }

          case 21520:
            {
              if (!stream.tty) return -59;
              return -28;
            }

          case 21531:
            {
              var argp = SYSCALLS.get();
              return FS.ioctl(stream, op, argp);
            }

          case 21523:
            {
              if (!stream.tty) return -59;
              return 0;
            }

          case 21524:
            {
              if (!stream.tty) return -59;
              return 0;
            }

          default:
            abort("bad ioctl syscall " + op);
        }
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_open(path, flags, varargs) {
      SYSCALLS.varargs = varargs;

      try {
        var pathname = SYSCALLS.getStr(path);
        var mode = SYSCALLS.get();
        var stream = FS.open(pathname, flags, mode);
        return stream.fd;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_read(fd, buf, count) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return FS.read(stream, HEAP8, buf, count);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_rename(old_path, new_path) {
      try {
        old_path = SYSCALLS.getStr(old_path);
        new_path = SYSCALLS.getStr(new_path);
        FS.rename(old_path, new_path);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_rmdir(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.rmdir(path);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_stat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function ___sys_unlink(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.unlink(path);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno;
      }
    }

    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

    function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }

    function emscripten_realloc_buffer(size) {
      try {
        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1;
      } catch (e) {}
    }

    function _emscripten_resize_heap(requestedSize) {
      requestedSize = requestedSize >>> 0;

      var oldSize = _emscripten_get_heap_size();

      var maxHeapSize = 2147483648;

      if (requestedSize > maxHeapSize) {
        return false;
      }

      var minHeapSize = 16777216;

      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
        var replacement = emscripten_realloc_buffer(newSize);

        if (replacement) {
          return true;
        }
      }

      return false;
    }

    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return e.errno;
      }
    }

    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        HEAP8[pbuf >> 0] = type;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return e.errno;
      }
    }

    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = SYSCALLS.doReadv(stream, iov, iovcnt);
        HEAP32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return e.errno;
      }
    }

    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var HIGH_OFFSET = 4294967296;
        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
        var DOUBLE_LIMIT = 9007199254740992;

        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
          return -61;
        }

        FS.llseek(stream, offset, whence);
        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return e.errno;
      }
    }

    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = SYSCALLS.doWritev(stream, iov, iovcnt);
        HEAP32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return e.errno;
      }
    }

    function _setTempRet0($i) {
      setTempRet0($i | 0);
    }

    function _time(ptr) {
      var ret = Date.now() / 1e3 | 0;

      if (ptr) {
        HEAP32[ptr >> 2] = ret;
      }

      return ret;
    }

    function _tzset() {
      if (_tzset.called) return;
      _tzset.called = true;
      HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      HEAP32[__get_daylight() >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());

      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      }

      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);

      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        HEAP32[__get_tzname() >> 2] = winterNamePtr;
        HEAP32[__get_tzname() + 4 >> 2] = summerNamePtr;
      } else {
        HEAP32[__get_tzname() >> 2] = summerNamePtr;
        HEAP32[__get_tzname() + 4 >> 2] = winterNamePtr;
      }
    }

    function _timegm(tmPtr) {
      _tzset();

      var time = Date.UTC(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var date = new Date(time);
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      return date.getTime() / 1e3 | 0;
    }

    var FSNode = function (parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }

      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };

    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function () {
          return (this.mode & readMode) === readMode;
        },
        set: function (val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        }
      },
      write: {
        get: function () {
          return (this.mode & writeMode) === writeMode;
        },
        set: function (val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        }
      },
      isFolder: {
        get: function () {
          return FS.isDir(this.mode);
        }
      },
      isDevice: {
        get: function () {
          return FS.isChrdev(this.mode);
        }
      }
    });
    FS.FSNode = FSNode;
    FS.staticInit();

    if (ENVIRONMENT_IS_NODE) {
      var fs = frozenFs;
      var NODEJS_PATH = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
      NODEFS.staticInit();
    }

    if (ENVIRONMENT_IS_NODE) {
      var _wrapNodeError = function (func) {
        return function () {
          try {
            return func.apply(this, arguments);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        };
      };

      var VFS = Object.assign({}, FS);

      for (var _key in NODERAWFS) FS[_key] = _wrapNodeError(NODERAWFS[_key]);
    } else {
      throw new Error("NODERAWFS is currently only supported on Node.js environment.");
    }

    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    }

    var decodeBase64 = typeof atob === "function" ? atob : function (input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

      do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output = output + String.fromCharCode(chr1);

        if (enc3 !== 64) {
          output = output + String.fromCharCode(chr2);
        }

        if (enc4 !== 64) {
          output = output + String.fromCharCode(chr3);
        }
      } while (i < input.length);

      return output;
    };

    function intArrayFromBase64(s) {
      if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
        var buf;

        try {
          buf = Buffer.from(s, "base64");
        } catch (_) {
          buf = new Buffer(s, "base64");
        }

        return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
      }

      try {
        var decoded = decodeBase64(s);
        var bytes = new Uint8Array(decoded.length);

        for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }

        return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }

    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }

      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }

    var asmLibraryArg = {
      m: ___gmtime_r,
      b: wasmTable,
      r: ___sys_chmod,
      g: ___sys_fcntl64,
      l: ___sys_fstat64,
      q: ___sys_ioctl,
      t: ___sys_open,
      s: ___sys_read,
      j: ___sys_rename,
      u: ___sys_rmdir,
      e: ___sys_stat64,
      i: ___sys_unlink,
      v: _emscripten_memcpy_big,
      w: _emscripten_resize_heap,
      h: _fd_close,
      k: _fd_fdstat_get,
      p: _fd_read,
      n: _fd_seek,
      f: _fd_write,
      a: wasmMemory,
      c: _setTempRet0,
      d: _time,
      o: _timegm
    };
    var asm = createWasm();

    Module.then = function (a) {
      asm.then(function () {
        delete Module.then;
        a(Module);
      });
    };

    var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function () {
      return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["x"]).apply(null, arguments);
    };

    var _zipstruct_stat = Module["_zipstruct_stat"] = function () {
      return (_zipstruct_stat = Module["_zipstruct_stat"] = Module["asm"]["y"]).apply(null, arguments);
    };

    var _zipstruct_statS = Module["_zipstruct_statS"] = function () {
      return (_zipstruct_statS = Module["_zipstruct_statS"] = Module["asm"]["z"]).apply(null, arguments);
    };

    var _zipstruct_stat_name = Module["_zipstruct_stat_name"] = function () {
      return (_zipstruct_stat_name = Module["_zipstruct_stat_name"] = Module["asm"]["A"]).apply(null, arguments);
    };

    var _zipstruct_stat_index = Module["_zipstruct_stat_index"] = function () {
      return (_zipstruct_stat_index = Module["_zipstruct_stat_index"] = Module["asm"]["B"]).apply(null, arguments);
    };

    var _zipstruct_stat_size = Module["_zipstruct_stat_size"] = function () {
      return (_zipstruct_stat_size = Module["_zipstruct_stat_size"] = Module["asm"]["C"]).apply(null, arguments);
    };

    var _zipstruct_stat_mtime = Module["_zipstruct_stat_mtime"] = function () {
      return (_zipstruct_stat_mtime = Module["_zipstruct_stat_mtime"] = Module["asm"]["D"]).apply(null, arguments);
    };

    var _zipstruct_error = Module["_zipstruct_error"] = function () {
      return (_zipstruct_error = Module["_zipstruct_error"] = Module["asm"]["E"]).apply(null, arguments);
    };

    var _zipstruct_errorS = Module["_zipstruct_errorS"] = function () {
      return (_zipstruct_errorS = Module["_zipstruct_errorS"] = Module["asm"]["F"]).apply(null, arguments);
    };

    var _zipstruct_error_code_zip = Module["_zipstruct_error_code_zip"] = function () {
      return (_zipstruct_error_code_zip = Module["_zipstruct_error_code_zip"] = Module["asm"]["G"]).apply(null, arguments);
    };

    var _zipstruct_stat_comp_size = Module["_zipstruct_stat_comp_size"] = function () {
      return (_zipstruct_stat_comp_size = Module["_zipstruct_stat_comp_size"] = Module["asm"]["H"]).apply(null, arguments);
    };

    var _zipstruct_stat_comp_method = Module["_zipstruct_stat_comp_method"] = function () {
      return (_zipstruct_stat_comp_method = Module["_zipstruct_stat_comp_method"] = Module["asm"]["I"]).apply(null, arguments);
    };

    var _zip_close = Module["_zip_close"] = function () {
      return (_zip_close = Module["_zip_close"] = Module["asm"]["J"]).apply(null, arguments);
    };

    var _zip_delete = Module["_zip_delete"] = function () {
      return (_zip_delete = Module["_zip_delete"] = Module["asm"]["K"]).apply(null, arguments);
    };

    var _zip_dir_add = Module["_zip_dir_add"] = function () {
      return (_zip_dir_add = Module["_zip_dir_add"] = Module["asm"]["L"]).apply(null, arguments);
    };

    var _zip_discard = Module["_zip_discard"] = function () {
      return (_zip_discard = Module["_zip_discard"] = Module["asm"]["M"]).apply(null, arguments);
    };

    var _zip_error_init_with_code = Module["_zip_error_init_with_code"] = function () {
      return (_zip_error_init_with_code = Module["_zip_error_init_with_code"] = Module["asm"]["N"]).apply(null, arguments);
    };

    var _zip_get_error = Module["_zip_get_error"] = function () {
      return (_zip_get_error = Module["_zip_get_error"] = Module["asm"]["O"]).apply(null, arguments);
    };

    var _zip_file_get_error = Module["_zip_file_get_error"] = function () {
      return (_zip_file_get_error = Module["_zip_file_get_error"] = Module["asm"]["P"]).apply(null, arguments);
    };

    var _zip_error_strerror = Module["_zip_error_strerror"] = function () {
      return (_zip_error_strerror = Module["_zip_error_strerror"] = Module["asm"]["Q"]).apply(null, arguments);
    };

    var _zip_fclose = Module["_zip_fclose"] = function () {
      return (_zip_fclose = Module["_zip_fclose"] = Module["asm"]["R"]).apply(null, arguments);
    };

    var _zip_file_add = Module["_zip_file_add"] = function () {
      return (_zip_file_add = Module["_zip_file_add"] = Module["asm"]["S"]).apply(null, arguments);
    };

    var _zip_file_get_external_attributes = Module["_zip_file_get_external_attributes"] = function () {
      return (_zip_file_get_external_attributes = Module["_zip_file_get_external_attributes"] = Module["asm"]["T"]).apply(null, arguments);
    };

    var _zip_file_set_external_attributes = Module["_zip_file_set_external_attributes"] = function () {
      return (_zip_file_set_external_attributes = Module["_zip_file_set_external_attributes"] = Module["asm"]["U"]).apply(null, arguments);
    };

    var _zip_file_set_mtime = Module["_zip_file_set_mtime"] = function () {
      return (_zip_file_set_mtime = Module["_zip_file_set_mtime"] = Module["asm"]["V"]).apply(null, arguments);
    };

    var _zip_fopen = Module["_zip_fopen"] = function () {
      return (_zip_fopen = Module["_zip_fopen"] = Module["asm"]["W"]).apply(null, arguments);
    };

    var _zip_fopen_index = Module["_zip_fopen_index"] = function () {
      return (_zip_fopen_index = Module["_zip_fopen_index"] = Module["asm"]["X"]).apply(null, arguments);
    };

    var _zip_fread = Module["_zip_fread"] = function () {
      return (_zip_fread = Module["_zip_fread"] = Module["asm"]["Y"]).apply(null, arguments);
    };

    var _zip_get_name = Module["_zip_get_name"] = function () {
      return (_zip_get_name = Module["_zip_get_name"] = Module["asm"]["Z"]).apply(null, arguments);
    };

    var _zip_get_num_entries = Module["_zip_get_num_entries"] = function () {
      return (_zip_get_num_entries = Module["_zip_get_num_entries"] = Module["asm"]["_"]).apply(null, arguments);
    };

    var _zip_name_locate = Module["_zip_name_locate"] = function () {
      return (_zip_name_locate = Module["_zip_name_locate"] = Module["asm"]["$"]).apply(null, arguments);
    };

    var _zip_open = Module["_zip_open"] = function () {
      return (_zip_open = Module["_zip_open"] = Module["asm"]["aa"]).apply(null, arguments);
    };

    var _zip_open_from_source = Module["_zip_open_from_source"] = function () {
      return (_zip_open_from_source = Module["_zip_open_from_source"] = Module["asm"]["ba"]).apply(null, arguments);
    };

    var _zip_set_file_compression = Module["_zip_set_file_compression"] = function () {
      return (_zip_set_file_compression = Module["_zip_set_file_compression"] = Module["asm"]["ca"]).apply(null, arguments);
    };

    var _zip_source_buffer = Module["_zip_source_buffer"] = function () {
      return (_zip_source_buffer = Module["_zip_source_buffer"] = Module["asm"]["da"]).apply(null, arguments);
    };

    var _zip_source_buffer_create = Module["_zip_source_buffer_create"] = function () {
      return (_zip_source_buffer_create = Module["_zip_source_buffer_create"] = Module["asm"]["ea"]).apply(null, arguments);
    };

    var _zip_source_close = Module["_zip_source_close"] = function () {
      return (_zip_source_close = Module["_zip_source_close"] = Module["asm"]["fa"]).apply(null, arguments);
    };

    var _zip_source_error = Module["_zip_source_error"] = function () {
      return (_zip_source_error = Module["_zip_source_error"] = Module["asm"]["ga"]).apply(null, arguments);
    };

    var _zip_source_free = Module["_zip_source_free"] = function () {
      return (_zip_source_free = Module["_zip_source_free"] = Module["asm"]["ha"]).apply(null, arguments);
    };

    var _zip_source_keep = Module["_zip_source_keep"] = function () {
      return (_zip_source_keep = Module["_zip_source_keep"] = Module["asm"]["ia"]).apply(null, arguments);
    };

    var _zip_source_open = Module["_zip_source_open"] = function () {
      return (_zip_source_open = Module["_zip_source_open"] = Module["asm"]["ja"]).apply(null, arguments);
    };

    var _zip_source_read = Module["_zip_source_read"] = function () {
      return (_zip_source_read = Module["_zip_source_read"] = Module["asm"]["ka"]).apply(null, arguments);
    };

    var _zip_source_seek = Module["_zip_source_seek"] = function () {
      return (_zip_source_seek = Module["_zip_source_seek"] = Module["asm"]["la"]).apply(null, arguments);
    };

    var _zip_source_set_mtime = Module["_zip_source_set_mtime"] = function () {
      return (_zip_source_set_mtime = Module["_zip_source_set_mtime"] = Module["asm"]["ma"]).apply(null, arguments);
    };

    var _zip_source_tell = Module["_zip_source_tell"] = function () {
      return (_zip_source_tell = Module["_zip_source_tell"] = Module["asm"]["na"]).apply(null, arguments);
    };

    var _zip_stat = Module["_zip_stat"] = function () {
      return (_zip_stat = Module["_zip_stat"] = Module["asm"]["oa"]).apply(null, arguments);
    };

    var _zip_stat_index = Module["_zip_stat_index"] = function () {
      return (_zip_stat_index = Module["_zip_stat_index"] = Module["asm"]["pa"]).apply(null, arguments);
    };

    var _zip_ext_count_symlinks = Module["_zip_ext_count_symlinks"] = function () {
      return (_zip_ext_count_symlinks = Module["_zip_ext_count_symlinks"] = Module["asm"]["qa"]).apply(null, arguments);
    };

    var ___errno_location = Module["___errno_location"] = function () {
      return (___errno_location = Module["___errno_location"] = Module["asm"]["ra"]).apply(null, arguments);
    };

    var __get_tzname = Module["__get_tzname"] = function () {
      return (__get_tzname = Module["__get_tzname"] = Module["asm"]["sa"]).apply(null, arguments);
    };

    var __get_daylight = Module["__get_daylight"] = function () {
      return (__get_daylight = Module["__get_daylight"] = Module["asm"]["ta"]).apply(null, arguments);
    };

    var __get_timezone = Module["__get_timezone"] = function () {
      return (__get_timezone = Module["__get_timezone"] = Module["asm"]["ua"]).apply(null, arguments);
    };

    var stackSave = Module["stackSave"] = function () {
      return (stackSave = Module["stackSave"] = Module["asm"]["va"]).apply(null, arguments);
    };

    var stackRestore = Module["stackRestore"] = function () {
      return (stackRestore = Module["stackRestore"] = Module["asm"]["wa"]).apply(null, arguments);
    };

    var stackAlloc = Module["stackAlloc"] = function () {
      return (stackAlloc = Module["stackAlloc"] = Module["asm"]["xa"]).apply(null, arguments);
    };

    var _malloc = Module["_malloc"] = function () {
      return (_malloc = Module["_malloc"] = Module["asm"]["ya"]).apply(null, arguments);
    };

    var _free = Module["_free"] = function () {
      return (_free = Module["_free"] = Module["asm"]["za"]).apply(null, arguments);
    };

    Module["cwrap"] = cwrap;
    Module["getValue"] = getValue;
    var calledRun;

    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };

    function run(args) {
      args = args || arguments_;

      if (runDependencies > 0) {
        return;
      }

      preRun();
      if (runDependencies > 0) return;

      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        preMain();
        if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
        postRun();
      }

      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(function () {
          setTimeout(function () {
            Module["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }

    Module["run"] = run;

    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];

      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }

    noExitRuntime = true;
    run();
    return module.exports;
  }.call({});
}

function $1b7420e6729c607d8a3cbf589616cbdf$init() {
  if (!$1b7420e6729c607d8a3cbf589616cbdf$executed) {
    $1b7420e6729c607d8a3cbf589616cbdf$executed = true;
    $1b7420e6729c607d8a3cbf589616cbdf$exec();
  }

  return $1b7420e6729c607d8a3cbf589616cbdf$exports;
}

// ASSET: node_modules/@yarnpkg/libzip/lib/async.js
var $65fa1f8282605ab74bde1e38aef95806$exports = {};
// ASSET: node_modules/@yarnpkg/libzip/lib/makeInterface.js
var $907a24567979ea079042543191eccb89$export$Errors,
    $907a24567979ea079042543191eccb89$exports = {};
Object.defineProperty($907a24567979ea079042543191eccb89$exports, "__esModule", {
  value: true
});
var $907a24567979ea079042543191eccb89$export$makeInterface = ($907a24567979ea079042543191eccb89$export$Errors = void 0, $907a24567979ea079042543191eccb89$exports.Errors = $907a24567979ea079042543191eccb89$export$Errors);
$907a24567979ea079042543191eccb89$exports.makeInterface = $907a24567979ea079042543191eccb89$export$makeInterface;
const $907a24567979ea079042543191eccb89$var$number64 = [`number`, `number`];
var $907a24567979ea079042543191eccb89$var$Errors;

(function (Errors) {
  Errors[Errors["ZIP_ER_OK"] = 0] = "ZIP_ER_OK";
  Errors[Errors["ZIP_ER_MULTIDISK"] = 1] = "ZIP_ER_MULTIDISK";
  Errors[Errors["ZIP_ER_RENAME"] = 2] = "ZIP_ER_RENAME";
  Errors[Errors["ZIP_ER_CLOSE"] = 3] = "ZIP_ER_CLOSE";
  Errors[Errors["ZIP_ER_SEEK"] = 4] = "ZIP_ER_SEEK";
  Errors[Errors["ZIP_ER_READ"] = 5] = "ZIP_ER_READ";
  Errors[Errors["ZIP_ER_WRITE"] = 6] = "ZIP_ER_WRITE";
  Errors[Errors["ZIP_ER_CRC"] = 7] = "ZIP_ER_CRC";
  Errors[Errors["ZIP_ER_ZIPCLOSED"] = 8] = "ZIP_ER_ZIPCLOSED";
  Errors[Errors["ZIP_ER_NOENT"] = 9] = "ZIP_ER_NOENT";
  Errors[Errors["ZIP_ER_EXISTS"] = 10] = "ZIP_ER_EXISTS";
  Errors[Errors["ZIP_ER_OPEN"] = 11] = "ZIP_ER_OPEN";
  Errors[Errors["ZIP_ER_TMPOPEN"] = 12] = "ZIP_ER_TMPOPEN";
  Errors[Errors["ZIP_ER_ZLIB"] = 13] = "ZIP_ER_ZLIB";
  Errors[Errors["ZIP_ER_MEMORY"] = 14] = "ZIP_ER_MEMORY";
  Errors[Errors["ZIP_ER_CHANGED"] = 15] = "ZIP_ER_CHANGED";
  Errors[Errors["ZIP_ER_COMPNOTSUPP"] = 16] = "ZIP_ER_COMPNOTSUPP";
  Errors[Errors["ZIP_ER_EOF"] = 17] = "ZIP_ER_EOF";
  Errors[Errors["ZIP_ER_INVAL"] = 18] = "ZIP_ER_INVAL";
  Errors[Errors["ZIP_ER_NOZIP"] = 19] = "ZIP_ER_NOZIP";
  Errors[Errors["ZIP_ER_INTERNAL"] = 20] = "ZIP_ER_INTERNAL";
  Errors[Errors["ZIP_ER_INCONS"] = 21] = "ZIP_ER_INCONS";
  Errors[Errors["ZIP_ER_REMOVE"] = 22] = "ZIP_ER_REMOVE";
  Errors[Errors["ZIP_ER_DELETED"] = 23] = "ZIP_ER_DELETED";
  Errors[Errors["ZIP_ER_ENCRNOTSUPP"] = 24] = "ZIP_ER_ENCRNOTSUPP";
  Errors[Errors["ZIP_ER_RDONLY"] = 25] = "ZIP_ER_RDONLY";
  Errors[Errors["ZIP_ER_NOPASSWD"] = 26] = "ZIP_ER_NOPASSWD";
  Errors[Errors["ZIP_ER_WRONGPASSWD"] = 27] = "ZIP_ER_WRONGPASSWD";
  Errors[Errors["ZIP_ER_OPNOTSUPP"] = 28] = "ZIP_ER_OPNOTSUPP";
  Errors[Errors["ZIP_ER_INUSE"] = 29] = "ZIP_ER_INUSE";
  Errors[Errors["ZIP_ER_TELL"] = 30] = "ZIP_ER_TELL";
  Errors[Errors["ZIP_ER_COMPRESSED_DATA"] = 31] = "ZIP_ER_COMPRESSED_DATA";
})($907a24567979ea079042543191eccb89$var$Errors = $907a24567979ea079042543191eccb89$exports.Errors || ($907a24567979ea079042543191eccb89$export$Errors = {}, $907a24567979ea079042543191eccb89$exports.Errors = $907a24567979ea079042543191eccb89$export$Errors));

const $907a24567979ea079042543191eccb89$var$makeInterface = libzip => ({
  // Those are getters because they can change after memory growth
  get HEAP8() {
    return libzip.HEAP8;
  },

  get HEAPU8() {
    return libzip.HEAPU8;
  },

  errors: $907a24567979ea079042543191eccb89$var$Errors,
  SEEK_SET: 0,
  SEEK_CUR: 1,
  SEEK_END: 2,
  ZIP_CHECKCONS: 4,
  ZIP_CREATE: 1,
  ZIP_EXCL: 2,
  ZIP_TRUNCATE: 8,
  ZIP_RDONLY: 16,
  ZIP_FL_OVERWRITE: 8192,
  ZIP_FL_COMPRESSED: 4,
  ZIP_OPSYS_DOS: 0x00,
  ZIP_OPSYS_AMIGA: 0x01,
  ZIP_OPSYS_OPENVMS: 0x02,
  ZIP_OPSYS_UNIX: 0x03,
  ZIP_OPSYS_VM_CMS: 0x04,
  ZIP_OPSYS_ATARI_ST: 0x05,
  ZIP_OPSYS_OS_2: 0x06,
  ZIP_OPSYS_MACINTOSH: 0x07,
  ZIP_OPSYS_Z_SYSTEM: 0x08,
  ZIP_OPSYS_CPM: 0x09,
  ZIP_OPSYS_WINDOWS_NTFS: 0x0a,
  ZIP_OPSYS_MVS: 0x0b,
  ZIP_OPSYS_VSE: 0x0c,
  ZIP_OPSYS_ACORN_RISC: 0x0d,
  ZIP_OPSYS_VFAT: 0x0e,
  ZIP_OPSYS_ALTERNATE_MVS: 0x0f,
  ZIP_OPSYS_BEOS: 0x10,
  ZIP_OPSYS_TANDEM: 0x11,
  ZIP_OPSYS_OS_400: 0x12,
  ZIP_OPSYS_OS_X: 0x13,
  ZIP_CM_DEFAULT: -1,
  ZIP_CM_STORE: 0,
  ZIP_CM_DEFLATE: 8,
  uint08S: libzip._malloc(1),
  uint16S: libzip._malloc(2),
  uint32S: libzip._malloc(4),
  uint64S: libzip._malloc(8),
  malloc: libzip._malloc,
  free: libzip._free,
  getValue: libzip.getValue,
  open: libzip.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
  openFromSource: libzip.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
  close: libzip.cwrap(`zip_close`, `number`, [`number`]),
  discard: libzip.cwrap(`zip_discard`, null, [`number`]),
  getError: libzip.cwrap(`zip_get_error`, `number`, [`number`]),
  getName: libzip.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
  getNumEntries: libzip.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
  delete: libzip.cwrap(`zip_delete`, `number`, [`number`, `number`]),
  stat: libzip.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
  statIndex: libzip.cwrap(`zip_stat_index`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`, `number`]),
  fopen: libzip.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
  fopenIndex: libzip.cwrap(`zip_fopen_index`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`]),
  fread: libzip.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
  fclose: libzip.cwrap(`zip_fclose`, `number`, [`number`]),
  dir: {
    add: libzip.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
  },
  file: {
    add: libzip.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
    getError: libzip.cwrap(`zip_file_get_error`, `number`, [`number`]),
    getExternalAttributes: libzip.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`, `number`, `number`]),
    setExternalAttributes: libzip.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`, `number`, `number`]),
    setMtime: libzip.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`, `number`]),
    setCompression: libzip.cwrap(`zip_set_file_compression`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`, `number`])
  },
  ext: {
    countSymlinks: libzip.cwrap(`zip_ext_count_symlinks`, `number`, [`number`])
  },
  error: {
    initWithCode: libzip.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
    strerror: libzip.cwrap(`zip_error_strerror`, `string`, [`number`])
  },
  name: {
    locate: libzip.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
  },
  source: {
    fromUnattachedBuffer: libzip.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
    fromBuffer: libzip.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`]),
    free: libzip.cwrap(`zip_source_free`, null, [`number`]),
    keep: libzip.cwrap(`zip_source_keep`, null, [`number`]),
    open: libzip.cwrap(`zip_source_open`, `number`, [`number`]),
    close: libzip.cwrap(`zip_source_close`, `number`, [`number`]),
    seek: libzip.cwrap(`zip_source_seek`, `number`, [`number`, ...$907a24567979ea079042543191eccb89$var$number64, `number`]),
    tell: libzip.cwrap(`zip_source_tell`, `number`, [`number`]),
    read: libzip.cwrap(`zip_source_read`, `number`, [`number`, `number`, `number`]),
    error: libzip.cwrap(`zip_source_error`, `number`, [`number`]),
    setMtime: libzip.cwrap(`zip_source_set_mtime`, `number`, [`number`, `number`])
  },
  struct: {
    stat: libzip.cwrap(`zipstruct_stat`, `number`, []),
    statS: libzip.cwrap(`zipstruct_statS`, `number`, []),
    statName: libzip.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
    statIndex: libzip.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
    statSize: libzip.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
    statCompSize: libzip.cwrap(`zipstruct_stat_comp_size`, `number`, [`number`]),
    statCompMethod: libzip.cwrap(`zipstruct_stat_comp_method`, `number`, [`number`]),
    statMtime: libzip.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
    error: libzip.cwrap(`zipstruct_error`, `number`, []),
    errorS: libzip.cwrap(`zipstruct_errorS`, `number`, []),
    errorCodeZip: libzip.cwrap(`zipstruct_error_code_zip`, `number`, [`number`])
  }
});

$907a24567979ea079042543191eccb89$export$makeInterface = $907a24567979ea079042543191eccb89$var$makeInterface;
$907a24567979ea079042543191eccb89$exports.makeInterface = $907a24567979ea079042543191eccb89$export$makeInterface;
Object.defineProperty($65fa1f8282605ab74bde1e38aef95806$exports, "__esModule", {
  value: true
});
var $65fa1f8282605ab74bde1e38aef95806$export$getLibzipPromise = ($65fa1f8282605ab74bde1e38aef95806$export$getLibzipSync = void 0, $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipSync = $65fa1f8282605ab74bde1e38aef95806$export$getLibzipSync);
$65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise = $65fa1f8282605ab74bde1e38aef95806$export$getLibzipPromise;
let $65fa1f8282605ab74bde1e38aef95806$var$promise = null;

function $65fa1f8282605ab74bde1e38aef95806$var$getLibzipSync() {
  throw new Error(`Cannot use getLibzipSync when using the async version of the libzip`);
}

var $65fa1f8282605ab74bde1e38aef95806$export$getLibzipSync = $65fa1f8282605ab74bde1e38aef95806$var$getLibzipSync;
$65fa1f8282605ab74bde1e38aef95806$exports.getLibzipSync = $65fa1f8282605ab74bde1e38aef95806$export$getLibzipSync;

async function $65fa1f8282605ab74bde1e38aef95806$var$getLibzipPromise() {
  if ($65fa1f8282605ab74bde1e38aef95806$var$promise === null) {
    $65fa1f8282605ab74bde1e38aef95806$var$promise = new Promise(resolve => {
      $1b7420e6729c607d8a3cbf589616cbdf$init().then(libzip => {
        resolve($907a24567979ea079042543191eccb89$exports.makeInterface(libzip));
      });
    });
  }

  return $65fa1f8282605ab74bde1e38aef95806$var$promise;
}

$65fa1f8282605ab74bde1e38aef95806$export$getLibzipPromise = $65fa1f8282605ab74bde1e38aef95806$var$getLibzipPromise;
$65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise = $65fa1f8282605ab74bde1e38aef95806$export$getLibzipPromise;
// ASSET: node_modules/lodash/capitalize.js
var $1cc60b568ee868d2cf655234c6771e9a$exports = {};
// ASSET: node_modules/lodash/toString.js
var $527b2e5779250a5bbe79f402e9a29e45$exports = {};
// ASSET: node_modules/lodash/_baseToString.js
var $cb57aceb05ee79bb62c111e43222d209$exports = {};
// ASSET: node_modules/lodash/_Symbol.js
var $53d8a9775bd80cdff9ff16cc102f07a5$exports = {};
// ASSET: node_modules/lodash/_root.js
var $00278192d9378b6bfd80fd44346289ac$exports = {};
// ASSET: node_modules/lodash/_freeGlobal.js
var $bf59b7f8d04b137ea8f22d68e8e84bd2$exports = {};

/** Detect free variable `global` from Node.js. */
var $bf59b7f8d04b137ea8f22d68e8e84bd2$var$freeGlobal = typeof $parcel$global == 'object' && $parcel$global && $parcel$global.Object === Object && $parcel$global;
$bf59b7f8d04b137ea8f22d68e8e84bd2$exports = $bf59b7f8d04b137ea8f22d68e8e84bd2$var$freeGlobal;

/** Detect free variable `self`. */
var $00278192d9378b6bfd80fd44346289ac$var$freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

/** Used as a reference to the global object. */
var $00278192d9378b6bfd80fd44346289ac$var$root = $bf59b7f8d04b137ea8f22d68e8e84bd2$exports || $00278192d9378b6bfd80fd44346289ac$var$freeSelf || Function('return this')();
$00278192d9378b6bfd80fd44346289ac$exports = $00278192d9378b6bfd80fd44346289ac$var$root;

/** Built-in value references. */
var $53d8a9775bd80cdff9ff16cc102f07a5$var$Symbol = $00278192d9378b6bfd80fd44346289ac$exports.Symbol;
$53d8a9775bd80cdff9ff16cc102f07a5$exports = $53d8a9775bd80cdff9ff16cc102f07a5$var$Symbol;
// ASSET: node_modules/lodash/_arrayMap.js
var $74ee63f8f2d3bed787959a6456fcea53$exports = {};

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function $74ee63f8f2d3bed787959a6456fcea53$var$arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

$74ee63f8f2d3bed787959a6456fcea53$exports = $74ee63f8f2d3bed787959a6456fcea53$var$arrayMap;
// ASSET: node_modules/lodash/isArray.js
var $a5b9c798e70b67ee906d88343e7b1453$exports = {};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var $a5b9c798e70b67ee906d88343e7b1453$var$isArray = Array.isArray;
$a5b9c798e70b67ee906d88343e7b1453$exports = $a5b9c798e70b67ee906d88343e7b1453$var$isArray;
// ASSET: node_modules/lodash/isSymbol.js
var $7209b164c4bc19c7fa171e29ac363020$exports = {};
// ASSET: node_modules/lodash/_baseGetTag.js
var $ed805bb9c88654724c0b38f8c70e8db8$exports = {};
// ASSET: node_modules/lodash/_getRawTag.js
var $390752126dade324728604aaa7ad9ea1$exports = {};

/** Used for built-in method references. */
var $390752126dade324728604aaa7ad9ea1$var$objectProto = Object.prototype;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $390752126dade324728604aaa7ad9ea1$var$hasOwnProperty = $390752126dade324728604aaa7ad9ea1$var$objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var $390752126dade324728604aaa7ad9ea1$var$nativeObjectToString = $390752126dade324728604aaa7ad9ea1$var$objectProto.toString;
/** Built-in value references. */

/** Built-in value references. */
var $390752126dade324728604aaa7ad9ea1$var$symToStringTag = $53d8a9775bd80cdff9ff16cc102f07a5$exports ? $53d8a9775bd80cdff9ff16cc102f07a5$exports.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function $390752126dade324728604aaa7ad9ea1$var$getRawTag(value) {
  var isOwn = $390752126dade324728604aaa7ad9ea1$var$hasOwnProperty.call(value, $390752126dade324728604aaa7ad9ea1$var$symToStringTag),
      tag = value[$390752126dade324728604aaa7ad9ea1$var$symToStringTag];

  try {
    value[$390752126dade324728604aaa7ad9ea1$var$symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = $390752126dade324728604aaa7ad9ea1$var$nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[$390752126dade324728604aaa7ad9ea1$var$symToStringTag] = tag;
    } else {
      delete value[$390752126dade324728604aaa7ad9ea1$var$symToStringTag];
    }
  }

  return result;
}

$390752126dade324728604aaa7ad9ea1$exports = $390752126dade324728604aaa7ad9ea1$var$getRawTag;
// ASSET: node_modules/lodash/_objectToString.js
var $744ff4ade5b4149de0abfd97b8028800$exports = {};

/** Used for built-in method references. */
var $744ff4ade5b4149de0abfd97b8028800$var$objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var $744ff4ade5b4149de0abfd97b8028800$var$nativeObjectToString = $744ff4ade5b4149de0abfd97b8028800$var$objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function $744ff4ade5b4149de0abfd97b8028800$var$objectToString(value) {
  return $744ff4ade5b4149de0abfd97b8028800$var$nativeObjectToString.call(value);
}

$744ff4ade5b4149de0abfd97b8028800$exports = $744ff4ade5b4149de0abfd97b8028800$var$objectToString;

/** `Object#toString` result references. */
var $ed805bb9c88654724c0b38f8c70e8db8$var$nullTag = '[object Null]',
    $ed805bb9c88654724c0b38f8c70e8db8$var$undefinedTag = '[object Undefined]';
/** Built-in value references. */

/** Built-in value references. */
var $ed805bb9c88654724c0b38f8c70e8db8$var$symToStringTag = $53d8a9775bd80cdff9ff16cc102f07a5$exports ? $53d8a9775bd80cdff9ff16cc102f07a5$exports.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function $ed805bb9c88654724c0b38f8c70e8db8$var$baseGetTag(value) {
  if (value == null) {
    return value === undefined ? $ed805bb9c88654724c0b38f8c70e8db8$var$undefinedTag : $ed805bb9c88654724c0b38f8c70e8db8$var$nullTag;
  }

  return $ed805bb9c88654724c0b38f8c70e8db8$var$symToStringTag && $ed805bb9c88654724c0b38f8c70e8db8$var$symToStringTag in Object(value) ? $390752126dade324728604aaa7ad9ea1$exports(value) : $744ff4ade5b4149de0abfd97b8028800$exports(value);
}

$ed805bb9c88654724c0b38f8c70e8db8$exports = $ed805bb9c88654724c0b38f8c70e8db8$var$baseGetTag;
// ASSET: node_modules/lodash/isObjectLike.js
var $19235f65527b96e6e29ea39c9a223705$exports = {};

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function $19235f65527b96e6e29ea39c9a223705$var$isObjectLike(value) {
  return value != null && typeof value == 'object';
}

$19235f65527b96e6e29ea39c9a223705$exports = $19235f65527b96e6e29ea39c9a223705$var$isObjectLike;

/** `Object#toString` result references. */
var $7209b164c4bc19c7fa171e29ac363020$var$symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function $7209b164c4bc19c7fa171e29ac363020$var$isSymbol(value) {
  return typeof value == 'symbol' || $19235f65527b96e6e29ea39c9a223705$exports(value) && $ed805bb9c88654724c0b38f8c70e8db8$exports(value) == $7209b164c4bc19c7fa171e29ac363020$var$symbolTag;
}

$7209b164c4bc19c7fa171e29ac363020$exports = $7209b164c4bc19c7fa171e29ac363020$var$isSymbol;

/** Used as references for various `Number` constants. */
var $cb57aceb05ee79bb62c111e43222d209$var$INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

/** Used to convert symbols to primitives and strings. */
var $cb57aceb05ee79bb62c111e43222d209$var$symbolProto = $53d8a9775bd80cdff9ff16cc102f07a5$exports ? $53d8a9775bd80cdff9ff16cc102f07a5$exports.prototype : undefined,
    $cb57aceb05ee79bb62c111e43222d209$var$symbolToString = $cb57aceb05ee79bb62c111e43222d209$var$symbolProto ? $cb57aceb05ee79bb62c111e43222d209$var$symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function $cb57aceb05ee79bb62c111e43222d209$var$baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if ($a5b9c798e70b67ee906d88343e7b1453$exports(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return $74ee63f8f2d3bed787959a6456fcea53$exports(value, $cb57aceb05ee79bb62c111e43222d209$var$baseToString) + '';
  }

  if ($7209b164c4bc19c7fa171e29ac363020$exports(value)) {
    return $cb57aceb05ee79bb62c111e43222d209$var$symbolToString ? $cb57aceb05ee79bb62c111e43222d209$var$symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -$cb57aceb05ee79bb62c111e43222d209$var$INFINITY ? '-0' : result;
}

$cb57aceb05ee79bb62c111e43222d209$exports = $cb57aceb05ee79bb62c111e43222d209$var$baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function $527b2e5779250a5bbe79f402e9a29e45$var$toString(value) {
  return value == null ? '' : $cb57aceb05ee79bb62c111e43222d209$exports(value);
}

$527b2e5779250a5bbe79f402e9a29e45$exports = $527b2e5779250a5bbe79f402e9a29e45$var$toString;
// ASSET: node_modules/lodash/upperFirst.js
var $146bc3ce47d0dc29aadc4c5dc505011d$exports = {};
// ASSET: node_modules/lodash/_createCaseFirst.js
var $f1e46ef7a52f113727a4f7301e7cc819$exports = {};
// ASSET: node_modules/lodash/_castSlice.js
var $a8a63024b346c1bf5aac27ec57534a36$exports = {};
// ASSET: node_modules/lodash/_baseSlice.js
var $684a8ad76246d9ed31ef68dcf083a20c$exports = {};

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function $684a8ad76246d9ed31ef68dcf083a20c$var$baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

$684a8ad76246d9ed31ef68dcf083a20c$exports = $684a8ad76246d9ed31ef68dcf083a20c$var$baseSlice;

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function $a8a63024b346c1bf5aac27ec57534a36$var$castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return !start && end >= length ? array : $684a8ad76246d9ed31ef68dcf083a20c$exports(array, start, end);
}

$a8a63024b346c1bf5aac27ec57534a36$exports = $a8a63024b346c1bf5aac27ec57534a36$var$castSlice;
// ASSET: node_modules/lodash/_hasUnicode.js
var $fc4a63b99f1aef1242a1e5660041b4ef$exports = {};

/** Used to compose unicode character classes. */
var $fc4a63b99f1aef1242a1e5660041b4ef$var$rsAstralRange = '\\ud800-\\udfff',
    $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboMarksRange = '\\u0300-\\u036f',
    $fc4a63b99f1aef1242a1e5660041b4ef$var$reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboSymbolsRange = '\\u20d0-\\u20ff',
    $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboRange = $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboMarksRange + $fc4a63b99f1aef1242a1e5660041b4ef$var$reComboHalfMarksRange + $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboSymbolsRange,
    $fc4a63b99f1aef1242a1e5660041b4ef$var$rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */

/** Used to compose unicode capture groups. */
var $fc4a63b99f1aef1242a1e5660041b4ef$var$rsZWJ = '\\u200d';
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var $fc4a63b99f1aef1242a1e5660041b4ef$var$reHasUnicode = RegExp('[' + $fc4a63b99f1aef1242a1e5660041b4ef$var$rsZWJ + $fc4a63b99f1aef1242a1e5660041b4ef$var$rsAstralRange + $fc4a63b99f1aef1242a1e5660041b4ef$var$rsComboRange + $fc4a63b99f1aef1242a1e5660041b4ef$var$rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function $fc4a63b99f1aef1242a1e5660041b4ef$var$hasUnicode(string) {
  return $fc4a63b99f1aef1242a1e5660041b4ef$var$reHasUnicode.test(string);
}

$fc4a63b99f1aef1242a1e5660041b4ef$exports = $fc4a63b99f1aef1242a1e5660041b4ef$var$hasUnicode;
// ASSET: node_modules/lodash/_stringToArray.js
var $1dd970f2601f02358394929bbc719e5a$exports = {};
// ASSET: node_modules/lodash/_asciiToArray.js
var $7a33b52adaafb2eb16eb7b01ff7519eb$exports = {};

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function $7a33b52adaafb2eb16eb7b01ff7519eb$var$asciiToArray(string) {
  return string.split('');
}

$7a33b52adaafb2eb16eb7b01ff7519eb$exports = $7a33b52adaafb2eb16eb7b01ff7519eb$var$asciiToArray;
// ASSET: node_modules/lodash/_unicodeToArray.js
var $2f8fdef0625b7075c738baa57decdb13$exports = {};

/** Used to compose unicode character classes. */
var $2f8fdef0625b7075c738baa57decdb13$var$rsAstralRange = '\\ud800-\\udfff',
    $2f8fdef0625b7075c738baa57decdb13$var$rsComboMarksRange = '\\u0300-\\u036f',
    $2f8fdef0625b7075c738baa57decdb13$var$reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    $2f8fdef0625b7075c738baa57decdb13$var$rsComboSymbolsRange = '\\u20d0-\\u20ff',
    $2f8fdef0625b7075c738baa57decdb13$var$rsComboRange = $2f8fdef0625b7075c738baa57decdb13$var$rsComboMarksRange + $2f8fdef0625b7075c738baa57decdb13$var$reComboHalfMarksRange + $2f8fdef0625b7075c738baa57decdb13$var$rsComboSymbolsRange,
    $2f8fdef0625b7075c738baa57decdb13$var$rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */

/** Used to compose unicode capture groups. */
var $2f8fdef0625b7075c738baa57decdb13$var$rsAstral = '[' + $2f8fdef0625b7075c738baa57decdb13$var$rsAstralRange + ']',
    $2f8fdef0625b7075c738baa57decdb13$var$rsCombo = '[' + $2f8fdef0625b7075c738baa57decdb13$var$rsComboRange + ']',
    $2f8fdef0625b7075c738baa57decdb13$var$rsFitz = '\\ud83c[\\udffb-\\udfff]',
    $2f8fdef0625b7075c738baa57decdb13$var$rsModifier = '(?:' + $2f8fdef0625b7075c738baa57decdb13$var$rsCombo + '|' + $2f8fdef0625b7075c738baa57decdb13$var$rsFitz + ')',
    $2f8fdef0625b7075c738baa57decdb13$var$rsNonAstral = '[^' + $2f8fdef0625b7075c738baa57decdb13$var$rsAstralRange + ']',
    $2f8fdef0625b7075c738baa57decdb13$var$rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    $2f8fdef0625b7075c738baa57decdb13$var$rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    $2f8fdef0625b7075c738baa57decdb13$var$rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */

/** Used to compose unicode regexes. */
var $2f8fdef0625b7075c738baa57decdb13$var$reOptMod = $2f8fdef0625b7075c738baa57decdb13$var$rsModifier + '?',
    $2f8fdef0625b7075c738baa57decdb13$var$rsOptVar = '[' + $2f8fdef0625b7075c738baa57decdb13$var$rsVarRange + ']?',
    $2f8fdef0625b7075c738baa57decdb13$var$rsOptJoin = '(?:' + $2f8fdef0625b7075c738baa57decdb13$var$rsZWJ + '(?:' + [$2f8fdef0625b7075c738baa57decdb13$var$rsNonAstral, $2f8fdef0625b7075c738baa57decdb13$var$rsRegional, $2f8fdef0625b7075c738baa57decdb13$var$rsSurrPair].join('|') + ')' + $2f8fdef0625b7075c738baa57decdb13$var$rsOptVar + $2f8fdef0625b7075c738baa57decdb13$var$reOptMod + ')*',
    $2f8fdef0625b7075c738baa57decdb13$var$rsSeq = $2f8fdef0625b7075c738baa57decdb13$var$rsOptVar + $2f8fdef0625b7075c738baa57decdb13$var$reOptMod + $2f8fdef0625b7075c738baa57decdb13$var$rsOptJoin,
    $2f8fdef0625b7075c738baa57decdb13$var$rsSymbol = '(?:' + [$2f8fdef0625b7075c738baa57decdb13$var$rsNonAstral + $2f8fdef0625b7075c738baa57decdb13$var$rsCombo + '?', $2f8fdef0625b7075c738baa57decdb13$var$rsCombo, $2f8fdef0625b7075c738baa57decdb13$var$rsRegional, $2f8fdef0625b7075c738baa57decdb13$var$rsSurrPair, $2f8fdef0625b7075c738baa57decdb13$var$rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var $2f8fdef0625b7075c738baa57decdb13$var$reUnicode = RegExp($2f8fdef0625b7075c738baa57decdb13$var$rsFitz + '(?=' + $2f8fdef0625b7075c738baa57decdb13$var$rsFitz + ')|' + $2f8fdef0625b7075c738baa57decdb13$var$rsSymbol + $2f8fdef0625b7075c738baa57decdb13$var$rsSeq, 'g');
/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function $2f8fdef0625b7075c738baa57decdb13$var$unicodeToArray(string) {
  return string.match($2f8fdef0625b7075c738baa57decdb13$var$reUnicode) || [];
}

$2f8fdef0625b7075c738baa57decdb13$exports = $2f8fdef0625b7075c738baa57decdb13$var$unicodeToArray;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function $1dd970f2601f02358394929bbc719e5a$var$stringToArray(string) {
  return $fc4a63b99f1aef1242a1e5660041b4ef$exports(string) ? $2f8fdef0625b7075c738baa57decdb13$exports(string) : $7a33b52adaafb2eb16eb7b01ff7519eb$exports(string);
}

$1dd970f2601f02358394929bbc719e5a$exports = $1dd970f2601f02358394929bbc719e5a$var$stringToArray;

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function $f1e46ef7a52f113727a4f7301e7cc819$var$createCaseFirst(methodName) {
  return function (string) {
    string = $527b2e5779250a5bbe79f402e9a29e45$exports(string);
    var strSymbols = $fc4a63b99f1aef1242a1e5660041b4ef$exports(string) ? $1dd970f2601f02358394929bbc719e5a$exports(string) : undefined;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? $a8a63024b346c1bf5aac27ec57534a36$exports(strSymbols, 1).join('') : string.slice(1);
    return chr[methodName]() + trailing;
  };
}

$f1e46ef7a52f113727a4f7301e7cc819$exports = $f1e46ef7a52f113727a4f7301e7cc819$var$createCaseFirst;

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var $146bc3ce47d0dc29aadc4c5dc505011d$var$upperFirst = $f1e46ef7a52f113727a4f7301e7cc819$exports('toUpperCase');
$146bc3ce47d0dc29aadc4c5dc505011d$exports = $146bc3ce47d0dc29aadc4c5dc505011d$var$upperFirst;

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function $1cc60b568ee868d2cf655234c6771e9a$var$capitalize(string) {
  return $146bc3ce47d0dc29aadc4c5dc505011d$exports($527b2e5779250a5bbe79f402e9a29e45$exports(string).toLowerCase());
}

$1cc60b568ee868d2cf655234c6771e9a$exports = $1cc60b568ee868d2cf655234c6771e9a$var$capitalize;
const $6881e9a961a5fe3922a1e41f40f331a3$var$capitalize_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($1cc60b568ee868d2cf655234c6771e9a$exports);
// ASSET: node_modules/p-limit/index.js
var $e6872599661a671bb42eeb06298de58e$exports = {};
// ASSET: node_modules/p-try/index.js
var $74d4519ff45ef4f3c1771f4bb511388b$exports = {};

const $74d4519ff45ef4f3c1771f4bb511388b$var$pTry = (fn, ...arguments_) => new Promise(resolve => {
  resolve(fn(...arguments_));
});

$74d4519ff45ef4f3c1771f4bb511388b$exports = $74d4519ff45ef4f3c1771f4bb511388b$var$pTry; // TODO: remove this in the next major version

var $74d4519ff45ef4f3c1771f4bb511388b$export$default = $74d4519ff45ef4f3c1771f4bb511388b$var$pTry;
// TODO: remove this in the next major version
$74d4519ff45ef4f3c1771f4bb511388b$exports.default = $74d4519ff45ef4f3c1771f4bb511388b$export$default;

const $e6872599661a671bb42eeb06298de58e$var$pLimit = concurrency => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
  }

  const queue = [];
  let activeCount = 0;

  const next = () => {
    activeCount--;

    if (queue.length > 0) {
      queue.shift()();
    }
  };

  const run = (fn, resolve, ...args) => {
    activeCount++;
    const result = $74d4519ff45ef4f3c1771f4bb511388b$exports(fn, ...args);
    resolve(result);
    result.then(next, next);
  };

  const enqueue = (fn, resolve, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve, ...args));
    }
  };

  const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));

  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};

$e6872599661a671bb42eeb06298de58e$exports = $e6872599661a671bb42eeb06298de58e$var$pLimit;
var $e6872599661a671bb42eeb06298de58e$export$default = $e6872599661a671bb42eeb06298de58e$var$pLimit;
$e6872599661a671bb42eeb06298de58e$exports.default = $e6872599661a671bb42eeb06298de58e$export$default;
const $6881e9a961a5fe3922a1e41f40f331a3$var$p_limit_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($e6872599661a671bb42eeb06298de58e$exports);
// ASSET: node_modules/@yarnpkg/core/lib/Manifest.js
var $e51f99366c3d7ff19a0ceeed21bc69c1$exports = {};
Object.defineProperty($e51f99366c3d7ff19a0ceeed21bc69c1$exports, "__esModule", {
  value: true
});
var $e51f99366c3d7ff19a0ceeed21bc69c1$export$Manifest = void 0;
$e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest = $e51f99366c3d7ff19a0ceeed21bc69c1$export$Manifest;
// ASSET: node_modules/@yarnpkg/parsers/lib/index.js
var $0e609d03a5066ebec776a5ec6a49b084$export$parseSyml,
    $0e609d03a5066ebec776a5ec6a49b084$export$stringifyResolution,
    $0e609d03a5066ebec776a5ec6a49b084$export$parseResolution,
    $0e609d03a5066ebec776a5ec6a49b084$export$parseShell,
    $0e609d03a5066ebec776a5ec6a49b084$exports = {};
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "__esModule", {
  value: true
});
var $0e609d03a5066ebec776a5ec6a49b084$export$stringifySyml = ($0e609d03a5066ebec776a5ec6a49b084$export$parseSyml = ($0e609d03a5066ebec776a5ec6a49b084$export$stringifyResolution = ($0e609d03a5066ebec776a5ec6a49b084$export$parseResolution = ($0e609d03a5066ebec776a5ec6a49b084$export$parseShell = void 0, $0e609d03a5066ebec776a5ec6a49b084$exports.parseShell = $0e609d03a5066ebec776a5ec6a49b084$export$parseShell), $0e609d03a5066ebec776a5ec6a49b084$exports.parseResolution = $0e609d03a5066ebec776a5ec6a49b084$export$parseResolution), $0e609d03a5066ebec776a5ec6a49b084$exports.stringifyResolution = $0e609d03a5066ebec776a5ec6a49b084$export$stringifyResolution), $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml = $0e609d03a5066ebec776a5ec6a49b084$export$parseSyml);
$0e609d03a5066ebec776a5ec6a49b084$exports.stringifySyml = $0e609d03a5066ebec776a5ec6a49b084$export$stringifySyml;
// ASSET: node_modules/@yarnpkg/parsers/lib/shell.js
var $6ad476ee9fadf9830c1ed0845d93d393$exports = {};
Object.defineProperty($6ad476ee9fadf9830c1ed0845d93d393$exports, "__esModule", {
  value: true
});
var $6ad476ee9fadf9830c1ed0845d93d393$export$parseShell = void 0;
$6ad476ee9fadf9830c1ed0845d93d393$exports.parseShell = $6ad476ee9fadf9830c1ed0845d93d393$export$parseShell;
// ASSET: node_modules/@yarnpkg/parsers/lib/grammars/shell.js
var $2d936006b26b112dbfcb6d3e3a756b63$exports = {};

function $2d936006b26b112dbfcb6d3e3a756b63$var$peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function $2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, $2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError);
  }
}

$2d936006b26b112dbfcb6d3e3a756b63$var$peg$subclass($2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError, Error);

$2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    "class": function (expectation) {
      var escapedParts = "",
          i;

      for (i = 0; i < expectation.parts.length; i++) {
        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
      }

      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function (expectation) {
      return "any character";
    },
    end: function (expectation) {
      return "end of input";
    },
    other: function (expectation) {
      return expectation.description;
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return '\\x0' + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return '\\x' + hex(ch);
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return '\\x0' + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return '\\x' + hex(ch);
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i,
        j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function $2d936006b26b112dbfcb6d3e3a756b63$var$peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},
      peg$startRuleFunctions = {
    Start: peg$parseStart
  },
      peg$startRuleFunction = peg$parseStart,
      peg$c0 = function (line) {
    return line ? line : [];
  },
      peg$c1 = function (command, type, then) {
    return [command].concat(then || []);
  },
      peg$c2 = function (command, type) {
    return [command];
  },
      peg$c3 = function (then) {
    return then;
  },
      peg$c4 = ";",
      peg$c5 = peg$literalExpectation(";", false),
      peg$c6 = function (chain, then) {
    return then ? {
      chain,
      then
    } : {
      chain
    };
  },
      peg$c7 = function (type, then) {
    return {
      type,
      line: then
    };
  },
      peg$c8 = "&&",
      peg$c9 = peg$literalExpectation("&&", false),
      peg$c10 = "||",
      peg$c11 = peg$literalExpectation("||", false),
      peg$c12 = function (main, then) {
    return then ? { ...main,
      then
    } : main;
  },
      peg$c13 = function (type, then) {
    return {
      type,
      chain: then
    };
  },
      peg$c14 = "|&",
      peg$c15 = peg$literalExpectation("|&", false),
      peg$c16 = "|",
      peg$c17 = peg$literalExpectation("|", false),
      peg$c18 = "=",
      peg$c19 = peg$literalExpectation("=", false),
      peg$c20 = function (name, arg) {
    return {
      name,
      args: [arg]
    };
  },
      peg$c21 = function (name) {
    return {
      name,
      args: []
    };
  },
      peg$c22 = "(",
      peg$c23 = peg$literalExpectation("(", false),
      peg$c24 = ")",
      peg$c25 = peg$literalExpectation(")", false),
      peg$c26 = function (subshell, args) {
    return {
      type: `subshell`,
      subshell,
      args
    };
  },
      peg$c27 = "{",
      peg$c28 = peg$literalExpectation("{", false),
      peg$c29 = "}",
      peg$c30 = peg$literalExpectation("}", false),
      peg$c31 = function (group, args) {
    return {
      type: `group`,
      group,
      args
    };
  },
      peg$c32 = function (envs, args) {
    return {
      type: `command`,
      args,
      envs
    };
  },
      peg$c33 = function (envs) {
    return {
      type: `envs`,
      envs
    };
  },
      peg$c34 = function (args) {
    return args;
  },
      peg$c35 = function (arg) {
    return arg;
  },
      peg$c36 = function (redirect, arg) {
    return {
      type: `redirection`,
      subtype: redirect,
      args: [arg]
    };
  },
      peg$c37 = ">>",
      peg$c38 = peg$literalExpectation(">>", false),
      peg$c39 = ">&",
      peg$c40 = peg$literalExpectation(">&", false),
      peg$c41 = ">",
      peg$c42 = peg$literalExpectation(">", false),
      peg$c43 = "<<<",
      peg$c44 = peg$literalExpectation("<<<", false),
      peg$c45 = "<&",
      peg$c46 = peg$literalExpectation("<&", false),
      peg$c47 = "<",
      peg$c48 = peg$literalExpectation("<", false),
      peg$c49 = function (segments) {
    return {
      type: `argument`,
      segments: [].concat(...segments)
    };
  },
      peg$c50 = function (string) {
    return string;
  },
      peg$c51 = "'",
      peg$c52 = peg$literalExpectation("'", false),
      peg$c53 = function (text) {
    return [{
      type: `text`,
      text
    }];
  },
      peg$c54 = "\"",
      peg$c55 = peg$literalExpectation("\"", false),
      peg$c56 = function (segments) {
    return segments;
  },
      peg$c57 = function (arithmetic) {
    return {
      type: `arithmetic`,
      arithmetic,
      quoted: true
    };
  },
      peg$c58 = function (shell) {
    return {
      type: `shell`,
      shell,
      quoted: true
    };
  },
      peg$c59 = function (variable) {
    return {
      type: `variable`,
      ...variable,
      quoted: true
    };
  },
      peg$c60 = function (text) {
    return {
      type: `text`,
      text
    };
  },
      peg$c61 = function (arithmetic) {
    return {
      type: `arithmetic`,
      arithmetic,
      quoted: false
    };
  },
      peg$c62 = function (shell) {
    return {
      type: `shell`,
      shell,
      quoted: false
    };
  },
      peg$c63 = function (variable) {
    return {
      type: `variable`,
      ...variable,
      quoted: false
    };
  },
      peg$c64 = function (pattern) {
    return {
      type: `glob`,
      pattern
    };
  },
      peg$c65 = "\\",
      peg$c66 = peg$literalExpectation("\\", false),
      peg$c67 = peg$anyExpectation(),
      peg$c68 = function (c) {
    return c;
  },
      peg$c69 = /^[^']/,
      peg$c70 = peg$classExpectation(["'"], true, false),
      peg$c71 = function (chars) {
    return chars.join(``);
  },
      peg$c72 = /^[^$"]/,
      peg$c73 = peg$classExpectation(["$", "\""], true, false),
      peg$c74 = "-",
      peg$c75 = peg$literalExpectation("-", false),
      peg$c76 = "+",
      peg$c77 = peg$literalExpectation("+", false),
      peg$c78 = /^[0-9]/,
      peg$c79 = peg$classExpectation([["0", "9"]], false, false),
      peg$c80 = ".",
      peg$c81 = peg$literalExpectation(".", false),
      peg$c82 = function (sign, left, right) {
    return {
      type: `number`,
      value: (sign === '-' ? -1 : 1) * parseFloat(left.join(``) + `.` + right.join(``))
    };
  },
      peg$c83 = function (sign, value) {
    return {
      type: `number`,
      value: (sign === '-' ? -1 : 1) * parseInt(value.join(``))
    };
  },
      peg$c84 = function (variable) {
    return {
      type: `variable`,
      ...variable
    };
  },
      peg$c85 = function (name) {
    return {
      type: `variable`,
      name
    };
  },
      peg$c86 = function (value) {
    return value;
  },
      peg$c87 = "*",
      peg$c88 = peg$literalExpectation("*", false),
      peg$c89 = function (left, right) {
    return {
      type: `multiplication`,
      left,
      right
    };
  },
      peg$c90 = "/",
      peg$c91 = peg$literalExpectation("/", false),
      peg$c92 = function (left, right) {
    return {
      type: `division`,
      left,
      right
    };
  },
      peg$c93 = function (left, right) {
    return {
      type: `addition`,
      left,
      right
    };
  },
      peg$c94 = function (left, right) {
    return {
      type: `subtraction`,
      left,
      right
    };
  },
      peg$c95 = "$((",
      peg$c96 = peg$literalExpectation("$((", false),
      peg$c97 = "))",
      peg$c98 = peg$literalExpectation("))", false),
      peg$c99 = function (arithmetic) {
    return arithmetic;
  },
      peg$c100 = "$(",
      peg$c101 = peg$literalExpectation("$(", false),
      peg$c102 = function (command) {
    return command;
  },
      peg$c103 = "${",
      peg$c104 = peg$literalExpectation("${", false),
      peg$c105 = ":-",
      peg$c106 = peg$literalExpectation(":-", false),
      peg$c107 = function (name, arg) {
    return {
      name,
      defaultValue: arg
    };
  },
      peg$c108 = ":-}",
      peg$c109 = peg$literalExpectation(":-}", false),
      peg$c110 = function (name) {
    return {
      name,
      defaultValue: []
    };
  },
      peg$c111 = function (name) {
    return {
      name
    };
  },
      peg$c112 = "$",
      peg$c113 = peg$literalExpectation("$", false),
      peg$c114 = function (pattern) {
    return options.isGlobPattern(pattern);
  },
      peg$c115 = function (pattern) {
    return pattern;
  },
      peg$c116 = /^[a-zA-Z0-9_]/,
      peg$c117 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false),
      peg$c118 = function () {
    return text();
  },
      peg$c119 = /^[$@*?#a-zA-Z0-9_\-]/,
      peg$c120 = peg$classExpectation(["$", "@", "*", "?", "#", ["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
      peg$c121 = /^[(){}<>$|&; \t"']/,
      peg$c122 = peg$classExpectation(["(", ")", "{", "}", "<", ">", "$", "|", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c123 = /^[<>&; \t"']/,
      peg$c124 = peg$classExpectation(["<", ">", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c125 = /^[ \t]/,
      peg$c126 = peg$classExpectation([" ", "\t"], false, false),
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{
    line: 1,
    column: 1
  }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {
      type: "literal",
      text: text,
      ignoreCase: ignoreCase
    };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  }

  function peg$anyExpectation() {
    return {
      type: "any"
    };
  }

  function peg$endExpectation() {
    return {
      type: "end"
    };
  }

  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
        p;

    if (details) {
      return details;
    } else {
      p = pos - 1;

      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new $2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new $2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError($2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }

  function peg$parseStart() {
    var s0, s1;
    s0 = peg$currPos;
    s1 = peg$parseShellLine();

    if (s1 === peg$FAILED) {
      s1 = null;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseShellLine() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parseCommandLine();

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parseShellLineType();

        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLineThen();

          if (s4 === peg$FAILED) {
            s4 = null;
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseCommandLine();

      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();

        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parseShellLineType();

          if (s3 === peg$FAILED) {
            s3 = null;
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseShellLineThen() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLine();

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();

        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseShellLineType() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 59) {
      s0 = peg$c4;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c5);
      }
    }

    return s0;
  }

  function peg$parseCommandLine() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseCommandChain();

    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineThen();

      if (s2 === peg$FAILED) {
        s2 = null;
      }

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineThen() {
    var s0, s1, s2, s3, s4, s5, s6;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineType();

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();

        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandLine();

          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();

            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c8) {
      s0 = peg$c8;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c9);
      }
    }

    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c10) {
        s0 = peg$c10;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c11);
        }
      }
    }

    return s0;
  }

  function peg$parseCommandChain() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseCommand();

    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainThen();

      if (s2 === peg$FAILED) {
        s2 = null;
      }

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c12(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainThen() {
    var s0, s1, s2, s3, s4, s5, s6;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainType();

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();

        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandChain();

          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();

            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c14) {
      s0 = peg$c14;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c15);
      }
    }

    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 124) {
        s0 = peg$c16;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c17);
        }
      }
    }

    return s0;
  }

  function peg$parseVariableAssignment() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseEnvVariable();

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 61) {
        s2 = peg$c18;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c19);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parseStrictValueArgument();

        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();

          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEnvVariable();

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c18;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();

          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c21(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseCommand() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c22;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c23);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();

        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLine();

          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();

            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }

            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c24;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c25);
                }
              }

              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseS();

                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parseS();
                }

                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parseRedirectArgument();

                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parseRedirectArgument();
                  }

                  if (s8 !== peg$FAILED) {
                    s9 = [];
                    s10 = peg$parseS();

                    while (s10 !== peg$FAILED) {
                      s9.push(s10);
                      s10 = peg$parseS();
                    }

                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c26(s4, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();

      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c27;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();

          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }

          if (s3 !== peg$FAILED) {
            s4 = peg$parseShellLine();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();

              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }

              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c29;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }

                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseS();

                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseS();
                  }

                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    s9 = peg$parseRedirectArgument();

                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$parseRedirectArgument();
                    }

                    if (s8 !== peg$FAILED) {
                      s9 = [];
                      s10 = peg$parseS();

                      while (s10 !== peg$FAILED) {
                        s9.push(s10);
                        s10 = peg$parseS();
                      }

                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s4, s8);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();

        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseVariableAssignment();

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseVariableAssignment();
          }

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }

            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseArgument();

              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseArgument();
                }
              } else {
                s4 = peg$FAILED;
              }

              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();

                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c32(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();

          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseVariableAssignment();

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseVariableAssignment();
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }

              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseCommandString() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseValueArgument();

      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseValueArgument();
        }
      } else {
        s2 = peg$FAILED;
      }

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();

        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArgument() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseRedirectArgument();

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();

      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseValueArgument();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseRedirectArgument() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseRedirectType();

      if (s2 !== peg$FAILED) {
        s3 = peg$parseValueArgument();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRedirectType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c37) {
      s0 = peg$c37;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c38);
      }
    }

    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c39) {
        s0 = peg$c39;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c40);
        }
      }

      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s0 = peg$c41;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c43) {
            s0 = peg$c43;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }

          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c45) {
              s0 = peg$c45;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c46);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s0 = peg$c47;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseValueArgument() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseStrictValueArgument();

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStrictValueArgument() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseArgumentSegment();

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseArgumentSegment();
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c49(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseArgumentSegment() {
    var s0, s1;
    s0 = peg$currPos;
    s1 = peg$parseSglQuoteString();

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c50(s1);
    }

    s0 = s1;

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseDblQuoteString();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50(s1);
      }

      s0 = s1;

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsePlainString();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c50(s1);
        }

        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseSglQuoteString() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c51;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c52);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseSglQuoteStringText();

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c51;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDblQuoteString() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c54;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c55);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDblQuoteStringSegment();

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDblQuoteStringSegment();
      }

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c54;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c56(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePlainString() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePlainStringSegment();

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsePlainStringSegment();
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c56(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseDblQuoteStringSegment() {
    var s0, s1;
    s0 = peg$currPos;
    s1 = peg$parseArithmetic();

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c57(s1);
    }

    s0 = s1;

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58(s1);
      }

      s0 = s1;

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c59(s1);
        }

        s0 = s1;

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDblQuoteStringText();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c60(s1);
          }

          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parsePlainStringSegment() {
    var s0, s1;
    s0 = peg$currPos;
    s1 = peg$parseArithmetic();

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }

    s0 = s1;

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c62(s1);
      }

      s0 = s1;

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c63(s1);
        }

        s0 = s1;

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseGlob();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePlainStringText();

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60(s1);
            }

            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseSglQuoteStringText() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c66);
      }
    }

    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }

      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }

    if (s2 === peg$FAILED) {
      if (peg$c69.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c70);
        }
      }
    }

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c65;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c66);
        }
      }

      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c68(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }

      if (s2 === peg$FAILED) {
        if (peg$c69.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c70);
          }
        }
      }
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseDblQuoteStringText() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c66);
      }
    }

    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }

      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }

    if (s2 === peg$FAILED) {
      if (peg$c72.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c73);
        }
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }

        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        if (s2 === peg$FAILED) {
          if (peg$c72.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parsePlainStringText() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c66);
      }
    }

    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }

      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }

    if (s2 === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseSpecialShellChars();
      peg$silentFails--;

      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }

      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }

        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c68(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }

        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }

        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSpecialShellChars();
          peg$silentFails--;

          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c67);
              }
            }

            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c68(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseArithmeticPrimary() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c74;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c75);
      }
    }

    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c76;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c77);
        }
      }
    }

    if (s1 === peg$FAILED) {
      s1 = null;
    }

    if (s1 !== peg$FAILED) {
      s2 = [];

      if (peg$c78.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c79);
        }
      }

      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);

          if (peg$c78.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c79);
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c80;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c81);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = [];

          if (peg$c78.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c79);
            }
          }

          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);

              if (peg$c78.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c79);
                }
              }
            }
          } else {
            s4 = peg$FAILED;
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c82(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c74;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c75);
        }
      }

      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c76;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
      }

      if (s1 === peg$FAILED) {
        s1 = null;
      }

      if (s1 !== peg$FAILED) {
        s2 = [];

        if (peg$c78.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c79);
          }
        }

        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);

            if (peg$c78.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c79);
              }
            }
          }
        } else {
          s2 = peg$FAILED;
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c83(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s1);
        }

        s0 = s1;

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c85(s1);
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c22;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c23);
              }
            }

            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();

              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }

              if (s2 !== peg$FAILED) {
                s3 = peg$parseArithmeticExpression();

                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();

                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }

                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s5 = peg$c24;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c25);
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c86(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseArithmeticTimesExpression() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseArithmeticPrimary();

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c87;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();

          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }

          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticTimesExpression();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c89(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticPrimary();

      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();

        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }

        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c90;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c91);
            }
          }

          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();

            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticTimesExpression();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c92(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticPrimary();
      }
    }

    return s0;
  }

  function peg$parseArithmeticExpression() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseArithmeticTimesExpression();

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c76;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();

          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }

          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticExpression();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c93(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticTimesExpression();

      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();

        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }

        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c74;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c75);
            }
          }

          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();

            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticExpression();

              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c94(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticTimesExpression();
      }
    }

    return s0;
  }

  function peg$parseArithmetic() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 3) === peg$c95) {
      s1 = peg$c95;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c96);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parseArithmeticExpression();

        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();

          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }

          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c97) {
              s5 = peg$c97;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c98);
              }
            }

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c99(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSubshell() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 2) === peg$c100) {
      s1 = peg$c100;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c101);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLine();

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s3 = peg$c24;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c102(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVariable() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 2) === peg$c103) {
      s1 = peg$c103;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c104);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseIdentifier();

      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c105) {
          s3 = peg$c105;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c106);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandString();

          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c29;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c107(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 2) === peg$c103) {
        s1 = peg$c103;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c104);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifier();

        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c108) {
            s3 = peg$c108;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c109);
            }
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c110(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c103) {
          s1 = peg$c103;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c29;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }

            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c111(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 36) {
            s1 = peg$c112;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c113);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();

            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c111(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseGlob() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = peg$parseGlobText();

    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c114(s1);

      if (s2) {
        s2 = void 0;
      } else {
        s2 = peg$FAILED;
      }

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c115(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGlobText() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parseGlobSpecialShellChars();
    peg$silentFails--;

    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }

    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }

      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseGlobSpecialShellChars();
        peg$silentFails--;

        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }

          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseEnvVariable() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];

    if (peg$c116.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c117);
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);

        if (peg$c116.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c118();
    }

    s0 = s1;
    return s0;
  }

  function peg$parseIdentifier() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];

    if (peg$c119.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c120);
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);

        if (peg$c119.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c120);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c118();
    }

    s0 = s1;
    return s0;
  }

  function peg$parseSpecialShellChars() {
    var s0;

    if (peg$c121.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c122);
      }
    }

    return s0;
  }

  function peg$parseGlobSpecialShellChars() {
    var s0;

    if (peg$c123.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c124);
      }
    }

    return s0;
  }

  function peg$parseS() {
    var s0, s1;
    s0 = [];

    if (peg$c125.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c126);
      }
    }

    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);

        if (peg$c125.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}

$2d936006b26b112dbfcb6d3e3a756b63$exports = {
  SyntaxError: $2d936006b26b112dbfcb6d3e3a756b63$var$peg$SyntaxError,
  parse: $2d936006b26b112dbfcb6d3e3a756b63$var$peg$parse
};

function $6ad476ee9fadf9830c1ed0845d93d393$var$parseShell(source, options = {
  isGlobPattern: () => false
}) {
  try {
    return $2d936006b26b112dbfcb6d3e3a756b63$exports.parse(source, options);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}

$6ad476ee9fadf9830c1ed0845d93d393$export$parseShell = $6ad476ee9fadf9830c1ed0845d93d393$var$parseShell;
$6ad476ee9fadf9830c1ed0845d93d393$exports.parseShell = $6ad476ee9fadf9830c1ed0845d93d393$export$parseShell;
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "parseShell", {
  enumerable: true,
  get: function () {
    return $6ad476ee9fadf9830c1ed0845d93d393$exports.parseShell;
  }
});
// ASSET: node_modules/@yarnpkg/parsers/lib/resolution.js
var $1e3c9512fd363c55039d4b4dfda68e43$exports = {};
Object.defineProperty($1e3c9512fd363c55039d4b4dfda68e43$exports, "__esModule", {
  value: true
});
var $1e3c9512fd363c55039d4b4dfda68e43$export$stringifyResolution = ($1e3c9512fd363c55039d4b4dfda68e43$export$parseResolution = void 0, $1e3c9512fd363c55039d4b4dfda68e43$exports.parseResolution = $1e3c9512fd363c55039d4b4dfda68e43$export$parseResolution);
$1e3c9512fd363c55039d4b4dfda68e43$exports.stringifyResolution = $1e3c9512fd363c55039d4b4dfda68e43$export$stringifyResolution;
// ASSET: node_modules/@yarnpkg/parsers/lib/grammars/resolution.js
var $7e61079e4edef6deb359237fda19c421$exports = {};

function $7e61079e4edef6deb359237fda19c421$var$peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function $7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, $7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError);
  }
}

$7e61079e4edef6deb359237fda19c421$var$peg$subclass($7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError, Error);

$7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },
    "class": function (expectation) {
      var escapedParts = "",
          i;

      for (i = 0; i < expectation.parts.length; i++) escapedParts += expectation.parts[i] instanceof Array ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}` : classEscape(expectation.parts[i]);

      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },
    any: function (expectation) {
      return "any character";
    },
    end: function (expectation) {
      return "end of input";
    },
    other: function (expectation) {
      return expectation.description;
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return `\\x0${hex(ch)}`;
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return `\\x${hex(ch)}`;
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return `\\x0${hex(ch)}`;
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return `\\x${hex(ch)}`;
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i,
        j;

    for (i = 0; i < expected.length; i++) descriptions[i] = describeExpectation(expected[i]);

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")}, or ${descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function $7e61079e4edef6deb359237fda19c421$var$peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},
      peg$startRuleFunctions = {
    resolution: peg$parseresolution
  },
      peg$startRuleFunction = peg$parseresolution,
      peg$c0 = "/",
      peg$c1 = peg$literalExpectation("/", false),
      peg$c2 = function (from, descriptor) {
    return {
      from,
      descriptor
    };
  },
      peg$c3 = function (descriptor) {
    return {
      descriptor
    };
  },
      peg$c4 = "@",
      peg$c5 = peg$literalExpectation("@", false),
      peg$c6 = function (fullName, description) {
    return {
      fullName,
      description
    };
  },
      peg$c7 = function (fullName) {
    return {
      fullName
    };
  },
      peg$c8 = function () {
    return text();
  },
      peg$c9 = /^[^\/@]/,
      peg$c10 = peg$classExpectation(["/", "@"], true, false),
      peg$c11 = /^[^\/]/,
      peg$c12 = peg$classExpectation(["/"], true, false),
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{
    line: 1,
    column: 1
  }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) throw new Error(`Can't start parsing from rule "${options.startRule}".`);
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {
      type: "literal",
      text: text,
      ignoreCase: ignoreCase
    };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$anyExpectation() {
    return {
      type: "any"
    };
  }

  function peg$endExpectation() {
    return {
      type: "end"
    };
  }

  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
        p;

    if (details) {
      return details;
    } else {
      p = pos - 1;

      while (!peg$posDetailsCache[p]) p--;

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new $7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new $7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError($7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }

  function peg$parseresolution() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parsespecifier();

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s2 = peg$c0;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c1);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parsespecifier();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsespecifier();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c3(s1);
      }

      s0 = s1;
    }

    return s0;
  }

  function peg$parsespecifier() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$parsefullName();

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 64) {
        s2 = peg$c4;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c5);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parsedescription();

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c6(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsefullName();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1);
      }

      s0 = s1;
    }

    return s0;
  }

  function peg$parsefullName() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 64) {
      s1 = peg$c4;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c5);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseident();

      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c0;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c1);
          }
        }

        if (s3 !== peg$FAILED) {
          s4 = peg$parseident();

          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident();

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }

      s0 = s1;
    }

    return s0;
  }

  function peg$parseident() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];

    if (peg$c9.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c10);
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);

        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }

    s0 = s1;
    return s0;
  }

  function peg$parsedescription() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];

    if (peg$c11.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c12);
      }
    }

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);

        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }

    s0 = s1;
    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}

$7e61079e4edef6deb359237fda19c421$exports = {
  SyntaxError: $7e61079e4edef6deb359237fda19c421$var$peg$SyntaxError,
  parse: $7e61079e4edef6deb359237fda19c421$var$peg$parse
};

function $1e3c9512fd363c55039d4b4dfda68e43$var$parseResolution(source) {
  const legacyResolution = source.match(/^\*{1,2}\/(.*)/);
  if (legacyResolution) throw new Error(`The override for '${source}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${legacyResolution[1]}' instead.`);

  try {
    return $7e61079e4edef6deb359237fda19c421$exports.parse(source);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}

var $1e3c9512fd363c55039d4b4dfda68e43$export$parseResolution = $1e3c9512fd363c55039d4b4dfda68e43$var$parseResolution;
$1e3c9512fd363c55039d4b4dfda68e43$exports.parseResolution = $1e3c9512fd363c55039d4b4dfda68e43$export$parseResolution;

function $1e3c9512fd363c55039d4b4dfda68e43$var$stringifyResolution(resolution) {
  let str = ``;

  if (resolution.from) {
    str += resolution.from.fullName;
    if (resolution.from.description) str += `@${resolution.from.description}`;
    str += `/`;
  }

  str += resolution.descriptor.fullName;
  if (resolution.descriptor.description) str += `@${resolution.descriptor.description}`;
  return str;
}

$1e3c9512fd363c55039d4b4dfda68e43$export$stringifyResolution = $1e3c9512fd363c55039d4b4dfda68e43$var$stringifyResolution;
$1e3c9512fd363c55039d4b4dfda68e43$exports.stringifyResolution = $1e3c9512fd363c55039d4b4dfda68e43$export$stringifyResolution;
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "parseResolution", {
  enumerable: true,
  get: function () {
    return $1e3c9512fd363c55039d4b4dfda68e43$exports.parseResolution;
  }
});
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "stringifyResolution", {
  enumerable: true,
  get: function () {
    return $1e3c9512fd363c55039d4b4dfda68e43$exports.stringifyResolution;
  }
});
// ASSET: node_modules/@yarnpkg/parsers/lib/syml.js
var $b007afdcdc3a457f30010926c327cba4$exports = {};
Object.defineProperty($b007afdcdc3a457f30010926c327cba4$exports, "__esModule", {
  value: true
});
var $b007afdcdc3a457f30010926c327cba4$export$parseSyml = ($b007afdcdc3a457f30010926c327cba4$export$stringifySyml = ($b007afdcdc3a457f30010926c327cba4$export$PreserveOrdering = void 0, $b007afdcdc3a457f30010926c327cba4$exports.PreserveOrdering = $b007afdcdc3a457f30010926c327cba4$export$PreserveOrdering), $b007afdcdc3a457f30010926c327cba4$exports.stringifySyml = $b007afdcdc3a457f30010926c327cba4$export$stringifySyml);
$b007afdcdc3a457f30010926c327cba4$exports.parseSyml = $b007afdcdc3a457f30010926c327cba4$export$parseSyml; // @ts-expect-error

// ASSET: node_modules/js-yaml/index.js
var $33a2e486b42a7206519a930f8dad43a7$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml.js
var $e21ce51baf1ea7509e523006a1b55351$exports = {};

function $e4705106f1abdb94c9e9554d63f12b0a$var$isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function $e4705106f1abdb94c9e9554d63f12b0a$var$isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}

function $e4705106f1abdb94c9e9554d63f12b0a$var$toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if ($e4705106f1abdb94c9e9554d63f12b0a$var$isNothing(sequence)) return [];
  return [sequence];
}

function $e4705106f1abdb94c9e9554d63f12b0a$var$extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function $e4705106f1abdb94c9e9554d63f12b0a$var$repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function $e4705106f1abdb94c9e9554d63f12b0a$var$isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

var $e4705106f1abdb94c9e9554d63f12b0a$export$isNothing = $e4705106f1abdb94c9e9554d63f12b0a$var$isNothing;
var $e4705106f1abdb94c9e9554d63f12b0a$export$isObject = $e4705106f1abdb94c9e9554d63f12b0a$var$isObject;
var $e4705106f1abdb94c9e9554d63f12b0a$export$toArray = $e4705106f1abdb94c9e9554d63f12b0a$var$toArray;
var $e4705106f1abdb94c9e9554d63f12b0a$export$repeat = $e4705106f1abdb94c9e9554d63f12b0a$var$repeat;
var $e4705106f1abdb94c9e9554d63f12b0a$export$isNegativeZero = $e4705106f1abdb94c9e9554d63f12b0a$var$isNegativeZero;
var $e4705106f1abdb94c9e9554d63f12b0a$export$extend = $e4705106f1abdb94c9e9554d63f12b0a$var$extend;
// ASSET: node_modules/js-yaml/lib/js-yaml/exception.js
var $a4131730fdea0a83c53cfcac61bc86fe$exports = {};

function $a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);
  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
} // Inherit from Error


// Inherit from Error
$a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException.prototype = Object.create(Error.prototype);
$a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException.prototype.constructor = $a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException;

$a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';
  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};

$a4131730fdea0a83c53cfcac61bc86fe$exports = $a4131730fdea0a83c53cfcac61bc86fe$var$YAMLException;
// ASSET: node_modules/js-yaml/lib/js-yaml/mark.js
var $931182cfb8ced117155b4bf370c8b7e8$exports = {};

function $931182cfb8ced117155b4bf370c8b7e8$var$Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}

$931182cfb8ced117155b4bf370c8b7e8$var$Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;
  if (!this.buffer) return null;
  indent = indent || 4;
  maxLength = maxLength || 75;
  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;

    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;

    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);
  return $e4705106f1abdb94c9e9554d63f12b0a$export$repeat(' ', indent) + head + snippet + tail + '\n' + $e4705106f1abdb94c9e9554d63f12b0a$export$repeat(' ', indent + this.position - start + head.length) + '^';
};

$931182cfb8ced117155b4bf370c8b7e8$var$Mark.prototype.toString = function toString(compact) {
  var snippet,
      where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};

$931182cfb8ced117155b4bf370c8b7e8$exports = $931182cfb8ced117155b4bf370c8b7e8$var$Mark;
// ASSET: node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var $3defc228960dbdbcf6a2a4a7bb913540$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/schema.js
var $a1778edf5fa0c0fb671dfa49596a0d70$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/type.js
var $d5c0c9d1c2801e774c431a84a7c32047$exports = {};
var $d5c0c9d1c2801e774c431a84a7c32047$var$TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
var $d5c0c9d1c2801e774c431a84a7c32047$var$YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function $d5c0c9d1c2801e774c431a84a7c32047$var$compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function $d5c0c9d1c2801e774c431a84a7c32047$var$Type(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function (name) {
    if ($d5c0c9d1c2801e774c431a84a7c32047$var$TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  }); // TODO: Add tag format check.

  // TODO: Add tag format check.
  this.tag = tag;
  this.kind = options['kind'] || null;

  this.resolve = options['resolve'] || function () {
    return true;
  };

  this.construct = options['construct'] || function (data) {
    return data;
  };

  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = $d5c0c9d1c2801e774c431a84a7c32047$var$compileStyleAliases(options['styleAliases'] || null);

  if ($d5c0c9d1c2801e774c431a84a7c32047$var$YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

$d5c0c9d1c2801e774c431a84a7c32047$exports = $d5c0c9d1c2801e774c431a84a7c32047$var$Type;

function $a1778edf5fa0c0fb671dfa49596a0d70$var$compileList(schema, name, result) {
  var exclude = [];
  schema.include.forEach(function (includedSchema) {
    result = $a1778edf5fa0c0fb671dfa49596a0d70$var$compileList(includedSchema, name, result);
  });
  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function $a1778edf5fa0c0fb671dfa49596a0d70$var$compileMap()
/* lists... */
{
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  },
      index,
      length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}

function $a1778edf5fa0c0fb671dfa49596a0d70$var$Schema(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];
  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });
  this.compiledImplicit = $a1778edf5fa0c0fb671dfa49596a0d70$var$compileList(this, 'implicit', []);
  this.compiledExplicit = $a1778edf5fa0c0fb671dfa49596a0d70$var$compileList(this, 'explicit', []);
  this.compiledTypeMap = $a1778edf5fa0c0fb671dfa49596a0d70$var$compileMap(this.compiledImplicit, this.compiledExplicit);
}

$a1778edf5fa0c0fb671dfa49596a0d70$var$Schema.DEFAULT = null;

$a1778edf5fa0c0fb671dfa49596a0d70$var$Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = $a1778edf5fa0c0fb671dfa49596a0d70$var$Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('Wrong number of arguments for Schema.create function');
  }

  schemas = $e4705106f1abdb94c9e9554d63f12b0a$export$toArray(schemas);
  types = $e4705106f1abdb94c9e9554d63f12b0a$export$toArray(types);

  if (!schemas.every(function (schema) {
    return schema instanceof $a1778edf5fa0c0fb671dfa49596a0d70$var$Schema;
  })) {
    throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) {
    return type instanceof $d5c0c9d1c2801e774c431a84a7c32047$exports;
  })) {
    throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new $a1778edf5fa0c0fb671dfa49596a0d70$var$Schema({
    include: schemas,
    explicit: types
  });
};

$a1778edf5fa0c0fb671dfa49596a0d70$exports = $a1778edf5fa0c0fb671dfa49596a0d70$var$Schema;
// ASSET: node_modules/js-yaml/lib/js-yaml/schema/core.js
var $80d4564761aebebcfdf65f1c0a37f822$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/schema/json.js
var $d7a4ee3e19e56762b970af13eb705788$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var $eca98ca4dd00b0f463845e6f15fef8e0$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/type/str.js
var $e18fbf829f8e4c811aa1d7ebdfa82ca8$exports = {};
$e18fbf829f8e4c811aa1d7ebdfa82ca8$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) {
    return data !== null ? data : '';
  }
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/seq.js
var $8c2dfbd9a0e1b13a083edbe88db088d4$exports = {};
$8c2dfbd9a0e1b13a083edbe88db088d4$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) {
    return data !== null ? data : [];
  }
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/map.js
var $77ceac0117a3b3f4fd2391f26a642483$exports = {};
$77ceac0117a3b3f4fd2391f26a642483$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) {
    return data !== null ? data : {};
  }
});
$eca98ca4dd00b0f463845e6f15fef8e0$exports = new $a1778edf5fa0c0fb671dfa49596a0d70$exports({
  explicit: [$e18fbf829f8e4c811aa1d7ebdfa82ca8$exports, $8c2dfbd9a0e1b13a083edbe88db088d4$exports, $77ceac0117a3b3f4fd2391f26a642483$exports]
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/null.js
var $54770c0130fb28758b614b76b4f35e8d$exports = {};

function $54770c0130fb28758b614b76b4f35e8d$var$resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function $54770c0130fb28758b614b76b4f35e8d$var$constructYamlNull() {
  return null;
}

function $54770c0130fb28758b614b76b4f35e8d$var$isNull(object) {
  return object === null;
}

$54770c0130fb28758b614b76b4f35e8d$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: $54770c0130fb28758b614b76b4f35e8d$var$resolveYamlNull,
  construct: $54770c0130fb28758b614b76b4f35e8d$var$constructYamlNull,
  predicate: $54770c0130fb28758b614b76b4f35e8d$var$isNull,
  represent: {
    canonical: function () {
      return '~';
    },
    lowercase: function () {
      return 'null';
    },
    uppercase: function () {
      return 'NULL';
    },
    camelcase: function () {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/bool.js
var $252fdcb1c9353986a843164ffee7d602$exports = {};

function $252fdcb1c9353986a843164ffee7d602$var$resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function $252fdcb1c9353986a843164ffee7d602$var$constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function $252fdcb1c9353986a843164ffee7d602$var$isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

$252fdcb1c9353986a843164ffee7d602$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: $252fdcb1c9353986a843164ffee7d602$var$resolveYamlBoolean,
  construct: $252fdcb1c9353986a843164ffee7d602$var$constructYamlBoolean,
  predicate: $252fdcb1c9353986a843164ffee7d602$var$isBoolean,
  represent: {
    lowercase: function (object) {
      return object ? 'true' : 'false';
    },
    uppercase: function (object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function (object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/int.js
var $2afc22ce6e78833029bbacc84f516676$exports = {};

function $2afc22ce6e78833029bbacc84f516676$var$isHexCode(c) {
  return 0x30
  /* 0 */
  <=
  /* 0 */
  c && c <= 0x39
  /* 9 */
  ||
  /* 9 */
  0x41
  /* A */
  <=
  /* A */
  c && c <= 0x46
  /* F */
  ||
  /* F */
  0x61
  /* a */
  <=
  /* a */
  c && c <= 0x66
  /* f */
  ;
}

function $2afc22ce6e78833029bbacc84f516676$var$isOctCode(c) {
  return 0x30
  /* 0 */
  <=
  /* 0 */
  c && c <= 0x37
  /* 7 */
  ;
}

function $2afc22ce6e78833029bbacc84f516676$var$isDecCode(c) {
  return 0x30
  /* 0 */
  <=
  /* 0 */
  c && c <= 0x39
  /* 9 */
  ;
}

function $2afc22ce6e78833029bbacc84f516676$var$resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;
  if (!max) return false;
  ch = data[index]; // sign

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index]; // base 2, base 8, base 16

    // base 2, base 8, base 16
    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!$2afc22ce6e78833029bbacc84f516676$var$isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    } // base 8


    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!$2afc22ce6e78833029bbacc84f516676$var$isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }

    return hasDigits && ch !== '_';
  } // base 10 (except 0) or base 60
  // value should not start with `_`;


  // base 10 (except 0) or base 60
  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;

    if (!$2afc22ce6e78833029bbacc84f516676$var$isDecCode(data.charCodeAt(index))) {
      return false;
    }

    hasDigits = true;
  } // Should have digits and should not end with `_`


  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false; // if !base60 - done;

  // if !base60 - done;
  if (ch !== ':') return true; // base60 almost not used, no needs to optimize

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function $2afc22ce6e78833029bbacc84f516676$var$constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch,
      base,
      digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }

  return sign * parseInt(value, 10);
}

function $2afc22ce6e78833029bbacc84f516676$var$isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !$e4705106f1abdb94c9e9554d63f12b0a$export$isNegativeZero(object);
}

$2afc22ce6e78833029bbacc84f516676$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: $2afc22ce6e78833029bbacc84f516676$var$resolveYamlInteger,
  construct: $2afc22ce6e78833029bbacc84f516676$var$constructYamlInteger,
  predicate: $2afc22ce6e78833029bbacc84f516676$var$isInteger,
  represent: {
    binary: function (obj) {
      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
    },
    octal: function (obj) {
      return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
    },
    decimal: function (obj) {
      return obj.toString(10);
    },

    /* eslint-disable max-len */
    hexadecimal: function (obj) {
      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/float.js
var $6398f36014f9277546c26e854dfd036d$exports = {};
var $6398f36014f9277546c26e854dfd036d$var$YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + // .inf
'|[-+]?\\.(?:inf|Inf|INF)' + // .nan
'|\\.(?:nan|NaN|NAN))$');

function $6398f36014f9277546c26e854dfd036d$var$resolveYamlFloat(data) {
  if (data === null) return false;

  if (!$6398f36014f9277546c26e854dfd036d$var$YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function $6398f36014f9277546c26e854dfd036d$var$constructYamlFloat(data) {
  var value, sign, base, digits;
  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });
    value = 0.0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }

  return sign * parseFloat(value, 10);
}

var $6398f36014f9277546c26e854dfd036d$var$SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function $6398f36014f9277546c26e854dfd036d$var$representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';

      case 'uppercase':
        return '.NAN';

      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';

      case 'uppercase':
        return '.INF';

      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';

      case 'uppercase':
        return '-.INF';

      case 'camelcase':
        return '-.Inf';
    }
  } else if ($e4705106f1abdb94c9e9554d63f12b0a$export$isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack
  return $6398f36014f9277546c26e854dfd036d$var$SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function $6398f36014f9277546c26e854dfd036d$var$isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || $e4705106f1abdb94c9e9554d63f12b0a$export$isNegativeZero(object));
}

$6398f36014f9277546c26e854dfd036d$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: $6398f36014f9277546c26e854dfd036d$var$resolveYamlFloat,
  construct: $6398f36014f9277546c26e854dfd036d$var$constructYamlFloat,
  predicate: $6398f36014f9277546c26e854dfd036d$var$isFloat,
  represent: $6398f36014f9277546c26e854dfd036d$var$representYamlFloat,
  defaultStyle: 'lowercase'
});
$d7a4ee3e19e56762b970af13eb705788$exports = new $a1778edf5fa0c0fb671dfa49596a0d70$exports({
  include: [$eca98ca4dd00b0f463845e6f15fef8e0$exports],
  implicit: [$54770c0130fb28758b614b76b4f35e8d$exports, $252fdcb1c9353986a843164ffee7d602$exports, $2afc22ce6e78833029bbacc84f516676$exports, $6398f36014f9277546c26e854dfd036d$exports]
});
$80d4564761aebebcfdf65f1c0a37f822$exports = new $a1778edf5fa0c0fb671dfa49596a0d70$exports({
  include: [$d7a4ee3e19e56762b970af13eb705788$exports]
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var $5f03f898ccc04698a774fd7ded12de9d$exports = {};
var $5f03f898ccc04698a774fd7ded12de9d$var$YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day

// [3] day
var $5f03f898ccc04698a774fd7ded12de9d$var$YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

// [11] tz_minute
function $5f03f898ccc04698a774fd7ded12de9d$var$resolveYamlTimestamp(data) {
  if (data === null) return false;
  if ($5f03f898ccc04698a774fd7ded12de9d$var$YAML_DATE_REGEXP.exec(data) !== null) return true;
  if ($5f03f898ccc04698a774fd7ded12de9d$var$YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function $5f03f898ccc04698a774fd7ded12de9d$var$constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;
  match = $5f03f898ccc04698a774fd7ded12de9d$var$YAML_DATE_REGEXP.exec(data);
  if (match === null) match = $5f03f898ccc04698a774fd7ded12de9d$var$YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day

  // match: [1] year [2] month [3] day
  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0

  // JS month starts with 0
  day = +match[3];

  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  } // match: [4] hour [5] minute [6] second [7] fraction


  // match: [4] hour [5] minute [6] second [7] fraction
  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);

    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }

    fraction = +fraction;
  } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute


  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds

    // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}

function $5f03f898ccc04698a774fd7ded12de9d$var$representYamlTimestamp(object
/*, style*/
)
/*, style*/
{
  return object.toISOString();
}

$5f03f898ccc04698a774fd7ded12de9d$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: $5f03f898ccc04698a774fd7ded12de9d$var$resolveYamlTimestamp,
  construct: $5f03f898ccc04698a774fd7ded12de9d$var$constructYamlTimestamp,
  instanceOf: Date,
  represent: $5f03f898ccc04698a774fd7ded12de9d$var$representYamlTimestamp
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/merge.js
var $fd13b1b801761993f83a45a57261dd88$exports = {};

function $fd13b1b801761993f83a45a57261dd88$var$resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

$fd13b1b801761993f83a45a57261dd88$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: $fd13b1b801761993f83a45a57261dd88$var$resolveYamlMerge
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/binary.js
var $10ac03ca7a777a27417c938d923365f9$exports = {};

/*eslint-disable no-bitwise*/
var $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var $10ac03ca7a777a27417c938d923365f9$var$_require = require;
  $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer = $10ac03ca7a777a27417c938d923365f9$var$_require('buffer').Buffer;
} catch (__) {}

// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var $10ac03ca7a777a27417c938d923365f9$var$BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function $10ac03ca7a777a27417c938d923365f9$var$resolveYamlBinary(data) {
  if (data === null) return false;
  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = $10ac03ca7a777a27417c938d923365f9$var$BASE64_MAP; // Convert one by one.

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx)); // Skip CR/LF

    // Skip CR/LF
    if (code > 64) continue; // Fail on illegal characters

    // Fail on illegal characters
    if (code < 0) return false;
    bitlen += 6;
  } // If there are any bits left, source was corrupted


  // If there are any bits left, source was corrupted
  return bitlen % 8 === 0;
}

function $10ac03ca7a777a27417c938d923365f9$var$constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      // remove CR/LF & padding to simplify scan
  max = input.length,
      map = $10ac03ca7a777a27417c938d923365f9$var$BASE64_MAP,
      bits = 0,
      result = []; // Collect by 6*4 bits (3 bytes)

  // Collect by 6*4 bits (3 bytes)
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  } // Dump tail


  // Dump tail
  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  } // Wrap into Buffer for NodeJS and leave Array for browser


  // Wrap into Buffer for NodeJS and leave Array for browser
  if ($10ac03ca7a777a27417c938d923365f9$var$NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer.from ? $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer.from(result) : new $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer(result);
  }

  return result;
}

function $10ac03ca7a777a27417c938d923365f9$var$representYamlBinary(object
/*, style*/
)
/*, style*/
{
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = $10ac03ca7a777a27417c938d923365f9$var$BASE64_MAP; // Convert every three bytes to 4 ASCII characters.

  // Convert every three bytes to 4 ASCII characters.
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  } // Dump tail


  // Dump tail
  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function $10ac03ca7a777a27417c938d923365f9$var$isBinary(object) {
  return $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer && $10ac03ca7a777a27417c938d923365f9$var$NodeBuffer.isBuffer(object);
}

$10ac03ca7a777a27417c938d923365f9$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: $10ac03ca7a777a27417c938d923365f9$var$resolveYamlBinary,
  construct: $10ac03ca7a777a27417c938d923365f9$var$constructYamlBinary,
  predicate: $10ac03ca7a777a27417c938d923365f9$var$isBinary,
  represent: $10ac03ca7a777a27417c938d923365f9$var$representYamlBinary
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/omap.js
var $9ccd21de91244f6c5d2eab66d302da20$exports = {};
var $9ccd21de91244f6c5d2eab66d302da20$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $9ccd21de91244f6c5d2eab66d302da20$var$_toString = Object.prototype.toString;

function $9ccd21de91244f6c5d2eab66d302da20$var$resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if ($9ccd21de91244f6c5d2eab66d302da20$var$_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if ($9ccd21de91244f6c5d2eab66d302da20$var$_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function $9ccd21de91244f6c5d2eab66d302da20$var$constructYamlOmap(data) {
  return data !== null ? data : [];
}

$9ccd21de91244f6c5d2eab66d302da20$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: $9ccd21de91244f6c5d2eab66d302da20$var$resolveYamlOmap,
  construct: $9ccd21de91244f6c5d2eab66d302da20$var$constructYamlOmap
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/pairs.js
var $85317b851cf74a4cb65b88215827739c$exports = {};
var $85317b851cf74a4cb65b88215827739c$var$_toString = Object.prototype.toString;

function $85317b851cf74a4cb65b88215827739c$var$resolveYamlPairs(data) {
  if (data === null) return true;
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if ($85317b851cf74a4cb65b88215827739c$var$_toString.call(pair) !== '[object Object]') return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function $85317b851cf74a4cb65b88215827739c$var$constructYamlPairs(data) {
  if (data === null) return [];
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

$85317b851cf74a4cb65b88215827739c$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: $85317b851cf74a4cb65b88215827739c$var$resolveYamlPairs,
  construct: $85317b851cf74a4cb65b88215827739c$var$constructYamlPairs
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/set.js
var $44c83e402875f139d6a3967bd1a75616$exports = {};
var $44c83e402875f139d6a3967bd1a75616$var$_hasOwnProperty = Object.prototype.hasOwnProperty;

function $44c83e402875f139d6a3967bd1a75616$var$resolveYamlSet(data) {
  if (data === null) return true;
  var key,
      object = data;

  for (key in object) {
    if ($44c83e402875f139d6a3967bd1a75616$var$_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function $44c83e402875f139d6a3967bd1a75616$var$constructYamlSet(data) {
  return data !== null ? data : {};
}

$44c83e402875f139d6a3967bd1a75616$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: $44c83e402875f139d6a3967bd1a75616$var$resolveYamlSet,
  construct: $44c83e402875f139d6a3967bd1a75616$var$constructYamlSet
});
$3defc228960dbdbcf6a2a4a7bb913540$exports = new $a1778edf5fa0c0fb671dfa49596a0d70$exports({
  include: [$80d4564761aebebcfdf65f1c0a37f822$exports],
  implicit: [$5f03f898ccc04698a774fd7ded12de9d$exports, $fd13b1b801761993f83a45a57261dd88$exports],
  explicit: [$10ac03ca7a777a27417c938d923365f9$exports, $9ccd21de91244f6c5d2eab66d302da20$exports, $85317b851cf74a4cb65b88215827739c$exports, $44c83e402875f139d6a3967bd1a75616$exports]
});
// ASSET: node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var $bcbcbd67bb21b2caa70bbdbfd1a8af91$exports = {};
// ASSET: node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var $f895392b5c1d1542c717897ea896d8ae$exports = {};

function $f895392b5c1d1542c717897ea896d8ae$var$resolveJavascriptUndefined() {
  return true;
}

function $f895392b5c1d1542c717897ea896d8ae$var$constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function $f895392b5c1d1542c717897ea896d8ae$var$representJavascriptUndefined() {
  return '';
}

function $f895392b5c1d1542c717897ea896d8ae$var$isUndefined(object) {
  return typeof object === 'undefined';
}

$f895392b5c1d1542c717897ea896d8ae$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: $f895392b5c1d1542c717897ea896d8ae$var$resolveJavascriptUndefined,
  construct: $f895392b5c1d1542c717897ea896d8ae$var$constructJavascriptUndefined,
  predicate: $f895392b5c1d1542c717897ea896d8ae$var$isUndefined,
  represent: $f895392b5c1d1542c717897ea896d8ae$var$representJavascriptUndefined
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var $61f210d9998d443628e2b228808b7c8a$exports = {};

function $61f210d9998d443628e2b228808b7c8a$var$resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated

    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function $61f210d9998d443628e2b228808b7c8a$var$constructJavascriptRegExp(data) {
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function $61f210d9998d443628e2b228808b7c8a$var$representJavascriptRegExp(object
/*, style*/
)
/*, style*/
{
  var result = '/' + object.source + '/';
  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';
  return result;
}

function $61f210d9998d443628e2b228808b7c8a$var$isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

$61f210d9998d443628e2b228808b7c8a$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: $61f210d9998d443628e2b228808b7c8a$var$resolveJavascriptRegExp,
  construct: $61f210d9998d443628e2b228808b7c8a$var$constructJavascriptRegExp,
  predicate: $61f210d9998d443628e2b228808b7c8a$var$isRegExp,
  represent: $61f210d9998d443628e2b228808b7c8a$var$representJavascriptRegExp
});
// ASSET: node_modules/js-yaml/lib/js-yaml/type/js/function.js
var $ccc86b0a1e520c2d2071b895d9f092b8$exports = {};
var $ccc86b0a1e520c2d2071b895d9f092b8$var$esprima; // Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var $ccc86b0a1e520c2d2071b895d9f092b8$var$_require = require;
  $ccc86b0a1e520c2d2071b895d9f092b8$var$esprima = $ccc86b0a1e520c2d2071b895d9f092b8$var$_require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */

  /* global window */
  if (typeof window !== 'undefined') $ccc86b0a1e520c2d2071b895d9f092b8$var$esprima = window.esprima;
}

function $ccc86b0a1e520c2d2071b895d9f092b8$var$resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast = $ccc86b0a1e520c2d2071b895d9f092b8$var$esprima.parse(source, {
      range: true
    });

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function $ccc86b0a1e520c2d2071b895d9f092b8$var$constructJavascriptFunction(data) {
  /*jslint evil:true*/
  var source = '(' + data + ')',
      ast = $ccc86b0a1e520c2d2071b895d9f092b8$var$esprima.parse(source, {
    range: true
  }),
      params = [],
      body;

  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });
  body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  } // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.

  /*eslint-disable no-new-func*/


  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.

  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function $ccc86b0a1e520c2d2071b895d9f092b8$var$representJavascriptFunction(object
/*, style*/
)
/*, style*/
{
  return object.toString();
}

function $ccc86b0a1e520c2d2071b895d9f092b8$var$isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

$ccc86b0a1e520c2d2071b895d9f092b8$exports = new $d5c0c9d1c2801e774c431a84a7c32047$exports('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: $ccc86b0a1e520c2d2071b895d9f092b8$var$resolveJavascriptFunction,
  construct: $ccc86b0a1e520c2d2071b895d9f092b8$var$constructJavascriptFunction,
  predicate: $ccc86b0a1e520c2d2071b895d9f092b8$var$isFunction,
  represent: $ccc86b0a1e520c2d2071b895d9f092b8$var$representJavascriptFunction
});
$bcbcbd67bb21b2caa70bbdbfd1a8af91$exports = $a1778edf5fa0c0fb671dfa49596a0d70$exports.DEFAULT = new $a1778edf5fa0c0fb671dfa49596a0d70$exports({
  include: [$3defc228960dbdbcf6a2a4a7bb913540$exports],
  explicit: [$f895392b5c1d1542c717897ea896d8ae$exports, $61f210d9998d443628e2b228808b7c8a$exports, $ccc86b0a1e520c2d2071b895d9f092b8$exports]
});
var $fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_IN = 1;
var $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_OUT = 2;
var $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_IN = 3;
var $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_OUT = 4;
var $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_CLIP = 1;
var $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_STRIP = 2;
var $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_KEEP = 3;
var $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function $fc0be4e9eb3049c97ae86677931f4875$var$_class(obj) {
  return Object.prototype.toString.call(obj);
}

function $fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(c) {
  return c === 0x0A
  /* LF */
  ||
  /* LF */
  c === 0x0D
  /* CR */
  ;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(c) {
  return c === 0x09
  /* Tab */
  ||
  /* Tab */
  c === 0x20
  /* Space */
  ;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(c) {
  return c === 0x09
  /* Tab */
  ||
  /* Tab */
  c === 0x20
  /* Space */
  || c === 0x0A
  /* LF */
  || c === 0x0D
  /* CR */
  ;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(c) {
  return c === 0x2C
  /* , */
  ||
  /* , */
  c === 0x5B
  /* [ */
  ||
  /* [ */
  c === 0x5D
  /* ] */
  ||
  /* ] */
  c === 0x7B
  /* { */
  ||
  /* { */
  c === 0x7D
  /* } */
  ;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$fromHexCode(c) {
  var lc;

  if (0x30
  /* 0 */
  <=
  /* 0 */
  c && c <= 0x39
  /* 9 */
  ) {
    return c - 0x30;
  }
  /*eslint-disable no-bitwise*/


  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if (0x61
  /* a */
  <=
  /* a */
  lc && lc <= 0x66
  /* f */
  ) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$escapedHexLen(c) {
  if (c === 0x78
  /* x */
  )
    /* x */
    {
      return 2;
    }

  if (c === 0x75
  /* u */
  )
    /* u */
    {
      return 4;
    }

  if (c === 0x55
  /* U */
  )
    /* U */
    {
      return 8;
    }

  return 0;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$fromDecimalCode(c) {
  if (0x30
  /* 0 */
  <=
  /* 0 */
  c && c <= 0x39
  /* 9 */
  ) {
    return c - 0x30;
  }

  return -1;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30
  /* 0 */
  ?
  /* 0 */
  '\x00' : c === 0x61
  /* a */
  ?
  /* a */
  '\x07' : c === 0x62
  /* b */
  ?
  /* b */
  '\x08' : c === 0x74
  /* t */
  ?
  /* t */
  '\x09' : c === 0x09
  /* Tab */
  ?
  /* Tab */
  '\x09' : c === 0x6E
  /* n */
  ?
  /* n */
  '\x0A' : c === 0x76
  /* v */
  ?
  /* v */
  '\x0B' : c === 0x66
  /* f */
  ?
  /* f */
  '\x0C' : c === 0x72
  /* r */
  ?
  /* r */
  '\x0D' : c === 0x65
  /* e */
  ?
  /* e */
  '\x1B' : c === 0x20
  /* Space */
  ?
  /* Space */
  ' ' : c === 0x22
  /* " */
  ?
  /* " */
  '\x22' : c === 0x2F
  /* / */
  ?
  /* / */
  '/' : c === 0x5C
  /* \ */
  ?
  /* \ */
  '\x5C' : c === 0x4E
  /* N */
  ?
  /* N */
  '\x85' : c === 0x5F
  /* _ */
  ?
  /* _ */
  '\xA0' : c === 0x4C
  /* L */
  ?
  /* L */
  '\u2028' : c === 0x50
  /* P */
  ?
  /* P */
  '\u2029' : '';
}

function $fc0be4e9eb3049c97ae86677931f4875$var$charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  } // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF


  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeCheck = new Array(256); // integer, for fast access

// integer, for fast access
var $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeMap = new Array(256);

for (var $fc0be4e9eb3049c97ae86677931f4875$var$i = 0; $fc0be4e9eb3049c97ae86677931f4875$var$i < 256; $fc0be4e9eb3049c97ae86677931f4875$var$i++) {
  $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeCheck[$fc0be4e9eb3049c97ae86677931f4875$var$i] = $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeSequence($fc0be4e9eb3049c97ae86677931f4875$var$i) ? 1 : 0;
  $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeMap[$fc0be4e9eb3049c97ae86677931f4875$var$i] = $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeSequence($fc0be4e9eb3049c97ae86677931f4875$var$i);
}

function $fc0be4e9eb3049c97ae86677931f4875$var$State(input, options) {
  this.input = input;
  this.filename = options['filename'] || null;
  this.schema = options['schema'] || $bcbcbd67bb21b2caa70bbdbfd1a8af91$exports;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function $fc0be4e9eb3049c97ae86677931f4875$var$generateError(state, message) {
  return new $a4131730fdea0a83c53cfcac61bc86fe$exports(message, new $931182cfb8ced117155b4bf370c8b7e8$exports(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}

function $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, message) {
  throw $fc0be4e9eb3049c97ae86677931f4875$var$generateError(state, message);
}

function $fc0be4e9eb3049c97ae86677931f4875$var$throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, $fc0be4e9eb3049c97ae86677931f4875$var$generateError(state, message));
  }
}

var $fc0be4e9eb3049c97ae86677931f4875$var$directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;

    if (state.version !== null) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwWarning(state, 'unsupported YAML version of the document');
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;

    if (args.length !== 2) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!$fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_HANDLE.test(handle)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if ($fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(state.tagMap, handle)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!$fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_URI.test(prefix)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};

function $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);

        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'expected valid JSON character');
        }
      }
    } else if ($fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_NON_PRINTABLE.test(_result)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function $fc0be4e9eb3049c97ae86677931f4875$var$mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!$e4705106f1abdb94c9e9554d63f12b0a$export$isObject(source)) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!$fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity; // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && $fc0be4e9eb3049c97ae86677931f4875$var$_class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  } // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)


  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && $fc0be4e9eb3049c97ae86677931f4875$var$_class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        $fc0be4e9eb3049c97ae86677931f4875$var$mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      $fc0be4e9eb3049c97ae86677931f4875$var$mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !$fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(overridableKeys, keyNode) && $fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'duplicated mapping key');
    }

    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A
  /* LF */
  )
    /* LF */
    {
      state.position++;
    } else if (ch === 0x0D
  /* CR */
  )
    /* CR */
    {
      state.position++;

      if (state.input.charCodeAt(state.position) === 0x0A
      /* LF */
      )
        /* LF */
        {
          state.position++;
        }
    } else {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23
    /* # */
    )
      /* # */
      {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A
        /* LF */
        &&
        /* LF */
        ch !== 0x0D
        /* CR */
        &&
        /* CR */
        ch !== 0);
      }

    if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20
      /* Space */
      )
      /* Space */
      {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$testDocumentSeparator(state) {
  var _position = state.position,
      ch;
  ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D
  /* - */
  ||
  /* - */
  ch === 0x2E
  /* . */
  ) &&
  /* . */
  ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);

    if (ch === 0 || $fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', count - 1);
  }
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch) || $fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(ch) || ch === 0x23
  /* # */
  ||
  /* # */
  ch === 0x26
  /* & */
  ||
  /* & */
  ch === 0x2A
  /* * */
  ||
  /* * */
  ch === 0x21
  /* ! */
  ||
  /* ! */
  ch === 0x7C
  /* | */
  ||
  /* | */
  ch === 0x3E
  /* > */
  ||
  /* > */
  ch === 0x27
  /* ' */
  ||
  /* ' */
  ch === 0x22
  /* " */
  ||
  /* " */
  ch === 0x25
  /* % */
  ||
  /* % */
  ch === 0x40
  /* @ */
  ||
  /* @ */
  ch === 0x60
  /* ` */
  )
    /* ` */
    {
      return false;
    }

  if (ch === 0x3F
  /* ? */
  ||
  /* ? */
  ch === 0x2D
  /* - */
  )
    /* - */
    {
      following = state.input.charCodeAt(state.position + 1);

      if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(following) || withinFlowCollection && $fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A
    /* : */
    )
      /* : */
      {
        following = state.input.charCodeAt(state.position + 1);

        if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(following) || withinFlowCollection && $fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23
    /* # */
    )
      /* # */
      {
        preceding = state.input.charCodeAt(state.position - 1);

        if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && $fc0be4e9eb3049c97ae86677931f4875$var$testDocumentSeparator(state) || withinFlowCollection && $fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(ch)) {
      break;
    } else if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, captureEnd, false);
      $fc0be4e9eb3049c97ae86677931f4875$var$writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!$fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27
  /* ' */
  )
    /* ' */
    {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27
    /* ' */
    )
      /* ' */
      {
        $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27
        /* ' */
        )
          /* ' */
          {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, captureEnd, true);
      $fc0be4e9eb3049c97ae86677931f4875$var$writeFoldedLines(state, $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && $fc0be4e9eb3049c97ae86677931f4875$var$testDocumentSeparator(state)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22
  /* " */
  )
    /* " */
    {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22
    /* " */
    )
      /* " */
      {
        $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C
    /* \ */
    )
      /* \ */
      {
        $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
          $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeCheck[ch]) {
          state.result += $fc0be4e9eb3049c97ae86677931f4875$var$simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = $fc0be4e9eb3049c97ae86677931f4875$var$escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = $fc0be4e9eb3049c97ae86677931f4875$var$fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += $fc0be4e9eb3049c97ae86677931f4875$var$charFromCodepoint(hexResult);
          state.position++;
        } else {
          $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, captureEnd, true);
      $fc0be4e9eb3049c97ae86677931f4875$var$writeFoldedLines(state, $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && $fc0be4e9eb3049c97ae86677931f4875$var$testDocumentSeparator(state)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B
  /* [ */
  )
    /* [ */
    {
      terminator = 0x5D;
      /* ] */

      /* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B
  /* { */
  )
    /* { */
    {
      terminator = 0x7D;
      /* } */

      /* } */
      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F
    /* ? */
    )
      /* ? */
      {
        following = state.input.charCodeAt(state.position + 1);

        if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    $fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, nodeIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A
    /* : */
    )
      /* : */
      {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, nodeIndent);
        $fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, nodeIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push($fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C
    /* , */
    )
      /* , */
      {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the stream within a flow collection');
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C
  /* | */
  )
    /* | */
    {
      folding = false;
    } else if (ch === 0x3E
  /* > */
  )
    /* > */
    {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B
    /* + */
    ||
    /* + */
    ch === 0x2D
    /* - */
    )
      /* - */
      {
        if ($fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B
          /* + */
          ?
          /* + */
          $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_KEEP : $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_STRIP;
        } else {
          $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = $fc0be4e9eb3049c97ae86677931f4875$var$fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch));

    if (ch === 0x23
    /* # */
    )
      /* # */
      {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!$fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    $fc0be4e9eb3049c97ae86677931f4875$var$readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20
    /* Space */
    ) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) {
      emptyLines++;
      continue;
    } // End of the scalar.


    // End of the scalar.
    if (state.lineIndent < textIndent) {
      // Perform the chomping.
      if (chomping === $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_KEEP) {
        state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === $fc0be4e9eb3049c97ae86677931f4875$var$CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      } // Break this `while` cycle and go to the funciton's epilogue.


      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    } // Folded style: use fancy rules to handle line breaks.


    // Folded style: use fancy rules to handle line breaks.
    if (folding) {
      // Lines starting with white space characters (more-indented lines) are not folded.
      if ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
        atMoreIndented = true; // except for the first content line (cf. Example 8.1)

        // except for the first content line (cf. Example 8.1)
        state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', emptyLines + 1); // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        } // Several line breaks - perceive as different lines.

      } else {
        state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', emptyLines);
      } // Literal style: just add exact number of line breaks between content lines.

    } else {
      // Keep all line breaks except the header line break.
      state.result += $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!$fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    $fc0be4e9eb3049c97ae86677931f4875$var$captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (ch !== 0x2D
    /* - */
    )
      /* - */
      {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if ($fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);

        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    $fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, nodeIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_IN, false, true);

    _result.push(state.result);

    $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }

  return false;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = {},
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    // Save the current line.
    _pos = state.position; //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F
    /* ? */
    ||
    /* ? */
    ch === 0x3A
    /* : */
    ) &&
    /* : */
    $fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(following)) {
      if (ch === 0x3F
      /* ? */
      )
        /* ? */
        {
          if (atExplicitKey) {
            $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following; //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if ($fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, flowIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A
        /* : */
        )
          /* : */
          {
            ch = state.input.charCodeAt(++state.position);

            if (!$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch)) {
              $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else // Keep the result of `composeNode`.
      {
        break; // Reading is done. Go to the epilogue.
      } //
    // Common reading code for both explicit and implicit notations.
    //


    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if ($fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, nodeIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && ch !== 0) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  } //
  // Epilogue.
  //
  // Special case: last mapping's node contains only the key in explicit notation.


  //
  // Epilogue.
  //
  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    $fc0be4e9eb3049c97ae86677931f4875$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  } // Expose the resulting mapping.


  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x21
  /* ! */
  )
    /* ! */
    return false;

  if (state.tag !== null) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C
  /* < */
  )
    /* < */
    {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21
  /* ! */
  )
    /* ! */
    {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E
    /* > */
    );

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch)) {
      if (ch === 0x21
      /* ! */
      )
        /* ! */
        {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!$fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_HANDLE.test(tagHandle)) {
              $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if ($fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_FLOW_INDICATORS.test(tagName)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !$fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_TAG_URI.test(tagName)) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if ($fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x26
  /* & */
  )
    /* & */
    return false;

  if (state.anchor !== null) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch) && !$fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x2A
  /* * */
  )
    /* * */
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch) && !$fc0be4e9eb3049c97ae86677931f4875$var$is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!$fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(state.anchorMap, alias)) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
  return true;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      // 1: this>parent, 0: this=parent, -1: this<parent
  atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_OUT === nodeContext || $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if ($fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while ($fc0be4e9eb3049c97ae86677931f4875$var$readTagProperty(state) || $fc0be4e9eb3049c97ae86677931f4875$var$readAnchorProperty(state)) {
      if ($fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_OUT === nodeContext) {
    if ($fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_IN === nodeContext || $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && ($fc0be4e9eb3049c97ae86677931f4875$var$readBlockSequence(state, blockIndent) || $fc0be4e9eb3049c97ae86677931f4875$var$readBlockMapping(state, blockIndent, flowIndent)) || $fc0be4e9eb3049c97ae86677931f4875$var$readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && $fc0be4e9eb3049c97ae86677931f4875$var$readBlockScalar(state, flowIndent) || $fc0be4e9eb3049c97ae86677931f4875$var$readSingleQuotedScalar(state, flowIndent) || $fc0be4e9eb3049c97ae86677931f4875$var$readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if ($fc0be4e9eb3049c97ae86677931f4875$var$readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'alias node should not have any properties');
          }
        } else if ($fc0be4e9eb3049c97ae86677931f4875$var$readPlainScalar(state, flowIndent, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && $fc0be4e9eb3049c97ae86677931f4875$var$readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }

          break;
        }
      }
    } else if ($fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }

  return state.tag !== null || state.anchor !== null || hasContent;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25
    /* % */
    )
      /* % */
      {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while ($fc0be4e9eb3049c97ae86677931f4875$var$is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23
      /* # */
      )
        /* # */
        {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch));

          break;
        }

      if ($fc0be4e9eb3049c97ae86677931f4875$var$is_EOL(ch)) break;
      _position = state.position;

      while (ch !== 0 && !$fc0be4e9eb3049c97ae86677931f4875$var$is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) $fc0be4e9eb3049c97ae86677931f4875$var$readLineBreak(state);

    if ($fc0be4e9eb3049c97ae86677931f4875$var$_hasOwnProperty.call($fc0be4e9eb3049c97ae86677931f4875$var$directiveHandlers, directiveName)) {
      $fc0be4e9eb3049c97ae86677931f4875$var$directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      $fc0be4e9eb3049c97ae86677931f4875$var$throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D
  /* - */
  &&
  /* - */
  state.input.charCodeAt(state.position + 1) === 0x2D
  /* - */
  &&
  /* - */
  state.input.charCodeAt(state.position + 2) === 0x2D
  /* - */
  )
    /* - */
    {
      state.position += 3;
      $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'directives end mark is expected');
  }

  $fc0be4e9eb3049c97ae86677931f4875$var$composeNode(state, state.lineIndent - 1, $fc0be4e9eb3049c97ae86677931f4875$var$CONTEXT_BLOCK_OUT, false, true);
  $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && $fc0be4e9eb3049c97ae86677931f4875$var$PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && $fc0be4e9eb3049c97ae86677931f4875$var$testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 0x2E
    /* . */
    )
      /* . */
      {
        state.position += 3;
        $fc0be4e9eb3049c97ae86677931f4875$var$skipSeparationSpace(state, true, -1);
      }

    return;
  }

  if (state.position < state.length - 1) {
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function $fc0be4e9eb3049c97ae86677931f4875$var$loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {
    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A
    /* LF */
    &&
    /* LF */
    input.charCodeAt(input.length - 1) !== 0x0D
    /* CR */
    )
      /* CR */
      {
        input += '\n';
      } // Strip BOM


    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new $fc0be4e9eb3049c97ae86677931f4875$var$State(input, options);
  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    $fc0be4e9eb3049c97ae86677931f4875$var$throwError(state, 'null byte is not allowed in input');
  } // Use 0 as string terminator. That significantly simplifies bounds check.


  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20
  /* Space */
  )
  /* Space */
  {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    $fc0be4e9eb3049c97ae86677931f4875$var$readDocument(state);
  }

  return state.documents;
}

function $fc0be4e9eb3049c97ae86677931f4875$var$loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = $fc0be4e9eb3049c97ae86677931f4875$var$loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function $fc0be4e9eb3049c97ae86677931f4875$var$load(input, options) {
  var documents = $fc0be4e9eb3049c97ae86677931f4875$var$loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }

  throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('expected a single document in the stream, but found more');
}

function $fc0be4e9eb3049c97ae86677931f4875$var$safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return $fc0be4e9eb3049c97ae86677931f4875$var$loadAll(input, iterator, $e4705106f1abdb94c9e9554d63f12b0a$export$extend({
    schema: $3defc228960dbdbcf6a2a4a7bb913540$exports
  }, options));
}

function $fc0be4e9eb3049c97ae86677931f4875$var$safeLoad(input, options) {
  return $fc0be4e9eb3049c97ae86677931f4875$var$load(input, $e4705106f1abdb94c9e9554d63f12b0a$export$extend({
    schema: $3defc228960dbdbcf6a2a4a7bb913540$exports
  }, options));
}

var $fc0be4e9eb3049c97ae86677931f4875$export$loadAll = $fc0be4e9eb3049c97ae86677931f4875$var$loadAll;
var $fc0be4e9eb3049c97ae86677931f4875$export$load = $fc0be4e9eb3049c97ae86677931f4875$var$load;
var $fc0be4e9eb3049c97ae86677931f4875$export$safeLoadAll = $fc0be4e9eb3049c97ae86677931f4875$var$safeLoadAll;
var $fc0be4e9eb3049c97ae86677931f4875$export$safeLoad = $fc0be4e9eb3049c97ae86677931f4875$var$safeLoad;
var $8117a301f45a2d4357cff31509d8e567$var$_toString = Object.prototype.toString;
var $8117a301f45a2d4357cff31509d8e567$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_TAB = 0x09;
/* Tab */

/* Tab */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED = 0x0A;
/* LF */

/* LF */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_CARRIAGE_RETURN = 0x0D;
/* CR */

/* CR */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_SPACE = 0x20;
/* Space */

/* Space */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_EXCLAMATION = 0x21;
/* ! */

/* ! */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_DOUBLE_QUOTE = 0x22;
/* " */

/* " */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_SHARP = 0x23;
/* # */

/* # */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_PERCENT = 0x25;
/* % */

/* % */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_AMPERSAND = 0x26;
/* & */

/* & */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_SINGLE_QUOTE = 0x27;
/* ' */

/* ' */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_ASTERISK = 0x2A;
/* * */

/* * */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_COMMA = 0x2C;
/* , */

/* , */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_MINUS = 0x2D;
/* - */

/* - */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_COLON = 0x3A;
/* : */

/* : */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_EQUALS = 0x3D;
/* = */

/* = */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_GREATER_THAN = 0x3E;
/* > */

/* > */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_QUESTION = 0x3F;
/* ? */

/* ? */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_COMMERCIAL_AT = 0x40;
/* @ */

/* @ */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_SQUARE_BRACKET = 0x5B;
/* [ */

/* [ */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
/* ] */

/* ] */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_GRAVE_ACCENT = 0x60;
/* ` */

/* ` */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_CURLY_BRACKET = 0x7B;
/* { */

/* { */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_VERTICAL_LINE = 0x7C;
/* | */

/* | */
var $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_CURLY_BRACKET = 0x7D;
/* } */

/* } */
var $8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES = {};
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x00] = '\\0';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x07] = '\\a';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x08] = '\\b';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x09] = '\\t';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x0A] = '\\n';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x0B] = '\\v';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x0C] = '\\f';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x0D] = '\\r';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x1B] = '\\e';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x22] = '\\"';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x5C] = '\\\\';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x85] = '\\N';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0xA0] = '\\_';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x2028] = '\\L';
$8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[0x2029] = '\\P';
var $8117a301f45a2d4357cff31509d8e567$var$DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

function $8117a301f45a2d4357cff31509d8e567$var$compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;
  if (map === null) return {};
  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap['fallback'][tag];

    if (type && $8117a301f45a2d4357cff31509d8e567$var$_hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function $8117a301f45a2d4357cff31509d8e567$var$encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + $e4705106f1abdb94c9e9554d63f12b0a$export$repeat('0', length - string.length) + string;
}

function $8117a301f45a2d4357cff31509d8e567$var$State(options) {
  this.schema = options['schema'] || $bcbcbd67bb21b2caa70bbdbfd1a8af91$exports;
  this.indent = Math.max(1, options['indent'] || 2);
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = $e4705106f1abdb94c9e9554d63f12b0a$export$isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = $8117a301f45a2d4357cff31509d8e567$var$compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = '';
  this.duplicates = [];
  this.usedDuplicates = null;
} // Indents every line in a string. Empty lines (\n only) are not indented.


// Indents every line in a string. Empty lines (\n only) are not indented.
function $8117a301f45a2d4357cff31509d8e567$var$indentString(string, spaces) {
  var ind = $e4705106f1abdb94c9e9554d63f12b0a$export$repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);

    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;
    result += line;
  }

  return result;
}

function $8117a301f45a2d4357cff31509d8e567$var$generateNextLine(state, level) {
  return '\n' + $e4705106f1abdb94c9e9554d63f12b0a$export$repeat(' ', state.indent * level);
}

function $8117a301f45a2d4357cff31509d8e567$var$testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
} // [33] s-white ::= s-space | s-tab


// [33] s-white ::= s-space | s-tab
function $8117a301f45a2d4357cff31509d8e567$var$isWhitespace(c) {
  return c === $8117a301f45a2d4357cff31509d8e567$var$CHAR_SPACE || c === $8117a301f45a2d4357cff31509d8e567$var$CHAR_TAB;
} // Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.


// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function $8117a301f45a2d4357cff31509d8e567$var$isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF
  /* BOM */
  || 0x10000 <= c && c <= 0x10FFFF;
} // [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF


// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function $8117a301f45a2d4357cff31509d8e567$var$isNsChar(c) {
  return $8117a301f45a2d4357cff31509d8e567$var$isPrintable(c) && !$8117a301f45a2d4357cff31509d8e567$var$isWhitespace(c) // byte-order-mark
  && // byte-order-mark
  c !== 0xFEFF // b-char
  && // b-char
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_CARRIAGE_RETURN && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED;
} // Simplified test for values allowed after the first character in plain style.


// Simplified test for values allowed after the first character in plain style.
function $8117a301f45a2d4357cff31509d8e567$var$isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return $8117a301f45a2d4357cff31509d8e567$var$isPrintable(c) && c !== 0xFEFF // - c-flow-indicator
  && // - c-flow-indicator
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_COMMA && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_SQUARE_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_CURLY_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_CURLY_BRACKET // - ":" - "#"
  // /* An ns-char preceding */ "#"
  && // - ":" - "#"
  // /* An ns-char preceding */ "#"
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_COLON && (c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_SHARP || prev && $8117a301f45a2d4357cff31509d8e567$var$isNsChar(prev));
} // Simplified test for values allowed as the first character in plain style.


// Simplified test for values allowed as the first character in plain style.
function $8117a301f45a2d4357cff31509d8e567$var$isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return $8117a301f45a2d4357cff31509d8e567$var$isPrintable(c) && c !== 0xFEFF && !$8117a301f45a2d4357cff31509d8e567$var$isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // - | ? | : | , | [ | ] | { | }
  && // - s-white
  // - (c-indicator ::=
  // - | ? | : | , | [ | ] | { | }
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_MINUS && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_QUESTION && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_COLON && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_COMMA && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_SQUARE_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_LEFT_CURLY_BRACKET && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_RIGHT_CURLY_BRACKET // | # | & | * | ! | | | = | > | ' | "
  && // | # | & | * | ! | | | = | > | ' | "
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_SHARP && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_AMPERSAND && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_ASTERISK && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_EXCLAMATION && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_VERTICAL_LINE && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_EQUALS && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_GREATER_THAN && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_SINGLE_QUOTE && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_DOUBLE_QUOTE // | % | @ | `)
  && // | % | @ | `)
  c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_PERCENT && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_COMMERCIAL_AT && c !== $8117a301f45a2d4357cff31509d8e567$var$CHAR_GRAVE_ACCENT;
} // Determines whether block indentation indicator is required.


// Determines whether block indentation indicator is required.
function $8117a301f45a2d4357cff31509d8e567$var$needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var $8117a301f45a2d4357cff31509d8e567$var$STYLE_PLAIN = 1,
    $8117a301f45a2d4357cff31509d8e567$var$STYLE_SINGLE = 2,
    $8117a301f45a2d4357cff31509d8e567$var$STYLE_LITERAL = 3,
    $8117a301f45a2d4357cff31509d8e567$var$STYLE_FOLDED = 4,
    $8117a301f45a2d4357cff31509d8e567$var$STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function $8117a301f45a2d4357cff31509d8e567$var$chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth

  // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly

  // count the first line correctly
  var plain = $8117a301f45a2d4357cff31509d8e567$var$isPlainSafeFirst(string.charCodeAt(0)) && !$8117a301f45a2d4357cff31509d8e567$var$isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);

      if (!$8117a301f45a2d4357cff31509d8e567$var$isPrintable(char)) {
        return $8117a301f45a2d4357cff31509d8e567$var$STYLE_DOUBLE;
      }

      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && $8117a301f45a2d4357cff31509d8e567$var$isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);

      if (char === $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED) {
        hasLineBreak = true; // Check if any line can be folded.

        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!$8117a301f45a2d4357cff31509d8e567$var$isPrintable(char)) {
        return $8117a301f45a2d4357cff31509d8e567$var$STYLE_DOUBLE;
      }

      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && $8117a301f45a2d4357cff31509d8e567$var$isPlainSafe(char, prev_char);
    } // in case the end is missing a \n


    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  } // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.


  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? $8117a301f45a2d4357cff31509d8e567$var$STYLE_PLAIN : $8117a301f45a2d4357cff31509d8e567$var$STYLE_SINGLE;
  } // Edge case: block indentation indicator can only have one digit.


  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && $8117a301f45a2d4357cff31509d8e567$var$needIndentIndicator(string)) {
    return $8117a301f45a2d4357cff31509d8e567$var$STYLE_DOUBLE;
  } // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.


  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? $8117a301f45a2d4357cff31509d8e567$var$STYLE_FOLDED : $8117a301f45a2d4357cff31509d8e567$var$STYLE_LITERAL;
} // Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.


// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function $8117a301f45a2d4357cff31509d8e567$var$writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }

    if (!state.noCompatMode && $8117a301f45a2d4357cff31509d8e567$var$DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.

    // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey // No block styles in flow mode.
    || // No block styles in flow mode.
    state.flowLevel > -1 && level >= state.flowLevel;

    function testAmbiguity(string) {
      return $8117a301f45a2d4357cff31509d8e567$var$testImplicitResolving(state, string);
    }

    switch ($8117a301f45a2d4357cff31509d8e567$var$chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case $8117a301f45a2d4357cff31509d8e567$var$STYLE_PLAIN:
        return string;

      case $8117a301f45a2d4357cff31509d8e567$var$STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";

      case $8117a301f45a2d4357cff31509d8e567$var$STYLE_LITERAL:
        return '|' + $8117a301f45a2d4357cff31509d8e567$var$blockHeader(string, state.indent) + $8117a301f45a2d4357cff31509d8e567$var$dropEndingNewline($8117a301f45a2d4357cff31509d8e567$var$indentString(string, indent));

      case $8117a301f45a2d4357cff31509d8e567$var$STYLE_FOLDED:
        return '>' + $8117a301f45a2d4357cff31509d8e567$var$blockHeader(string, state.indent) + $8117a301f45a2d4357cff31509d8e567$var$dropEndingNewline($8117a301f45a2d4357cff31509d8e567$var$indentString($8117a301f45a2d4357cff31509d8e567$var$foldString(string, lineWidth), indent));

      case $8117a301f45a2d4357cff31509d8e567$var$STYLE_DOUBLE:
        return '"' + $8117a301f45a2d4357cff31509d8e567$var$escapeString(string, lineWidth) + '"';

      default:
        throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('impossible error: invalid scalar style');
    }
  }();
} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.


// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function $8117a301f45a2d4357cff31509d8e567$var$blockHeader(string, indentPerLevel) {
  var indentIndicator = $8117a301f45a2d4357cff31509d8e567$var$needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\n' counts as a "trailing" empty line.

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';
  return indentIndicator + chomp + '\n';
} // (See the note for writeScalar.)


// (See the note for writeScalar.)
function $8117a301f45a2d4357cff31509d8e567$var$dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
} // Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.


// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function $8117a301f45a2d4357cff31509d8e567$var$foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)

  // first line (possibly an empty line)
  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return $8117a301f45a2d4357cff31509d8e567$var$foldLine(string.slice(0, nextLF), width);
  }(); // If we haven't reached the first content line yet, don't add an extra \n.


  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented; // rest of the lines

  // rest of the lines
  var match;

  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + $8117a301f45a2d4357cff31509d8e567$var$foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
} // Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.


// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function $8117a301f45a2d4357cff31509d8e567$var$foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.

  // note: the match index will always be <= length-2.
  var match; // start is an inclusive index. end, curr, and next are exclusive.

  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = ''; // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while (match = breakRe.exec(line)) {
    next = match.index; // maintain invariant: curr - start <= width

    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2

      // derive end <= length-2
      result += '\n' + line.slice(start, end); // skip the space that was output as \n

      // skip the space that was output as \n
      start = end + 1; // derive start <= length-1
    }

    curr = next;
  } // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.


  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n'; // Insert a break if the remainder is too long and there is a break available.

  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
} // Escapes a double-quoted string.


// Escapes a double-quoted string.
function $8117a301f45a2d4357cff31509d8e567$var$escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").

    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF
    /* high surrogate */
    )
      /* high surrogate */
      {
        nextChar = string.charCodeAt(i + 1);

        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF
        /* low surrogate */
        )
          /* low surrogate */
          {
            // Combine the surrogate pair and store it escaped.
            result += $8117a301f45a2d4357cff31509d8e567$var$encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.

            // Advance index one extra since we already used that char here.
            i++;
            continue;
          }
      }

    escapeSeq = $8117a301f45a2d4357cff31509d8e567$var$ESCAPE_SEQUENCES[char];
    result += !escapeSeq && $8117a301f45a2d4357cff31509d8e567$var$isPrintable(char) ? string[i] : escapeSeq || $8117a301f45a2d4357cff31509d8e567$var$encodeHex(char);
  }

  return result;
}

function $8117a301f45a2d4357cff31509d8e567$var$writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if ($8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function $8117a301f45a2d4357cff31509d8e567$var$writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if ($8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += $8117a301f45a2d4357cff31509d8e567$var$generateNextLine(state, level);
      }

      if (state.dump && $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function $8117a301f45a2d4357cff31509d8e567$var$writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!$8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';
    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!$8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump; // Both key and value are valid.

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function $8117a301f45a2d4357cff31509d8e567$var$writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer; // Allow sorting keys so that the output file is deterministic

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += $8117a301f45a2d4357cff31509d8e567$var$generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!$8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += $8117a301f45a2d4357cff31509d8e567$var$generateNextLine(state, level);
    }

    if (!$8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && $8117a301f45a2d4357cff31509d8e567$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump; // Both key and value are valid.

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function $8117a301f45a2d4357cff31509d8e567$var$detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ($8117a301f45a2d4357cff31509d8e567$var$_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if ($8117a301f45a2d4357cff31509d8e567$var$_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
} // Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//


// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function $8117a301f45a2d4357cff31509d8e567$var$writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!$8117a301f45a2d4357cff31509d8e567$var$detectType(state, object, false)) {
    $8117a301f45a2d4357cff31509d8e567$var$detectType(state, object, true);
  }

  var type = $8117a301f45a2d4357cff31509d8e567$var$_toString.call(state.dump);

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }

    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        $8117a301f45a2d4357cff31509d8e567$var$writeBlockMapping(state, level, state.dump, compact);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        $8117a301f45a2d4357cff31509d8e567$var$writeFlowMapping(state, level, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;

      if (block && state.dump.length !== 0) {
        $8117a301f45a2d4357cff31509d8e567$var$writeBlockSequence(state, arrayLevel, state.dump, compact);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        $8117a301f45a2d4357cff31509d8e567$var$writeFlowSequence(state, arrayLevel, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        $8117a301f45a2d4357cff31509d8e567$var$writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new $a4131730fdea0a83c53cfcac61bc86fe$exports('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function $8117a301f45a2d4357cff31509d8e567$var$getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;
  $8117a301f45a2d4357cff31509d8e567$var$inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }

  state.usedDuplicates = new Array(length);
}

function $8117a301f45a2d4357cff31509d8e567$var$inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);

    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          $8117a301f45a2d4357cff31509d8e567$var$inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          $8117a301f45a2d4357cff31509d8e567$var$inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function $8117a301f45a2d4357cff31509d8e567$var$dump(input, options) {
  options = options || {};
  var state = new $8117a301f45a2d4357cff31509d8e567$var$State(options);
  if (!state.noRefs) $8117a301f45a2d4357cff31509d8e567$var$getDuplicateReferences(input, state);
  if ($8117a301f45a2d4357cff31509d8e567$var$writeNode(state, 0, input, true, true)) return state.dump + '\n';
  return '';
}

function $8117a301f45a2d4357cff31509d8e567$var$safeDump(input, options) {
  return $8117a301f45a2d4357cff31509d8e567$var$dump(input, $e4705106f1abdb94c9e9554d63f12b0a$export$extend({
    schema: $3defc228960dbdbcf6a2a4a7bb913540$exports
  }, options));
}

var $8117a301f45a2d4357cff31509d8e567$export$dump = $8117a301f45a2d4357cff31509d8e567$var$dump;
var $8117a301f45a2d4357cff31509d8e567$export$safeDump = $8117a301f45a2d4357cff31509d8e567$var$safeDump;

function $e21ce51baf1ea7509e523006a1b55351$var$deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}

$e21ce51baf1ea7509e523006a1b55351$exports.Type = $d5c0c9d1c2801e774c431a84a7c32047$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.Schema = $a1778edf5fa0c0fb671dfa49596a0d70$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.FAILSAFE_SCHEMA = $eca98ca4dd00b0f463845e6f15fef8e0$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.JSON_SCHEMA = $d7a4ee3e19e56762b970af13eb705788$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.CORE_SCHEMA = $80d4564761aebebcfdf65f1c0a37f822$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.DEFAULT_SAFE_SCHEMA = $3defc228960dbdbcf6a2a4a7bb913540$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.DEFAULT_FULL_SCHEMA = $bcbcbd67bb21b2caa70bbdbfd1a8af91$exports;
var $e21ce51baf1ea7509e523006a1b55351$export$load = $fc0be4e9eb3049c97ae86677931f4875$export$load;
$e21ce51baf1ea7509e523006a1b55351$exports.load = $e21ce51baf1ea7509e523006a1b55351$export$load;
var $e21ce51baf1ea7509e523006a1b55351$export$loadAll = $fc0be4e9eb3049c97ae86677931f4875$export$loadAll;
$e21ce51baf1ea7509e523006a1b55351$exports.loadAll = $e21ce51baf1ea7509e523006a1b55351$export$loadAll;
var $e21ce51baf1ea7509e523006a1b55351$export$safeLoad = $fc0be4e9eb3049c97ae86677931f4875$export$safeLoad;
$e21ce51baf1ea7509e523006a1b55351$exports.safeLoad = $e21ce51baf1ea7509e523006a1b55351$export$safeLoad;
var $e21ce51baf1ea7509e523006a1b55351$export$safeLoadAll = $fc0be4e9eb3049c97ae86677931f4875$export$safeLoadAll;
$e21ce51baf1ea7509e523006a1b55351$exports.safeLoadAll = $e21ce51baf1ea7509e523006a1b55351$export$safeLoadAll;
var $e21ce51baf1ea7509e523006a1b55351$export$dump = $8117a301f45a2d4357cff31509d8e567$export$dump;
$e21ce51baf1ea7509e523006a1b55351$exports.dump = $e21ce51baf1ea7509e523006a1b55351$export$dump;
var $e21ce51baf1ea7509e523006a1b55351$export$safeDump = $8117a301f45a2d4357cff31509d8e567$export$safeDump;
$e21ce51baf1ea7509e523006a1b55351$exports.safeDump = $e21ce51baf1ea7509e523006a1b55351$export$safeDump;
$e21ce51baf1ea7509e523006a1b55351$exports.YAMLException = $a4131730fdea0a83c53cfcac61bc86fe$exports; // Deprecated schema names from JS-YAML 2.0.x

// Deprecated schema names from JS-YAML 2.0.x
$e21ce51baf1ea7509e523006a1b55351$exports.MINIMAL_SCHEMA = $eca98ca4dd00b0f463845e6f15fef8e0$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.SAFE_SCHEMA = $3defc228960dbdbcf6a2a4a7bb913540$exports;
$e21ce51baf1ea7509e523006a1b55351$exports.DEFAULT_SCHEMA = $bcbcbd67bb21b2caa70bbdbfd1a8af91$exports; // Deprecated functions from JS-YAML 1.x.x

var $e21ce51baf1ea7509e523006a1b55351$export$scan = $e21ce51baf1ea7509e523006a1b55351$var$deprecated('scan');
// Deprecated functions from JS-YAML 1.x.x
$e21ce51baf1ea7509e523006a1b55351$exports.scan = $e21ce51baf1ea7509e523006a1b55351$export$scan;
var $e21ce51baf1ea7509e523006a1b55351$export$parse = $e21ce51baf1ea7509e523006a1b55351$var$deprecated('parse');
$e21ce51baf1ea7509e523006a1b55351$exports.parse = $e21ce51baf1ea7509e523006a1b55351$export$parse;
var $e21ce51baf1ea7509e523006a1b55351$export$compose = $e21ce51baf1ea7509e523006a1b55351$var$deprecated('compose');
$e21ce51baf1ea7509e523006a1b55351$exports.compose = $e21ce51baf1ea7509e523006a1b55351$export$compose;
var $e21ce51baf1ea7509e523006a1b55351$export$addConstructor = $e21ce51baf1ea7509e523006a1b55351$var$deprecated('addConstructor');
$e21ce51baf1ea7509e523006a1b55351$exports.addConstructor = $e21ce51baf1ea7509e523006a1b55351$export$addConstructor;
$33a2e486b42a7206519a930f8dad43a7$exports = $e21ce51baf1ea7509e523006a1b55351$exports;
// ASSET: node_modules/@yarnpkg/parsers/lib/grammars/syml.js
var $32b5fea0fee4d621e2053d602e071a1a$exports = {};

function $32b5fea0fee4d621e2053d602e071a1a$var$peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function $32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, $32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError);
  }
}

$32b5fea0fee4d621e2053d602e071a1a$var$peg$subclass($32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError, Error);

$32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },
    "class": function (expectation) {
      var escapedParts = "",
          i;

      for (i = 0; i < expectation.parts.length; i++) escapedParts += expectation.parts[i] instanceof Array ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}` : classEscape(expectation.parts[i]);

      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },
    any: function (expectation) {
      return "any character";
    },
    end: function (expectation) {
      return "end of input";
    },
    other: function (expectation) {
      return expectation.description;
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return `\\x0${hex(ch)}`;
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return `\\x${hex(ch)}`;
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return `\\x0${hex(ch)}`;
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return `\\x${hex(ch)}`;
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i,
        j;

    for (i = 0; i < expected.length; i++) descriptions[i] = describeExpectation(expected[i]);

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")}, or ${descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function $32b5fea0fee4d621e2053d602e071a1a$var$peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},
      peg$startRuleFunctions = {
    Start: peg$parseStart
  },
      peg$startRuleFunction = peg$parseStart,
      peg$c0 = function (statements) {
    return [].concat(...statements);
  },
      peg$c1 = "-",
      peg$c2 = peg$literalExpectation("-", false),
      peg$c3 = function (value) {
    return value;
  },
      peg$c4 = function (statements) {
    return Object.assign({}, ...statements);
  },
      peg$c5 = "#",
      peg$c6 = peg$literalExpectation("#", false),
      peg$c7 = peg$anyExpectation(),
      peg$c8 = function () {
    return {};
  },
      peg$c9 = ":",
      peg$c10 = peg$literalExpectation(":", false),
      peg$c11 = function (property, value) {
    return {
      [property]: value
    };
  },
      peg$c12 = ",",
      peg$c13 = peg$literalExpectation(",", false),
      peg$c14 = function (property, other) {
    return other;
  },
      peg$c15 = function (property, others, value) {
    return Object.assign({}, ...[property].concat(others).map(property => ({
      [property]: value
    })));
  },
      peg$c16 = function (statements) {
    return statements;
  },
      peg$c17 = function (expression) {
    return expression;
  },
      peg$c18 = peg$otherExpectation("correct indentation"),
      peg$c19 = " ",
      peg$c20 = peg$literalExpectation(" ", false),
      peg$c21 = function (spaces) {
    return spaces.length === indentLevel * INDENT_STEP;
  },
      peg$c22 = function (spaces) {
    return spaces.length === (indentLevel + 1) * INDENT_STEP;
  },
      peg$c23 = function () {
    indentLevel++;
    return true;
  },
      peg$c24 = function () {
    indentLevel--;
    return true;
  },
      peg$c25 = function () {
    return text();
  },
      peg$c26 = peg$otherExpectation("pseudostring"),
      peg$c27 = /^[^\r\n\t ?:,\][{}#&*!|>'"%@`\-]/,
      peg$c28 = peg$classExpectation(["\r", "\n", "\t", " ", "?", ":", ",", "]", "[", "{", "}", "#", "&", "*", "!", "|", ">", "'", "\"", "%", "@", "`", "-"], true, false),
      peg$c29 = /^[^\r\n\t ,\][{}:#"']/,
      peg$c30 = peg$classExpectation(["\r", "\n", "\t", " ", ",", "]", "[", "{", "}", ":", "#", "\"", "'"], true, false),
      peg$c31 = function () {
    return text().replace(/^ *| *$/g, '');
  },
      peg$c32 = "--",
      peg$c33 = peg$literalExpectation("--", false),
      peg$c34 = /^[a-zA-Z\/0-9]/,
      peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "/", ["0", "9"]], false, false),
      peg$c36 = /^[^\r\n\t :,]/,
      peg$c37 = peg$classExpectation(["\r", "\n", "\t", " ", ":", ","], true, false),
      peg$c38 = "null",
      peg$c39 = peg$literalExpectation("null", false),
      peg$c40 = function () {
    return null;
  },
      peg$c41 = "true",
      peg$c42 = peg$literalExpectation("true", false),
      peg$c43 = function () {
    return true;
  },
      peg$c44 = "false",
      peg$c45 = peg$literalExpectation("false", false),
      peg$c46 = function () {
    return false;
  },
      peg$c47 = peg$otherExpectation("string"),
      peg$c48 = "\"",
      peg$c49 = peg$literalExpectation("\"", false),
      peg$c50 = function () {
    return "";
  },
      peg$c51 = function (chars) {
    return chars;
  },
      peg$c52 = function (chars) {
    return chars.join(``);
  },
      peg$c53 = /^[^"\\\0-\x1F\x7F]/,
      peg$c54 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
      peg$c55 = "\\\"",
      peg$c56 = peg$literalExpectation("\\\"", false),
      peg$c57 = function () {
    return `"`;
  },
      peg$c58 = "\\\\",
      peg$c59 = peg$literalExpectation("\\\\", false),
      peg$c60 = function () {
    return `\\`;
  },
      peg$c61 = "\\/",
      peg$c62 = peg$literalExpectation("\\/", false),
      peg$c63 = function () {
    return `/`;
  },
      peg$c64 = "\\b",
      peg$c65 = peg$literalExpectation("\\b", false),
      peg$c66 = function () {
    return `\b`;
  },
      peg$c67 = "\\f",
      peg$c68 = peg$literalExpectation("\\f", false),
      peg$c69 = function () {
    return `\f`;
  },
      peg$c70 = "\\n",
      peg$c71 = peg$literalExpectation("\\n", false),
      peg$c72 = function () {
    return `\n`;
  },
      peg$c73 = "\\r",
      peg$c74 = peg$literalExpectation("\\r", false),
      peg$c75 = function () {
    return `\r`;
  },
      peg$c76 = "\\t",
      peg$c77 = peg$literalExpectation("\\t", false),
      peg$c78 = function () {
    return `\t`;
  },
      peg$c79 = "\\u",
      peg$c80 = peg$literalExpectation("\\u", false),
      peg$c81 = function (h1, h2, h3, h4) {
    return String.fromCharCode(parseInt(`0x${h1}${h2}${h3}${h4}`));
  },
      peg$c82 = /^[0-9a-fA-F]/,
      peg$c83 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
      peg$c84 = peg$otherExpectation("blank space"),
      peg$c85 = /^[ \t]/,
      peg$c86 = peg$classExpectation([" ", "\t"], false, false),
      peg$c87 = peg$otherExpectation("white space"),
      peg$c88 = /^[ \t\n\r]/,
      peg$c89 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
      peg$c90 = "\r\n",
      peg$c91 = peg$literalExpectation("\r\n", false),
      peg$c92 = "\n",
      peg$c93 = peg$literalExpectation("\n", false),
      peg$c94 = "\r",
      peg$c95 = peg$literalExpectation("\r", false),
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{
    line: 1,
    column: 1
  }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) throw new Error(`Can't start parsing from rule "${options.startRule}".`);
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {
      type: "literal",
      text: text,
      ignoreCase: ignoreCase
    };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  }

  function peg$anyExpectation() {
    return {
      type: "any"
    };
  }

  function peg$endExpectation() {
    return {
      type: "end"
    };
  }

  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
        p;

    if (details) {
      return details;
    } else {
      p = pos - 1;

      while (!peg$posDetailsCache[p]) p--;

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new $32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new $32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError($32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }

  function peg$parseStart() {
    var s0;
    s0 = peg$parsePropertyStatements();
    return s0;
  }

  function peg$parseItemStatements() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseItemStatement();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseItemStatement();
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parseItemStatement() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;
    s1 = peg$parseSamedent();

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c1;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c2);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = peg$parseB();

        if (s3 !== peg$FAILED) {
          s4 = peg$parseExpression();

          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePropertyStatements() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePropertyStatement();

    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsePropertyStatement();
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c4(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parsePropertyStatement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
    s0 = peg$currPos;
    s1 = peg$parseB();
    if (s1 === peg$FAILED) s1 = null;

    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 35) {
        s3 = peg$c5;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c6);
        }
      }

      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$silentFails++;
        s7 = peg$parseEOL();
        peg$silentFails--;

        if (s7 === peg$FAILED) {
          s6 = void 0;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }

        if (s6 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }

          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }

        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseEOL();
            peg$silentFails--;

            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }

            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }

              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
        } else {
          s4 = peg$FAILED;
        }

        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }

      if (s2 === peg$FAILED) s2 = null;

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseEOL_ANY();

        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseEOL_ANY();
          }
        } else {
          s3 = peg$FAILED;
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSamedent();

      if (s1 !== peg$FAILED) {
        s2 = peg$parseName();

        if (s2 !== peg$FAILED) {
          s3 = peg$parseB();
          if (s3 === peg$FAILED) s3 = null;

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseB();
              if (s5 === peg$FAILED) s5 = null;

              if (s5 !== peg$FAILED) {
                s6 = peg$parseExpression();

                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c11(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSamedent();

        if (s1 !== peg$FAILED) {
          s2 = peg$parseLegacyName();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseB();
            if (s3 === peg$FAILED) s3 = null;

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parseB();
                if (s5 === peg$FAILED) s5 = null;

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseExpression();

                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSamedent();

          if (s1 !== peg$FAILED) {
            s2 = peg$parseLegacyName();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseB();

              if (s3 !== peg$FAILED) {
                s4 = peg$parseLegacyLiteral();

                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseEOL_ANY();

                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseEOL_ANY();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }

                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSamedent();

            if (s1 !== peg$FAILED) {
              s2 = peg$parseLegacyName();

              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseB();
                if (s5 === peg$FAILED) s5 = null;

                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c12;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c13);
                    }
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseB();
                    if (s7 === peg$FAILED) s7 = null;

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseLegacyName();

                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s4;
                        s5 = peg$c14(s2, s8);
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }

                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseB();
                    if (s5 === peg$FAILED) s5 = null;

                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s6 = peg$c12;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;

                        if (peg$silentFails === 0) {
                          peg$fail(peg$c13);
                        }
                      }

                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseB();
                        if (s7 === peg$FAILED) s7 = null;

                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseLegacyName();

                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s5 = peg$c14(s2, s8);
                            s4 = s5;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                } else {
                  s3 = peg$FAILED;
                }

                if (s3 !== peg$FAILED) {
                  s4 = peg$parseB();
                  if (s4 === peg$FAILED) s4 = null;

                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseB();
                      if (s6 === peg$FAILED) s6 = null;

                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseExpression();

                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c15(s2, s3, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseExpression() {
    var s0, s1, s2, s3, s4, s5, s6;
    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseEOL();

    if (s3 !== peg$FAILED) {
      s4 = peg$parseExtradent();

      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s5 = peg$c1;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }

        if (s5 !== peg$FAILED) {
          s6 = peg$parseB();

          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }

    peg$silentFails--;

    if (s2 !== peg$FAILED) {
      peg$currPos = s1;
      s1 = void 0;
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOL_ANY();

      if (s2 !== peg$FAILED) {
        s3 = peg$parseIndent();

        if (s3 !== peg$FAILED) {
          s4 = peg$parseItemStatements();

          if (s4 !== peg$FAILED) {
            s5 = peg$parseDedent();

            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEOL();

      if (s1 !== peg$FAILED) {
        s2 = peg$parseIndent();

        if (s2 !== peg$FAILED) {
          s3 = peg$parsePropertyStatements();

          if (s3 !== peg$FAILED) {
            s4 = peg$parseDedent();

            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLiteral();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseEOL_ANY();

          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseEOL_ANY();
            }
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseSamedent() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];

    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c20);
      }
    }

    while (s2 !== peg$FAILED) {
      s1.push(s2);

      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c20);
        }
      }
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c21(s1);
      if (s2) s2 = void 0;else s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$silentFails--;

    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c18);
      }
    }

    return s0;
  }

  function peg$parseExtradent() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];

    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c20);
      }
    }

    while (s2 !== peg$FAILED) {
      s1.push(s2);

      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c20);
        }
      }
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c22(s1);
      if (s2) s2 = void 0;else s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIndent() {
    var s0;
    peg$savedPos = peg$currPos;
    s0 = peg$c23();
    if (s0) s0 = void 0;else s0 = peg$FAILED;
    return s0;
  }

  function peg$parseDedent() {
    var s0;
    peg$savedPos = peg$currPos;
    s0 = peg$c24();
    if (s0) s0 = void 0;else s0 = peg$FAILED;
    return s0;
  }

  function peg$parseName() {
    var s0;
    s0 = peg$parsestring();
    if (s0 === peg$FAILED) s0 = peg$parsepseudostring();
    return s0;
  }

  function peg$parseLegacyName() {
    var s0, s1, s2;
    s0 = peg$parsestring();

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsepseudostringLegacy();

      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsepseudostringLegacy();
        }
      } else {
        s1 = peg$FAILED;
      }

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c25();
      }

      s0 = s1;
    }

    return s0;
  }

  function peg$parseLiteral() {
    var s0;
    s0 = peg$parsenull();

    if (s0 === peg$FAILED) {
      s0 = peg$parseboolean();

      if (s0 === peg$FAILED) {
        s0 = peg$parsestring();

        if (s0 === peg$FAILED) {
          s0 = peg$parsepseudostring();
        }
      }
    }

    return s0;
  }

  function peg$parseLegacyLiteral() {
    var s0;
    s0 = peg$parsenull();

    if (s0 === peg$FAILED) {
      s0 = peg$parsestring();

      if (s0 === peg$FAILED) {
        s0 = peg$parsepseudostringLegacy();
      }
    }

    return s0;
  }

  function peg$parsepseudostring() {
    var s0, s1, s2, s3, s4, s5;
    peg$silentFails++;
    s0 = peg$currPos;

    if (peg$c27.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c28);
      }
    }

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED) s4 = null;

      if (s4 !== peg$FAILED) {
        if (peg$c29.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }

        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED) s4 = null;

        if (s4 !== peg$FAILED) {
          if (peg$c29.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }

          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c31();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$silentFails--;

    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c26);
      }
    }

    return s0;
  }

  function peg$parsepseudostringLegacy() {
    var s0, s1, s2, s3, s4;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 2) === peg$c32) {
      s1 = peg$c32;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c33);
      }
    }

    if (s1 === peg$FAILED) s1 = null;

    if (s1 !== peg$FAILED) {
      if (peg$c34.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c35);
        }
      }

      if (s2 !== peg$FAILED) {
        s3 = [];

        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }

        while (s4 !== peg$FAILED) {
          s3.push(s4);

          if (peg$c36.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
        }

        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenull() {
    var s0, s1;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 4) === peg$c38) {
      s1 = peg$c38;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c39);
      }
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c40();
    }

    s0 = s1;
    return s0;
  }

  function peg$parseboolean() {
    var s0, s1;
    s0 = peg$currPos;

    if (input.substr(peg$currPos, 4) === peg$c41) {
      s1 = peg$c41;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c42);
      }
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }

    s0 = s1;

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 5) === peg$c44) {
        s1 = peg$c44;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c45);
        }
      }

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46();
      }

      s0 = s1;
    }

    return s0;
  }

  function peg$parsestring() {
    var s0, s1, s2, s3;
    peg$silentFails++;
    s0 = peg$currPos;

    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c48;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c49);
      }
    }

    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c48;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c49);
        }
      }

      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c48;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c49);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parsechars();

        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c48;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c49);
            }
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$silentFails--;

    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c47);
      }
    }

    return s0;
  }

  function peg$parsechars() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();

    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }

    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }

    s0 = s1;
    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2, s3, s4, s5;

    if (peg$c53.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c54);
      }
    }

    if (s0 === peg$FAILED) {
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 2) === peg$c55) {
        s1 = peg$c55;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c56);
        }
      }

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
      }

      s0 = s1;

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 2) === peg$c58) {
          s1 = peg$c58;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c59);
          }
        }

        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60();
        }

        s0 = s1;

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.substr(peg$currPos, 2) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }

          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63();
          }

          s0 = s1;

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;

            if (input.substr(peg$currPos, 2) === peg$c64) {
              s1 = peg$c64;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }

            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66();
            }

            s0 = s1;

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.substr(peg$currPos, 2) === peg$c67) {
                s1 = peg$c67;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c68);
                }
              }

              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c69();
              }

              s0 = s1;

              if (s0 === peg$FAILED) {
                s0 = peg$currPos;

                if (input.substr(peg$currPos, 2) === peg$c70) {
                  s1 = peg$c70;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c71);
                  }
                }

                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c72();
                }

                s0 = s1;

                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;

                  if (input.substr(peg$currPos, 2) === peg$c73) {
                    s1 = peg$c73;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c74);
                    }
                  }

                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c75();
                  }

                  s0 = s1;

                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;

                    if (input.substr(peg$currPos, 2) === peg$c76) {
                      s1 = peg$c76;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c77);
                      }
                    }

                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c78();
                    }

                    s0 = s1;

                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;

                      if (input.substr(peg$currPos, 2) === peg$c79) {
                        s1 = peg$c79;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;

                        if (peg$silentFails === 0) {
                          peg$fail(peg$c80);
                        }
                      }

                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsehexDigit();

                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsehexDigit();

                          if (s3 !== peg$FAILED) {
                            s4 = peg$parsehexDigit();

                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsehexDigit();

                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c81(s2, s3, s4, s5);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsehexDigit() {
    var s0;

    if (peg$c82.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c83);
      }
    }

    return s0;
  }

  function peg$parseB() {
    var s0, s1;
    peg$silentFails++;
    s0 = [];

    if (peg$c85.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c86);
      }
    }

    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    peg$silentFails--;

    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c84);
      }
    }

    return s0;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$parseS() {
    var s0, s1;
    peg$silentFails++;
    s0 = [];

    if (peg$c88.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c89);
      }
    }

    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);

        if (peg$c88.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    peg$silentFails--;

    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c87);
      }
    }

    return s0;
  } // eslint-disable-next-line @typescript-eslint/camelcase


  // eslint-disable-next-line @typescript-eslint/camelcase
  function peg$parseEOL_ANY() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    s1 = peg$parseEOL();

    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED) s4 = null;

      if (s4 !== peg$FAILED) {
        s5 = peg$parseEOL();

        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }

      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED) s4 = null;

        if (s4 !== peg$FAILED) {
          s5 = peg$parseEOL();

          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEOL() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c90) {
      s0 = peg$c90;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;

      if (peg$silentFails === 0) {
        peg$fail(peg$c91);
      }
    }

    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c92;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c93);
        }
      }

      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c94;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
      }
    }

    return s0;
  }

  const INDENT_STEP = 2;
  let indentLevel = 0;
  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}

$32b5fea0fee4d621e2053d602e071a1a$exports = {
  SyntaxError: $32b5fea0fee4d621e2053d602e071a1a$var$peg$SyntaxError,
  parse: $32b5fea0fee4d621e2053d602e071a1a$var$peg$parse
};
const $b007afdcdc3a457f30010926c327cba4$var$simpleStringPattern = /^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/; // The following keys will always be stored at the top of the object, in the
// specified order. It's not fair but life isn't fair either.

// The following keys will always be stored at the top of the object, in the
// specified order. It's not fair but life isn't fair either.
const $b007afdcdc3a457f30010926c327cba4$var$specialObjectKeys = [`__metadata`, `version`, `resolution`, `dependencies`, `peerDependencies`, `dependenciesMeta`, `peerDependenciesMeta`, `binaries`];

class $b007afdcdc3a457f30010926c327cba4$var$PreserveOrdering {
  constructor(data) {
    this.data = data;
  }

}

var $b007afdcdc3a457f30010926c327cba4$export$PreserveOrdering = $b007afdcdc3a457f30010926c327cba4$var$PreserveOrdering;
$b007afdcdc3a457f30010926c327cba4$exports.PreserveOrdering = $b007afdcdc3a457f30010926c327cba4$export$PreserveOrdering;

function $b007afdcdc3a457f30010926c327cba4$var$stringifyString(value) {
  if (value.match($b007afdcdc3a457f30010926c327cba4$var$simpleStringPattern)) {
    return value;
  } else {
    return JSON.stringify(value);
  }
}

function $b007afdcdc3a457f30010926c327cba4$var$isRemovableField(value) {
  if (typeof value === `undefined`) return true;
  if (typeof value === `object` && value !== null) return Object.keys(value).every(key => $b007afdcdc3a457f30010926c327cba4$var$isRemovableField(value[key]));
  return false;
}

function $b007afdcdc3a457f30010926c327cba4$var$stringifyValue(value, indentLevel, newLineIfObject) {
  if (value === null) return `null\n`;
  if (typeof value === `number` || typeof value === `boolean`) return `${value.toString()}\n`;
  if (typeof value === `string`) return `${$b007afdcdc3a457f30010926c327cba4$var$stringifyString(value)}\n`;

  if (Array.isArray(value)) {
    if (value.length === 0) return `[]\n`;
    const indent = `  `.repeat(indentLevel);
    const serialized = value.map(sub => {
      return `${indent}- ${$b007afdcdc3a457f30010926c327cba4$var$stringifyValue(sub, indentLevel + 1, false)}`;
    }).join(``);
    return `\n${serialized}`;
  }

  if (typeof value === `object` && value) {
    let data;
    let sort;

    if (value instanceof $b007afdcdc3a457f30010926c327cba4$var$PreserveOrdering) {
      data = value.data;
      sort = false;
    } else {
      data = value;
      sort = true;
    }

    const indent = `  `.repeat(indentLevel);
    const keys = Object.keys(data);

    if (sort) {
      keys.sort((a, b) => {
        const aIndex = $b007afdcdc3a457f30010926c327cba4$var$specialObjectKeys.indexOf(a);
        const bIndex = $b007afdcdc3a457f30010926c327cba4$var$specialObjectKeys.indexOf(b);
        if (aIndex === -1 && bIndex === -1) return a < b ? -1 : a > b ? +1 : 0;
        if (aIndex !== -1 && bIndex === -1) return -1;
        if (aIndex === -1 && bIndex !== -1) return +1;
        return aIndex - bIndex;
      });
    }

    const fields = keys.filter(key => {
      return !$b007afdcdc3a457f30010926c327cba4$var$isRemovableField(data[key]);
    }).map((key, index) => {
      const value = data[key];
      const stringifiedKey = $b007afdcdc3a457f30010926c327cba4$var$stringifyString(key);
      const stringifiedValue = $b007afdcdc3a457f30010926c327cba4$var$stringifyValue(value, indentLevel + 1, true);
      const recordIndentation = index > 0 || newLineIfObject ? indent : ``;

      if (stringifiedValue.startsWith(`\n`)) {
        return `${recordIndentation}${stringifiedKey}:${stringifiedValue}`;
      } else {
        return `${recordIndentation}${stringifiedKey}: ${stringifiedValue}`;
      }
    }).join(indentLevel === 0 ? `\n` : ``) || `\n`;

    if (!newLineIfObject) {
      return `${fields}`;
    } else {
      return `\n${fields}`;
    }
  }

  throw new Error(`Unsupported value type (${value})`);
}

function $b007afdcdc3a457f30010926c327cba4$var$stringifySyml(value) {
  try {
    const stringified = $b007afdcdc3a457f30010926c327cba4$var$stringifyValue(value, 0, false);
    return stringified !== `\n` ? stringified : ``;
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}

var $b007afdcdc3a457f30010926c327cba4$export$stringifySyml = $b007afdcdc3a457f30010926c327cba4$var$stringifySyml;
$b007afdcdc3a457f30010926c327cba4$exports.stringifySyml = $b007afdcdc3a457f30010926c327cba4$export$stringifySyml;
$b007afdcdc3a457f30010926c327cba4$var$stringifySyml.PreserveOrdering = $b007afdcdc3a457f30010926c327cba4$var$PreserveOrdering;

function $b007afdcdc3a457f30010926c327cba4$var$parseViaPeg(source) {
  if (!source.endsWith(`\n`)) source += `\n`;
  return $32b5fea0fee4d621e2053d602e071a1a$exports.parse(source);
}

const $b007afdcdc3a457f30010926c327cba4$var$LEGACY_REGEXP = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;

function $b007afdcdc3a457f30010926c327cba4$var$parseViaJsYaml(source) {
  if ($b007afdcdc3a457f30010926c327cba4$var$LEGACY_REGEXP.test(source)) return $b007afdcdc3a457f30010926c327cba4$var$parseViaPeg(source);
  const value = $33a2e486b42a7206519a930f8dad43a7$exports.safeLoad(source, {
    schema: $33a2e486b42a7206519a930f8dad43a7$exports.FAILSAFE_SCHEMA
  }); // Empty files are parsed as `undefined` instead of an empty object
  // Empty files with 2 newlines or more are `null` instead

  // Empty files are parsed as `undefined` instead of an empty object
  // Empty files with 2 newlines or more are `null` instead
  if (value === undefined || value === null) return {};
  if (typeof value !== `object`) throw new Error(`Expected an indexed object, got a ${typeof value} instead. Does your file follow Yaml's rules?`);
  if (Array.isArray(value)) throw new Error(`Expected an indexed object, got an array instead. Does your file follow Yaml's rules?`);
  return value;
}

function $b007afdcdc3a457f30010926c327cba4$var$parseSyml(source) {
  return $b007afdcdc3a457f30010926c327cba4$var$parseViaJsYaml(source);
}

$b007afdcdc3a457f30010926c327cba4$export$parseSyml = $b007afdcdc3a457f30010926c327cba4$var$parseSyml;
$b007afdcdc3a457f30010926c327cba4$exports.parseSyml = $b007afdcdc3a457f30010926c327cba4$export$parseSyml;
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "parseSyml", {
  enumerable: true,
  get: function () {
    return $b007afdcdc3a457f30010926c327cba4$exports.parseSyml;
  }
});
Object.defineProperty($0e609d03a5066ebec776a5ec6a49b084$exports, "stringifySyml", {
  enumerable: true,
  get: function () {
    return $b007afdcdc3a457f30010926c327cba4$exports.stringifySyml;
  }
});
const $e51f99366c3d7ff19a0ceeed21bc69c1$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $e51f99366c3d7ff19a0ceeed21bc69c1$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
// ASSET: node_modules/@yarnpkg/core/lib/semverUtils.js
var $4b3129d95390e44c4289200276bae532$exports = {};
Object.defineProperty($4b3129d95390e44c4289200276bae532$exports, "__esModule", {
  value: true
});
var $4b3129d95390e44c4289200276bae532$export$validRange = ($4b3129d95390e44c4289200276bae532$export$satisfiesWithPrereleases = void 0, $4b3129d95390e44c4289200276bae532$exports.satisfiesWithPrereleases = $4b3129d95390e44c4289200276bae532$export$satisfiesWithPrereleases);
$4b3129d95390e44c4289200276bae532$exports.validRange = $4b3129d95390e44c4289200276bae532$export$validRange;
const $4b3129d95390e44c4289200276bae532$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
/**
 * Returns whether the given semver version satisfies the given range. Notably
 * this supports prerelease versions so that "2.0.0-rc.0" satisfies the range
 * ">=1.0.0", for example.
 *
 * This function exists because the semver.satisfies method does not include
 * pre releases. This means ranges such as * would not satisfy 1.0.0-rc. The
 * includePrerelease flag has a weird behavior and cannot be used (if you want
 * to try it out, just run the `semverUtils` testsuite using this flag instead
 * of our own implementation, and you'll see the failing cases).
 *
 * See https://github.com/yarnpkg/berry/issues/575 for more context.
 */

/**
 * Returns whether the given semver version satisfies the given range. Notably
 * this supports prerelease versions so that "2.0.0-rc.0" satisfies the range
 * ">=1.0.0", for example.
 *
 * This function exists because the semver.satisfies method does not include
 * pre releases. This means ranges such as * would not satisfy 1.0.0-rc. The
 * includePrerelease flag has a weird behavior and cannot be used (if you want
 * to try it out, just run the `semverUtils` testsuite using this flag instead
 * of our own implementation, and you'll see the failing cases).
 *
 * See https://github.com/yarnpkg/berry/issues/575 for more context.
 */
function $4b3129d95390e44c4289200276bae532$var$satisfiesWithPrereleases(version, range, loose = false) {
  let semverRange;

  try {
    semverRange = new $4b3129d95390e44c4289200276bae532$var$semver_1.default.Range(range, {
      includePrerelease: true,
      loose
    });
  } catch (err) {
    return false;
  }

  if (!version) return false;
  let semverVersion;

  try {
    semverVersion = new $4b3129d95390e44c4289200276bae532$var$semver_1.default.SemVer(version, semverRange);

    if (semverVersion.prerelease) {
      semverVersion.prerelease = [];
    }
  } catch (err) {
    return false;
  } // A range has multiple sets of comparators. A version must satisfy all
  // comparators in a set and at least one set to satisfy the range.


  // A range has multiple sets of comparators. A version must satisfy all
  // comparators in a set and at least one set to satisfy the range.
  return semverRange.set.some(comparatorSet => {
    for (const comparator of comparatorSet) if (comparator.semver.prerelease) comparator.semver.prerelease = [];

    return comparatorSet.every(comparator => {
      return comparator.test(semverVersion);
    });
  });
}

var $4b3129d95390e44c4289200276bae532$export$satisfiesWithPrereleases = $4b3129d95390e44c4289200276bae532$var$satisfiesWithPrereleases;
$4b3129d95390e44c4289200276bae532$exports.satisfiesWithPrereleases = $4b3129d95390e44c4289200276bae532$export$satisfiesWithPrereleases;
const $4b3129d95390e44c4289200276bae532$var$rangesCache = new Map();
/**
 * A cached version of `new semver.Range(potentialRange)` that returns `null` on invalid ranges
 */

/**
 * A cached version of `new semver.Range(potentialRange)` that returns `null` on invalid ranges
 */
function $4b3129d95390e44c4289200276bae532$var$validRange(potentialRange) {
  if (potentialRange.indexOf(`:`) !== -1) return null;
  let range = $4b3129d95390e44c4289200276bae532$var$rangesCache.get(potentialRange);
  if (typeof range !== `undefined`) return range;

  try {
    range = new $4b3129d95390e44c4289200276bae532$var$semver_1.default.Range(potentialRange);
  } catch (_a) {
    range = null;
  }

  $4b3129d95390e44c4289200276bae532$var$rangesCache.set(potentialRange, range);
  return range;
}

$4b3129d95390e44c4289200276bae532$export$validRange = $4b3129d95390e44c4289200276bae532$var$validRange;
$4b3129d95390e44c4289200276bae532$exports.validRange = $4b3129d95390e44c4289200276bae532$export$validRange;
const $e51f99366c3d7ff19a0ceeed21bc69c1$var$semverUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4b3129d95390e44c4289200276bae532$exports);
const $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest {
  constructor() {
    this.indent = `  `;
    this.name = null;
    this.version = null;
    this.os = null;
    this.cpu = null;
    this.type = null;
    this["private"] = false;
    this.license = null;
    this.main = null;
    this.module = null;
    this.browser = null;
    this.languageName = null;
    this.bin = new Map();
    this.scripts = new Map();
    this.dependencies = new Map();
    this.devDependencies = new Map();
    this.peerDependencies = new Map();
    this.workspaceDefinitions = [];
    this.dependenciesMeta = new Map();
    this.peerDependenciesMeta = new Map();
    this.resolutions = [];
    this.files = null;
    this.publishConfig = null;
    this.installConfig = null;
    this.preferUnplugged = null;
    this.raw = {};
    /**
     * errors found in the raw manifest while loading
     */

    /**
     * errors found in the raw manifest while loading
     */
    this.errors = [];
  }

  static async tryFind(path, {
    baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS()
  } = {}) {
    const manifestPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(path, `package.json`);
    if (!(await baseFs.existsPromise(manifestPath))) return null;
    return await $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.fromFile(manifestPath, {
      baseFs
    });
  }

  static async find(path, {
    baseFs
  } = {}) {
    const manifest = await $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.tryFind(path, {
      baseFs
    });
    if (manifest === null) throw new Error(`Manifest not found`);
    return manifest;
  }

  static async fromFile(path, {
    baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS()
  } = {}) {
    const manifest = new $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest();
    await manifest.loadFile(path, {
      baseFs
    });
    return manifest;
  }

  static fromText(text) {
    const manifest = new $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest();
    manifest.loadFromText(text);
    return manifest;
  }

  static isManifestFieldCompatible(rules, actual) {
    if (rules === null) return true;
    let isNotOnAllowlist = true;
    let isOnDenylist = false;

    for (const rule of rules) {
      if (rule[0] === `!`) {
        isOnDenylist = true;

        if (actual === rule.slice(1)) {
          return false;
        }
      } else {
        isNotOnAllowlist = false;

        if (rule === actual) {
          return true;
        }
      }
    } // Denylists with allowlisted items should be treated as allowlists for `os` and `cpu` in `package.json`


    // Denylists with allowlisted items should be treated as allowlists for `os` and `cpu` in `package.json`
    return isOnDenylist && isNotOnAllowlist;
  }

  loadFromText(text) {
    let data;

    try {
      data = JSON.parse($e51f99366c3d7ff19a0ceeed21bc69c1$var$stripBOM(text) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${text})`;
      throw error;
    }

    this.load(data);
    this.indent = $e51f99366c3d7ff19a0ceeed21bc69c1$var$getIndent(text);
  }

  async loadFile(path, {
    baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS()
  }) {
    const content = await baseFs.readFilePromise(path, `utf8`);
    let data;

    try {
      data = JSON.parse($e51f99366c3d7ff19a0ceeed21bc69c1$var$stripBOM(content) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${path})`;
      throw error;
    }

    this.load(data);
    this.indent = $e51f99366c3d7ff19a0ceeed21bc69c1$var$getIndent(content);
  }

  load(data, {
    yamlCompatibilityMode = false
  } = {}) {
    if (typeof data !== `object` || data === null) throw new Error(`Utterly invalid manifest data (${data})`);
    this.raw = data;
    const errors = [];

    if (typeof data.name === `string`) {
      try {
        this.name = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(data.name);
      } catch (error) {
        errors.push(new Error(`Parsing failed for the 'name' field`));
      }
    }

    if (typeof data.version === `string`) this.version = data.version;

    if (Array.isArray(data.os)) {
      const os = [];
      this.os = os;

      for (const item of data.os) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'os' field`));
        } else {
          os.push(item);
        }
      }
    }

    if (Array.isArray(data.cpu)) {
      const cpu = [];
      this.cpu = cpu;

      for (const item of data.cpu) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'cpu' field`));
        } else {
          cpu.push(item);
        }
      }
    }

    if (typeof data.type === `string`) this.type = data.type;
    if (typeof data.private === `boolean`) this.private = data.private;
    if (typeof data.license === `string`) this.license = data.license;
    if (typeof data.languageName === `string`) this.languageName = data.languageName;
    if (typeof data.main === `string`) this.main = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.main);
    if (typeof data.module === `string`) this.module = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.module);

    if (data.browser != null) {
      if (typeof data.browser === `string`) {
        this.browser = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.browser);
      } else {
        this.browser = new Map();

        for (const [key, value] of Object.entries(data.browser)) {
          this.browser.set($e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(key), typeof value === `string` ? $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(value) : value);
        }
      }
    }

    if (typeof data.bin === `string`) {
      if (this.name !== null) {
        this.bin = new Map([[this.name.name, $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.bin)]]);
      } else {
        errors.push(new Error(`String bin field, but no attached package name`));
      }
    } else if (typeof data.bin === `object` && data.bin !== null) {
      for (const [key, value] of Object.entries(data.bin)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid bin definition for '${key}'`));
          continue;
        }

        this.bin.set(key, $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(value));
      }
    }

    if (typeof data.scripts === `object` && data.scripts !== null) {
      for (const [key, value] of Object.entries(data.scripts)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid script definition for '${key}'`));
          continue;
        }

        this.scripts.set(key, value);
      }
    }

    if (typeof data.dependencies === `object` && data.dependencies !== null) {
      for (const [name, range] of Object.entries(data.dependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor(ident, range);
        this.dependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.devDependencies === `object` && data.devDependencies !== null) {
      for (const [name, range] of Object.entries(data.devDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor(ident, range);
        this.devDependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.peerDependencies === `object` && data.peerDependencies !== null) {
      for (let [name, range] of Object.entries(data.peerDependencies)) {
        let ident;

        try {
          ident = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        if (typeof range !== `string` || !$e51f99366c3d7ff19a0ceeed21bc69c1$var$semverUtils.validRange(range)) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          range = `*`;
        }

        const descriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor(ident, range);
        this.peerDependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.workspaces === `object` && data.workspaces.nohoist) errors.push(new Error(`'nohoist' is deprecated, please use 'installConfig.hoistingLimits' instead`));
    const workspaces = Array.isArray(data.workspaces) ? data.workspaces : typeof data.workspaces === `object` && data.workspaces !== null && Array.isArray(data.workspaces.packages) ? data.workspaces.packages : [];

    for (const entry of workspaces) {
      if (typeof entry !== `string`) {
        errors.push(new Error(`Invalid workspace definition for '${entry}'`));
        continue;
      }

      this.workspaceDefinitions.push({
        pattern: entry
      });
    }

    if (typeof data.dependenciesMeta === `object` && data.dependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.dependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}`));
          continue;
        }

        const descriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseDescriptor(pattern);
        const dependencyMeta = this.ensureDependencyMeta(descriptor);
        const built = $e51f99366c3d7ff19a0ceeed21bc69c1$var$tryParseOptionalBoolean(meta.built, {
          yamlCompatibilityMode
        });

        if (built === null) {
          errors.push(new Error(`Invalid built meta field for '${pattern}'`));
          continue;
        }

        const optional = $e51f99366c3d7ff19a0ceeed21bc69c1$var$tryParseOptionalBoolean(meta.optional, {
          yamlCompatibilityMode
        });

        if (optional === null) {
          errors.push(new Error(`Invalid optional meta field for '${pattern}'`));
          continue;
        }

        const unplugged = $e51f99366c3d7ff19a0ceeed21bc69c1$var$tryParseOptionalBoolean(meta.unplugged, {
          yamlCompatibilityMode
        });

        if (unplugged === null) {
          errors.push(new Error(`Invalid unplugged meta field for '${pattern}'`));
          continue;
        }

        Object.assign(dependencyMeta, {
          built,
          optional,
          unplugged
        });
      }
    }

    if (typeof data.peerDependenciesMeta === `object` && data.peerDependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.peerDependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}'`));
          continue;
        }

        const descriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseDescriptor(pattern);
        const peerDependencyMeta = this.ensurePeerDependencyMeta(descriptor);
        const optional = $e51f99366c3d7ff19a0ceeed21bc69c1$var$tryParseOptionalBoolean(meta.optional, {
          yamlCompatibilityMode
        });

        if (optional === null) {
          errors.push(new Error(`Invalid optional meta field for '${pattern}'`));
          continue;
        }

        Object.assign(peerDependencyMeta, {
          optional
        });
      }
    }

    if (typeof data.resolutions === `object` && data.resolutions !== null) {
      for (const [pattern, reference] of Object.entries(data.resolutions)) {
        if (typeof reference !== `string`) {
          errors.push(new Error(`Invalid resolution entry for '${pattern}'`));
          continue;
        }

        try {
          this.resolutions.push({
            pattern: $0e609d03a5066ebec776a5ec6a49b084$exports.parseResolution(pattern),
            reference
          });
        } catch (error) {
          errors.push(error);
          continue;
        }
      }
    }

    if (Array.isArray(data.files)) {
      this.files = new Set();

      for (const filename of data.files) {
        if (typeof filename !== `string`) {
          errors.push(new Error(`Invalid files entry for '${filename}'`));
          continue;
        }

        this.files.add(filename);
      }
    }

    if (typeof data.publishConfig === `object` && data.publishConfig !== null) {
      this.publishConfig = {};
      if (typeof data.publishConfig.access === `string`) this.publishConfig.access = data.publishConfig.access;
      if (typeof data.publishConfig.main === `string`) this.publishConfig.main = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.publishConfig.main);
      if (typeof data.publishConfig.module === `string`) this.publishConfig.module = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.publishConfig.module);

      if (data.publishConfig.browser != null) {
        if (typeof data.publishConfig.browser === `string`) {
          this.publishConfig.browser = $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.publishConfig.browser);
        } else {
          this.publishConfig.browser = new Map();

          for (const [key, value] of Object.entries(data.publishConfig.browser)) {
            this.publishConfig.browser.set($e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(key), typeof value === `string` ? $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(value) : value);
          }
        }
      }

      if (typeof data.publishConfig.registry === `string`) this.publishConfig.registry = data.publishConfig.registry;

      if (typeof data.publishConfig.bin === `string`) {
        if (this.name !== null) {
          this.publishConfig.bin = new Map([[this.name.name, $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(data.publishConfig.bin)]]);
        } else {
          errors.push(new Error(`String bin field, but no attached package name`));
        }
      } else if (typeof data.publishConfig.bin === `object` && data.publishConfig.bin !== null) {
        this.publishConfig.bin = new Map();

        for (const [key, value] of Object.entries(data.publishConfig.bin)) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid bin definition for '${key}'`));
            continue;
          }

          this.publishConfig.bin.set(key, $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(value));
        }
      }

      if (Array.isArray(data.publishConfig.executableFiles)) {
        this.publishConfig.executableFiles = new Set();

        for (const value of data.publishConfig.executableFiles) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid executable file definition`));
            continue;
          }

          this.publishConfig.executableFiles.add($e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(value));
        }
      }
    }

    if (typeof data.installConfig === `object` && data.installConfig !== null) {
      this.installConfig = {};

      for (const key of Object.keys(data.installConfig)) {
        if (key === `hoistingLimits`) {
          if (typeof data.installConfig.hoistingLimits === `string`) {
            this.installConfig.hoistingLimits = data.installConfig.hoistingLimits;
          } else {
            errors.push(new Error(`Invalid hoisting limits definition`));
          }
        } else {
          errors.push(new Error(`Unrecognized installConfig key: ${key}`));
        }
      }
    } // We treat optional dependencies after both the regular dependency field
    // and the dependenciesMeta field have been generated (because we will
    // override them)


    // We treat optional dependencies after both the regular dependency field
    // and the dependenciesMeta field have been generated (because we will
    // override them)
    if (typeof data.optionalDependencies === `object` && data.optionalDependencies !== null) {
      for (const [name, range] of Object.entries(data.optionalDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        } // Note that we store the optional dependencies in the same store as
        // the one that keep the regular dependencies, because they're
        // effectively the same (the only difference is that optional
        // dependencies have an extra field set in dependenciesMeta).


        // Note that we store the optional dependencies in the same store as
        // the one that keep the regular dependencies, because they're
        // effectively the same (the only difference is that optional
        // dependencies have an extra field set in dependenciesMeta).
        const realDescriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor(ident, range);
        this.dependencies.set(realDescriptor.identHash, realDescriptor);
        const identDescriptor = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor(ident, `unknown`);
        const dependencyMeta = this.ensureDependencyMeta(identDescriptor);
        Object.assign(dependencyMeta, {
          optional: true
        });
      }
    }

    if (typeof data.preferUnplugged === `boolean`) this.preferUnplugged = data.preferUnplugged;
    this.errors = errors;
  }

  getForScope(type) {
    switch (type) {
      case `dependencies`:
        return this.dependencies;

      case `devDependencies`:
        return this.devDependencies;

      case `peerDependencies`:
        return this.peerDependencies;

      default:
        {
          throw new Error(`Unsupported value ("${type}")`);
        }
    }
  }

  hasConsumerDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasHardDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.devDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasSoftDependency(ident) {
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasDependency(ident) {
    if (this.hasHardDependency(ident)) return true;
    if (this.hasSoftDependency(ident)) return true;
    return false;
  }

  isCompatibleWithOS(os) {
    return $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.isManifestFieldCompatible(this.os, os);
  }

  isCompatibleWithCPU(cpu) {
    return $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.isManifestFieldCompatible(this.cpu, cpu);
  }

  ensureDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown` && !$e51f99366c3d7ff19a0ceeed21bc69c1$var$semver_1.default.valid(descriptor.range)) throw new Error(`Invalid meta field range for '${$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyDescriptor(descriptor)}'`);
    const identString = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(descriptor);
    const range = descriptor.range !== `unknown` ? descriptor.range : null;
    let dependencyMetaSet = this.dependenciesMeta.get(identString);
    if (!dependencyMetaSet) this.dependenciesMeta.set(identString, dependencyMetaSet = new Map());
    let dependencyMeta = dependencyMetaSet.get(range);
    if (!dependencyMeta) dependencyMetaSet.set(range, dependencyMeta = {});
    return dependencyMeta;
  }

  ensurePeerDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown`) throw new Error(`Invalid meta field range for '${$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyDescriptor(descriptor)}'`);
    const identString = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(descriptor);
    let peerDependencyMeta = this.peerDependenciesMeta.get(identString);
    if (!peerDependencyMeta) this.peerDependenciesMeta.set(identString, peerDependencyMeta = {});
    return peerDependencyMeta;
  }

  setRawField(name, value, {
    after = []
  } = {}) {
    const afterSet = new Set(after.filter(key => {
      return Object.prototype.hasOwnProperty.call(this.raw, key);
    }));

    if (afterSet.size === 0 || Object.prototype.hasOwnProperty.call(this.raw, name)) {
      this.raw[name] = value;
    } else {
      const oldRaw = this.raw;
      const newRaw = this.raw = {};
      let inserted = false;

      for (const key of Object.keys(oldRaw)) {
        newRaw[key] = oldRaw[key];

        if (!inserted) {
          afterSet.delete(key);

          if (afterSet.size === 0) {
            newRaw[name] = value;
            inserted = true;
          }
        }
      }
    }
  }

  exportTo(data, {
    compatibilityMode = true
  } = {}) {
    // Note that we even set the fields that we re-set later; it
    // allows us to preserve the key ordering
    Object.assign(data, this.raw);
    if (this.name !== null) data.name = $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(this.name);else delete data.name;
    if (this.version !== null) data.version = this.version;else delete data.version;
    if (this.os !== null) data.os = this.os;else delete data.os;
    if (this.cpu !== null) data.cpu = this.cpu;else delete data.cpu;
    if (this.type !== null) data.type = this.type;else delete data.type;
    if (this.private) data.private = true;else delete data.private;
    if (this.license !== null) data.license = this.license;else delete data.license;
    if (this.languageName !== null) data.languageName = this.languageName;else delete data.languageName;
    if (this.main !== null) data.main = this.main;else delete data.main;
    if (this.module !== null) data.module = this.module;else delete data.module;

    if (this.browser !== null) {
      const browser = this.browser;

      if (typeof browser === `string`) {
        data.browser = browser;
      } else if (browser instanceof Map) {
        data.browser = Object.assign({}, ...Array.from(browser.keys()).sort().map(name => {
          return {
            [name]: browser.get(name)
          };
        }));
      }
    } else {
      delete data.browser;
    }

    if (this.bin.size === 1 && this.name !== null && this.bin.has(this.name.name)) {
      data.bin = this.bin.get(this.name.name);
    } else if (this.bin.size > 0) {
      data.bin = Object.assign({}, ...Array.from(this.bin.keys()).sort().map(name => {
        return {
          [name]: this.bin.get(name)
        };
      }));
    } else {
      delete data.bin;
    }

    if (this.workspaceDefinitions.length > 0) {
      if (this.raw.workspaces && !Array.isArray(this.raw.workspaces)) {
        data.workspaces = { ...this.raw.workspaces,
          packages: this.workspaceDefinitions.map(({
            pattern
          }) => pattern)
        };
      } else {
        data.workspaces = this.workspaceDefinitions.map(({
          pattern
        }) => pattern);
      }
    } else if (this.raw.workspaces && !Array.isArray(this.raw.workspaces) && Object.keys(this.raw.workspaces).length > 0) {
      data.workspaces = this.raw.workspaces;
    } else {
      delete data.workspaces;
    }

    const regularDependencies = [];
    const optionalDependencies = [];

    for (const dependency of this.dependencies.values()) {
      const dependencyMetaSet = this.dependenciesMeta.get($e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(dependency));
      let isOptionallyBuilt = false;

      if (compatibilityMode) {
        if (dependencyMetaSet) {
          const meta = dependencyMetaSet.get(null);

          if (meta && meta.optional) {
            isOptionallyBuilt = true;
          }
        }
      }

      if (isOptionallyBuilt) {
        optionalDependencies.push(dependency);
      } else {
        regularDependencies.push(dependency);
      }
    }

    if (regularDependencies.length > 0) {
      data.dependencies = Object.assign({}, ...$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.sortDescriptors(regularDependencies).map(dependency => {
        return {
          [$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.dependencies;
    }

    if (optionalDependencies.length > 0) {
      data.optionalDependencies = Object.assign({}, ...$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.sortDescriptors(optionalDependencies).map(dependency => {
        return {
          [$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.optionalDependencies;
    }

    if (this.devDependencies.size > 0) {
      data.devDependencies = Object.assign({}, ...$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.sortDescriptors(this.devDependencies.values()).map(dependency => {
        return {
          [$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.devDependencies;
    }

    if (this.peerDependencies.size > 0) {
      data.peerDependencies = Object.assign({}, ...$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.sortDescriptors(this.peerDependencies.values()).map(dependency => {
        return {
          [$e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.peerDependencies;
    }

    data.dependenciesMeta = {};

    for (const [identString, dependencyMetaSet] of $e51f99366c3d7ff19a0ceeed21bc69c1$var$miscUtils.sortMap(this.dependenciesMeta.entries(), ([identString, dependencyMetaSet]) => identString)) {
      for (const [range, meta] of $e51f99366c3d7ff19a0ceeed21bc69c1$var$miscUtils.sortMap(dependencyMetaSet.entries(), ([range, meta]) => range !== null ? `0${range}` : `1`)) {
        const key = range !== null ? $e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.stringifyDescriptor($e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.makeDescriptor($e51f99366c3d7ff19a0ceeed21bc69c1$var$structUtils.parseIdent(identString), range)) : identString;
        const metaCopy = { ...meta
        };
        if (compatibilityMode && range === null) delete metaCopy.optional;
        if (Object.keys(metaCopy).length === 0) continue;
        data.dependenciesMeta[key] = metaCopy;
      }
    }

    if (Object.keys(data.dependenciesMeta).length === 0) delete data.dependenciesMeta;

    if (this.peerDependenciesMeta.size > 0) {
      data.peerDependenciesMeta = Object.assign({}, ...$e51f99366c3d7ff19a0ceeed21bc69c1$var$miscUtils.sortMap(this.peerDependenciesMeta.entries(), ([identString, meta]) => identString).map(([identString, meta]) => {
        return {
          [identString]: meta
        };
      }));
    } else {
      delete data.peerDependenciesMeta;
    }

    if (this.resolutions.length > 0) {
      data.resolutions = Object.assign({}, ...this.resolutions.map(({
        pattern,
        reference
      }) => {
        return {
          [$0e609d03a5066ebec776a5ec6a49b084$exports.stringifyResolution(pattern)]: reference
        };
      }));
    } else {
      delete data.resolutions;
    }

    if (this.files !== null) data.files = Array.from(this.files);else delete data.files;
    if (this.preferUnplugged !== null) data.preferUnplugged = this.preferUnplugged;else delete data.preferUnplugged;
    return data;
  }

}

$e51f99366c3d7ff19a0ceeed21bc69c1$export$Manifest = $e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest;
$e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest = $e51f99366c3d7ff19a0ceeed21bc69c1$export$Manifest;
$e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.fileName = `package.json`;
$e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.allDependencies = [`dependencies`, `devDependencies`, `peerDependencies`];
$e51f99366c3d7ff19a0ceeed21bc69c1$var$Manifest.hardDependencies = [`dependencies`, `devDependencies`];

function $e51f99366c3d7ff19a0ceeed21bc69c1$var$getIndent(content) {
  const indentMatch = content.match(/^[ \t]+/m);

  if (indentMatch) {
    return indentMatch[0];
  } else {
    return `  `;
  }
}

function $e51f99366c3d7ff19a0ceeed21bc69c1$var$stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    return content.slice(1);
  } else {
    return content;
  }
}

function $e51f99366c3d7ff19a0ceeed21bc69c1$var$normalizeSlashes(str) {
  return str.replace(/\\/g, `/`);
}

function $e51f99366c3d7ff19a0ceeed21bc69c1$var$tryParseOptionalBoolean(value, {
  yamlCompatibilityMode
}) {
  if (yamlCompatibilityMode) return $e51f99366c3d7ff19a0ceeed21bc69c1$var$miscUtils.tryParseOptionalBoolean(value);
  if (typeof value === `undefined` || typeof value === `boolean`) return value;
  return null;
}

// ASSET: node_modules/@yarnpkg/core/lib/Report.js
var $9baf3138444c7a279b4b3775d56e5534$exports = {};
Object.defineProperty($9baf3138444c7a279b4b3775d56e5534$exports, "__esModule", {
  value: true
});
var $9baf3138444c7a279b4b3775d56e5534$export$Report = ($9baf3138444c7a279b4b3775d56e5534$export$isReportError = ($9baf3138444c7a279b4b3775d56e5534$export$ReportError = void 0, $9baf3138444c7a279b4b3775d56e5534$exports.ReportError = $9baf3138444c7a279b4b3775d56e5534$export$ReportError), $9baf3138444c7a279b4b3775d56e5534$exports.isReportError = $9baf3138444c7a279b4b3775d56e5534$export$isReportError);
$9baf3138444c7a279b4b3775d56e5534$exports.Report = $9baf3138444c7a279b4b3775d56e5534$export$Report;
const $9baf3138444c7a279b4b3775d56e5534$var$string_decoder_1 = $9902be2109033b88050ebe7f370f9452$init();

class $9baf3138444c7a279b4b3775d56e5534$var$ReportError extends Error {
  constructor(code, message, reportExtra) {
    super(message);
    this.reportExtra = reportExtra;
    this.reportCode = code;
  }

}

var $9baf3138444c7a279b4b3775d56e5534$export$ReportError = $9baf3138444c7a279b4b3775d56e5534$var$ReportError;
$9baf3138444c7a279b4b3775d56e5534$exports.ReportError = $9baf3138444c7a279b4b3775d56e5534$export$ReportError;

function $9baf3138444c7a279b4b3775d56e5534$var$isReportError(error) {
  return typeof error.reportCode !== `undefined`;
}

var $9baf3138444c7a279b4b3775d56e5534$export$isReportError = $9baf3138444c7a279b4b3775d56e5534$var$isReportError;
$9baf3138444c7a279b4b3775d56e5534$exports.isReportError = $9baf3138444c7a279b4b3775d56e5534$export$isReportError;

class $9baf3138444c7a279b4b3775d56e5534$var$Report {
  constructor() {
    this.reportedInfos = new Set();
    this.reportedWarnings = new Set();
    this.reportedErrors = new Set();
  }

  static progressViaCounter(max) {
    let current = 0;
    let unlock;
    let lock = new Promise(resolve => {
      unlock = resolve;
    });

    const set = n => {
      const thisUnlock = unlock;
      lock = new Promise(resolve => {
        unlock = resolve;
      });
      current = n;
      thisUnlock();
    };

    const tick = (n = 0) => {
      set(current + 1);
    };

    const gen = async function* () {
      while (current < max) {
        await lock;
        yield {
          progress: current / max
        };
      }
    }();

    return {
      [Symbol.asyncIterator]() {
        return gen;
      },

      set,
      tick
    };
  }

  reportInfoOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedInfos.has(key)) {
      this.reportedInfos.add(key);
      this.reportInfo(name, text);
    }
  }

  reportWarningOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedWarnings.has(key)) {
      this.reportedWarnings.add(key);
      this.reportWarning(name, text);
    }
  }

  reportErrorOnce(name, text, opts) {
    var _a;

    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedErrors.has(key)) {
      this.reportedErrors.add(key);
      this.reportError(name, text);
      (_a = opts === null || opts === void 0 ? void 0 : opts.reportExtra) === null || _a === void 0 ? void 0 : _a.call(opts, this);
    }
  }

  reportExceptionOnce(error) {
    if ($9baf3138444c7a279b4b3775d56e5534$var$isReportError(error)) {
      this.reportErrorOnce(error.reportCode, error.message, {
        key: error,
        reportExtra: error.reportExtra
      });
    } else {
      this.reportErrorOnce($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.EXCEPTION, error.stack || error.message, {
        key: error
      });
    }
  }

  createStreamReporter(prefix = null) {
    const stream = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough();
    const decoder = new $9baf3138444c7a279b4b3775d56e5534$var$string_decoder_1.StringDecoder();
    let buffer = ``;
    stream.on(`data`, chunk => {
      let chunkStr = decoder.write(chunk);
      let lineIndex;

      do {
        lineIndex = chunkStr.indexOf(`\n`);

        if (lineIndex !== -1) {
          const line = buffer + chunkStr.substr(0, lineIndex);
          chunkStr = chunkStr.substr(lineIndex + 1);
          buffer = ``;

          if (prefix !== null) {
            this.reportInfo(null, `${prefix} ${line}`);
          } else {
            this.reportInfo(null, line);
          }
        }
      } while (lineIndex !== -1);

      buffer += chunkStr;
    });
    stream.on(`end`, () => {
      const last = decoder.end();

      if (last !== ``) {
        if (prefix !== null) {
          this.reportInfo(null, `${prefix} ${last}`);
        } else {
          this.reportInfo(null, last);
        }
      }
    });
    return stream;
  }

}

$9baf3138444c7a279b4b3775d56e5534$export$Report = $9baf3138444c7a279b4b3775d56e5534$var$Report;
$9baf3138444c7a279b4b3775d56e5534$exports.Report = $9baf3138444c7a279b4b3775d56e5534$export$Report;
// ASSET: node_modules/@yarnpkg/core/lib/StreamReport.js
var $4aa00afc119f35e9c4530bef5e53f2e3$exports = {};
var $4aa00afc119f35e9c4530bef5e53f2e3$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($4aa00afc119f35e9c4530bef5e53f2e3$exports, "__esModule", {
  value: true
});
var $4aa00afc119f35e9c4530bef5e53f2e3$export$StreamReport = ($4aa00afc119f35e9c4530bef5e53f2e3$export$formatNameWithHyperlink = ($4aa00afc119f35e9c4530bef5e53f2e3$export$formatName = void 0, $4aa00afc119f35e9c4530bef5e53f2e3$exports.formatName = $4aa00afc119f35e9c4530bef5e53f2e3$export$formatName), $4aa00afc119f35e9c4530bef5e53f2e3$exports.formatNameWithHyperlink = $4aa00afc119f35e9c4530bef5e53f2e3$export$formatNameWithHyperlink);
$4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport = $4aa00afc119f35e9c4530bef5e53f2e3$export$StreamReport;
const $4aa00afc119f35e9c4530bef5e53f2e3$var$slice_ansi_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault({});
const $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
const $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_FRAMES = [``, ``, ``, ``, ``, ``, ``, ``, ``, ``];
const $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_INTERVAL = 80;
const $4aa00afc119f35e9c4530bef5e53f2e3$var$BASE_FORGETTABLE_NAMES = new Set([$3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FETCH_NOT_CACHED, $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNUSED_CACHE_ENTRY]);
const $4aa00afc119f35e9c4530bef5e53f2e3$var$BASE_FORGETTABLE_BUFFER_SIZE = 5;
const $4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP = undefined ? {
  start: what => `::group::${what}\n`,
  end: what => `::endgroup::\n`
} : undefined ? {
  start: what => `travis_fold:start:${what}\n`,
  end: what => `travis_fold:end:${what}\n`
} : undefined ? {
  start: what => `section_start:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K${what}\n`,
  end: what => `section_end:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K`
} : null;
const $4aa00afc119f35e9c4530bef5e53f2e3$var$now = new Date(); // We only want to support environments that will out-of-the-box accept the
// characters we want to use. Others can enforce the style from the project
// configuration.

// We only want to support environments that will out-of-the-box accept the
// characters we want to use. Others can enforce the style from the project
// configuration.
const $4aa00afc119f35e9c4530bef5e53f2e3$var$supportsEmojis = [`iTerm.app`, `Apple_Terminal`].includes(undefined) || !!undefined;

const $4aa00afc119f35e9c4530bef5e53f2e3$var$makeRecord = obj => obj;

const $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_STYLES = $4aa00afc119f35e9c4530bef5e53f2e3$var$makeRecord({
  patrick: {
    date: [17, 3],
    chars: [``, ``],
    size: 40
  },
  simba: {
    date: [19, 7],
    chars: [``, ``],
    size: 40
  },
  jack: {
    date: [31, 10],
    chars: [``, ``],
    size: 40
  },
  hogsfather: {
    date: [31, 12],
    chars: [``, ``],
    size: 40
  },
  default: {
    chars: [`=`, `-`],
    size: 80
  }
});
const $4aa00afc119f35e9c4530bef5e53f2e3$var$defaultStyle = $4aa00afc119f35e9c4530bef5e53f2e3$var$supportsEmojis && Object.keys($4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_STYLES).find(name => {
  const style = $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_STYLES[name];
  if (style.date && (style.date[0] !== $4aa00afc119f35e9c4530bef5e53f2e3$var$now.getDate() || style.date[1] !== $4aa00afc119f35e9c4530bef5e53f2e3$var$now.getMonth() + 1)) return false;
  return true;
}) || `default`;

function $4aa00afc119f35e9c4530bef5e53f2e3$var$formatName(name, {
  configuration,
  json
}) {
  const num = name === null ? 0 : name;
  const label = $3d67898ffca54ab381ec6b3d32821fc7$exports.stringifyMessageName(num);

  if (!json && name === null) {
    return $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(configuration, label, `grey`);
  } else {
    return label;
  }
}

var $4aa00afc119f35e9c4530bef5e53f2e3$export$formatName = $4aa00afc119f35e9c4530bef5e53f2e3$var$formatName;
$4aa00afc119f35e9c4530bef5e53f2e3$exports.formatName = $4aa00afc119f35e9c4530bef5e53f2e3$export$formatName;

function $4aa00afc119f35e9c4530bef5e53f2e3$var$formatNameWithHyperlink(name, {
  configuration,
  json
}) {
  const code = $4aa00afc119f35e9c4530bef5e53f2e3$var$formatName(name, {
    configuration,
    json
  }); // Only print hyperlinks if allowed per configuration

  // Only print hyperlinks if allowed per configuration
  if (!configuration.get(`enableHyperlinks`)) return code; // Don't print hyperlinks for the generic messages

  // Don't print hyperlinks for the generic messages
  if (name === null || name === $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED) return code;
  const desc = $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName[name];
  const href = `https://yarnpkg.com/advanced/error-codes#${code}---${desc}`.toLowerCase(); // We use BELL as ST because it seems that iTerm doesn't properly support
  // the \x1b\\ sequence described in the reference document
  // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda#the-escape-sequence

  // We use BELL as ST because it seems that iTerm doesn't properly support
  // the \x1b\\ sequence described in the reference document
  // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda#the-escape-sequence
  return `\u001b]8;;${href}\u0007${code}\u001b]8;;\u0007`;
}

var $4aa00afc119f35e9c4530bef5e53f2e3$export$formatNameWithHyperlink = $4aa00afc119f35e9c4530bef5e53f2e3$var$formatNameWithHyperlink;
$4aa00afc119f35e9c4530bef5e53f2e3$exports.formatNameWithHyperlink = $4aa00afc119f35e9c4530bef5e53f2e3$export$formatNameWithHyperlink;

class $4aa00afc119f35e9c4530bef5e53f2e3$var$StreamReport extends $9baf3138444c7a279b4b3775d56e5534$exports.Report {
  constructor({
    configuration,
    stdout,
    json = false,
    includeFooter = true,
    includeLogs = !json,
    includeInfos = includeLogs,
    includeWarnings = includeLogs,
    forgettableBufferSize = $4aa00afc119f35e9c4530bef5e53f2e3$var$BASE_FORGETTABLE_BUFFER_SIZE,
    forgettableNames = new Set()
  }) {
    super();
    this.uncommitted = new Set();
    this.cacheHitCount = 0;
    this.cacheMissCount = 0;
    this.warningCount = 0;
    this.errorCount = 0;
    this.startTime = Date.now();
    this.indent = 0;
    this.progress = new Map();
    this.progressTime = 0;
    this.progressFrame = 0;
    this.progressTimeout = null;
    this.forgettableLines = [];
    $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.addLogFilterSupport(this, {
      configuration
    });
    this.configuration = configuration;
    this.forgettableBufferSize = forgettableBufferSize;
    this.forgettableNames = new Set([...forgettableNames, ...$4aa00afc119f35e9c4530bef5e53f2e3$var$BASE_FORGETTABLE_NAMES]);
    this.includeFooter = includeFooter;
    this.includeInfos = includeInfos;
    this.includeWarnings = includeWarnings;
    this.json = json;
    this.stdout = stdout;
    const styleName = this.configuration.get(`progressBarStyle`) || $4aa00afc119f35e9c4530bef5e53f2e3$var$defaultStyle;
    if (!Object.prototype.hasOwnProperty.call($4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_STYLES, styleName)) throw new Error(`Assertion failed: Invalid progress bar style`);
    this.progressStyle = $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_STYLES[styleName];
    const PAD_LEFT = ` YN0000:  `.length;
    const maxWidth = Math.max(0, Math.min(80 - PAD_LEFT, 80));
    this.progressMaxScaledSize = Math.floor(this.progressStyle.size * maxWidth / 80);
  }

  static async start(opts, cb) {
    const report = new this(opts);
    const emitWarning = $4aa00afc119f35e9c4530bef5e53f2e3$var$process.emitWarning;

    $4aa00afc119f35e9c4530bef5e53f2e3$var$process.emitWarning = (message, name) => {
      if (typeof message !== `string`) {
        const error = message;
        message = error.message;
        name = name !== null && name !== void 0 ? name : error.name;
      }

      const fullMessage = typeof name !== `undefined` ? `${name}: ${message}` : message;
      report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, fullMessage);
    };

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
      $4aa00afc119f35e9c4530bef5e53f2e3$var$process.emitWarning = emitWarning;
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {
    this.cacheHitCount += 1;
  }

  reportCacheMiss(locator, message) {
    this.cacheMissCount += 1;

    if (typeof message !== `undefined` && !this.configuration.get(`preferAggregateCacheInfo`)) {
      this.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FETCH_NOT_CACHED, message);
    }
  }

  startTimerSync(what, opts, cb) {
    const realOpts = typeof opts === `function` ? {} : opts;
    const realCb = typeof opts === `function` ? opts : cb;
    const mark = {
      committed: false,
      action: () => {
        this.reportInfo(null, ` ${what}`);
        this.indent += 1;

        if ($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP !== null) {
          this.stdout.write($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP.start(what));
        }
      }
    };

    if (realOpts.skipIfEmpty) {
      this.uncommitted.add(mark);
    } else {
      mark.action();
      mark.committed = true;
    }

    const before = Date.now();

    try {
      return realCb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.uncommitted.delete(mark);

      if (mark.committed) {
        this.indent -= 1;
        if ($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP !== null) this.stdout.write($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP.end(what));

        if (this.configuration.get(`enableTimers`) && after - before > 200) {
          this.reportInfo(null, ` Completed in ${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, after - before, $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.Type.DURATION)}`);
        } else {
          this.reportInfo(null, ` Completed`);
        }
      }
    }
  }

  async startTimerPromise(what, opts, cb) {
    const realOpts = typeof opts === `function` ? {} : opts;
    const realCb = typeof opts === `function` ? opts : cb;
    const mark = {
      committed: false,
      action: () => {
        this.reportInfo(null, ` ${what}`);
        this.indent += 1;

        if ($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP !== null) {
          this.stdout.write($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP.start(what));
        }
      }
    };

    if (realOpts.skipIfEmpty) {
      this.uncommitted.add(mark);
    } else {
      mark.action();
      mark.committed = true;
    }

    const before = Date.now();

    try {
      return await realCb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.uncommitted.delete(mark);

      if (mark.committed) {
        this.indent -= 1;
        if ($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP !== null) this.stdout.write($4aa00afc119f35e9c4530bef5e53f2e3$var$GROUP.end(what));

        if (this.configuration.get(`enableTimers`) && after - before > 200) {
          this.reportInfo(null, ` Completed in ${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, after - before, $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.Type.DURATION)}`);
        } else {
          this.reportInfo(null, ` Completed`);
        }
      }
    }
  }

  async startCacheReport(cb) {
    const cacheInfo = this.configuration.get(`preferAggregateCacheInfo`) ? {
      cacheHitCount: this.cacheHitCount,
      cacheMissCount: this.cacheMissCount
    } : null;

    try {
      return await cb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      if (cacheInfo !== null) {
        this.reportCacheChanges(cacheInfo);
      }
    }
  }

  reportSeparator() {
    if (this.indent === 0) {
      this.writeLineWithForgettableReset(``);
    } else {
      this.reportInfo(null, ``);
    }
  }

  reportInfo(name, text) {
    if (!this.includeInfos) return;
    this.commit();
    const message = `${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, ``, `blueBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`;

    if (!this.json) {
      if (this.forgettableNames.has(name)) {
        this.forgettableLines.push(message);

        if (this.forgettableLines.length > this.forgettableBufferSize) {
          while (this.forgettableLines.length > this.forgettableBufferSize) this.forgettableLines.shift();

          this.writeLines(this.forgettableLines, {
            truncate: true
          });
        } else {
          this.writeLine(message, {
            truncate: true
          });
        }
      } else {
        this.writeLineWithForgettableReset(message);
      }
    } else {
      this.reportJson({
        type: `info`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportWarning(name, text) {
    this.warningCount += 1;
    if (!this.includeWarnings) return;
    this.commit();

    if (!this.json) {
      this.writeLineWithForgettableReset(`${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, ``, `yellowBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`);
    } else {
      this.reportJson({
        type: `warning`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportError(name, text) {
    this.errorCount += 1;
    this.commit();

    if (!this.json) {
      this.writeLineWithForgettableReset(`${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, ``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`, {
        truncate: false
      });
    } else {
      this.reportJson({
        type: `error`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportProgress(progressIt) {
    let stopped = false;
    const promise = Promise.resolve().then(async () => {
      const progressDefinition = {
        progress: 0,
        title: undefined
      };
      this.progress.set(progressIt, {
        definition: progressDefinition,
        lastScaledSize: -1
      });
      this.refreshProgress(-1);

      for await (const {
        progress,
        title
      } of progressIt) {
        if (stopped) continue;
        if (progressDefinition.progress === progress && progressDefinition.title === title) continue;
        progressDefinition.progress = progress;
        progressDefinition.title = title;
        this.refreshProgress();
      }

      stop();
    });

    const stop = () => {
      if (stopped) return;
      stopped = true;
      this.progress.delete(progressIt);
      this.refreshProgress(+1);
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {
    if (this.json) {
      this.writeLineWithForgettableReset(`${JSON.stringify(data)}`);
    }
  }

  async finalize() {
    if (!this.includeFooter) return;
    let installStatus = ``;
    if (this.errorCount > 0) installStatus = `Failed with errors`;else if (this.warningCount > 0) installStatus = `Done with warnings`;else installStatus = `Done`;
    const timing = $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, Date.now() - this.startTime, $4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.Type.DURATION);
    const message = this.configuration.get(`enableTimers`) ? `${installStatus} in ${timing}` : installStatus;

    if (this.errorCount > 0) {
      this.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, message);
    } else if (this.warningCount > 0) {
      this.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, message);
    } else {
      this.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, message);
    }
  }

  writeLine(str, {
    truncate
  } = {}) {
    this.clearProgress({
      clear: true
    });
    this.stdout.write(`${this.truncate(str, {
      truncate
    })}\n`);
    this.writeProgress();
  }

  writeLineWithForgettableReset(str, {
    truncate
  } = {}) {
    this.forgettableLines = [];
    this.writeLine(str, {
      truncate
    });
  }

  writeLines(lines, {
    truncate
  } = {}) {
    this.clearProgress({
      delta: lines.length
    });

    for (const line of lines) this.stdout.write(`${this.truncate(line, {
      truncate
    })}\n`);

    this.writeProgress();
  }

  reportCacheChanges({
    cacheHitCount,
    cacheMissCount
  }) {
    const cacheHitDelta = this.cacheHitCount - cacheHitCount;
    const cacheMissDelta = this.cacheMissCount - cacheMissCount;
    if (cacheHitDelta === 0 && cacheMissDelta === 0) return;
    let fetchStatus = ``;
    if (this.cacheHitCount > 1) fetchStatus += `${this.cacheHitCount} packages were already cached`;else if (this.cacheHitCount === 1) fetchStatus += ` - one package was already cached`;else fetchStatus += `No packages were cached`;

    if (this.cacheHitCount > 0) {
      if (this.cacheMissCount > 1) {
        fetchStatus += `, ${this.cacheMissCount} had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += `, one had to be fetched`;
      }
    } else {
      if (this.cacheMissCount > 1) {
        fetchStatus += ` - ${this.cacheMissCount} packages had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += ` - one package had to be fetched`;
      }
    }

    this.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FETCH_NOT_CACHED, fetchStatus);
  }

  commit() {
    const marks = this.uncommitted;
    this.uncommitted = new Set();

    for (const mark of marks) {
      mark.committed = true;
      mark.action();
    }
  }

  clearProgress({
    delta = 0,
    clear = false
  }) {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;

    if (this.progress.size + delta > 0) {
      this.stdout.write(`\x1b[${this.progress.size + delta}A`);

      if (delta > 0 || clear) {
        this.stdout.write(`\x1b[0J`);
      }
    }
  }

  writeProgress() {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;
    if (this.progressTimeout !== null) clearTimeout(this.progressTimeout);
    this.progressTimeout = null;
    if (this.progress.size === 0) return;
    const now = Date.now();

    if (now - this.progressTime > $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_INTERVAL) {
      this.progressFrame = (this.progressFrame + 1) % $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_FRAMES.length;
      this.progressTime = now;
    }

    const spinner = $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_FRAMES[this.progressFrame];

    for (const progress of this.progress.values()) {
      const ok = this.progressStyle.chars[0].repeat(progress.lastScaledSize);
      const ko = this.progressStyle.chars[1].repeat(this.progressMaxScaledSize - progress.lastScaledSize);
      this.stdout.write(`${$4aa00afc119f35e9c4530bef5e53f2e3$var$formatUtils.pretty(this.configuration, ``, `blueBright`)} ${this.formatName(null)}: ${spinner} ${ok}${ko}\n`);
    }

    this.progressTimeout = setTimeout(() => {
      this.refreshProgress();
    }, $4aa00afc119f35e9c4530bef5e53f2e3$var$PROGRESS_INTERVAL);
  }

  refreshProgress(delta = 0) {
    let needsUpdate = false;

    if (this.progress.size === 0) {
      needsUpdate = true;
    } else {
      for (const progress of this.progress.values()) {
        const refreshedScaledSize = Math.trunc(this.progressMaxScaledSize * progress.definition.progress);
        const previousScaledSize = progress.lastScaledSize;
        progress.lastScaledSize = refreshedScaledSize;

        if (refreshedScaledSize !== previousScaledSize) {
          needsUpdate = true;
          break;
        }
      }
    }

    if (needsUpdate) {
      this.clearProgress({
        delta
      });
      this.writeProgress();
    }
  }

  truncate(str, {
    truncate
  } = {}) {
    if (!this.configuration.get(`enableProgressBars`)) truncate = false;
    if (typeof truncate === `undefined`) truncate = this.configuration.get(`preferTruncatedLines`); // The -1 is to account for terminals that would wrap after
    // the last column rather before the first overwrite

    // The -1 is to account for terminals that would wrap after
    // the last column rather before the first overwrite
    if (truncate) str = $4aa00afc119f35e9c4530bef5e53f2e3$var$slice_ansi_1.default(str, 0, $4aa00afc119f35e9c4530bef5e53f2e3$var$process.stdout.columns - 1);
    return str;
  }

  formatName(name) {
    return $4aa00afc119f35e9c4530bef5e53f2e3$var$formatName(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatNameWithHyperlink(name) {
    return $4aa00afc119f35e9c4530bef5e53f2e3$var$formatNameWithHyperlink(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatIndent() {
    return ` `.repeat(this.indent);
  }

}

$4aa00afc119f35e9c4530bef5e53f2e3$export$StreamReport = $4aa00afc119f35e9c4530bef5e53f2e3$var$StreamReport;
$4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport = $4aa00afc119f35e9c4530bef5e53f2e3$export$StreamReport;
// ASSET: node_modules/@yarnpkg/core/lib/YarnVersion.js
var $20f6fdfeae1ebf083311e47fc70a4ef9$exports = {};
Object.defineProperty($20f6fdfeae1ebf083311e47fc70a4ef9$exports, "__esModule", {
  value: true
});
var $20f6fdfeae1ebf083311e47fc70a4ef9$export$YarnVersion = void 0;
$20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion = $20f6fdfeae1ebf083311e47fc70a4ef9$export$YarnVersion;
$20f6fdfeae1ebf083311e47fc70a4ef9$export$YarnVersion = typeof YARN_VERSION !== `undefined` ? YARN_VERSION : null;
$20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion = $20f6fdfeae1ebf083311e47fc70a4ef9$export$YarnVersion;
const $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($a1aaa55bbb549bd0e69fc516a4c245d6$exports);
const $6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
const $6881e9a961a5fe3922a1e41f40f331a3$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
const $6881e9a961a5fe3922a1e41f40f331a3$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
var $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager;

(function (PackageManager) {
  PackageManager["Yarn1"] = "Yarn Classic";
  PackageManager["Yarn2"] = "Yarn";
  PackageManager["Npm"] = "npm";
  PackageManager["Pnpm"] = "pnpm";
})($6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager || ($6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager = {}));

async function $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(location, name, argv0, args = []) {
  if ($6881e9a961a5fe3922a1e41f40f331a3$var$process.platform === `win32`) {
    await Promise.all([$ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.format({
      dir: location,
      name,
      ext: `.exe`
    }), binjumper_1.getBinjumper()), $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.format({
      dir: location,
      name,
      ext: `.exe.info`
    }), [argv0, ...args].join(`\n`)), $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.format({
      dir: location,
      name,
      ext: `.cmd`
    }), `@"${argv0}" ${args.map(arg => `"${arg.replace(`"`, `""`)}"`).join(` `)} %*\n`)]);
  }

  await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, name), `#!/bin/sh\nexec "${argv0}" ${args.map(arg => `'${arg.replace(/'/g, `'"'"'`)}'`).join(` `)} "$@"\n`);
  await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.chmodPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, name), 0o755);
}

async function $6881e9a961a5fe3922a1e41f40f331a3$var$detectPackageManager(location) {
  let yarnLock = null;

  try {
    yarnLock = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $ea9c1e38c3e8cca334929a597a084311$exports.Filename.lockfile), `utf8`);
  } catch (_a) {}

  if (yarnLock !== null) {
    if (yarnLock.match(/^__metadata:$/m)) {
      return $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Yarn2;
    } else {
      return $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Yarn1;
    }
  }

  if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, `package-lock.json`))) return $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Npm;
  if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, `pnpm-lock.yaml`))) return $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Pnpm;
  return null;
}

async function $6881e9a961a5fe3922a1e41f40f331a3$var$makeScriptEnv({
  project,
  binFolder,
  lifecycleScript
}) {
  const scriptEnv = {};

  for (const [key, value] of Object.entries($6881e9a961a5fe3922a1e41f40f331a3$var$process.env)) if (typeof value !== `undefined`) scriptEnv[key.toLowerCase() !== `path` ? key : `PATH`] = value;

  const nBinFolder = $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(binFolder); // We expose the base folder in the environment so that we can later add the
  // binaries for the dependencies of the active package

  // We expose the base folder in the environment so that we can later add the
  // binaries for the dependencies of the active package
  scriptEnv.BERRY_BIN_FOLDER = $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(nBinFolder); // Register some binaries that must be made available in all subprocesses
  // spawned by Yarn (we thus ensure that they always use the right version)

  // Register some binaries that must be made available in all subprocesses
  // spawned by Yarn (we thus ensure that they always use the right version)
  await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, `node`, $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath);

  if ($20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion !== null) {
    await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, `run`, $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [$6881e9a961a5fe3922a1e41f40f331a3$var$process.argv[1], `run`]);
    await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, `yarn`, $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [$6881e9a961a5fe3922a1e41f40f331a3$var$process.argv[1]]);
    await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, `yarnpkg`, $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [$6881e9a961a5fe3922a1e41f40f331a3$var$process.argv[1]]);
    await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, `node-gyp`, $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [$6881e9a961a5fe3922a1e41f40f331a3$var$process.argv[1], `run`, `--top-level`, `node-gyp`]);
  }

  if (project) scriptEnv.INIT_CWD = $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(project.configuration.startingCwd);
  scriptEnv.PATH = scriptEnv.PATH ? `${nBinFolder}${$ea9c1e38c3e8cca334929a597a084311$exports.npath.delimiter}${scriptEnv.PATH}` : `${nBinFolder}`;
  scriptEnv.npm_execpath = `${nBinFolder}${$ea9c1e38c3e8cca334929a597a084311$exports.npath.sep}yarn`;
  scriptEnv.npm_node_execpath = `${nBinFolder}${$ea9c1e38c3e8cca334929a597a084311$exports.npath.sep}node`;
  const version = $20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion !== null ? `yarn/${$20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion}` : `yarn/${$6881e9a961a5fe3922a1e41f40f331a3$var$miscUtils.dynamicRequire(`@yarnpkg/core`).version}-core`;
  scriptEnv.npm_config_user_agent = `${version} npm/? node/${$6881e9a961a5fe3922a1e41f40f331a3$var$process.versions.node} ${$6881e9a961a5fe3922a1e41f40f331a3$var$process.platform} ${$6881e9a961a5fe3922a1e41f40f331a3$var$process.arch}`;
  if (lifecycleScript) scriptEnv.npm_lifecycle_event = lifecycleScript;

  if (project) {
    await project.configuration.triggerHook(hook => hook.setupScriptEnvironment, project, scriptEnv, async (name, argv0, args) => {
      return await $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(name), argv0, args);
    });
  }

  return scriptEnv;
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$makeScriptEnv = $6881e9a961a5fe3922a1e41f40f331a3$var$makeScriptEnv;
$6881e9a961a5fe3922a1e41f40f331a3$exports.makeScriptEnv = $6881e9a961a5fe3922a1e41f40f331a3$export$makeScriptEnv;
/**
 * Given a folder, prepares this project for use. Runs `yarn install` then
 * `yarn build` if a `package.json` is found.
 */

/**
 * Given a folder, prepares this project for use. Runs `yarn install` then
 * `yarn build` if a `package.json` is found.
 */
const $6881e9a961a5fe3922a1e41f40f331a3$var$MAX_PREPARE_CONCURRENCY = 2;
const $6881e9a961a5fe3922a1e41f40f331a3$var$prepareLimit = $6881e9a961a5fe3922a1e41f40f331a3$var$p_limit_1.default($6881e9a961a5fe3922a1e41f40f331a3$var$MAX_PREPARE_CONCURRENCY);

async function $6881e9a961a5fe3922a1e41f40f331a3$var$prepareExternalProject(cwd, outputPath, {
  configuration,
  report,
  workspace = null
}) {
  await $6881e9a961a5fe3922a1e41f40f331a3$var$prepareLimit(async () => {
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async logDir => {
      const logFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(logDir, `pack.log`);
      const stdin = null;
      const {
        stdout,
        stderr
      } = configuration.getSubprocessStreams(logFile, {
        prefix: cwd,
        report
      });
      const packageManager = await $6881e9a961a5fe3922a1e41f40f331a3$var$detectPackageManager(cwd);
      let effectivePackageManager;

      if (packageManager !== null) {
        stdout.write(`Installing the project using ${packageManager}\n\n`);
        effectivePackageManager = packageManager;
      } else {
        stdout.write(`No package manager detected; defaulting to Yarn\n\n`);
        effectivePackageManager = $6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Yarn2;
      }

      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async binFolder => {
        const env = await $6881e9a961a5fe3922a1e41f40f331a3$var$makeScriptEnv({
          binFolder
        });
        const workflows = new Map([[$6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Yarn1, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // Makes sure that we'll be using Yarn 1.x

          // Makes sure that we'll be using Yarn 1.x
          const version = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`yarn`, [`set`, `version`, `classic`, `--only-if-needed`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.EndStrategy.ErrorCode
          });
          if (version.code !== 0) return version.code; // Otherwise Yarn 1 will pack the .yarn directory :(

          // Otherwise Yarn 1 will pack the .yarn directory :(
          await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.appendFilePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(cwd, `.npmignore`), `/.yarn\n`);
          stdout.write(`\n`); // Run an install; we can't avoid it unless we inspect the
          // package.json, which I don't want to do to keep the codebase
          // clean (even if it has a slight perf cost when cloning v1 repos)

          // Run an install; we can't avoid it unless we inspect the
          // package.json, which I don't want to do to keep the codebase
          // clean (even if it has a slight perf cost when cloning v1 repos)
          const install = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`yarn`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          stdout.write(`\n`);
          const pack = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`yarn`, [...workspaceCli, `pack`, `--filename`, $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [$6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Yarn2, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // We enable inline builds, because nobody wants to
          // read a logfile telling them to open another logfile

          // We enable inline builds, because nobody wants to
          // read a logfile telling them to open another logfile
          env.YARN_ENABLE_INLINE_BUILDS = `1`; // If a lockfile doesn't exist we create a empty one to
          // prevent the project root detection from thinking it's in an
          // undeclared workspace when the user has a lockfile in their home
          // directory on Windows

          // If a lockfile doesn't exist we create a empty one to
          // prevent the project root detection from thinking it's in an
          // undeclared workspace when the user has a lockfile in their home
          // directory on Windows
          const lockfilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(cwd, $ea9c1e38c3e8cca334929a597a084311$exports.Filename.lockfile);
          if (!(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsPromise(lockfilePath))) await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFilePromise(lockfilePath, ``); // Yarn 2 supports doing the install and the pack in a single command,
          // so we leverage that. We also don't need the "set version" call since
          // we're already operating within a Yarn 2 context (plus people should
          // really check-in their Yarn versions anyway).

          // Yarn 2 supports doing the install and the pack in a single command,
          // so we leverage that. We also don't need the "set version" call since
          // we're already operating within a Yarn 2 context (plus people should
          // really check-in their Yarn versions anyway).
          const pack = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`yarn`, [...workspaceCli, `pack`, `--install-if-needed`, `--filename`, $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [$6881e9a961a5fe3922a1e41f40f331a3$var$PackageManager.Npm, async () => {
          if (workspace !== null) throw new Error(`Workspaces aren't supported by npm, which has been detected as the primary package manager for ${cwd}`); // Otherwise npm won't properly set the user agent, using the Yarn
          // one instead

          // Otherwise npm won't properly set the user agent, using the Yarn
          // one instead
          delete env.npm_config_user_agent; // We can't use `npm ci` because some projects don't have npm
          // lockfiles that are up-to-date. Hopefully npm won't decide
          // to change the versions randomly.

          // We can't use `npm ci` because some projects don't have npm
          // lockfiles that are up-to-date. Hopefully npm won't decide
          // to change the versions randomly.
          const install = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`npm`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          const packStream = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough();
          const packPromise = $6881e9a961a5fe3922a1e41f40f331a3$var$miscUtils.bufferStream(packStream);
          packStream.pipe(stdout); // It seems that npm doesn't support specifying the pack output path,
          // so we have to extract the stdout on top of forking it to the logs.

          // It seems that npm doesn't support specifying the pack output path,
          // so we have to extract the stdout on top of forking it to the logs.
          const pack = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp(`npm`, [`pack`, `--silent`], {
            cwd,
            env,
            stdin,
            stdout: packStream,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          const packOutput = (await packPromise).toString().trim();
          const packTarget = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(cwd, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(packOutput)); // Only then can we move the pack to its rightful location

          // Only then can we move the pack to its rightful location
          await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.renamePromise(packTarget, outputPath);
          return 0;
        }]]);
        const workflow = workflows.get(effectivePackageManager);
        if (typeof workflow === `undefined`) throw new Error(`Assertion failed: Unsupported workflow`);
        const code = await workflow();
        if (code === 0 || typeof code === `undefined`) return;
        $ea9c1e38c3e8cca334929a597a084311$exports.xfs.detachTemp(logDir);
        throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.PACKAGE_PREPARATION_FAILED, `Packing the package failed (exit code ${code}, logs can be found here: ${logFile})`);
      });
    });
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$prepareExternalProject = $6881e9a961a5fe3922a1e41f40f331a3$var$prepareExternalProject;
$6881e9a961a5fe3922a1e41f40f331a3$exports.prepareExternalProject = $6881e9a961a5fe3922a1e41f40f331a3$export$prepareExternalProject;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$hasPackageScript(locator, scriptName, {
  project
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(project.configuration, locator)} not found in the project`);
  return await $ea9c1e38c3e8cca334929a597a084311$exports.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new $4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport({
        stdout: new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new $ea9c1e38c3e8cca334929a597a084311$exports.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest.find($ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot, {
      baseFs: packageFs
    });
    return manifest.scripts.has(scriptName);
  }, {
    libzip: await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise()
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$hasPackageScript = $6881e9a961a5fe3922a1e41f40f331a3$var$hasPackageScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.hasPackageScript = $6881e9a961a5fe3922a1e41f40f331a3$export$hasPackageScript;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageScript(locator, scriptName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async binFolder => {
    const {
      manifest,
      env,
      cwd: realCwd
    } = await $6881e9a961a5fe3922a1e41f40f331a3$var$initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd,
      lifecycleScript: scriptName
    });
    const script = manifest.scripts.get(scriptName);
    if (typeof script === `undefined`) return 1;

    const realExecutor = async () => {
      return await shell_1.execute(script, args, {
        cwd: realCwd,
        env,
        stdin,
        stdout,
        stderr
      });
    };

    const executor = await project.configuration.reduceHook(hooks => {
      return hooks.wrapScriptExecution;
    }, realExecutor, project, locator, scriptName, {
      script,
      args,
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
    return await executor();
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageScript = $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageScript;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageShellcode(locator, command, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async binFolder => {
    const {
      env,
      cwd: realCwd
    } = await $6881e9a961a5fe3922a1e41f40f331a3$var$initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd
    });
    return await shell_1.execute(command, args, {
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageShellcode = $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageShellcode;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageShellcode = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageShellcode;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$initializePackageEnvironment(locator, {
  project,
  binFolder,
  cwd,
  lifecycleScript
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(project.configuration, locator)} not found in the project`);
  return await $ea9c1e38c3e8cca334929a597a084311$exports.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new $4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport({
        stdout: new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const env = await $6881e9a961a5fe3922a1e41f40f331a3$var$makeScriptEnv({
      project,
      binFolder,
      lifecycleScript
    });
    await Promise.all(Array.from(await $6881e9a961a5fe3922a1e41f40f331a3$var$getPackageAccessibleBinaries(locator, {
      project
    }), ([binaryName, [, binaryPath]]) => $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(binFolder, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(binaryName), $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [binaryPath])));
    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new $ea9c1e38c3e8cca334929a597a084311$exports.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest.find($ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot, {
      baseFs: packageFs
    });
    if (typeof cwd === `undefined`) cwd = packageLocation;
    return {
      manifest,
      binFolder,
      env,
      cwd
    };
  }, {
    libzip: await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise()
  });
}

async function $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceScript(workspace, scriptName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageScript(workspace.anchoredLocator, scriptName, args, {
    cwd,
    project: workspace.project,
    stdin,
    stdout,
    stderr
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceScript;

function $6881e9a961a5fe3922a1e41f40f331a3$var$hasWorkspaceScript(workspace, scriptName) {
  return workspace.manifest.scripts.has(scriptName);
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$hasWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$var$hasWorkspaceScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.hasWorkspaceScript = $6881e9a961a5fe3922a1e41f40f331a3$export$hasWorkspaceScript;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, {
  cwd,
  report
}) {
  const {
    configuration
  } = workspace.project;
  const stdin = null;
  await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async logDir => {
    const logFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(logDir, `${lifecycleScriptName}.log`);
    const header = `# This file contains the result of Yarn calling the "${lifecycleScriptName}" lifecycle script inside a workspace ("${workspace.cwd}")\n`;
    const {
      stdout,
      stderr
    } = configuration.getSubprocessStreams(logFile, {
      report,
      prefix: $6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(configuration, workspace.anchoredLocator),
      header
    });
    report.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.LIFECYCLE_SCRIPT, `Calling the "${lifecycleScriptName}" lifecycle script`);
    const exitCode = await $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceScript(workspace, lifecycleScriptName, [], {
      cwd,
      stdin,
      stdout,
      stderr
    });
    stdout.end();
    stderr.end();

    if (exitCode !== 0) {
      $ea9c1e38c3e8cca334929a597a084311$exports.xfs.detachTemp(logDir);
      throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.LIFECYCLE_SCRIPT, `${$6881e9a961a5fe3922a1e41f40f331a3$var$capitalize_1.default(lifecycleScriptName)} script failed (exit code ${$6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.pretty(configuration, exitCode, $6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.Type.NUMBER)}, logs can be found here: ${$6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.pretty(configuration, logFile, $6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.Type.PATH)}); run ${$6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.pretty(configuration, `yarn ${lifecycleScriptName}`, $6881e9a961a5fe3922a1e41f40f331a3$var$formatUtils.Type.CODE)} to investigate`);
    }
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceLifecycleScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceLifecycleScript;

async function $6881e9a961a5fe3922a1e41f40f331a3$var$maybeExecuteWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts) {
  if ($6881e9a961a5fe3922a1e41f40f331a3$var$hasWorkspaceScript(workspace, lifecycleScriptName)) {
    await $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts);
  }
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$maybeExecuteWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$var$maybeExecuteWorkspaceLifecycleScript;
$6881e9a961a5fe3922a1e41f40f331a3$exports.maybeExecuteWorkspaceLifecycleScript = $6881e9a961a5fe3922a1e41f40f331a3$export$maybeExecuteWorkspaceLifecycleScript;
/**
 * Return the binaries that can be accessed by the specified package
 *
 * @param locator The queried package
 * @param project The project owning the package
 */

/**
 * Return the binaries that can be accessed by the specified package
 *
 * @param locator The queried package
 * @param project The project owning the package
 */
async function $6881e9a961a5fe3922a1e41f40f331a3$var$getPackageAccessibleBinaries(locator, {
  project
}) {
  const configuration = project.configuration;
  const binaries = new Map();
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(configuration, locator)} not found in the project`);
  const stdout = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable();
  const linkers = configuration.getLinkers();
  const linkerOptions = {
    project,
    report: new $4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport({
      configuration,
      stdout
    })
  };
  const visibleLocators = new Set([locator.locatorHash]);

  for (const descriptor of pkg.dependencies.values()) {
    const resolution = project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution (${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyDescriptor(configuration, descriptor)}) should have been registered`);
    visibleLocators.add(resolution);
  }

  for (const locatorHash of visibleLocators) {
    const dependency = project.storedPackages.get(locatorHash);
    if (!dependency) throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
    if (dependency.bin.size === 0) continue;
    const linker = linkers.find(linker => linker.supportsPackage(dependency, linkerOptions));
    if (!linker) continue;
    let packageLocation = null;

    try {
      packageLocation = await linker.findPackageLocation(dependency, linkerOptions);
    } catch (err) {
      // Some packages may not be installed when they are incompatible
      // with the current system.
      if (err.code === `LOCATOR_NOT_INSTALLED`) {
        continue;
      } else {
        throw err;
      }
    }

    for (const [name, target] of dependency.bin) {
      binaries.set(name, [dependency, $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(packageLocation, target))]);
    }
  }

  return binaries;
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$getPackageAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$var$getPackageAccessibleBinaries;
$6881e9a961a5fe3922a1e41f40f331a3$exports.getPackageAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$export$getPackageAccessibleBinaries;
/**
 * Return the binaries that can be accessed by the specified workspace
 *
 * @param workspace The queried workspace
 */

/**
 * Return the binaries that can be accessed by the specified workspace
 *
 * @param workspace The queried workspace
 */
async function $6881e9a961a5fe3922a1e41f40f331a3$var$getWorkspaceAccessibleBinaries(workspace) {
  return await $6881e9a961a5fe3922a1e41f40f331a3$var$getPackageAccessibleBinaries(workspace.anchoredLocator, {
    project: workspace.project
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$getWorkspaceAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$var$getWorkspaceAccessibleBinaries;
$6881e9a961a5fe3922a1e41f40f331a3$exports.getWorkspaceAccessibleBinaries = $6881e9a961a5fe3922a1e41f40f331a3$export$getWorkspaceAccessibleBinaries;
/**
 * Execute a binary from the specified package.
 *
 * Note that "binary" in this sense means "a Javascript file". Actual native
 * binaries cannot be executed this way, because we use Node in order to
 * transparently read from the archives.
 *
 * @param locator The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

/**
 * Execute a binary from the specified package.
 *
 * Note that "binary" in this sense means "a Javascript file". Actual native
 * binaries cannot be executed this way, because we use Node in order to
 * transparently read from the archives.
 *
 * @param locator The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */
async function $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageAccessibleBinary(locator, binaryName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr,
  nodeArgs = []
}) {
  const packageAccessibleBinaries = await $6881e9a961a5fe3922a1e41f40f331a3$var$getPackageAccessibleBinaries(locator, {
    project
  });
  const binary = packageAccessibleBinaries.get(binaryName);
  if (!binary) throw new Error(`Binary not found (${binaryName}) for ${$6881e9a961a5fe3922a1e41f40f331a3$var$structUtils.prettyLocator(project.configuration, locator)}`);
  return await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async binFolder => {
    const [, binaryPath] = binary;
    const env = await $6881e9a961a5fe3922a1e41f40f331a3$var$makeScriptEnv({
      project,
      binFolder
    });
    await Promise.all(Array.from(packageAccessibleBinaries, ([binaryName, [, binaryPath]]) => $6881e9a961a5fe3922a1e41f40f331a3$var$makePathWrapper(env.BERRY_BIN_FOLDER, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(binaryName), $6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [binaryPath])));
    let result;

    try {
      result = await $6881e9a961a5fe3922a1e41f40f331a3$var$execUtils.pipevp($6881e9a961a5fe3922a1e41f40f331a3$var$process.execPath, [...nodeArgs, binaryPath, ...args], {
        cwd,
        env,
        stdin,
        stdout,
        stderr
      });
    } finally {
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(env.BERRY_BIN_FOLDER);
    }

    return result.code;
  });
}

var $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageAccessibleBinary;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executePackageAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$export$executePackageAccessibleBinary;
/**
 * Execute a binary from the specified workspace
 *
 * @param workspace The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

/**
 * Execute a binary from the specified workspace
 *
 * @param workspace The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */
async function $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceAccessibleBinary(workspace, binaryName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await $6881e9a961a5fe3922a1e41f40f331a3$var$executePackageAccessibleBinary(workspace.anchoredLocator, binaryName, args, {
    project: workspace.project,
    cwd,
    stdin,
    stdout,
    stderr
  });
}

$6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$var$executeWorkspaceAccessibleBinary;
$6881e9a961a5fe3922a1e41f40f331a3$exports.executeWorkspaceAccessibleBinary = $6881e9a961a5fe3922a1e41f40f331a3$export$executeWorkspaceAccessibleBinary;
const $b0ffa420366ed37c7cf8ff798018d16e$var$scriptUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($6881e9a961a5fe3922a1e41f40f331a3$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$scriptUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$scriptUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.scriptUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$scriptUtils;
const $b0ffa420366ed37c7cf8ff798018d16e$var$semverUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4b3129d95390e44c4289200276bae532$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$semverUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$semverUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.semverUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$semverUtils;
const $b0ffa420366ed37c7cf8ff798018d16e$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$structUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$structUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$structUtils;
// ASSET: node_modules/@yarnpkg/core/lib/tgzUtils.js
var $31d442cda49d4c25c4453eede3f8dbe6$exports = {};
var $31d442cda49d4c25c4453eede3f8dbe6$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
Object.defineProperty($31d442cda49d4c25c4453eede3f8dbe6$exports, "__esModule", {
  value: true
});
var $31d442cda49d4c25c4453eede3f8dbe6$export$extractArchiveTo = ($31d442cda49d4c25c4453eede3f8dbe6$export$convertToZip = ($31d442cda49d4c25c4453eede3f8dbe6$export$makeArchiveFromDirectory = void 0, $31d442cda49d4c25c4453eede3f8dbe6$exports.makeArchiveFromDirectory = $31d442cda49d4c25c4453eede3f8dbe6$export$makeArchiveFromDirectory), $31d442cda49d4c25c4453eede3f8dbe6$exports.convertToZip = $31d442cda49d4c25c4453eede3f8dbe6$export$convertToZip);
$31d442cda49d4c25c4453eede3f8dbe6$exports.extractArchiveTo = $31d442cda49d4c25c4453eede3f8dbe6$export$extractArchiveTo;
// ASSET: node_modules/tar-stream/index.js
var $304172bebba8cfa2ca02bbe84bf9c570$exports = {};
// ASSET: node_modules/tar-stream/extract.js
var $298cd9424da48944d0a1b1f181868c73$exports = {};
var $298cd9424da48944d0a1b1f181868c73$var$util = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/bl/bl.js
var $dbe8484841f74ff43c4a93369cb69126$exports = {};
const $dbe8484841f74ff43c4a93369cb69126$var$DuplexStream = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Duplex;
const $dbe8484841f74ff43c4a93369cb69126$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
// ASSET: node_modules/bl/BufferList.js
var $e0786dc6d76a75a632032ab089b78d6f$exports = {};
const {
  Buffer: $e0786dc6d76a75a632032ab089b78d6f$var$Buffer
} = $4bb8553ea3f2a3c18bc67044f716b1cc$init();
const $e0786dc6d76a75a632032ab089b78d6f$var$symbol = Symbol.for('BufferList');

function $e0786dc6d76a75a632032ab089b78d6f$var$BufferList(buf) {
  if (!(this instanceof $e0786dc6d76a75a632032ab089b78d6f$var$BufferList)) {
    return new $e0786dc6d76a75a632032ab089b78d6f$var$BufferList(buf);
  }

  $e0786dc6d76a75a632032ab089b78d6f$var$BufferList._init.call(this, buf);
}

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList._init = function _init(buf) {
  Object.defineProperty(this, $e0786dc6d76a75a632032ab089b78d6f$var$symbol, {
    value: true
  });
  this._bufs = [];
  this.length = 0;

  if (buf) {
    this.append(buf);
  }
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._new = function _new(buf) {
  return new $e0786dc6d76a75a632032ab089b78d6f$var$BufferList(buf);
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._offset = function _offset(offset) {
  if (offset === 0) {
    return [0, 0];
  }

  let tot = 0;

  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length;

    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot];
    }

    tot = _t;
  }
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._reverseOffset = function (blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];

  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length;
  }

  return offset;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.get = function get(index) {
  if (index > this.length || index < 0) {
    return undefined;
  }

  const offset = this._offset(index);

  return this._bufs[offset[0]][offset[1]];
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.slice = function slice(start, end) {
  if (typeof start === 'number' && start < 0) {
    start += this.length;
  }

  if (typeof end === 'number' && end < 0) {
    end += this.length;
  }

  return this.copy(null, 0, start, end);
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== 'number' || srcStart < 0) {
    srcStart = 0;
  }

  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
    srcEnd = this.length;
  }

  if (srcStart >= this.length) {
    return dst || $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.alloc(0);
  }

  if (srcEnd <= 0) {
    return dst || $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.alloc(0);
  }

  const copy = !!dst;

  const off = this._offset(srcStart);

  const len = srcEnd - srcStart;
  let bytes = len;
  let bufoff = copy && dstStart || 0;
  let start = off[1]; // copy/slice everything

  // copy/slice everything
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy) {
      // slice, but full concat if multiple buffers
      return this._bufs.length === 1 ? this._bufs[0] : $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.concat(this._bufs, this.length);
    } // copy, need to copy individual buffers


    // copy, need to copy individual buffers
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff);

      bufoff += this._bufs[i].length;
    }

    return dst;
  } // easy, cheap case where it's a subset of one of the buffers


  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  }

  if (!copy) {
    // a slice, we need something to copy in to
    dst = $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.allocUnsafe(len);
  }

  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start;

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start);

      bufoff += l;
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes);

      bufoff += l;
      break;
    }

    bytes -= l;

    if (start) {
      start = 0;
    }
  } // safeguard so that we don't return uninitialized memory


  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff);
  return dst;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
  start = start || 0;
  end = typeof end !== 'number' ? this.length : end;

  if (start < 0) {
    start += this.length;
  }

  if (end < 0) {
    end += this.length;
  }

  if (start === end) {
    return this._new();
  }

  const startOffset = this._offset(start);

  const endOffset = this._offset(end);

  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

  if (endOffset[1] === 0) {
    buffers.pop();
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
  }

  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1]);
  }

  return this._new(buffers);
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.toString = function toString(encoding, start, end) {
  return this.slice(start, end).toString(encoding);
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.consume = function consume(bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes); // do nothing if not a positive number

  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this;

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length;
      this.length -= this._bufs[0].length;

      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes);
      this.length -= bytes;
      break;
    }
  }

  return this;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.duplicate = function duplicate() {
  const copy = this._new();

  for (let i = 0; i < this._bufs.length; i++) {
    copy.append(this._bufs[i]);
  }

  return copy;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.append = function append(buf) {
  if (buf == null) {
    return this;
  }

  if (buf.buffer) {
    // append a view of the underlying ArrayBuffer
    this._appendBuffer($e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i]);
    }
  } else if (this._isBufferList(buf)) {
    // unwrap argument into individual BufferLists
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i]);
    }
  } else {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf === 'number') {
      buf = buf.toString();
    }

    this._appendBuffer($e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from(buf));
  }

  return this;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._appendBuffer = function appendBuffer(buf) {
  this._bufs.push(buf);

  this.length += buf.length;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset;
    offset = undefined;
  }

  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  } else if (typeof search === 'number') {
    search = $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from([search]);
  } else if (typeof search === 'string') {
    search = $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from(search, encoding);
  } else if (this._isBufferList(search)) {
    search = search.slice();
  } else if (Array.isArray(search.buffer)) {
    search = $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from(search.buffer, search.byteOffset, search.byteLength);
  } else if (!$e0786dc6d76a75a632032ab089b78d6f$var$Buffer.isBuffer(search)) {
    search = $e0786dc6d76a75a632032ab089b78d6f$var$Buffer.from(search);
  }

  offset = Number(offset || 0);

  if (isNaN(offset)) {
    offset = 0;
  }

  if (offset < 0) {
    offset = this.length + offset;
  }

  if (offset < 0) {
    offset = 0;
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset;
  }

  const blOffset = this._offset(offset);

  let blIndex = blOffset[0]; // index of which internal buffer we're working on

  // index of which internal buffer we're working on
  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on
  // scan over each buffer

  // offset of the internal buffer we're working on
  // scan over each buffer
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];

    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset;

      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);

        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult]);
        }

        buffOffset = buff.length - search.length + 1; // end of native search window
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);

        if (this._match(revOffset, search)) {
          return revOffset;
        }

        buffOffset++;
      }
    }

    buffOffset = 0;
  }

  return -1;
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._match = function (offset, search) {
  if (this.length - offset < search.length) {
    return false;
  }

  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false;
    }
  }

  return true;
};

(function () {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };

  for (const m in methods) {
    (function (m) {
      if (methods[m] === null) {
        $e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength);
        };
      } else {
        $e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype[m] = function (offset) {
          return this.slice(offset, offset + methods[m])[m](0);
        };
      }
    })(m);
  }
})(); // Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.


// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.prototype._isBufferList = function _isBufferList(b) {
  return b instanceof $e0786dc6d76a75a632032ab089b78d6f$var$BufferList || $e0786dc6d76a75a632032ab089b78d6f$var$BufferList.isBufferList(b);
};

$e0786dc6d76a75a632032ab089b78d6f$var$BufferList.isBufferList = function isBufferList(b) {
  return b != null && b[$e0786dc6d76a75a632032ab089b78d6f$var$symbol];
};

$e0786dc6d76a75a632032ab089b78d6f$exports = $e0786dc6d76a75a632032ab089b78d6f$var$BufferList;

function $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream(callback) {
  if (!(this instanceof $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream)) {
    return new $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream(callback);
  }

  if (typeof callback === 'function') {
    this._callback = callback;

    const piper = function piper(err) {
      if (this._callback) {
        this._callback(err);

        this._callback = null;
      }
    }.bind(this);

    this.on('pipe', function onPipe(src) {
      src.on('error', piper);
    });
    this.on('unpipe', function onUnpipe(src) {
      src.removeListener('error', piper);
    });
    callback = null;
  }

  $e0786dc6d76a75a632032ab089b78d6f$exports._init.call(this, callback);

  $dbe8484841f74ff43c4a93369cb69126$var$DuplexStream.call(this);
}

$dbe8484841f74ff43c4a93369cb69126$var$inherits($dbe8484841f74ff43c4a93369cb69126$var$BufferListStream, $dbe8484841f74ff43c4a93369cb69126$var$DuplexStream);
Object.assign($dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype, $e0786dc6d76a75a632032ab089b78d6f$exports.prototype);

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype._new = function _new(callback) {
  return new $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream(callback);
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype._write = function _write(buf, encoding, callback) {
  this._appendBuffer(buf);

  if (typeof callback === 'function') {
    callback();
  }
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype._read = function _read(size) {
  if (!this.length) {
    return this.push(null);
  }

  size = Math.min(size, this.length);
  this.push(this.slice(0, size));
  this.consume(size);
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype.end = function end(chunk) {
  $dbe8484841f74ff43c4a93369cb69126$var$DuplexStream.prototype.end.call(this, chunk);

  if (this._callback) {
    this._callback(null, this.slice());

    this._callback = null;
  }
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype._destroy = function _destroy(err, cb) {
  this._bufs.length = 0;
  this.length = 0;
  cb(err);
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.prototype._isBufferList = function _isBufferList(b) {
  return b instanceof $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream || b instanceof $e0786dc6d76a75a632032ab089b78d6f$exports || $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.isBufferList(b);
};

$dbe8484841f74ff43c4a93369cb69126$var$BufferListStream.isBufferList = $e0786dc6d76a75a632032ab089b78d6f$exports.isBufferList;
$dbe8484841f74ff43c4a93369cb69126$exports = $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream;
var $dbe8484841f74ff43c4a93369cb69126$export$BufferListStream = $dbe8484841f74ff43c4a93369cb69126$var$BufferListStream;
$dbe8484841f74ff43c4a93369cb69126$exports.BufferListStream = $dbe8484841f74ff43c4a93369cb69126$export$BufferListStream;
$dbe8484841f74ff43c4a93369cb69126$exports.BufferList = $e0786dc6d76a75a632032ab089b78d6f$exports;
var $a88111b76d21e1bbe343effdc5638669$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $a88111b76d21e1bbe343effdc5638669$var$alloc = $a88111b76d21e1bbe343effdc5638669$var$Buffer.alloc;
var $a88111b76d21e1bbe343effdc5638669$var$ZEROS = '0000000000000000000';
var $a88111b76d21e1bbe343effdc5638669$var$SEVENS = '7777777777777777777';
var $a88111b76d21e1bbe343effdc5638669$var$ZERO_OFFSET = '0'.charCodeAt(0);
var $a88111b76d21e1bbe343effdc5638669$var$USTAR_MAGIC = $a88111b76d21e1bbe343effdc5638669$var$Buffer.from('ustar\x00', 'binary');
var $a88111b76d21e1bbe343effdc5638669$var$USTAR_VER = $a88111b76d21e1bbe343effdc5638669$var$Buffer.from('00', 'binary');
var $a88111b76d21e1bbe343effdc5638669$var$GNU_MAGIC = $a88111b76d21e1bbe343effdc5638669$var$Buffer.from('ustar\x20', 'binary');
var $a88111b76d21e1bbe343effdc5638669$var$GNU_VER = $a88111b76d21e1bbe343effdc5638669$var$Buffer.from('\x20\x00', 'binary');
var $a88111b76d21e1bbe343effdc5638669$var$MASK = parseInt('7777', 8);
var $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET = 257;
var $a88111b76d21e1bbe343effdc5638669$var$VERSION_OFFSET = 263;

var $a88111b76d21e1bbe343effdc5638669$var$clamp = function (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index; // Coerce to integer.

  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
};

var $a88111b76d21e1bbe343effdc5638669$var$toType = function (flag) {
  switch (flag) {
    case 0:
      return 'file';

    case 1:
      return 'link';

    case 2:
      return 'symlink';

    case 3:
      return 'character-device';

    case 4:
      return 'block-device';

    case 5:
      return 'directory';

    case 6:
      return 'fifo';

    case 7:
      return 'contiguous-file';

    case 72:
      return 'pax-header';

    case 55:
      return 'pax-global-header';

    case 27:
      return 'gnu-long-link-path';

    case 28:
    case 30:
      return 'gnu-long-path';
  }

  return null;
};

var $a88111b76d21e1bbe343effdc5638669$var$toTypeflag = function (flag) {
  switch (flag) {
    case 'file':
      return 0;

    case 'link':
      return 1;

    case 'symlink':
      return 2;

    case 'character-device':
      return 3;

    case 'block-device':
      return 4;

    case 'directory':
      return 5;

    case 'fifo':
      return 6;

    case 'contiguous-file':
      return 7;

    case 'pax-header':
      return 72;
  }

  return 0;
};

var $a88111b76d21e1bbe343effdc5638669$var$indexOf = function (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset;
  }

  return end;
};

var $a88111b76d21e1bbe343effdc5638669$var$cksum = function (block) {
  var sum = 8 * 32;

  for (var i = 0; i < 148; i++) sum += block[i];

  for (var j = 156; j < 512; j++) sum += block[j];

  return sum;
};

var $a88111b76d21e1bbe343effdc5638669$var$encodeOct = function (val, n) {
  val = val.toString(8);
  if (val.length > n) return $a88111b76d21e1bbe343effdc5638669$var$SEVENS.slice(0, n) + ' ';else return $a88111b76d21e1bbe343effdc5638669$var$ZEROS.slice(0, n - val.length) + val + ' ';
};
/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */


/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function $a88111b76d21e1bbe343effdc5638669$var$parse256(buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  var positive;
  if (buf[0] === 0x80) positive = true;else if (buf[0] === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest

  // build up a base-256 tuple from the least sig to the highest
  var tuple = [];

  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i];
    if (positive) tuple.push(byte);else tuple.push(0xFF - byte);
  }

  var sum = 0;
  var l = tuple.length;

  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i);
  }

  return positive ? sum : -1 * sum;
}

var $a88111b76d21e1bbe343effdc5638669$var$decodeOct = function (val, offset, length) {
  val = val.slice(offset, offset + length);
  offset = 0; // If prefixed with 0x80 then parse as a base-256 integer

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return $a88111b76d21e1bbe343effdc5638669$var$parse256(val);
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++;

    var end = $a88111b76d21e1bbe343effdc5638669$var$clamp($a88111b76d21e1bbe343effdc5638669$var$indexOf(val, 32, offset, val.length), val.length, val.length);

    while (offset < end && val[offset] === 0) offset++;

    if (end === offset) return 0;
    return parseInt(val.slice(offset, end).toString(), 8);
  }
};

var $a88111b76d21e1bbe343effdc5638669$var$decodeStr = function (val, offset, length, encoding) {
  return val.slice(offset, $a88111b76d21e1bbe343effdc5638669$var$indexOf(val, 0, offset, offset + length)).toString(encoding);
};

var $a88111b76d21e1bbe343effdc5638669$var$addLength = function (str) {
  var len = $a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(str);
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) digits++;
  return len + digits + str;
};

var $a88111b76d21e1bbe343effdc5638669$export$decodeLongPath = function (buf, encoding) {
  return $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 0, buf.length, encoding);
};

var $a88111b76d21e1bbe343effdc5638669$export$encodePax = function (opts) {
  // TODO: encode more stuff in pax
  var result = '';
  if (opts.name) result += $a88111b76d21e1bbe343effdc5638669$var$addLength(' path=' + opts.name + '\n');
  if (opts.linkname) result += $a88111b76d21e1bbe343effdc5638669$var$addLength(' linkpath=' + opts.linkname + '\n');
  var pax = opts.pax;

  if (pax) {
    for (var key in pax) {
      result += $a88111b76d21e1bbe343effdc5638669$var$addLength(' ' + key + '=' + pax[key] + '\n');
    }
  }

  return $a88111b76d21e1bbe343effdc5638669$var$Buffer.from(result);
};

var $a88111b76d21e1bbe343effdc5638669$export$decodePax = function (buf) {
  var result = {};

  while (buf.length) {
    var i = 0;

    while (i < buf.length && buf[i] !== 32) i++;

    var len = parseInt(buf.slice(0, i).toString(), 10);
    if (!len) return result;
    var b = buf.slice(i + 1, len - 1).toString();
    var keyIndex = b.indexOf('=');
    if (keyIndex === -1) return result;
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
    buf = buf.slice(len);
  }

  return result;
};

var $a88111b76d21e1bbe343effdc5638669$export$encode = function (opts) {
  var buf = $a88111b76d21e1bbe343effdc5638669$var$alloc(512);
  var name = opts.name;
  var prefix = '';
  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/';
  if ($a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(name) !== name.length) return null; // utf-8

  // utf-8
  while ($a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(name) > 100) {
    var i = name.indexOf('/');
    if (i === -1) return null;
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
    name = name.slice(i + 1);
  }

  if ($a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(name) > 100 || $a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(prefix) > 155) return null;
  if (opts.linkname && $a88111b76d21e1bbe343effdc5638669$var$Buffer.byteLength(opts.linkname) > 100) return null;
  buf.write(name);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.mode & $a88111b76d21e1bbe343effdc5638669$var$MASK, 6), 100);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.uid, 6), 108);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.gid, 6), 116);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.size, 11), 124);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
  buf[156] = $a88111b76d21e1bbe343effdc5638669$var$ZERO_OFFSET + $a88111b76d21e1bbe343effdc5638669$var$toTypeflag(opts.type);
  if (opts.linkname) buf.write(opts.linkname, 157);
  $a88111b76d21e1bbe343effdc5638669$var$USTAR_MAGIC.copy(buf, $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET);
  $a88111b76d21e1bbe343effdc5638669$var$USTAR_VER.copy(buf, $a88111b76d21e1bbe343effdc5638669$var$VERSION_OFFSET);
  if (opts.uname) buf.write(opts.uname, 265);
  if (opts.gname) buf.write(opts.gname, 297);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.devmajor || 0, 6), 329);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct(opts.devminor || 0, 6), 337);
  if (prefix) buf.write(prefix, 345);
  buf.write($a88111b76d21e1bbe343effdc5638669$var$encodeOct($a88111b76d21e1bbe343effdc5638669$var$cksum(buf), 6), 148);
  return buf;
};

var $a88111b76d21e1bbe343effdc5638669$export$decode = function (buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - $a88111b76d21e1bbe343effdc5638669$var$ZERO_OFFSET;
  var name = $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 0, 100, filenameEncoding);
  var mode = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 100, 8);
  var uid = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 108, 8);
  var gid = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 116, 8);
  var size = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 124, 12);
  var mtime = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 136, 12);
  var type = $a88111b76d21e1bbe343effdc5638669$var$toType(typeflag);
  var linkname = buf[157] === 0 ? null : $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 157, 100, filenameEncoding);
  var uname = $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 265, 32);
  var gname = $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 297, 32);
  var devmajor = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 329, 8);
  var devminor = $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 337, 8);
  var c = $a88111b76d21e1bbe343effdc5638669$var$cksum(buf); // checksum is still initial value if header was null.

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null; // valid checksum

  // valid checksum
  if (c !== $a88111b76d21e1bbe343effdc5638669$var$decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');

  if ($a88111b76d21e1bbe343effdc5638669$var$USTAR_MAGIC.compare(buf, $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET, $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET + 6) === 0) {
    // ustar (posix) format.
    // prepend prefix, if present.
    if (buf[345]) name = $a88111b76d21e1bbe343effdc5638669$var$decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;
  } else if ($a88111b76d21e1bbe343effdc5638669$var$GNU_MAGIC.compare(buf, $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET, $a88111b76d21e1bbe343effdc5638669$var$MAGIC_OFFSET + 6) === 0 && $a88111b76d21e1bbe343effdc5638669$var$GNU_VER.compare(buf, $a88111b76d21e1bbe343effdc5638669$var$VERSION_OFFSET, $a88111b76d21e1bbe343effdc5638669$var$VERSION_OFFSET + 2) === 0) {// 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
  } else {
    throw new Error('Invalid tar header: unknown format.');
  } // to support old tar versions that use trailing / to indicate dirs


  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;
  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1000 * mtime),
    type,
    linkname,
    uname,
    gname,
    devmajor,
    devminor
  };
};

var $298cd9424da48944d0a1b1f181868c73$var$Writable = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable;
var $298cd9424da48944d0a1b1f181868c73$var$PassThrough = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough;

var $298cd9424da48944d0a1b1f181868c73$var$noop = function () {};

var $298cd9424da48944d0a1b1f181868c73$var$overflow = function (size) {
  size &= 511;
  return size && 512 - size;
};

var $298cd9424da48944d0a1b1f181868c73$var$emptyStream = function (self, offset) {
  var s = new $298cd9424da48944d0a1b1f181868c73$var$Source(self, offset);
  s.end();
  return s;
};

var $298cd9424da48944d0a1b1f181868c73$var$mixinPax = function (header, pax) {
  if (pax.path) header.name = pax.path;
  if (pax.linkpath) header.linkname = pax.linkpath;
  if (pax.size) header.size = parseInt(pax.size, 10);
  header.pax = pax;
  return header;
};

var $298cd9424da48944d0a1b1f181868c73$var$Source = function (self, offset) {
  this._parent = self;
  this.offset = offset;
  $298cd9424da48944d0a1b1f181868c73$var$PassThrough.call(this, {
    autoDestroy: false
  });
};

$298cd9424da48944d0a1b1f181868c73$var$util.inherits($298cd9424da48944d0a1b1f181868c73$var$Source, $298cd9424da48944d0a1b1f181868c73$var$PassThrough);

$298cd9424da48944d0a1b1f181868c73$var$Source.prototype.destroy = function (err) {
  this._parent.destroy(err);
};

var $298cd9424da48944d0a1b1f181868c73$var$Extract = function (opts) {
  if (!(this instanceof $298cd9424da48944d0a1b1f181868c73$var$Extract)) return new $298cd9424da48944d0a1b1f181868c73$var$Extract(opts);
  $298cd9424da48944d0a1b1f181868c73$var$Writable.call(this, opts);
  opts = opts || {};
  this._offset = 0;
  this._buffer = $dbe8484841f74ff43c4a93369cb69126$exports();
  this._missing = 0;
  this._partial = false;
  this._onparse = $298cd9424da48944d0a1b1f181868c73$var$noop;
  this._header = null;
  this._stream = null;
  this._overflow = null;
  this._cb = null;
  this._locked = false;
  this._destroyed = false;
  this._pax = null;
  this._paxGlobal = null;
  this._gnuLongPath = null;
  this._gnuLongLinkPath = null;
  var self = this;
  var b = self._buffer;

  var oncontinue = function () {
    self._continue();
  };

  var onunlock = function (err) {
    self._locked = false;
    if (err) return self.destroy(err);
    if (!self._stream) oncontinue();
  };

  var onstreamend = function () {
    self._stream = null;
    var drain = $298cd9424da48944d0a1b1f181868c73$var$overflow(self._header.size);
    if (drain) self._parse(drain, ondrain);else self._parse(512, onheader);
    if (!self._locked) oncontinue();
  };

  var ondrain = function () {
    self._buffer.consume($298cd9424da48944d0a1b1f181868c73$var$overflow(self._header.size));

    self._parse(512, onheader);

    oncontinue();
  };

  var onpaxglobalheader = function () {
    var size = self._header.size;
    self._paxGlobal = $a88111b76d21e1bbe343effdc5638669$export$decodePax(b.slice(0, size));
    b.consume(size);
    onstreamend();
  };

  var onpaxheader = function () {
    var size = self._header.size;
    self._pax = $a88111b76d21e1bbe343effdc5638669$export$decodePax(b.slice(0, size));
    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax);
    b.consume(size);
    onstreamend();
  };

  var ongnulongpath = function () {
    var size = self._header.size;
    this._gnuLongPath = $a88111b76d21e1bbe343effdc5638669$export$decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };

  var ongnulonglinkpath = function () {
    var size = self._header.size;
    this._gnuLongLinkPath = $a88111b76d21e1bbe343effdc5638669$export$decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };

  var onheader = function () {
    var offset = self._offset;
    var header;

    try {
      header = self._header = $a88111b76d21e1bbe343effdc5638669$export$decode(b.slice(0, 512), opts.filenameEncoding);
    } catch (err) {
      self.emit('error', err);
    }

    b.consume(512);

    if (!header) {
      self._parse(512, onheader);

      oncontinue();
      return;
    }

    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath);

      oncontinue();
      return;
    }

    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath);

      oncontinue();
      return;
    }

    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader);

      oncontinue();
      return;
    }

    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader);

      oncontinue();
      return;
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath;
      self._gnuLongPath = null;
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath;
      self._gnuLongLinkPath = null;
    }

    if (self._pax) {
      self._header = header = $298cd9424da48944d0a1b1f181868c73$var$mixinPax(header, self._pax);
      self._pax = null;
    }

    self._locked = true;

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader);

      self.emit('entry', header, $298cd9424da48944d0a1b1f181868c73$var$emptyStream(self, offset), onunlock);
      return;
    }

    self._stream = new $298cd9424da48944d0a1b1f181868c73$var$Source(self, offset);
    self.emit('entry', header, self._stream, onunlock);

    self._parse(header.size, onstreamend);

    oncontinue();
  };

  this._onheader = onheader;

  this._parse(512, onheader);
};

$298cd9424da48944d0a1b1f181868c73$var$util.inherits($298cd9424da48944d0a1b1f181868c73$var$Extract, $298cd9424da48944d0a1b1f181868c73$var$Writable);

$298cd9424da48944d0a1b1f181868c73$var$Extract.prototype.destroy = function (err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit('error', err);
  this.emit('close');
  if (this._stream) this._stream.emit('close');
};

$298cd9424da48944d0a1b1f181868c73$var$Extract.prototype._parse = function (size, onparse) {
  if (this._destroyed) return;
  this._offset += size;
  this._missing = size;
  if (onparse === this._onheader) this._partial = false;
  this._onparse = onparse;
};

$298cd9424da48944d0a1b1f181868c73$var$Extract.prototype._continue = function () {
  if (this._destroyed) return;
  var cb = this._cb;
  this._cb = $298cd9424da48944d0a1b1f181868c73$var$noop;
  if (this._overflow) this._write(this._overflow, undefined, cb);else cb();
};

$298cd9424da48944d0a1b1f181868c73$var$Extract.prototype._write = function (data, enc, cb) {
  if (this._destroyed) return;
  var s = this._stream;
  var b = this._buffer;
  var missing = this._missing;
  if (data.length) this._partial = true; // we do not reach end-of-chunk now. just forward it

  // we do not reach end-of-chunk now. just forward it
  if (data.length < missing) {
    this._missing -= data.length;
    this._overflow = null;
    if (s) return s.write(data, cb);
    b.append(data);
    return cb();
  } // end-of-chunk. the parser should call cb.


  // end-of-chunk. the parser should call cb.
  this._cb = cb;
  this._missing = 0;
  var overflow = null;

  if (data.length > missing) {
    overflow = data.slice(missing);
    data = data.slice(0, missing);
  }

  if (s) s.end(data);else b.append(data);
  this._overflow = overflow;

  this._onparse();
};

$298cd9424da48944d0a1b1f181868c73$var$Extract.prototype._final = function (cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'));
  cb();
};

$298cd9424da48944d0a1b1f181868c73$exports = $298cd9424da48944d0a1b1f181868c73$var$Extract;
$304172bebba8cfa2ca02bbe84bf9c570$exports.extract = $298cd9424da48944d0a1b1f181868c73$exports;
// ASSET: node_modules/tar-stream/pack.js
var $f7ee701634ec31d4012383171b4bb5ef$exports = {};
var $f7ee701634ec31d4012383171b4bb5ef$var$Buffer = $4bb8553ea3f2a3c18bc67044f716b1cc$init().Buffer;
var $f7ee701634ec31d4012383171b4bb5ef$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// ASSET: node_modules/fs-constants/browser.js
var $15ac080ff9e0d489e205862822dca89d$exports = {};
$15ac080ff9e0d489e205862822dca89d$exports = {};
// ASSET: node_modules/end-of-stream/index.js
var $bd286992e96c1d04d348f5b0e99e52b7$exports = {};
var $bd286992e96c1d04d348f5b0e99e52b7$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// ASSET: node_modules/once/once.js
var $bbd23e1cdd02e78a07754b0caa7aad8b$exports = {};
// ASSET: node_modules/wrappy/wrappy.js
var $a59c7ccf5ee709c883fa35335b0e5fa6$exports = {};
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
$a59c7ccf5ee709c883fa35335b0e5fa6$exports = $a59c7ccf5ee709c883fa35335b0e5fa6$var$wrappy;

function $a59c7ccf5ee709c883fa35335b0e5fa6$var$wrappy(fn, cb) {
  if (fn && cb) return $a59c7ccf5ee709c883fa35335b0e5fa6$var$wrappy(fn)(cb);
  if (typeof fn !== 'function') throw new TypeError('need wrapper function');
  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });
  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];

    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }

    return ret;
  }
}

$bbd23e1cdd02e78a07754b0caa7aad8b$exports = $a59c7ccf5ee709c883fa35335b0e5fa6$exports($bbd23e1cdd02e78a07754b0caa7aad8b$var$once);
var $bbd23e1cdd02e78a07754b0caa7aad8b$export$strict = $a59c7ccf5ee709c883fa35335b0e5fa6$exports($bbd23e1cdd02e78a07754b0caa7aad8b$var$onceStrict);
$bbd23e1cdd02e78a07754b0caa7aad8b$exports.strict = $bbd23e1cdd02e78a07754b0caa7aad8b$export$strict;
$bbd23e1cdd02e78a07754b0caa7aad8b$var$once.proto = $bbd23e1cdd02e78a07754b0caa7aad8b$var$once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return $bbd23e1cdd02e78a07754b0caa7aad8b$var$once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return $bbd23e1cdd02e78a07754b0caa7aad8b$var$onceStrict(this);
    },
    configurable: true
  });
});

function $bbd23e1cdd02e78a07754b0caa7aad8b$var$once(fn) {
  var f = function () {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  f.called = false;
  return f;
}

function $bbd23e1cdd02e78a07754b0caa7aad8b$var$onceStrict(fn) {
  var f = function () {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}

var $bd286992e96c1d04d348f5b0e99e52b7$var$noop = function () {};

var $bd286992e96c1d04d348f5b0e99e52b7$var$isRequest = function (stream) {
  return stream.setHeader && typeof stream.abort === 'function';
};

var $bd286992e96c1d04d348f5b0e99e52b7$var$isChildProcess = function (stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};

var $bd286992e96c1d04d348f5b0e99e52b7$var$eos = function (stream, opts, callback) {
  if (typeof opts === 'function') return $bd286992e96c1d04d348f5b0e99e52b7$var$eos(stream, null, opts);
  if (!opts) opts = {};
  callback = $bbd23e1cdd02e78a07754b0caa7aad8b$exports(callback || $bd286992e96c1d04d348f5b0e99e52b7$var$noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;

  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };

  var onfinish = function () {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function () {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function (exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function (err) {
    callback.call(stream, err);
  };

  var onclose = function () {
    $bd286992e96c1d04d348f5b0e99e52b7$var$process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function () {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
    if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
  };

  var onrequest = function () {
    stream.req.on('finish', onfinish);
  };

  if ($bd286992e96c1d04d348f5b0e99e52b7$var$isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if ($bd286992e96c1d04d348f5b0e99e52b7$var$isChildProcess(stream)) stream.on('exit', onexit);
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

$bd286992e96c1d04d348f5b0e99e52b7$exports = $bd286992e96c1d04d348f5b0e99e52b7$var$eos;
var $f7ee701634ec31d4012383171b4bb5ef$var$inherits = $5e04eef67f3cc70b90141a363590b6ee$init();
var $f7ee701634ec31d4012383171b4bb5ef$var$alloc = $f7ee701634ec31d4012383171b4bb5ef$var$Buffer.alloc;
var $f7ee701634ec31d4012383171b4bb5ef$var$Readable = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable;
var $f7ee701634ec31d4012383171b4bb5ef$var$Writable = $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable;
var $f7ee701634ec31d4012383171b4bb5ef$var$StringDecoder = $9902be2109033b88050ebe7f370f9452$init().StringDecoder;
var $f7ee701634ec31d4012383171b4bb5ef$var$DMODE = parseInt('755', 8);
var $f7ee701634ec31d4012383171b4bb5ef$var$FMODE = parseInt('644', 8);
var $f7ee701634ec31d4012383171b4bb5ef$var$END_OF_TAR = $f7ee701634ec31d4012383171b4bb5ef$var$alloc(1024);

var $f7ee701634ec31d4012383171b4bb5ef$var$noop = function () {};

var $f7ee701634ec31d4012383171b4bb5ef$var$overflow = function (self, size) {
  size &= 511;
  if (size) self.push($f7ee701634ec31d4012383171b4bb5ef$var$END_OF_TAR.slice(0, 512 - size));
};

function $f7ee701634ec31d4012383171b4bb5ef$var$modeToType(mode) {
  switch (mode & $15ac080ff9e0d489e205862822dca89d$exports.S_IFMT) {
    case $15ac080ff9e0d489e205862822dca89d$exports.S_IFBLK:
      return 'block-device';

    case $15ac080ff9e0d489e205862822dca89d$exports.S_IFCHR:
      return 'character-device';

    case $15ac080ff9e0d489e205862822dca89d$exports.S_IFDIR:
      return 'directory';

    case $15ac080ff9e0d489e205862822dca89d$exports.S_IFIFO:
      return 'fifo';

    case $15ac080ff9e0d489e205862822dca89d$exports.S_IFLNK:
      return 'symlink';
  }

  return 'file';
}

var $f7ee701634ec31d4012383171b4bb5ef$var$Sink = function (to) {
  $f7ee701634ec31d4012383171b4bb5ef$var$Writable.call(this);
  this.written = 0;
  this._to = to;
  this._destroyed = false;
};

$f7ee701634ec31d4012383171b4bb5ef$var$inherits($f7ee701634ec31d4012383171b4bb5ef$var$Sink, $f7ee701634ec31d4012383171b4bb5ef$var$Writable);

$f7ee701634ec31d4012383171b4bb5ef$var$Sink.prototype._write = function (data, enc, cb) {
  this.written += data.length;
  if (this._to.push(data)) return cb();
  this._to._drain = cb;
};

$f7ee701634ec31d4012383171b4bb5ef$var$Sink.prototype.destroy = function () {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit('close');
};

var $f7ee701634ec31d4012383171b4bb5ef$var$LinkSink = function () {
  $f7ee701634ec31d4012383171b4bb5ef$var$Writable.call(this);
  this.linkname = '';
  this._decoder = new $f7ee701634ec31d4012383171b4bb5ef$var$StringDecoder('utf-8');
  this._destroyed = false;
};

$f7ee701634ec31d4012383171b4bb5ef$var$inherits($f7ee701634ec31d4012383171b4bb5ef$var$LinkSink, $f7ee701634ec31d4012383171b4bb5ef$var$Writable);

$f7ee701634ec31d4012383171b4bb5ef$var$LinkSink.prototype._write = function (data, enc, cb) {
  this.linkname += this._decoder.write(data);
  cb();
};

$f7ee701634ec31d4012383171b4bb5ef$var$LinkSink.prototype.destroy = function () {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit('close');
};

var $f7ee701634ec31d4012383171b4bb5ef$var$Void = function () {
  $f7ee701634ec31d4012383171b4bb5ef$var$Writable.call(this);
  this._destroyed = false;
};

$f7ee701634ec31d4012383171b4bb5ef$var$inherits($f7ee701634ec31d4012383171b4bb5ef$var$Void, $f7ee701634ec31d4012383171b4bb5ef$var$Writable);

$f7ee701634ec31d4012383171b4bb5ef$var$Void.prototype._write = function (data, enc, cb) {
  cb(new Error('No body allowed for this entry'));
};

$f7ee701634ec31d4012383171b4bb5ef$var$Void.prototype.destroy = function () {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit('close');
};

var $f7ee701634ec31d4012383171b4bb5ef$var$Pack = function (opts) {
  if (!(this instanceof $f7ee701634ec31d4012383171b4bb5ef$var$Pack)) return new $f7ee701634ec31d4012383171b4bb5ef$var$Pack(opts);
  $f7ee701634ec31d4012383171b4bb5ef$var$Readable.call(this, opts);
  this._drain = $f7ee701634ec31d4012383171b4bb5ef$var$noop;
  this._finalized = false;
  this._finalizing = false;
  this._destroyed = false;
  this._stream = null;
};

$f7ee701634ec31d4012383171b4bb5ef$var$inherits($f7ee701634ec31d4012383171b4bb5ef$var$Pack, $f7ee701634ec31d4012383171b4bb5ef$var$Readable);

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype.entry = function (header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry');
  if (this._finalized || this._destroyed) return;

  if (typeof buffer === 'function') {
    callback = buffer;
    buffer = null;
  }

  if (!callback) callback = $f7ee701634ec31d4012383171b4bb5ef$var$noop;
  var self = this;
  if (!header.size || header.type === 'symlink') header.size = 0;
  if (!header.type) header.type = $f7ee701634ec31d4012383171b4bb5ef$var$modeToType(header.mode);
  if (!header.mode) header.mode = header.type === 'directory' ? $f7ee701634ec31d4012383171b4bb5ef$var$DMODE : $f7ee701634ec31d4012383171b4bb5ef$var$FMODE;
  if (!header.uid) header.uid = 0;
  if (!header.gid) header.gid = 0;
  if (!header.mtime) header.mtime = new Date();
  if (typeof buffer === 'string') buffer = $f7ee701634ec31d4012383171b4bb5ef$var$Buffer.from(buffer);

  if ($f7ee701634ec31d4012383171b4bb5ef$var$Buffer.isBuffer(buffer)) {
    header.size = buffer.length;

    this._encode(header);

    var ok = this.push(buffer);
    $f7ee701634ec31d4012383171b4bb5ef$var$overflow(self, header.size);
    if (ok) $f7ee701634ec31d4012383171b4bb5ef$var$process.nextTick(callback);else this._drain = callback;
    return new $f7ee701634ec31d4012383171b4bb5ef$var$Void();
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new $f7ee701634ec31d4012383171b4bb5ef$var$LinkSink();
    $bd286992e96c1d04d348f5b0e99e52b7$exports(linkSink, function (err) {
      if (err) {
        // stream was closed
        self.destroy();
        return callback(err);
      }

      header.linkname = linkSink.linkname;

      self._encode(header);

      callback();
    });
    return linkSink;
  }

  this._encode(header);

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    $f7ee701634ec31d4012383171b4bb5ef$var$process.nextTick(callback);
    return new $f7ee701634ec31d4012383171b4bb5ef$var$Void();
  }

  var sink = new $f7ee701634ec31d4012383171b4bb5ef$var$Sink(this);
  this._stream = sink;
  $bd286992e96c1d04d348f5b0e99e52b7$exports(sink, function (err) {
    self._stream = null;

    if (err) {
      // stream was closed
      self.destroy();
      return callback(err);
    }

    if (sink.written !== header.size) {
      // corrupting tar
      self.destroy();
      return callback(new Error('size mismatch'));
    }

    $f7ee701634ec31d4012383171b4bb5ef$var$overflow(self, header.size);
    if (self._finalizing) self.finalize();
    callback();
  });
  return sink;
};

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype.finalize = function () {
  if (this._stream) {
    this._finalizing = true;
    return;
  }

  if (this._finalized) return;
  this._finalized = true;
  this.push($f7ee701634ec31d4012383171b4bb5ef$var$END_OF_TAR);
  this.push(null);
};

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype.destroy = function (err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit('error', err);
  this.emit('close');
  if (this._stream && this._stream.destroy) this._stream.destroy();
};

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype._encode = function (header) {
  if (!header.pax) {
    var buf = $a88111b76d21e1bbe343effdc5638669$export$encode(header);

    if (buf) {
      this.push(buf);
      return;
    }
  }

  this._encodePax(header);
};

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype._encodePax = function (header) {
  var paxHeader = $a88111b76d21e1bbe343effdc5638669$export$encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  });
  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  this.push($a88111b76d21e1bbe343effdc5638669$export$encode(newHeader));
  this.push(paxHeader);
  $f7ee701634ec31d4012383171b4bb5ef$var$overflow(this, paxHeader.length);
  newHeader.size = header.size;
  newHeader.type = header.type;
  this.push($a88111b76d21e1bbe343effdc5638669$export$encode(newHeader));
};

$f7ee701634ec31d4012383171b4bb5ef$var$Pack.prototype._read = function (n) {
  var drain = this._drain;
  this._drain = $f7ee701634ec31d4012383171b4bb5ef$var$noop;
  drain();
};

$f7ee701634ec31d4012383171b4bb5ef$exports = $f7ee701634ec31d4012383171b4bb5ef$var$Pack;
$304172bebba8cfa2ca02bbe84bf9c570$exports.pack = $f7ee701634ec31d4012383171b4bb5ef$exports;
const $31d442cda49d4c25c4453eede3f8dbe6$var$tar_stream_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($304172bebba8cfa2ca02bbe84bf9c570$exports);
const $31d442cda49d4c25c4453eede3f8dbe6$var$util_1 = $69678d3e0618202337016e1b4ed76965$init();
const $31d442cda49d4c25c4453eede3f8dbe6$var$zlib_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($5051c00e87739024f780cb19cb94c308$exports);
const $31d442cda49d4c25c4453eede3f8dbe6$var$gunzip = $31d442cda49d4c25c4453eede3f8dbe6$var$util_1.promisify($31d442cda49d4c25c4453eede3f8dbe6$var$zlib_1.default.gunzip);

async function $31d442cda49d4c25c4453eede3f8dbe6$var$makeArchiveFromDirectory(source, {
  baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS(),
  prefixPath = $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.root,
  compressionLevel,
  inMemory = false
} = {}) {
  const libzip = await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise();
  let zipFs;

  if (inMemory) {
    zipFs = new $ea9c1e38c3e8cca334929a597a084311$exports.ZipFS(null, {
      libzip,
      level: compressionLevel
    });
  } else {
    const tmpFolder = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise();
    const tmpFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(tmpFolder, `archive.zip`);
    zipFs = new $ea9c1e38c3e8cca334929a597a084311$exports.ZipFS(tmpFile, {
      create: true,
      libzip,
      level: compressionLevel
    });
  }

  const target = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve($ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.root, prefixPath);
  await zipFs.copyPromise(target, source, {
    baseFs,
    stableTime: true,
    stableSort: true
  });
  return zipFs;
}

var $31d442cda49d4c25c4453eede3f8dbe6$export$makeArchiveFromDirectory = $31d442cda49d4c25c4453eede3f8dbe6$var$makeArchiveFromDirectory;
$31d442cda49d4c25c4453eede3f8dbe6$exports.makeArchiveFromDirectory = $31d442cda49d4c25c4453eede3f8dbe6$export$makeArchiveFromDirectory;

async function $31d442cda49d4c25c4453eede3f8dbe6$var$convertToZip(tgz, opts) {
  const tmpFolder = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise();
  const tmpFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(tmpFolder, `archive.zip`);
  const {
    compressionLevel,
    ...bufferOpts
  } = opts;
  return await $31d442cda49d4c25c4453eede3f8dbe6$var$extractArchiveTo(tgz, new $ea9c1e38c3e8cca334929a597a084311$exports.ZipFS(tmpFile, {
    create: true,
    libzip: await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise(),
    level: compressionLevel
  }), bufferOpts);
}

var $31d442cda49d4c25c4453eede3f8dbe6$export$convertToZip = $31d442cda49d4c25c4453eede3f8dbe6$var$convertToZip;
$31d442cda49d4c25c4453eede3f8dbe6$exports.convertToZip = $31d442cda49d4c25c4453eede3f8dbe6$export$convertToZip;

async function $31d442cda49d4c25c4453eede3f8dbe6$var$extractArchiveTo(tgz, targetFs, {
  stripComponents = 0,
  prefixPath = $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot
} = {}) {
  // 1980-01-01, like Fedora
  const defaultTime = 315532800;
  const parser = $31d442cda49d4c25c4453eede3f8dbe6$var$tar_stream_1.default.extract();

  function ignore(entry) {
    // Disallow absolute paths; might be malicious (ex: /etc/passwd)
    if (entry.name[0] === `/`) return true;
    const parts = entry.name.split(/\//g); // We also ignore paths that could lead to escaping outside the archive

    // We also ignore paths that could lead to escaping outside the archive
    if (parts.some(part => part === `..`)) return true;
    if (parts.length <= stripComponents) return true;
    return false;
  }

  parser.on(`entry`, (header, stream, next) => {
    var _a, _b;

    if (ignore(header)) {
      next();
      return;
    }

    const parts = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.normalize($ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(header.name)).replace(/\/$/, ``).split(/\//g);

    if (parts.length <= stripComponents) {
      stream.resume();
      next();
      return;
    }

    const slicePath = parts.slice(stripComponents).join(`/`);
    const mappedPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(prefixPath, slicePath);
    let mode = 0o644; // If a single executable bit is set, normalize so that all are

    // If a single executable bit is set, normalize so that all are
    if (header.type === `directory` || (((_a = header.mode) !== null && _a !== void 0 ? _a : 0) & 0o111) !== 0) mode |= 0o111;

    switch (header.type) {
      case `directory`:
        {
          targetFs.mkdirpSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.mkdirSync(mappedPath);
          targetFs.chmodSync(mappedPath, mode);
          targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      case `file`:
        {
          targetFs.mkdirpSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          const chunks = [];
          stream.on(`data`, chunk => chunks.push(chunk));
          stream.on(`end`, () => {
            targetFs.writeFileSync(mappedPath, $31d442cda49d4c25c4453eede3f8dbe6$var$Buffer.concat(chunks));
            targetFs.chmodSync(mappedPath, mode);
            targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
            next();
          });
        }
        break;

      case `symlink`:
        {
          targetFs.mkdirpSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.symlinkSync(header.linkname, mappedPath);
          (_b = targetFs.lutimesSync) === null || _b === void 0 ? void 0 : _b.call(targetFs, mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      default:
        {
          stream.resume();
          next();
        }
    }
  });
  const gunzipped = await $31d442cda49d4c25c4453eede3f8dbe6$var$gunzip(tgz);
  return await new Promise((resolve, reject) => {
    parser.on(`error`, error => {
      reject(error);
    });
    parser.on(`finish`, () => {
      resolve(targetFs);
    });
    parser.end(gunzipped);
  });
}

$31d442cda49d4c25c4453eede3f8dbe6$export$extractArchiveTo = $31d442cda49d4c25c4453eede3f8dbe6$var$extractArchiveTo;
$31d442cda49d4c25c4453eede3f8dbe6$exports.extractArchiveTo = $31d442cda49d4c25c4453eede3f8dbe6$export$extractArchiveTo;
const $b0ffa420366ed37c7cf8ff798018d16e$var$tgzUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($31d442cda49d4c25c4453eede3f8dbe6$exports);
var $b0ffa420366ed37c7cf8ff798018d16e$export$tgzUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$tgzUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.tgzUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$tgzUtils;
// ASSET: node_modules/@yarnpkg/core/lib/treeUtils.js
var $5948051ccc289a50b9fb84058c129888$exports = {};
Object.defineProperty($5948051ccc289a50b9fb84058c129888$exports, "__esModule", {
  value: true
});
var $5948051ccc289a50b9fb84058c129888$export$emitTree = ($5948051ccc289a50b9fb84058c129888$export$emitList = ($5948051ccc289a50b9fb84058c129888$export$treeNodeToJson = ($5948051ccc289a50b9fb84058c129888$export$treeNodeToTreeify = void 0, $5948051ccc289a50b9fb84058c129888$exports.treeNodeToTreeify = $5948051ccc289a50b9fb84058c129888$export$treeNodeToTreeify), $5948051ccc289a50b9fb84058c129888$exports.treeNodeToJson = $5948051ccc289a50b9fb84058c129888$export$treeNodeToJson), $5948051ccc289a50b9fb84058c129888$exports.emitList = $5948051ccc289a50b9fb84058c129888$export$emitList);
$5948051ccc289a50b9fb84058c129888$exports.emitTree = $5948051ccc289a50b9fb84058c129888$export$emitTree;
// ASSET: node_modules/treeify/treeify.js
var $c593f091c81ef644a8f3efad1d84546c$exports = {};
var $c593f091c81ef644a8f3efad1d84546c$var$define;

//     treeify.js
//     Luke Plaster <notatestuser@gmail.com>
//     https://github.com/notatestuser/treeify.js
// do the universal module definition dance
(function (root, factory) {
  if (typeof $c593f091c81ef644a8f3efad1d84546c$exports === 'object') {
    $c593f091c81ef644a8f3efad1d84546c$exports = factory();
  } else if (typeof $c593f091c81ef644a8f3efad1d84546c$var$define === 'function' && $c593f091c81ef644a8f3efad1d84546c$var$define.amd) {
    $c593f091c81ef644a8f3efad1d84546c$var$define(factory);
  } else {
    root.treeify = factory();
  }
})($c593f091c81ef644a8f3efad1d84546c$exports, function () {
  function makePrefix(key, last) {
    var str = last ? '' : '';

    if (key) {
      str += ' ';
    } else {
      str += '';
    }

    return str;
  }

  function filterKeys(obj, hideFunctions) {
    var keys = [];

    for (var branch in obj) {
      // always exclude anything in the object's prototype
      if (!obj.hasOwnProperty(branch)) {
        continue;
      } // ... and hide any keys mapped to functions if we've been told to


      // ... and hide any keys mapped to functions if we've been told to
      if (hideFunctions && typeof obj[branch] === "function") {
        continue;
      }

      keys.push(branch);
    }

    return keys;
  }

  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
    var line = '',
        index = 0,
        lastKey,
        circular,
        lastStatesCopy = lastStates.slice(0);

    if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
      // based on the "was last element" states of whatever we're nested within,
      // we need to append either blankness or a branch to our line
      lastStates.forEach(function (lastState, idx) {
        if (idx > 0) {
          line += (lastState[1] ? ' ' : '') + '  ';
        }

        if (!circular && lastState[0] === root) {
          circular = true;
        }
      }); // the prefix varies based on whether the key contains something to show and
      // whether we're dealing with the last element in this collection

      // the prefix varies based on whether the key contains something to show and
      // whether we're dealing with the last element in this collection
      line += makePrefix(key, last) + key; // append values and the circular reference indicator

      // append values and the circular reference indicator
      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);
      circular && (line += ' (circular ref.)');
      callback(line);
    } // can we descend into the next item?


    // can we descend into the next item?
    if (!circular && typeof root === 'object') {
      var keys = filterKeys(root, hideFunctions);
      keys.forEach(function (branch) {
        // the last key is always printed with a different prefix, so we'll need to know if we have it
        lastKey = ++index === keys.length; // hold your breath for recursive action

        // hold your breath for recursive action
        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
      });
    }
  }

  ; // --------------------

  // --------------------
  var Treeify = {}; // Treeify.asLines
  // --------------------
  // Outputs the tree line-by-line, calling the lineCallback when each one is available.

  // Treeify.asLines
  // --------------------
  // Outputs the tree line-by-line, calling the lineCallback when each one is available.
  Treeify.asLines = function (obj, showValues, hideFunctions, lineCallback) {
    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */
    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;
    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
  }; // Treeify.asTree
  // --------------------
  // Outputs the entire tree, returning it as a string with line breaks.


  // Treeify.asTree
  // --------------------
  // Outputs the entire tree, returning it as a string with line breaks.
  Treeify.asTree = function (obj, showValues, hideFunctions) {
    var tree = '';
    growBranch('.', obj, false, [], showValues, hideFunctions, function (line) {
      tree += line + '\n';
    });
    return tree;
  }; // --------------------


  // --------------------
  return Treeify;
});

const $5948051ccc289a50b9fb84058c129888$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);

function $5948051ccc289a50b9fb84058c129888$var$treeNodeToTreeify(printTree, {
  configuration
}) {
  const target = {};

  const copyTree = (printNode, targetNode) => {
    const iterator = Array.isArray(printNode) ? printNode.entries() : Object.entries(printNode);

    for (const [key, {
      label,
      value,
      children
    }] of iterator) {
      const finalParts = [];
      if (typeof label !== `undefined`) finalParts.push($5948051ccc289a50b9fb84058c129888$var$formatUtils.applyStyle(configuration, label, $5948051ccc289a50b9fb84058c129888$var$formatUtils.Style.BOLD));
      if (typeof value !== `undefined`) finalParts.push($5948051ccc289a50b9fb84058c129888$var$formatUtils.pretty(configuration, value[0], value[1]));
      if (finalParts.length === 0) finalParts.push($5948051ccc289a50b9fb84058c129888$var$formatUtils.applyStyle(configuration, `${key}`, $5948051ccc289a50b9fb84058c129888$var$formatUtils.Style.BOLD));
      const finalLabel = finalParts.join(`: `);
      const createdNode = targetNode[finalLabel] = {};

      if (typeof children !== `undefined`) {
        copyTree(children, createdNode);
      }
    }
  };

  if (typeof printTree.children === `undefined`) throw new Error(`The root node must only contain children`);
  copyTree(printTree.children, target);
  return target;
}

var $5948051ccc289a50b9fb84058c129888$export$treeNodeToTreeify = $5948051ccc289a50b9fb84058c129888$var$treeNodeToTreeify;
$5948051ccc289a50b9fb84058c129888$exports.treeNodeToTreeify = $5948051ccc289a50b9fb84058c129888$export$treeNodeToTreeify;

function $5948051ccc289a50b9fb84058c129888$var$treeNodeToJson(printTree) {
  const copyTree = printNode => {
    var _a;

    if (typeof printNode.children === `undefined`) {
      if (typeof printNode.value === `undefined`) throw new Error(`Assertion failed: Expected a value to be set if the children are missing`);
      return $5948051ccc289a50b9fb84058c129888$var$formatUtils.json(printNode.value[0], printNode.value[1]);
    }

    const iterator = Array.isArray(printNode.children) ? printNode.children.entries() : Object.entries((_a = printNode.children) !== null && _a !== void 0 ? _a : {});
    const targetChildren = Array.isArray(printNode.children) ? [] : {};

    for (const [key, child] of iterator) targetChildren[key] = copyTree(child);

    if (typeof printNode.value === `undefined`) return targetChildren;
    return {
      value: $5948051ccc289a50b9fb84058c129888$var$formatUtils.json(printNode.value[0], printNode.value[1]),
      children: targetChildren
    };
  };

  return copyTree(printTree);
}

var $5948051ccc289a50b9fb84058c129888$export$treeNodeToJson = $5948051ccc289a50b9fb84058c129888$var$treeNodeToJson;
$5948051ccc289a50b9fb84058c129888$exports.treeNodeToJson = $5948051ccc289a50b9fb84058c129888$export$treeNodeToJson;

function $5948051ccc289a50b9fb84058c129888$var$emitList(values, {
  configuration,
  stdout,
  json
}) {
  const children = values.map(value => ({
    value
  }));
  $5948051ccc289a50b9fb84058c129888$var$emitTree({
    children
  }, {
    configuration,
    stdout,
    json
  });
}

var $5948051ccc289a50b9fb84058c129888$export$emitList = $5948051ccc289a50b9fb84058c129888$var$emitList;
$5948051ccc289a50b9fb84058c129888$exports.emitList = $5948051ccc289a50b9fb84058c129888$export$emitList;

function $5948051ccc289a50b9fb84058c129888$var$emitTree(tree, {
  configuration,
  stdout,
  json,
  separators = 0
}) {
  var _a;

  if (json) {
    const iterator = Array.isArray(tree.children) ? tree.children.values() : Object.values((_a = tree.children) !== null && _a !== void 0 ? _a : {});

    for (const child of iterator) stdout.write(`${JSON.stringify($5948051ccc289a50b9fb84058c129888$var$treeNodeToJson(child))}\n`);

    return;
  }

  let treeOutput = $c593f091c81ef644a8f3efad1d84546c$exports.asTree($5948051ccc289a50b9fb84058c129888$var$treeNodeToTreeify(tree, {
    configuration
  }), false, false); // A slight hack to add line returns between two top-level entries

  // A slight hack to add line returns between two top-level entries
  if (separators >= 1) treeOutput = treeOutput.replace(/^([])/gm, `\n$1`).replace(/^\n/, ``); // Another one for the second level fields. We run it twice because in some pathological cases the regex matches would

  // Another one for the second level fields. We run it twice because in some pathological cases the regex matches would
  if (separators >= 2) for (let t = 0; t < 2; ++t) treeOutput = treeOutput.replace(/^([ ].{2}[ ].{2}[^\n]+\n)(([ ]).{2}[].{2}[^\n]*\n[ ].{2}[ ].{2}[])/gm, `$1$3  \n$2`).replace(/^\n/, ``);
  if (separators >= 3) throw new Error(`Only the first two levels are accepted by treeUtils.emitTree`);
  stdout.write(treeOutput);
}

$5948051ccc289a50b9fb84058c129888$export$emitTree = $5948051ccc289a50b9fb84058c129888$var$emitTree;
$5948051ccc289a50b9fb84058c129888$exports.emitTree = $5948051ccc289a50b9fb84058c129888$export$emitTree;
const $b0ffa420366ed37c7cf8ff798018d16e$var$treeUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($5948051ccc289a50b9fb84058c129888$exports);
$b0ffa420366ed37c7cf8ff798018d16e$export$treeUtils = $b0ffa420366ed37c7cf8ff798018d16e$var$treeUtils;
$b0ffa420366ed37c7cf8ff798018d16e$exports.treeUtils = $b0ffa420366ed37c7cf8ff798018d16e$export$treeUtils;
// ASSET: node_modules/@yarnpkg/core/lib/Cache.js
var $bc6de8a954db7b2009bb9925037cc283$exports = {};
Object.defineProperty($bc6de8a954db7b2009bb9925037cc283$exports, "__esModule", {
  value: true
});
var $bc6de8a954db7b2009bb9925037cc283$export$Cache = void 0;
$bc6de8a954db7b2009bb9925037cc283$exports.Cache = $bc6de8a954db7b2009bb9925037cc283$export$Cache;
const $bc6de8a954db7b2009bb9925037cc283$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
const $bc6de8a954db7b2009bb9925037cc283$var$hashUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($d8692e28e950b48ea4715ab19e9bf9a1$exports);
const $bc6de8a954db7b2009bb9925037cc283$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
const $bc6de8a954db7b2009bb9925037cc283$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
const $bc6de8a954db7b2009bb9925037cc283$var$CACHE_VERSION = 7;

class $bc6de8a954db7b2009bb9925037cc283$var$Cache {
  constructor(cacheCwd, {
    configuration,
    immutable = configuration.get(`enableImmutableCache`),
    check = false
  }) {
    // Contains the list of cache files that got accessed since the last time
    // you cleared the variable. Useful to know which files aren't needed
    // anymore when used in conjunction with fetchEverything.
    this.markedFiles = new Set();
    this.mutexes = new Map();
    this.configuration = configuration;
    this.cwd = cacheCwd;
    this.immutable = immutable;
    this.check = check;
    const cacheKeyOverride = configuration.get(`cacheKeyOverride`);

    if (cacheKeyOverride !== null) {
      this.cacheKey = `${cacheKeyOverride}`;
    } else {
      const compressionLevel = configuration.get(`compressionLevel`);
      const compressionKey = compressionLevel !== $ea9c1e38c3e8cca334929a597a084311$exports.DEFAULT_COMPRESSION_LEVEL ? `c${compressionLevel}` : ``;
      this.cacheKey = [$bc6de8a954db7b2009bb9925037cc283$var$CACHE_VERSION, compressionKey].join(``);
    }
  }

  static async find(configuration, {
    immutable,
    check
  } = {}) {
    const cache = new $bc6de8a954db7b2009bb9925037cc283$var$Cache(configuration.get(`cacheFolder`), {
      configuration,
      immutable,
      check
    });
    await cache.setup();
    return cache;
  }

  get mirrorCwd() {
    if (!this.configuration.get(`enableMirror`)) return null;
    const mirrorCwd = `${this.configuration.get(`globalFolder`)}/cache`;
    return mirrorCwd !== this.cwd ? mirrorCwd : null;
  }

  getVersionFilename(locator) {
    return `${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.slugifyLocator(locator)}-${this.cacheKey}.zip`;
  }

  getChecksumFilename(locator, checksum) {
    // We only want the actual checksum (not the cache version, since the whole
    // point is to avoid changing the filenames when the cache version changes)
    const contentChecksum = $bc6de8a954db7b2009bb9925037cc283$var$getHashComponent(checksum); // We only care about the first few characters. It doesn't matter if that
    // makes the hash easier to collide with, because we check the file hashes
    // during each install anyway.

    // We only care about the first few characters. It doesn't matter if that
    // makes the hash easier to collide with, because we check the file hashes
    // during each install anyway.
    const significantChecksum = contentChecksum.slice(0, 10);
    return `${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.slugifyLocator(locator)}-${significantChecksum}.zip`;
  }

  getLocatorPath(locator, expectedChecksum) {
    // If there is no mirror, then the local cache *is* the mirror, in which
    // case we use the versioned filename pattern.
    if (this.mirrorCwd === null) return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(this.cwd, this.getVersionFilename(locator)); // If we don't yet know the checksum, discard the path resolution for now
    // until the checksum can be obtained from somewhere (mirror or network).

    // If we don't yet know the checksum, discard the path resolution for now
    // until the checksum can be obtained from somewhere (mirror or network).
    if (expectedChecksum === null) return null; // If the cache key changed then we assume that the content probably got
    // altered as well and thus the existing path won't be good enough anymore.

    // If the cache key changed then we assume that the content probably got
    // altered as well and thus the existing path won't be good enough anymore.
    const cacheKey = $bc6de8a954db7b2009bb9925037cc283$var$getCacheKeyComponent(expectedChecksum);
    if (cacheKey !== this.cacheKey) return null;
    return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(this.cwd, this.getChecksumFilename(locator, expectedChecksum));
  }

  getLocatorMirrorPath(locator) {
    const mirrorCwd = this.mirrorCwd;
    return mirrorCwd !== null ? $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(mirrorCwd, this.getVersionFilename(locator)) : null;
  }

  async setup() {
    if (!this.configuration.get(`enableGlobalCache`)) {
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(this.cwd, {
        recursive: true
      });
      const gitignorePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(this.cwd, `.gitignore`);
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(gitignorePath, `/.gitignore\n*.flock\n`);
    }
  }

  async fetchPackageFromCache(locator, expectedChecksum, {
    onHit,
    onMiss,
    loader,
    skipIntegrityCheck
  }) {
    const mirrorPath = this.getLocatorMirrorPath(locator);
    const baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS();

    const validateFile = async (path, refetchPath = null) => {
      const actualChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await $bc6de8a954db7b2009bb9925037cc283$var$hashUtils.checksumFile(path)}` : expectedChecksum;

      if (refetchPath !== null) {
        const previousChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await $bc6de8a954db7b2009bb9925037cc283$var$hashUtils.checksumFile(refetchPath)}` : expectedChecksum;

        if (actualChecksum !== previousChecksum) {
          throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the local checksum - has the local cache been corrupted?`);
        }
      }

      if (expectedChecksum !== null && actualChecksum !== expectedChecksum) {
        let checksumBehavior; // Using --check-cache overrides any preconfigured checksum behavior

        // Using --check-cache overrides any preconfigured checksum behavior
        if (this.check) checksumBehavior = `throw`; // If the lockfile references an old cache format, we tolerate different checksums
        else // If the lockfile references an old cache format, we tolerate different checksums
          if ($bc6de8a954db7b2009bb9925037cc283$var$getCacheKeyComponent(expectedChecksum) !== $bc6de8a954db7b2009bb9925037cc283$var$getCacheKeyComponent(actualChecksum)) checksumBehavior = `update`;else checksumBehavior = this.configuration.get(`checksumBehavior`);

        switch (checksumBehavior) {
          case `ignore`:
            return expectedChecksum;

          case `update`:
            return actualChecksum;

          default:
          case `throw`:
            {
              throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the expected checksum`);
            }
        }
      }

      return actualChecksum;
    };

    const validateFileAgainstRemote = async cachePath => {
      if (!loader) throw new Error(`Cache check required but no loader configured for ${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.prettyLocator(this.configuration, locator)}`);
      const zipFs = await loader();
      const refetchPath = zipFs.getRealPath();
      zipFs.saveAndClose();
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.chmodPromise(refetchPath, 0o644);
      return await validateFile(cachePath, refetchPath);
    };

    const loadPackageThroughMirror = async () => {
      if (mirrorPath === null || !(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsPromise(mirrorPath))) {
        const zipFs = await loader();
        const realPath = zipFs.getRealPath();
        zipFs.saveAndClose();
        return realPath;
      }

      const tempDir = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise();
      const tempPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(tempDir, this.getVersionFilename(locator));
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.copyFilePromise(mirrorPath, tempPath, $bc6de8a954db7b2009bb9925037cc283$var$fs_1.default.constants.COPYFILE_FICLONE);
      return tempPath;
    };

    const loadPackage = async () => {
      if (!loader) throw new Error(`Cache entry required but missing for ${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.prettyLocator(this.configuration, locator)}`);
      if (this.immutable) throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.IMMUTABLE_CACHE, `Cache entry required but missing for ${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.prettyLocator(this.configuration, locator)}`);
      const originalPath = await loadPackageThroughMirror();
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.chmodPromise(originalPath, 0o644); // Do this before moving the file so that we don't pollute the cache with corrupted archives

      // Do this before moving the file so that we don't pollute the cache with corrupted archives
      const checksum = await validateFile(originalPath);
      const cachePath = this.getLocatorPath(locator, checksum);
      if (!cachePath) throw new Error(`Assertion failed: Expected the cache path to be available`);
      return await this.writeFileWithLock(cachePath, async () => {
        return await this.writeFileWithLock(mirrorPath, async () => {
          // Doing a move is important to ensure atomic writes (todo: cross-drive?)
          await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.movePromise(originalPath, cachePath);
          if (mirrorPath !== null) await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.copyFilePromise(cachePath, mirrorPath, $bc6de8a954db7b2009bb9925037cc283$var$fs_1.default.constants.COPYFILE_FICLONE);
          return [cachePath, checksum];
        });
      });
    };

    const loadPackageThroughMutex = async () => {
      const mutexedLoad = async () => {
        // We don't yet know whether the cache path can be computed yet, since that
        // depends on whether the cache is actually the mirror or not, and whether
        // the checksum is known or not.
        const tentativeCachePath = this.getLocatorPath(locator, expectedChecksum);
        const cacheExists = tentativeCachePath !== null ? await baseFs.existsPromise(tentativeCachePath) : false;
        const action = cacheExists ? onHit : onMiss;
        if (action) action();

        if (!cacheExists) {
          return loadPackage();
        } else {
          let checksum = null;
          const cachePath = tentativeCachePath;
          if (this.check) checksum = await validateFileAgainstRemote(cachePath);else checksum = await validateFile(cachePath);
          return [cachePath, checksum];
        }
      };

      const mutex = mutexedLoad();
      this.mutexes.set(locator.locatorHash, mutex);

      try {
        return await mutex;
      } finally {
        this.mutexes.delete(locator.locatorHash);
      }
    };

    for (let mutex; mutex = this.mutexes.get(locator.locatorHash);) await mutex;

    const [cachePath, checksum] = await loadPackageThroughMutex();
    this.markedFiles.add(cachePath);
    let zipFs = null;
    const libzip = await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise();
    const lazyFs = new $ea9c1e38c3e8cca334929a597a084311$exports.LazyFS(() => $bc6de8a954db7b2009bb9925037cc283$var$miscUtils.prettifySyncErrors(() => {
      return zipFs = new $ea9c1e38c3e8cca334929a597a084311$exports.ZipFS(cachePath, {
        baseFs,
        libzip,
        readOnly: true
      });
    }, message => {
      return `Failed to open the cache entry for ${$bc6de8a954db7b2009bb9925037cc283$var$structUtils.prettyLocator(this.configuration, locator)}: ${message}`;
    }), $ea9c1e38c3e8cca334929a597a084311$exports.ppath); // We use an AliasFS to speed up getRealPath calls (e.g. VirtualFetcher.ensureVirtualLink)
    // (there's no need to create the lazy baseFs instance to gather the already-known cachePath)

    // We use an AliasFS to speed up getRealPath calls (e.g. VirtualFetcher.ensureVirtualLink)
    // (there's no need to create the lazy baseFs instance to gather the already-known cachePath)
    const aliasFs = new $ea9c1e38c3e8cca334929a597a084311$exports.AliasFS(cachePath, {
      baseFs: lazyFs,
      pathUtils: $ea9c1e38c3e8cca334929a597a084311$exports.ppath
    });

    const releaseFs = () => {
      if (zipFs !== null) {
        zipFs.discardAndClose();
      }
    };

    return [aliasFs, releaseFs, checksum];
  }

  async writeFileWithLock(file, generator) {
    if (file === null) return await generator();
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(file), {
      recursive: true
    });
    return await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.lockPromise(file, async () => {
      return await generator();
    });
  }

}

$bc6de8a954db7b2009bb9925037cc283$export$Cache = $bc6de8a954db7b2009bb9925037cc283$var$Cache;
$bc6de8a954db7b2009bb9925037cc283$exports.Cache = $bc6de8a954db7b2009bb9925037cc283$export$Cache;

function $bc6de8a954db7b2009bb9925037cc283$var$getCacheKeyComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(0, split) : null;
}

function $bc6de8a954db7b2009bb9925037cc283$var$getHashComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(split + 1) : checksum;
}

Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Cache", {
  enumerable: true,
  get: function () {
    return $bc6de8a954db7b2009bb9925037cc283$exports.Cache;
  }
});
// ASSET: node_modules/@yarnpkg/core/lib/Configuration.js
var $423262bd9e933160a1646431d9f01697$export$SettingsType,
    $423262bd9e933160a1646431d9f01697$export$ProjectLookup,
    $423262bd9e933160a1646431d9f01697$exports = {};
var $423262bd9e933160a1646431d9f01697$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($423262bd9e933160a1646431d9f01697$exports, "__esModule", {
  value: true
});
var $423262bd9e933160a1646431d9f01697$export$Configuration = ($423262bd9e933160a1646431d9f01697$export$ProjectLookup = ($423262bd9e933160a1646431d9f01697$export$coreDefinitions = ($423262bd9e933160a1646431d9f01697$export$FormatType = ($423262bd9e933160a1646431d9f01697$export$SettingsType = ($423262bd9e933160a1646431d9f01697$export$SECRET = ($423262bd9e933160a1646431d9f01697$export$DEFAULT_LOCK_FILENAME = ($423262bd9e933160a1646431d9f01697$export$DEFAULT_RC_FILENAME = ($423262bd9e933160a1646431d9f01697$export$ENVIRONMENT_PREFIX = void 0, $423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX = $423262bd9e933160a1646431d9f01697$export$ENVIRONMENT_PREFIX), $423262bd9e933160a1646431d9f01697$exports.DEFAULT_RC_FILENAME = $423262bd9e933160a1646431d9f01697$export$DEFAULT_RC_FILENAME), $423262bd9e933160a1646431d9f01697$exports.DEFAULT_LOCK_FILENAME = $423262bd9e933160a1646431d9f01697$export$DEFAULT_LOCK_FILENAME), $423262bd9e933160a1646431d9f01697$exports.SECRET = $423262bd9e933160a1646431d9f01697$export$SECRET), $423262bd9e933160a1646431d9f01697$exports.SettingsType = $423262bd9e933160a1646431d9f01697$export$SettingsType), $423262bd9e933160a1646431d9f01697$exports.FormatType = $423262bd9e933160a1646431d9f01697$export$FormatType), $423262bd9e933160a1646431d9f01697$exports.coreDefinitions = $423262bd9e933160a1646431d9f01697$export$coreDefinitions), $423262bd9e933160a1646431d9f01697$exports.ProjectLookup = $423262bd9e933160a1646431d9f01697$export$ProjectLookup);
$423262bd9e933160a1646431d9f01697$exports.Configuration = $423262bd9e933160a1646431d9f01697$export$Configuration;
// ASSET: node_modules/camelcase/index.js
var $af83f2d96ee3ef017ebae3b2ffe06c36$exports = {};

const $af83f2d96ee3ef017ebae3b2ffe06c36$var$preserveCamelCase = string => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;

  for (let i = 0; i < string.length; i++) {
    const character = string[i];

    if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
      string = string.slice(0, i) + '-' + string.slice(i);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
      string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
    }
  }

  return string;
};

const $af83f2d96ee3ef017ebae3b2ffe06c36$var$camelCase = (input, options) => {
  if (!(typeof input === 'string' || Array.isArray(input))) {
    throw new TypeError('Expected the input to be `string | string[]`');
  }

  options = Object.assign({
    pascalCase: false
  }, options);

  const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

  if (Array.isArray(input)) {
    input = input.map(x => x.trim()).filter(x => x.length).join('-');
  } else {
    input = input.trim();
  }

  if (input.length === 0) {
    return '';
  }

  if (input.length === 1) {
    return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
  }

  const hasUpperCase = input !== input.toLowerCase();

  if (hasUpperCase) {
    input = $af83f2d96ee3ef017ebae3b2ffe06c36$var$preserveCamelCase(input);
  }

  input = input.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, m => m.toUpperCase());
  return postProcess(input);
};

$af83f2d96ee3ef017ebae3b2ffe06c36$exports = $af83f2d96ee3ef017ebae3b2ffe06c36$var$camelCase; // TODO: Remove this for the next major release

var $af83f2d96ee3ef017ebae3b2ffe06c36$export$default = $af83f2d96ee3ef017ebae3b2ffe06c36$var$camelCase;
// TODO: Remove this for the next major release
$af83f2d96ee3ef017ebae3b2ffe06c36$exports.default = $af83f2d96ee3ef017ebae3b2ffe06c36$export$default;
const $423262bd9e933160a1646431d9f01697$var$camelcase_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($af83f2d96ee3ef017ebae3b2ffe06c36$exports);
const $423262bd9e933160a1646431d9f01697$var$ci_info_1 = {};
const $423262bd9e933160a1646431d9f01697$var$p_limit_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($e6872599661a671bb42eeb06298de58e$exports);
const $423262bd9e933160a1646431d9f01697$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
// ASSET: node_modules/@yarnpkg/core/lib/CorePlugin.js
var $c94854a52fa15ac05aa4c02a3d9a9e6a$exports = {};
Object.defineProperty($c94854a52fa15ac05aa4c02a3d9a9e6a$exports, "__esModule", {
  value: true
});
var $c94854a52fa15ac05aa4c02a3d9a9e6a$export$CorePlugin = void 0;
$c94854a52fa15ac05aa4c02a3d9a9e6a$exports.CorePlugin = $c94854a52fa15ac05aa4c02a3d9a9e6a$export$CorePlugin;
const $c94854a52fa15ac05aa4c02a3d9a9e6a$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
$c94854a52fa15ac05aa4c02a3d9a9e6a$export$CorePlugin = {
  hooks: {
    reduceDependency: (dependency, project, locator, initialDependency, {
      resolver,
      resolveOptions
    }) => {
      for (const {
        pattern,
        reference
      } of project.topLevelWorkspace.manifest.resolutions) {
        if (pattern.from && pattern.from.fullName !== $c94854a52fa15ac05aa4c02a3d9a9e6a$var$structUtils.requirableIdent(locator)) continue;
        if (pattern.from && pattern.from.description && pattern.from.description !== locator.reference) continue;
        if (pattern.descriptor.fullName !== $c94854a52fa15ac05aa4c02a3d9a9e6a$var$structUtils.requirableIdent(dependency)) continue;
        if (pattern.descriptor.description && pattern.descriptor.description !== dependency.range) continue;
        const alias = resolver.bindDescriptor($c94854a52fa15ac05aa4c02a3d9a9e6a$var$structUtils.makeDescriptor(dependency, reference), project.topLevelWorkspace.anchoredLocator, resolveOptions);
        return alias;
      }

      return dependency;
    },
    validateProject: async (project, report) => {
      for (const workspace of project.workspaces) {
        const workspaceName = $c94854a52fa15ac05aa4c02a3d9a9e6a$var$structUtils.prettyWorkspace(project.configuration, workspace);
        await project.configuration.triggerHook(hooks => {
          return hooks.validateWorkspace;
        }, workspace, {
          reportWarning: (name, text) => report.reportWarning(name, `${workspaceName}: ${text}`),
          reportError: (name, text) => report.reportError(name, `${workspaceName}: ${text}`)
        });
      }
    },
    validateWorkspace: async (workspace, report) => {
      // Validate manifest
      const {
        manifest
      } = workspace;
      if (manifest.resolutions.length && workspace.cwd !== workspace.project.cwd) manifest.errors.push(new Error(`Resolutions field will be ignored`));

      for (const manifestError of manifest.errors) {
        report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.INVALID_MANIFEST, manifestError.message);
      }
    }
  }
};
$c94854a52fa15ac05aa4c02a3d9a9e6a$exports.CorePlugin = $c94854a52fa15ac05aa4c02a3d9a9e6a$export$CorePlugin;
// ASSET: node_modules/@yarnpkg/core/lib/MultiFetcher.js
var $f91eb5f17c077b9ec21b15cbced9ebda$exports = {};
Object.defineProperty($f91eb5f17c077b9ec21b15cbced9ebda$exports, "__esModule", {
  value: true
});
var $f91eb5f17c077b9ec21b15cbced9ebda$export$MultiFetcher = void 0;
$f91eb5f17c077b9ec21b15cbced9ebda$exports.MultiFetcher = $f91eb5f17c077b9ec21b15cbced9ebda$export$MultiFetcher;
const $f91eb5f17c077b9ec21b15cbced9ebda$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $f91eb5f17c077b9ec21b15cbced9ebda$var$MultiFetcher {
  constructor(fetchers) {
    this.fetchers = fetchers;
  }

  supports(locator, opts) {
    if (!this.tryFetcher(locator, opts)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return fetcher.getLocalPath(locator, opts);
  }

  async fetch(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return await fetcher.fetch(locator, opts);
  }

  tryFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) return null;
    return fetcher;
  }

  getFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FETCHER_NOT_FOUND, `${$f91eb5f17c077b9ec21b15cbced9ebda$var$structUtils.prettyLocator(opts.project.configuration, locator)} isn't supported by any available fetcher`);
    return fetcher;
  }

}

$f91eb5f17c077b9ec21b15cbced9ebda$export$MultiFetcher = $f91eb5f17c077b9ec21b15cbced9ebda$var$MultiFetcher;
$f91eb5f17c077b9ec21b15cbced9ebda$exports.MultiFetcher = $f91eb5f17c077b9ec21b15cbced9ebda$export$MultiFetcher;
// ASSET: node_modules/@yarnpkg/core/lib/MultiResolver.js
var $d87b895bfcf6a6f21386ff7ce5f5276b$exports = {};
Object.defineProperty($d87b895bfcf6a6f21386ff7ce5f5276b$exports, "__esModule", {
  value: true
});
var $d87b895bfcf6a6f21386ff7ce5f5276b$export$MultiResolver = void 0;
$d87b895bfcf6a6f21386ff7ce5f5276b$exports.MultiResolver = $d87b895bfcf6a6f21386ff7ce5f5276b$export$MultiResolver;
const $d87b895bfcf6a6f21386ff7ce5f5276b$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $d87b895bfcf6a6f21386ff7ce5f5276b$var$MultiResolver {
  constructor(resolvers) {
    this.resolvers = resolvers.filter(resolver => resolver);
  }

  supportsDescriptor(descriptor, opts) {
    const resolver = this.tryResolverByDescriptor(descriptor, opts);
    return !!resolver;
  }

  supportsLocator(locator, opts) {
    const resolver = this.tryResolverByLocator(locator, opts);
    return !!resolver;
  }

  shouldPersistResolution(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return await resolver.getCandidates(descriptor, dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.getSatisfying(descriptor, references, opts);
  }

  async resolve(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return await resolver.resolve(locator, opts);
  }

  tryResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) throw new Error(`${$d87b895bfcf6a6f21386ff7ce5f5276b$var$structUtils.prettyDescriptor(opts.project.configuration, descriptor)} isn't supported by any available resolver`);
    return resolver;
  }

  tryResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) throw new Error(`${$d87b895bfcf6a6f21386ff7ce5f5276b$var$structUtils.prettyLocator(opts.project.configuration, locator)} isn't supported by any available resolver`);
    return resolver;
  }

}

$d87b895bfcf6a6f21386ff7ce5f5276b$export$MultiResolver = $d87b895bfcf6a6f21386ff7ce5f5276b$var$MultiResolver;
$d87b895bfcf6a6f21386ff7ce5f5276b$exports.MultiResolver = $d87b895bfcf6a6f21386ff7ce5f5276b$export$MultiResolver;
// ASSET: node_modules/@yarnpkg/core/lib/ProtocolResolver.js
var $75d39c0c5e08a7896c4fa0e540ce7c49$exports = {};
Object.defineProperty($75d39c0c5e08a7896c4fa0e540ce7c49$exports, "__esModule", {
  value: true
});
var $75d39c0c5e08a7896c4fa0e540ce7c49$export$ProtocolResolver = ($75d39c0c5e08a7896c4fa0e540ce7c49$export$TAG_REGEXP = void 0, $75d39c0c5e08a7896c4fa0e540ce7c49$exports.TAG_REGEXP = $75d39c0c5e08a7896c4fa0e540ce7c49$export$TAG_REGEXP);
$75d39c0c5e08a7896c4fa0e540ce7c49$exports.ProtocolResolver = $75d39c0c5e08a7896c4fa0e540ce7c49$export$ProtocolResolver;
const $75d39c0c5e08a7896c4fa0e540ce7c49$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $75d39c0c5e08a7896c4fa0e540ce7c49$var$semverUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4b3129d95390e44c4289200276bae532$exports);
const $75d39c0c5e08a7896c4fa0e540ce7c49$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
var $75d39c0c5e08a7896c4fa0e540ce7c49$export$TAG_REGEXP = /^(?!v)[a-z0-9-.]+$/i;
$75d39c0c5e08a7896c4fa0e540ce7c49$exports.TAG_REGEXP = $75d39c0c5e08a7896c4fa0e540ce7c49$export$TAG_REGEXP;

class $75d39c0c5e08a7896c4fa0e540ce7c49$var$ProtocolResolver {
  supportsDescriptor(descriptor, opts) {
    if ($75d39c0c5e08a7896c4fa0e540ce7c49$var$semverUtils.validRange(descriptor.range)) return true;
    if ($75d39c0c5e08a7896c4fa0e540ce7c49$exports.TAG_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if ($75d39c0c5e08a7896c4fa0e540ce7c49$var$semver_1.default.valid(locator.reference)) return true;
    if ($75d39c0c5e08a7896c4fa0e540ce7c49$exports.TAG_REGEXP.test(locator.reference)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return opts.resolver.getResolutionDependencies(this.forwardDescriptor(descriptor, opts), opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    return await opts.resolver.getSatisfying(this.forwardDescriptor(descriptor, opts), references, opts);
  }

  async resolve(locator, opts) {
    const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
    return $75d39c0c5e08a7896c4fa0e540ce7c49$var$structUtils.renamePackage(pkg, locator);
  }

  forwardDescriptor(descriptor, opts) {
    return $75d39c0c5e08a7896c4fa0e540ce7c49$var$structUtils.makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
  }

  forwardLocator(locator, opts) {
    return $75d39c0c5e08a7896c4fa0e540ce7c49$var$structUtils.makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
  }

}

$75d39c0c5e08a7896c4fa0e540ce7c49$export$ProtocolResolver = $75d39c0c5e08a7896c4fa0e540ce7c49$var$ProtocolResolver;
$75d39c0c5e08a7896c4fa0e540ce7c49$exports.ProtocolResolver = $75d39c0c5e08a7896c4fa0e540ce7c49$export$ProtocolResolver;
// ASSET: node_modules/@yarnpkg/core/lib/VirtualFetcher.js
var $fc50e50f7b33bbd0cc6647e8b74fa144$exports = {};
Object.defineProperty($fc50e50f7b33bbd0cc6647e8b74fa144$exports, "__esModule", {
  value: true
});
var $fc50e50f7b33bbd0cc6647e8b74fa144$export$VirtualFetcher = void 0;
$fc50e50f7b33bbd0cc6647e8b74fa144$exports.VirtualFetcher = $fc50e50f7b33bbd0cc6647e8b74fa144$export$VirtualFetcher;
const $fc50e50f7b33bbd0cc6647e8b74fa144$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $fc50e50f7b33bbd0cc6647e8b74fa144$var$VirtualFetcher {
  supports(locator) {
    if (!locator.reference.startsWith(`virtual:`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = $fc50e50f7b33bbd0cc6647e8b74fa144$var$structUtils.makeLocator(locator, nextReference);
    return opts.fetcher.getLocalPath(nextLocator, opts);
  }

  async fetch(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = $fc50e50f7b33bbd0cc6647e8b74fa144$var$structUtils.makeLocator(locator, nextReference);
    const parentFetch = await opts.fetcher.fetch(nextLocator, opts);
    return await this.ensureVirtualLink(locator, parentFetch, opts);
  }

  getLocatorFilename(locator) {
    return $fc50e50f7b33bbd0cc6647e8b74fa144$var$structUtils.slugifyLocator(locator);
  }

  async ensureVirtualLink(locator, sourceFetch, opts) {
    const to = sourceFetch.packageFs.getRealPath();
    const virtualFolder = opts.project.configuration.get(`virtualFolder`);
    const virtualName = this.getLocatorFilename(locator);
    const virtualPath = $ea9c1e38c3e8cca334929a597a084311$exports.VirtualFS.makeVirtualPath(virtualFolder, virtualName, to); // We then use an alias to tell anyone that asks us that we're operating within the virtual folder, while still using the same old fs

    // We then use an alias to tell anyone that asks us that we're operating within the virtual folder, while still using the same old fs
    const aliasFs = new $ea9c1e38c3e8cca334929a597a084311$exports.AliasFS(virtualPath, {
      baseFs: sourceFetch.packageFs,
      pathUtils: $ea9c1e38c3e8cca334929a597a084311$exports.ppath
    });
    return { ...sourceFetch,
      packageFs: aliasFs
    };
  }

}

$fc50e50f7b33bbd0cc6647e8b74fa144$export$VirtualFetcher = $fc50e50f7b33bbd0cc6647e8b74fa144$var$VirtualFetcher;
$fc50e50f7b33bbd0cc6647e8b74fa144$exports.VirtualFetcher = $fc50e50f7b33bbd0cc6647e8b74fa144$export$VirtualFetcher;
// ASSET: node_modules/@yarnpkg/core/lib/VirtualResolver.js
var $f185e3c645e9965f23ab62acf4fbf46d$exports = {};
Object.defineProperty($f185e3c645e9965f23ab62acf4fbf46d$exports, "__esModule", {
  value: true
});
var $f185e3c645e9965f23ab62acf4fbf46d$export$VirtualResolver = void 0;
$f185e3c645e9965f23ab62acf4fbf46d$exports.VirtualResolver = $f185e3c645e9965f23ab62acf4fbf46d$export$VirtualResolver;

class $f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver {
  static isVirtualDescriptor(descriptor) {
    if (!descriptor.range.startsWith($f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver.protocol)) return false;
    return true;
  }

  static isVirtualLocator(locator) {
    if (!locator.reference.startsWith($f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver.protocol)) return false;
    return true;
  }

  supportsDescriptor(descriptor, opts) {
    return $f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver.isVirtualDescriptor(descriptor);
  }

  supportsLocator(locator, opts) {
    return $f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver.isVirtualLocator(locator);
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "bindDescriptor" on a virtual descriptor is unsupported`);
  }

  getResolutionDependencies(descriptor, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "getResolutionDependencies" on a virtual descriptor is unsupported`);
  }

  async getCandidates(descriptor, dependencies, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `getCandidates` anymore.
    throw new Error(`Assertion failed: calling "getCandidates" on a virtual descriptor is unsupported`);
  }

  async getSatisfying(descriptor, candidates, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `getSatisfying` anymore.
    throw new Error(`Assertion failed: calling "getSatisfying" on a virtual descriptor is unsupported`);
  }

  async resolve(locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `resolve` anymore.
    throw new Error(`Assertion failed: calling "resolve" on a virtual locator is unsupported`);
  }

}

$f185e3c645e9965f23ab62acf4fbf46d$export$VirtualResolver = $f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver;
$f185e3c645e9965f23ab62acf4fbf46d$exports.VirtualResolver = $f185e3c645e9965f23ab62acf4fbf46d$export$VirtualResolver;
$f185e3c645e9965f23ab62acf4fbf46d$var$VirtualResolver.protocol = `virtual:`;
// ASSET: node_modules/@yarnpkg/core/lib/WorkspaceFetcher.js
var $503b443396459f312634283e2397528c$exports = {};
Object.defineProperty($503b443396459f312634283e2397528c$exports, "__esModule", {
  value: true
});
var $503b443396459f312634283e2397528c$export$WorkspaceFetcher = void 0;
$503b443396459f312634283e2397528c$exports.WorkspaceFetcher = $503b443396459f312634283e2397528c$export$WorkspaceFetcher;
// ASSET: node_modules/@yarnpkg/core/lib/WorkspaceResolver.js
var $e51615528f8e8c3722173c3f23aaa762$exports = {};
Object.defineProperty($e51615528f8e8c3722173c3f23aaa762$exports, "__esModule", {
  value: true
});
var $e51615528f8e8c3722173c3f23aaa762$export$WorkspaceResolver = void 0;
$e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver = $e51615528f8e8c3722173c3f23aaa762$export$WorkspaceResolver;

class $e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver {
  supportsDescriptor(descriptor, opts) {
    if (descriptor.range.startsWith($e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver.protocol)) return true;
    const workspace = opts.project.tryWorkspaceByDescriptor(descriptor);
    if (workspace !== null) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith($e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver.protocol)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const workspace = opts.project.getWorkspaceByDescriptor(descriptor);
    return [workspace.anchoredLocator];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    const workspace = opts.project.getWorkspaceByCwd(locator.reference.slice($e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver.protocol.length));
    return { ...locator,
      version: workspace.manifest.version || `0.0.0`,
      languageName: `unknown`,
      linkType: $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType.SOFT,
      dependencies: new Map([...workspace.manifest.dependencies, ...workspace.manifest.devDependencies]),
      peerDependencies: new Map([...workspace.manifest.peerDependencies]),
      dependenciesMeta: workspace.manifest.dependenciesMeta,
      peerDependenciesMeta: workspace.manifest.peerDependenciesMeta,
      bin: workspace.manifest.bin
    };
  }

}

$e51615528f8e8c3722173c3f23aaa762$export$WorkspaceResolver = $e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver;
$e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver = $e51615528f8e8c3722173c3f23aaa762$export$WorkspaceResolver;
$e51615528f8e8c3722173c3f23aaa762$var$WorkspaceResolver.protocol = `workspace:`;

class $503b443396459f312634283e2397528c$var$WorkspaceFetcher {
  supports(locator) {
    if (!locator.reference.startsWith($e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return this.getWorkspace(locator, opts).cwd;
  }

  async fetch(locator, opts) {
    const sourcePath = this.getWorkspace(locator, opts).cwd;
    return {
      packageFs: new $ea9c1e38c3e8cca334929a597a084311$exports.CwdFS(sourcePath),
      prefixPath: $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot,
      localPath: sourcePath
    };
  }

  getWorkspace(locator, opts) {
    return opts.project.getWorkspaceByCwd(locator.reference.slice($e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol.length));
  }

}

$503b443396459f312634283e2397528c$export$WorkspaceFetcher = $503b443396459f312634283e2397528c$var$WorkspaceFetcher;
$503b443396459f312634283e2397528c$exports.WorkspaceFetcher = $503b443396459f312634283e2397528c$export$WorkspaceFetcher;
const $423262bd9e933160a1646431d9f01697$var$folderUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4e053bc37466537c5bd23b074c01d016$exports);
const $423262bd9e933160a1646431d9f01697$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
const $423262bd9e933160a1646431d9f01697$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
// ASSET: node_modules/@yarnpkg/core/lib/nodeUtils.js
var $bccf5812cffa24bd2c819d474c7e6e49$exports = {};
var $bccf5812cffa24bd2c819d474c7e6e49$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($bccf5812cffa24bd2c819d474c7e6e49$exports, "__esModule", {
  value: true
});
var $bccf5812cffa24bd2c819d474c7e6e49$export$builtinModules = ($bccf5812cffa24bd2c819d474c7e6e49$export$dynamicRequire = void 0, $bccf5812cffa24bd2c819d474c7e6e49$exports.dynamicRequire = $bccf5812cffa24bd2c819d474c7e6e49$export$dynamicRequire);
$bccf5812cffa24bd2c819d474c7e6e49$exports.builtinModules = $bccf5812cffa24bd2c819d474c7e6e49$export$builtinModules;
const $bccf5812cffa24bd2c819d474c7e6e49$var$module_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault({});

function $bccf5812cffa24bd2c819d474c7e6e49$var$dynamicRequire(request) {
  const req = typeof __non_webpack_require__ !== `undefined` ? __non_webpack_require__ : require;
  return req(request);
}

var $bccf5812cffa24bd2c819d474c7e6e49$export$dynamicRequire = $bccf5812cffa24bd2c819d474c7e6e49$var$dynamicRequire;
$bccf5812cffa24bd2c819d474c7e6e49$exports.dynamicRequire = $bccf5812cffa24bd2c819d474c7e6e49$export$dynamicRequire;

function $bccf5812cffa24bd2c819d474c7e6e49$var$builtinModules() {
  // @ts-expect-error
  return new Set($bccf5812cffa24bd2c819d474c7e6e49$var$module_1.default.builtinModules || Object.keys($bccf5812cffa24bd2c819d474c7e6e49$var$process.binding(`natives`)));
}

$bccf5812cffa24bd2c819d474c7e6e49$export$builtinModules = $bccf5812cffa24bd2c819d474c7e6e49$var$builtinModules;
$bccf5812cffa24bd2c819d474c7e6e49$exports.builtinModules = $bccf5812cffa24bd2c819d474c7e6e49$export$builtinModules;
const $423262bd9e933160a1646431d9f01697$var$nodeUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($bccf5812cffa24bd2c819d474c7e6e49$exports);
const $423262bd9e933160a1646431d9f01697$var$semverUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4b3129d95390e44c4289200276bae532$exports);
const $423262bd9e933160a1646431d9f01697$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
const $423262bd9e933160a1646431d9f01697$var$IGNORED_ENV_VARIABLES = new Set([// "binFolder" is the magic location where the parent process stored the
// current binaries; not an actual configuration settings
`binFolder`, // "version" is set by Docker:
// https://github.com/nodejs/docker-node/blob/5a6a5e91999358c5b04fddd6c22a9a4eb0bf3fbf/10/alpine/Dockerfile#L51
`version`, // "flags" is set by Netlify; they use it to specify the flags to send to the
// CLI when running the automatic `yarn install`
`flags`, // "gpg" and "profile" are used by the install.sh script:
// https://classic.yarnpkg.com/install.sh
`profile`, `gpg`, // "ignoreNode" is used to disable the Node version check
`ignoreNode`, // "wrapOutput" was a variable used to indicate nested "yarn run" processes
// back in Yarn 1.
`wrapOutput`]);
var $423262bd9e933160a1646431d9f01697$export$ENVIRONMENT_PREFIX = `yarn_`;
$423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX = $423262bd9e933160a1646431d9f01697$export$ENVIRONMENT_PREFIX;
var $423262bd9e933160a1646431d9f01697$export$DEFAULT_RC_FILENAME = `.yarnrc.yml`;
$423262bd9e933160a1646431d9f01697$exports.DEFAULT_RC_FILENAME = $423262bd9e933160a1646431d9f01697$export$DEFAULT_RC_FILENAME;
var $423262bd9e933160a1646431d9f01697$export$DEFAULT_LOCK_FILENAME = `yarn.lock`;
$423262bd9e933160a1646431d9f01697$exports.DEFAULT_LOCK_FILENAME = $423262bd9e933160a1646431d9f01697$export$DEFAULT_LOCK_FILENAME;
var $423262bd9e933160a1646431d9f01697$export$SECRET = `********`;
$423262bd9e933160a1646431d9f01697$exports.SECRET = $423262bd9e933160a1646431d9f01697$export$SECRET;
var $423262bd9e933160a1646431d9f01697$var$SettingsType;

(function (SettingsType) {
  SettingsType["ANY"] = "ANY";
  SettingsType["BOOLEAN"] = "BOOLEAN";
  SettingsType["ABSOLUTE_PATH"] = "ABSOLUTE_PATH";
  SettingsType["LOCATOR"] = "LOCATOR";
  SettingsType["LOCATOR_LOOSE"] = "LOCATOR_LOOSE";
  SettingsType["NUMBER"] = "NUMBER";
  SettingsType["STRING"] = "STRING";
  SettingsType["SECRET"] = "SECRET";
  SettingsType["SHAPE"] = "SHAPE";
  SettingsType["MAP"] = "MAP";
})($423262bd9e933160a1646431d9f01697$var$SettingsType = $423262bd9e933160a1646431d9f01697$exports.SettingsType || ($423262bd9e933160a1646431d9f01697$export$SettingsType = {}, $423262bd9e933160a1646431d9f01697$exports.SettingsType = $423262bd9e933160a1646431d9f01697$export$SettingsType));

var $423262bd9e933160a1646431d9f01697$export$FormatType = $423262bd9e933160a1646431d9f01697$var$formatUtils.Type;
$423262bd9e933160a1646431d9f01697$exports.FormatType = $423262bd9e933160a1646431d9f01697$export$FormatType; // General rules:
//
// - filenames that don't accept actual paths must end with the "Filename" suffix
//   prefer to use absolute paths instead, since they are automatically resolved
//   ex: lockfileFilename
//
// - folders must end with the "Folder" suffix
//   ex: cacheFolder, pnpVirtualFolder
//
// - actual paths to a file must end with the "Path" suffix
//   ex: pnpPath
//
// - options that tweaks the strictness must begin with the "allow" prefix
//   ex: allowInvalidChecksums
//
// - options that enable a feature must begin with the "enable" prefix
//   ex: enableEmojis, enableColors

var $423262bd9e933160a1646431d9f01697$export$coreDefinitions = {
  // Not implemented for now, but since it's part of all Yarn installs we want to declare it in order to improve drop-in compatibility
  lastUpdateCheck: {
    description: `Last timestamp we checked whether new Yarn versions were available`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: null
  },
  // Settings related to proxying all Yarn calls to a specific executable
  yarnPath: {
    description: `Path to the local executable that must be used over the global one`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: null
  },
  ignorePath: {
    description: `If true, the local executable will be ignored when using the global one`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  ignoreCwd: {
    description: `If true, the \`--cwd\` flag will be ignored`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the package manager internal names
  cacheKeyOverride: {
    description: `A global cache key override; used only for test purposes`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: null
  },
  globalFolder: {
    description: `Folder where are stored the system-wide settings`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: $423262bd9e933160a1646431d9f01697$var$folderUtils.getDefaultGlobalFolder()
  },
  cacheFolder: {
    description: `Folder where the cache files must be written`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/cache`
  },
  compressionLevel: {
    description: `Zip files compression level, from 0 to 9 or mixed (a variant of 9, which stores some files uncompressed, when compression doesn't yield good results)`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER,
    values: [`mixed`, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    default: $ea9c1e38c3e8cca334929a597a084311$exports.DEFAULT_COMPRESSION_LEVEL
  },
  virtualFolder: {
    description: `Folder where the virtual packages (cf doc) will be mapped on the disk (must be named $$virtual)`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/$$virtual`
  },
  bstatePath: {
    description: `Path of the file where the current state of the built packages must be stored`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/build-state.yml`
  },
  lockfileFilename: {
    description: `Name of the files where the Yarn dependency tree entries must be stored`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: $423262bd9e933160a1646431d9f01697$exports.DEFAULT_LOCK_FILENAME
  },
  installStatePath: {
    description: `Path of the file where the install state will be persisted`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/install-state.gz`
  },
  immutablePatterns: {
    description: `Array of glob patterns; files matching them won't be allowed to change during immutable installs`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: [],
    isArray: true
  },
  rcFilename: {
    description: `Name of the files where the configuration can be found`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: $423262bd9e933160a1646431d9f01697$var$getRcFilename()
  },
  enableGlobalCache: {
    description: `If true, the system-wide cache folder will be used regardless of \`cache-folder\``,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  enableAbsoluteVirtuals: {
    description: `If true, the virtual symlinks will use absolute paths if required [non portable!!]`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the output style
  enableColors: {
    description: `If true, the CLI is allowed to use colors in its output`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: $423262bd9e933160a1646431d9f01697$var$formatUtils.supportsColor,
    defaultText: `<dynamic>`
  },
  enableHyperlinks: {
    description: `If true, the CLI is allowed to use hyperlinks in its output`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: $423262bd9e933160a1646431d9f01697$var$formatUtils.supportsHyperlinks,
    defaultText: `<dynamic>`
  },
  enableInlineBuilds: {
    description: `If true, the CLI will print the build output on the command line`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: $423262bd9e933160a1646431d9f01697$var$ci_info_1.isCI,
    defaultText: `<dynamic>`
  },
  enableProgressBars: {
    description: `If true, the CLI is allowed to show a progress bar for long-running events`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false,
    //!ci_info_1.isCI && process.stdout.isTTY && process.stdout.columns > 22,
    defaultText: `<dynamic>`
  },
  enableTimers: {
    description: `If true, the CLI is allowed to print the time spent executing commands`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  preferAggregateCacheInfo: {
    description: `If true, the CLI will only print a one-line report of any cache changes`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: $423262bd9e933160a1646431d9f01697$var$ci_info_1.isCI
  },
  preferInteractive: {
    description: `If true, the CLI will automatically use the interactive mode when called from a TTY`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  preferTruncatedLines: {
    description: `If true, the CLI will truncate lines that would go beyond the size of the terminal`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  progressBarStyle: {
    description: `Which style of progress bar should be used (only when progress bars are enabled)`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: undefined,
    defaultText: `<dynamic>`
  },
  // Settings related to how packages are interpreted by default
  defaultLanguageName: {
    description: `Default language mode that should be used when a package doesn't offer any insight`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: `node`
  },
  defaultProtocol: {
    description: `Default resolution protocol used when resolving pure semver and tag ranges`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: `npm:`
  },
  enableTransparentWorkspaces: {
    description: `If false, Yarn won't automatically resolve workspace dependencies unless they use the \`workspace:\` protocol`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  // Settings related to network access
  enableMirror: {
    description: `If true, the downloaded packages will be retrieved and stored in both the local and global folders`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  enableNetwork: {
    description: `If false, the package manager will refuse to use the network if required to`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  httpProxy: {
    description: `URL of the http proxy that must be used for outgoing http requests`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: null
  },
  httpsProxy: {
    description: `URL of the http proxy that must be used for outgoing https requests`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: null
  },
  unsafeHttpWhitelist: {
    description: `List of the hostnames for which http queries are allowed (glob patterns are supported)`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: [],
    isArray: true
  },
  httpTimeout: {
    description: `Timeout of each http request in milliseconds`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER,
    default: 60000
  },
  httpRetry: {
    description: `Retry times on http failure`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER,
    default: 3
  },
  networkConcurrency: {
    description: `Maximal number of concurrent requests`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER,
    default: Infinity
  },
  networkSettings: {
    description: `Network settings per hostname (glob patterns are supported)`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP,
    valueDefinition: {
      description: ``,
      type: $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE,
      properties: {
        caFilePath: {
          description: `Path to file containing one or multiple Certificate Authority signing certificates`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
          default: null
        },
        enableNetwork: {
          description: `If false, the package manager will refuse to use the network if required to`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
          default: null
        },
        httpProxy: {
          description: `URL of the http proxy that must be used for outgoing http requests`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
          default: null
        },
        httpsProxy: {
          description: `URL of the http proxy that must be used for outgoing https requests`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
          default: null
        }
      }
    }
  },
  caFilePath: {
    description: `A path to a file containing one or multiple Certificate Authority signing certificates`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH,
    default: null
  },
  enableStrictSsl: {
    description: `If false, SSL certificate errors will be ignored`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  logFilters: {
    description: `Overrides for log levels`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE,
    isArray: true,
    concatenateValues: true,
    properties: {
      code: {
        description: `Code of the messages covered by this override`,
        type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
        default: undefined
      },
      text: {
        description: `Code of the texts covered by this override`,
        type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
        default: undefined
      },
      level: {
        description: `Log level override, set to null to remove override`,
        type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
        values: Object.values($423262bd9e933160a1646431d9f01697$var$formatUtils.LogLevel),
        isNullable: true,
        default: undefined
      }
    }
  },
  // Settings related to telemetry
  enableTelemetry: {
    description: `If true, telemetry will be periodically sent, following the rules in https://yarnpkg.com/advanced/telemetry`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  telemetryInterval: {
    description: `Minimal amount of time between two telemetry uploads, in days`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER,
    default: 7
  },
  telemetryUserId: {
    description: `If you desire to tell us which project you are, you can set this field. Completely optional and opt-in.`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: null
  },
  // Settings related to security
  enableScripts: {
    description: `If true, packages are allowed to have install scripts by default`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: true
  },
  enableImmutableCache: {
    description: `If true, the cache is reputed immutable and actions that would modify it will throw`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
    default: false
  },
  checksumBehavior: {
    description: `Enumeration defining what to do when a checksum doesn't match expectations`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING,
    default: `throw`
  },
  // Package patching - to fix incorrect definitions
  packageExtensions: {
    description: `Map of package corrections to apply on the dependency tree`,
    type: $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP,
    valueDefinition: {
      description: `The extension that will be applied to any package whose version matches the specified range`,
      type: $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE,
      properties: {
        dependencies: {
          description: `The set of dependencies that must be made available to the current package in order for it to work properly`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP,
          valueDefinition: {
            description: `A range`,
            type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING
          }
        },
        peerDependencies: {
          description: `Inherited dependencies - the consumer of the package will be tasked to provide them`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP,
          valueDefinition: {
            description: `A semver range`,
            type: $423262bd9e933160a1646431d9f01697$var$SettingsType.STRING
          }
        },
        peerDependenciesMeta: {
          description: `Extra information related to the dependencies listed in the peerDependencies field`,
          type: $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP,
          valueDefinition: {
            description: `The peerDependency meta`,
            type: $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE,
            properties: {
              optional: {
                description: `If true, the selected peer dependency will be marked as optional by the package manager and the consumer omitting it won't be reported as an error`,
                type: $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN,
                default: false
              }
            }
          }
        }
      }
    }
  }
};
// General rules:
//
// - filenames that don't accept actual paths must end with the "Filename" suffix
//   prefer to use absolute paths instead, since they are automatically resolved
//   ex: lockfileFilename
//
// - folders must end with the "Folder" suffix
//   ex: cacheFolder, pnpVirtualFolder
//
// - actual paths to a file must end with the "Path" suffix
//   ex: pnpPath
//
// - options that tweaks the strictness must begin with the "allow" prefix
//   ex: allowInvalidChecksums
//
// - options that enable a feature must begin with the "enable" prefix
//   ex: enableEmojis, enableColors
$423262bd9e933160a1646431d9f01697$exports.coreDefinitions = $423262bd9e933160a1646431d9f01697$export$coreDefinitions;

function $423262bd9e933160a1646431d9f01697$var$parseValue(configuration, path, value, definition, folder) {
  if (definition.isArray) {
    if (!Array.isArray(value)) {
      return String(value).split(/,/).map(segment => {
        return $423262bd9e933160a1646431d9f01697$var$parseSingleValue(configuration, path, segment, definition, folder);
      });
    } else {
      return value.map((sub, i) => $423262bd9e933160a1646431d9f01697$var$parseSingleValue(configuration, `${path}[${i}]`, sub, definition, folder));
    }
  } else {
    if (Array.isArray(value)) {
      throw new Error(`Non-array configuration settings "${path}" cannot be an array`);
    } else {
      return $423262bd9e933160a1646431d9f01697$var$parseSingleValue(configuration, path, value, definition, folder);
    }
  }
}

function $423262bd9e933160a1646431d9f01697$var$parseSingleValue(configuration, path, value, definition, folder) {
  var _a;

  switch (definition.type) {
    case $423262bd9e933160a1646431d9f01697$var$SettingsType.ANY:
      return value;

    case $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE:
      return $423262bd9e933160a1646431d9f01697$var$parseShape(configuration, path, value, definition, folder);

    case $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP:
      return $423262bd9e933160a1646431d9f01697$var$parseMap(configuration, path, value, definition, folder);
  }

  if (value === null && !definition.isNullable && definition.default !== null) throw new Error(`Non-nullable configuration settings "${path}" cannot be set to null`);
  if ((_a = definition.values) === null || _a === void 0 ? void 0 : _a.includes(value)) return value;

  const interpretValue = () => {
    if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.BOOLEAN) return $423262bd9e933160a1646431d9f01697$var$miscUtils.parseBoolean(value);
    if (typeof value !== `string`) throw new Error(`Expected value (${value}) to be a string`);
    const valueWithReplacedVariables = $423262bd9e933160a1646431d9f01697$var$miscUtils.replaceEnvVariables(value, {
      env: $423262bd9e933160a1646431d9f01697$var$process.env
    });

    switch (definition.type) {
      case $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH:
        return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(folder, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(valueWithReplacedVariables));

      case $423262bd9e933160a1646431d9f01697$var$SettingsType.LOCATOR_LOOSE:
        return $423262bd9e933160a1646431d9f01697$var$structUtils.parseLocator(valueWithReplacedVariables, false);

      case $423262bd9e933160a1646431d9f01697$var$SettingsType.NUMBER:
        return parseInt(valueWithReplacedVariables);

      case $423262bd9e933160a1646431d9f01697$var$SettingsType.LOCATOR:
        return $423262bd9e933160a1646431d9f01697$var$structUtils.parseLocator(valueWithReplacedVariables);

      default:
        return valueWithReplacedVariables;
    }
  };

  const interpreted = interpretValue();
  if (definition.values && !definition.values.includes(interpreted)) throw new Error(`Invalid value, expected one of ${definition.values.join(`, `)}`);
  return interpreted;
}

function $423262bd9e933160a1646431d9f01697$var$parseShape(configuration, path, value, definition, folder) {
  if (typeof value !== `object` || Array.isArray(value)) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Object configuration settings "${path}" must be an object`);
  const result = $423262bd9e933160a1646431d9f01697$var$getDefaultValue(configuration, definition, {
    ignoreArrays: true
  });
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const subPath = `${path}.${propKey}`;
    const subDefinition = definition.properties[propKey];
    if (!subDefinition) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Unrecognized configuration settings found: ${path}.${propKey} - run "yarn config -v" to see the list of settings supported in Yarn`);
    result.set(propKey, $423262bd9e933160a1646431d9f01697$var$parseValue(configuration, subPath, propValue, definition.properties[propKey], folder));
  }

  return result;
}

function $423262bd9e933160a1646431d9f01697$var$parseMap(configuration, path, value, definition, folder) {
  const result = new Map();
  if (typeof value !== `object` || Array.isArray(value)) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Map configuration settings "${path}" must be an object`);
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const normalizedKey = definition.normalizeKeys ? definition.normalizeKeys(propKey) : propKey;
    const subPath = `${path}['${normalizedKey}']`; // @ts-expect-error: SettingsDefinitionNoDefault has ... no default ... but
    // that's fine because we're guaranteed it's not undefined.

    // @ts-expect-error: SettingsDefinitionNoDefault has ... no default ... but
    // that's fine because we're guaranteed it's not undefined.
    const valueDefinition = definition.valueDefinition;
    result.set(normalizedKey, $423262bd9e933160a1646431d9f01697$var$parseValue(configuration, subPath, propValue, valueDefinition, folder));
  }

  return result;
}

function $423262bd9e933160a1646431d9f01697$var$getDefaultValue(configuration, definition, {
  ignoreArrays = false
} = {}) {
  switch (definition.type) {
    case $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE:
      {
        if (definition.isArray && !ignoreArrays) return [];
        const result = new Map();

        for (const [propKey, propDefinition] of Object.entries(definition.properties)) result.set(propKey, $423262bd9e933160a1646431d9f01697$var$getDefaultValue(configuration, propDefinition));

        return result;
      }
      break;

    case $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP:
      {
        if (definition.isArray && !ignoreArrays) return [];
        return new Map();
      }
      break;

    case $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH:
      {
        if (definition.default === null) return null;

        if (configuration.projectCwd === null) {
          if ($ea9c1e38c3e8cca334929a597a084311$exports.ppath.isAbsolute(definition.default)) {
            return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.normalize(definition.default);
          } else if (definition.isNullable) {
            return null;
          } else {
            // Reached when a relative path is the default but the current
            // context is evaluated outside of a Yarn project
            return undefined;
          }
        } else {
          if (Array.isArray(definition.default)) {
            return definition.default.map(entry => $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(configuration.projectCwd, entry));
          } else {
            return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(configuration.projectCwd, definition.default);
          }
        }
      }
      break;

    default:
      {
        return definition.default;
      }
      break;
  }
}

function $423262bd9e933160a1646431d9f01697$var$transformConfiguration(rawValue, definition, transforms) {
  if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.SECRET && typeof rawValue === `string` && transforms.hideSecrets) return $423262bd9e933160a1646431d9f01697$exports.SECRET;
  if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.ABSOLUTE_PATH && typeof rawValue === `string` && transforms.getNativePaths) return $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(rawValue);

  if (definition.isArray && Array.isArray(rawValue)) {
    const newValue = [];

    for (const value of rawValue) newValue.push($423262bd9e933160a1646431d9f01697$var$transformConfiguration(value, definition, transforms));

    return newValue;
  }

  if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) newValue.set(key, $423262bd9e933160a1646431d9f01697$var$transformConfiguration(value, definition.valueDefinition, transforms));

    return newValue;
  }

  if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.SHAPE && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) {
      const propertyDefinition = definition.properties[key];
      newValue.set(key, $423262bd9e933160a1646431d9f01697$var$transformConfiguration(value, propertyDefinition, transforms));
    }

    return newValue;
  }

  return rawValue;
}

function $423262bd9e933160a1646431d9f01697$var$getEnvironmentSettings() {
  const environmentSettings = {};

  for (let [key, value] of Object.entries($423262bd9e933160a1646431d9f01697$var$process.env)) {
    key = key.toLowerCase();
    if (!key.startsWith($423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX)) continue;
    key = $423262bd9e933160a1646431d9f01697$var$camelcase_1.default(key.slice($423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX.length));
    environmentSettings[key] = value;
  }

  return environmentSettings;
}

function $423262bd9e933160a1646431d9f01697$var$getRcFilename() {
  const rcKey = `${$423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX}rc_filename`;

  for (const [key, value] of Object.entries($423262bd9e933160a1646431d9f01697$var$process.env)) if (key.toLowerCase() === rcKey && typeof value === `string`) return value;

  return $423262bd9e933160a1646431d9f01697$exports.DEFAULT_RC_FILENAME;
}

var $423262bd9e933160a1646431d9f01697$var$ProjectLookup;

(function (ProjectLookup) {
  ProjectLookup[ProjectLookup["LOCKFILE"] = 0] = "LOCKFILE";
  ProjectLookup[ProjectLookup["MANIFEST"] = 1] = "MANIFEST";
  ProjectLookup[ProjectLookup["NONE"] = 2] = "NONE";
})($423262bd9e933160a1646431d9f01697$var$ProjectLookup = $423262bd9e933160a1646431d9f01697$exports.ProjectLookup || ($423262bd9e933160a1646431d9f01697$export$ProjectLookup = {}, $423262bd9e933160a1646431d9f01697$exports.ProjectLookup = $423262bd9e933160a1646431d9f01697$export$ProjectLookup));

class $423262bd9e933160a1646431d9f01697$var$Configuration {
  constructor(startingCwd) {
    this.projectCwd = null;
    this.plugins = new Map();
    this.settings = new Map();
    this.values = new Map();
    this.sources = new Map();
    this.invalid = new Map();
    this.packageExtensions = new Map();
    this.limits = new Map();
    this.startingCwd = startingCwd;
  }

  static create(startingCwd, projectCwdOrPlugins, maybePlugins) {
    const configuration = new $423262bd9e933160a1646431d9f01697$var$Configuration(startingCwd);
    if (typeof projectCwdOrPlugins !== `undefined` && !(projectCwdOrPlugins instanceof Map)) configuration.projectCwd = projectCwdOrPlugins;
    configuration.importSettings($423262bd9e933160a1646431d9f01697$exports.coreDefinitions);
    const plugins = typeof maybePlugins !== `undefined` ? maybePlugins : projectCwdOrPlugins instanceof Map ? projectCwdOrPlugins : new Map();

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    return configuration;
  }
  /**
   * Instantiate a new configuration object exposing the configuration obtained
   * from reading the various rc files and the environment settings.
   *
   * The `pluginConfiguration` parameter is expected to indicate:
   *
   * 1. which modules should be made available to plugins when they require a
   *    package (this is the dynamic linking part - for example we want all the
   *    plugins to use the exact same version of @yarnpkg/core, which also is the
   *    version used by the running Yarn instance).
   *
   * 2. which of those modules are actually plugins that need to be injected
   *    within the configuration.
   *
   * Note that some extra plugins will be automatically added based on the
   * content of the rc files - with the rc plugins taking precedence over
   * the other ones.
   *
   * One particularity: the plugin initialization order is quite strict, with
   * plugins listed in /foo/bar/.yarnrc.yml taking precedence over plugins
   * listed in /foo/.yarnrc.yml and /.yarnrc.yml. Additionally, while plugins
   * can depend on one another, they can only depend on plugins that have been
   * instantiated before them (so a plugin listed in /foo/.yarnrc.yml can
   * depend on another one listed on /foo/bar/.yarnrc.yml, but not the other
   * way around).
   */


  /**
   * Instantiate a new configuration object exposing the configuration obtained
   * from reading the various rc files and the environment settings.
   *
   * The `pluginConfiguration` parameter is expected to indicate:
   *
   * 1. which modules should be made available to plugins when they require a
   *    package (this is the dynamic linking part - for example we want all the
   *    plugins to use the exact same version of @yarnpkg/core, which also is the
   *    version used by the running Yarn instance).
   *
   * 2. which of those modules are actually plugins that need to be injected
   *    within the configuration.
   *
   * Note that some extra plugins will be automatically added based on the
   * content of the rc files - with the rc plugins taking precedence over
   * the other ones.
   *
   * One particularity: the plugin initialization order is quite strict, with
   * plugins listed in /foo/bar/.yarnrc.yml taking precedence over plugins
   * listed in /foo/.yarnrc.yml and /.yarnrc.yml. Additionally, while plugins
   * can depend on one another, they can only depend on plugins that have been
   * instantiated before them (so a plugin listed in /foo/.yarnrc.yml can
   * depend on another one listed on /foo/bar/.yarnrc.yml, but not the other
   * way around).
   */
  static async find(startingCwd, pluginConfiguration, {
    lookup = $423262bd9e933160a1646431d9f01697$var$ProjectLookup.LOCKFILE,
    strict = true,
    usePath = false,
    useRc = true
  } = {}) {
    const environmentSettings = $423262bd9e933160a1646431d9f01697$var$getEnvironmentSettings();
    delete environmentSettings.rcFilename;
    const rcFiles = await $423262bd9e933160a1646431d9f01697$var$Configuration.findRcFiles(startingCwd);
    const homeRcFile = await $423262bd9e933160a1646431d9f01697$var$Configuration.findHomeRcFile();

    const pickCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    }) => ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    });

    const excludeCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename,
      ...rest
    }) => rest;

    const configuration = new $423262bd9e933160a1646431d9f01697$var$Configuration(startingCwd);
    configuration.importSettings(pickCoreFields($423262bd9e933160a1646431d9f01697$exports.coreDefinitions));
    configuration.useWithSource(`<environment>`, pickCoreFields(environmentSettings), startingCwd, {
      strict: false
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, pickCoreFields(data), cwd, {
      strict: false
    });

    if (homeRcFile) configuration.useWithSource(homeRcFile.path, pickCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (usePath) {
      const yarnPath = configuration.get(`yarnPath`);
      const ignorePath = configuration.get(`ignorePath`);

      if (yarnPath !== null && !ignorePath) {
        return configuration;
      }
    } // We need to know the project root before being able to truly instantiate
    // our configuration, and to know that we need to know the lockfile name


    // We need to know the project root before being able to truly instantiate
    // our configuration, and to know that we need to know the lockfile name
    const lockfileFilename = configuration.get(`lockfileFilename`);
    let projectCwd;

    switch (lookup) {
      case $423262bd9e933160a1646431d9f01697$var$ProjectLookup.LOCKFILE:
        {
          projectCwd = await $423262bd9e933160a1646431d9f01697$var$Configuration.findProjectCwd(startingCwd, lockfileFilename);
        }
        break;

      case $423262bd9e933160a1646431d9f01697$var$ProjectLookup.MANIFEST:
        {
          projectCwd = await $423262bd9e933160a1646431d9f01697$var$Configuration.findProjectCwd(startingCwd, null);
        }
        break;

      case $423262bd9e933160a1646431d9f01697$var$ProjectLookup.NONE:
        {
          if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(startingCwd, `package.json`))) {
            projectCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(startingCwd);
          } else {
            projectCwd = null;
          }
        }
        break;
    } // Great! We now have enough information to really start to setup the
    // core configuration object.


    // Great! We now have enough information to really start to setup the
    // core configuration object.
    configuration.startingCwd = startingCwd;
    configuration.projectCwd = projectCwd;
    configuration.importSettings(excludeCoreFields($423262bd9e933160a1646431d9f01697$exports.coreDefinitions)); // Now that the configuration object is almost ready, we need to load all
    // the configured plugins

    // Now that the configuration object is almost ready, we need to load all
    // the configured plugins
    const plugins = new Map([[`@@core`, $c94854a52fa15ac05aa4c02a3d9a9e6a$exports.CorePlugin]]);

    const interop = obj => obj.__esModule ? obj.default : obj;

    if (pluginConfiguration !== null) {
      for (const request of pluginConfiguration.plugins.keys()) plugins.set(request, interop(pluginConfiguration.modules.get(request)));

      const requireEntries = new Map();

      for (const request of $423262bd9e933160a1646431d9f01697$var$nodeUtils.builtinModules()) requireEntries.set(request, () => $423262bd9e933160a1646431d9f01697$var$nodeUtils.dynamicRequire(request));

      for (const [request, embedModule] of pluginConfiguration.modules) requireEntries.set(request, () => embedModule);

      const dynamicPlugins = new Set();

      const getDefault = object => {
        return object.default || object;
      };

      const importPlugin = (pluginPath, source) => {
        const {
          factory,
          name
        } = $423262bd9e933160a1646431d9f01697$var$nodeUtils.dynamicRequire($ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(pluginPath)); // Prevent plugin redefinition so that the ones declared deeper in the
        // filesystem always have precedence over the ones below.

        // Prevent plugin redefinition so that the ones declared deeper in the
        // filesystem always have precedence over the ones below.
        if (dynamicPlugins.has(name)) return;
        const pluginRequireEntries = new Map(requireEntries);

        const pluginRequire = request => {
          if (pluginRequireEntries.has(request)) {
            return pluginRequireEntries.get(request)();
          } else {
            throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`This plugin cannot access the package referenced via ${request} which is neither a builtin, nor an exposed entry`);
          }
        };

        const plugin = $423262bd9e933160a1646431d9f01697$var$miscUtils.prettifySyncErrors(() => {
          return getDefault(factory(pluginRequire));
        }, message => {
          return `${message} (when initializing ${name}, defined in ${source})`;
        });
        requireEntries.set(name, () => plugin);
        dynamicPlugins.add(name);
        plugins.set(name, plugin);
      };

      if (environmentSettings.plugins) {
        for (const userProvidedPath of environmentSettings.plugins.split(`;`)) {
          const pluginPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(startingCwd, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, `<environment>`);
        }
      }

      for (const {
        path,
        cwd,
        data
      } of rcFiles) {
        if (!useRc) continue;
        if (!Array.isArray(data.plugins)) continue;

        for (const userPluginEntry of data.plugins) {
          const userProvidedPath = typeof userPluginEntry !== `string` ? userPluginEntry.path : userPluginEntry;
          const pluginPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(cwd, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, path);
        }
      }
    }

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    configuration.useWithSource(`<environment>`, excludeCoreFields(environmentSettings), startingCwd, {
      strict
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, excludeCoreFields(data), cwd, {
      strict
    }); // The home configuration is never strict because it improves support for
    // multiple projects using different Yarn versions on the same machine


    // The home configuration is never strict because it improves support for
    // multiple projects using different Yarn versions on the same machine
    if (homeRcFile) configuration.useWithSource(homeRcFile.path, excludeCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (configuration.get(`enableGlobalCache`)) {
      configuration.values.set(`cacheFolder`, `${configuration.get(`globalFolder`)}/cache`);
      configuration.sources.set(`cacheFolder`, `<internal>`);
    }

    await configuration.refreshPackageExtensions();
    return configuration;
  }

  static async findRcFiles(startingCwd) {
    const rcFilename = $423262bd9e933160a1646431d9f01697$var$getRcFilename();
    const rcFiles = [];
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      const rcPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(currentCwd, rcFilename);

      if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(rcPath)) {
        const content = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(rcPath, `utf8`);
        let data;

        try {
          data = $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(content);
        } catch (error) {
          let tip = ``;
          if (content.match(/^\s+(?!-)[^:]+\s+\S+/m)) tip = ` (in particular, make sure you list the colons after each key name)`;
          throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Parse error when loading ${rcPath}; please check it's proper Yaml${tip}`);
        }

        rcFiles.push({
          path: rcPath,
          cwd: currentCwd,
          data
        });
      }

      nextCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(currentCwd);
    }

    return rcFiles;
  }

  static async findHomeRcFile() {
    const rcFilename = $423262bd9e933160a1646431d9f01697$var$getRcFilename();
    const homeFolder = $423262bd9e933160a1646431d9f01697$var$folderUtils.getHomeFolder();
    const homeRcFilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(homeFolder, rcFilename);

    if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(homeRcFilePath)) {
      const content = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(homeRcFilePath, `utf8`);
      const data = $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(content);
      return {
        path: homeRcFilePath,
        cwd: homeFolder,
        data
      };
    }

    return null;
  }

  static async findProjectCwd(startingCwd, lockfileFilename) {
    let projectCwd = null;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(currentCwd, `package.json`))) projectCwd = currentCwd;

      if (lockfileFilename !== null) {
        if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(currentCwd, lockfileFilename))) {
          projectCwd = currentCwd;
          break;
        }
      } else {
        if (projectCwd !== null) {
          break;
        }
      }

      nextCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(currentCwd);
    }

    return projectCwd;
  }

  static async updateConfiguration(cwd, patch) {
    const rcFilename = $423262bd9e933160a1646431d9f01697$var$getRcFilename();
    const configurationPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(cwd, rcFilename);
    const current = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(configurationPath) ? $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(configurationPath, `utf8`)) : {};
    let patched = false;
    let replacement;

    if (typeof patch === `function`) {
      try {
        replacement = patch(current);
      } catch (_a) {
        replacement = patch({});
      }

      if (replacement === current) {
        return;
      }
    } else {
      replacement = current;

      for (const key of Object.keys(patch)) {
        const currentValue = current[key];
        const patchField = patch[key];
        let nextValue;

        if (typeof patchField === `function`) {
          try {
            nextValue = patchField(currentValue);
          } catch (_b) {
            nextValue = patchField(undefined);
          }
        } else {
          nextValue = patchField;
        }

        if (currentValue === nextValue) continue;
        replacement[key] = nextValue;
        patched = true;
      }

      if (!patched) {
        return;
      }
    }

    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(configurationPath, $0e609d03a5066ebec776a5ec6a49b084$exports.stringifySyml(replacement), {
      automaticNewlines: true
    });
  }

  static async updateHomeConfiguration(patch) {
    const homeFolder = $423262bd9e933160a1646431d9f01697$var$folderUtils.getHomeFolder();
    return await $423262bd9e933160a1646431d9f01697$var$Configuration.updateConfiguration(homeFolder, patch);
  }

  activatePlugin(name, plugin) {
    this.plugins.set(name, plugin);

    if (typeof plugin.configuration !== `undefined`) {
      this.importSettings(plugin.configuration);
    }
  }

  importSettings(definitions) {
    for (const [name, definition] of Object.entries(definitions)) {
      if (definition == null) continue;
      if (this.settings.has(name)) throw new Error(`Cannot redefine settings "${name}"`);
      this.settings.set(name, definition);
      this.values.set(name, $423262bd9e933160a1646431d9f01697$var$getDefaultValue(this, definition));
    }
  }

  useWithSource(source, data, folder, opts) {
    try {
      this.use(source, data, folder, opts);
    } catch (error) {
      error.message += ` (in ${$423262bd9e933160a1646431d9f01697$var$formatUtils.pretty(this, source, $423262bd9e933160a1646431d9f01697$var$formatUtils.Type.PATH)})`;
      throw error;
    }
  }

  use(source, data, folder, {
    strict = true,
    overwrite = false
  } = {}) {
    for (const key of Object.keys(data)) {
      const value = data[key];
      if (typeof value === `undefined`) continue; // The plugins have already been loaded at this point

      // The plugins have already been loaded at this point
      if (key === `plugins`) continue; // Some environment variables should be ignored when applying the configuration

      // Some environment variables should be ignored when applying the configuration
      if (source === `<environment>` && $423262bd9e933160a1646431d9f01697$var$IGNORED_ENV_VARIABLES.has(key)) continue; // It wouldn't make much sense, would it?

      // It wouldn't make much sense, would it?
      if (key === `rcFilename`) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`The rcFilename settings can only be set via ${`${$423262bd9e933160a1646431d9f01697$exports.ENVIRONMENT_PREFIX}RC_FILENAME`.toUpperCase()}, not via a rc file`);
      const definition = this.settings.get(key);

      if (!definition) {
        if (strict) {
          throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Unrecognized or legacy configuration settings found: ${key} - run "yarn config -v" to see the list of settings supported in Yarn`);
        } else {
          this.invalid.set(key, source);
          continue;
        }
      }

      if (this.sources.has(key) && !(overwrite || definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP || definition.isArray && definition.concatenateValues)) continue;
      let parsed;

      try {
        parsed = $423262bd9e933160a1646431d9f01697$var$parseValue(this, key, data[key], definition, folder);
      } catch (error) {
        error.message += ` in ${$423262bd9e933160a1646431d9f01697$var$formatUtils.pretty(this, source, $423262bd9e933160a1646431d9f01697$var$formatUtils.Type.PATH)}`;
        throw error;
      }

      if (definition.type === $423262bd9e933160a1646431d9f01697$var$SettingsType.MAP) {
        const previousValue = this.values.get(key);
        this.values.set(key, new Map(overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]));
        this.sources.set(key, `${this.sources.get(key)}, ${source}`);
      } else if (definition.isArray && definition.concatenateValues) {
        const previousValue = this.values.get(key);
        this.values.set(key, overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]);
        this.sources.set(key, `${this.sources.get(key)}, ${source}`);
      } else {
        this.values.set(key, parsed);
        this.sources.set(key, source);
      }
    }
  }

  get(key) {
    if (!this.values.has(key)) throw new Error(`Invalid configuration key "${key}"`);
    return this.values.get(key);
  }

  getSpecial(key, {
    hideSecrets = false,
    getNativePaths = false
  }) {
    const rawValue = this.get(key);
    const definition = this.settings.get(key);
    if (typeof definition === `undefined`) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Couldn't find a configuration settings named "${key}"`);
    return $423262bd9e933160a1646431d9f01697$var$transformConfiguration(rawValue, definition, {
      hideSecrets,
      getNativePaths
    });
  }

  getSubprocessStreams(logFile, {
    header,
    prefix,
    report
  }) {
    let stdout;
    let stderr;
    const logStream = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.createWriteStream(logFile);

    if (this.get(`enableInlineBuilds`)) {
      const stdoutLineReporter = report.createStreamReporter(`${prefix} ${$423262bd9e933160a1646431d9f01697$var$formatUtils.pretty(this, `STDOUT`, `green`)}`);
      const stderrLineReporter = report.createStreamReporter(`${prefix} ${$423262bd9e933160a1646431d9f01697$var$formatUtils.pretty(this, `STDERR`, `red`)}`);
      stdout = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough();
      stdout.pipe(stdoutLineReporter);
      stdout.pipe(logStream);
      stderr = new $77f1f3b73e58a1193c01fee8e7b8ba28$exports.PassThrough();
      stderr.pipe(stderrLineReporter);
      stderr.pipe(logStream);
    } else {
      stdout = logStream;
      stderr = logStream;

      if (typeof header !== `undefined`) {
        stdout.write(`${header}\n`);
      }
    }

    return {
      stdout,
      stderr
    };
  }

  makeResolver() {
    const pluginResolvers = [];

    for (const plugin of this.plugins.values()) for (const resolver of plugin.resolvers || []) pluginResolvers.push(new resolver());

    return new $d87b895bfcf6a6f21386ff7ce5f5276b$exports.MultiResolver([new $f185e3c645e9965f23ab62acf4fbf46d$exports.VirtualResolver(), new $e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver(), new $75d39c0c5e08a7896c4fa0e540ce7c49$exports.ProtocolResolver(), ...pluginResolvers]);
  }

  makeFetcher() {
    const pluginFetchers = [];

    for (const plugin of this.plugins.values()) for (const fetcher of plugin.fetchers || []) pluginFetchers.push(new fetcher());

    return new $f91eb5f17c077b9ec21b15cbced9ebda$exports.MultiFetcher([new $fc50e50f7b33bbd0cc6647e8b74fa144$exports.VirtualFetcher(), new $503b443396459f312634283e2397528c$exports.WorkspaceFetcher(), ...pluginFetchers]);
  }

  getLinkers() {
    const linkers = [];

    for (const plugin of this.plugins.values()) for (const linker of plugin.linkers || []) linkers.push(new linker());

    return linkers;
  }

  async refreshPackageExtensions() {
    this.packageExtensions = new Map();
    const packageExtensions = this.packageExtensions;

    const registerPackageExtension = (descriptor, extensionData, {
      userProvided = false
    } = {}) => {
      if (!$423262bd9e933160a1646431d9f01697$var$semver_1.default.validRange(descriptor.range)) throw new Error(`Only semver ranges are allowed as keys for the lockfileExtensions setting`);
      const extension = new $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest();
      extension.load(extensionData, {
        yamlCompatibilityMode: true
      });
      const extensionsPerIdent = $423262bd9e933160a1646431d9f01697$var$miscUtils.getArrayWithDefault(packageExtensions, descriptor.identHash);
      const extensionsPerRange = [];
      extensionsPerIdent.push([descriptor.range, extensionsPerRange]);
      const baseExtension = {
        status: $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Inactive,
        userProvided,
        parentDescriptor: descriptor
      };

      for (const dependency of extension.dependencies.values()) extensionsPerRange.push({ ...baseExtension,
        type: $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.Dependency,
        descriptor: dependency,
        description: `${$423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(descriptor)} > ${$423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(dependency)}`
      });

      for (const peerDependency of extension.peerDependencies.values()) extensionsPerRange.push({ ...baseExtension,
        type: $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependency,
        descriptor: peerDependency,
        description: `${$423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(descriptor)} >> ${$423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(peerDependency)}`
      });

      for (const [selector, meta] of extension.peerDependenciesMeta) {
        for (const [key, value] of Object.entries(meta)) {
          extensionsPerRange.push({ ...baseExtension,
            type: $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependencyMeta,
            selector,
            key: key,
            value,
            description: `${$423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(descriptor)} >> ${selector} / ${key}`
          });
        }
      }
    };

    await this.triggerHook(hooks => {
      return hooks.registerPackageExtensions;
    }, this, registerPackageExtension);

    for (const [descriptorString, extensionData] of this.get(`packageExtensions`)) {
      registerPackageExtension($423262bd9e933160a1646431d9f01697$var$structUtils.parseDescriptor(descriptorString, true), $423262bd9e933160a1646431d9f01697$var$miscUtils.convertMapsToIndexableObjects(extensionData), {
        userProvided: true
      });
    }
  }

  normalizePackage(original) {
    const pkg = $423262bd9e933160a1646431d9f01697$var$structUtils.copyPackage(original); // We use the extensions to define additional dependencies that weren't
    // properly listed in the original package definition

    // We use the extensions to define additional dependencies that weren't
    // properly listed in the original package definition
    if (this.packageExtensions == null) throw new Error(`refreshPackageExtensions has to be called before normalizing packages`);
    const extensionsPerIdent = this.packageExtensions.get(original.identHash);

    if (typeof extensionsPerIdent !== `undefined`) {
      const version = original.version;

      if (version !== null) {
        for (const [range, extensionsPerRange] of extensionsPerIdent) {
          if (!$423262bd9e933160a1646431d9f01697$var$semverUtils.satisfiesWithPrereleases(version, range)) continue;

          for (const extension of extensionsPerRange) {
            // If an extension is active for a package but redundant
            // for another one, it should be considered active
            if (extension.status === $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Inactive) extension.status = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Redundant;

            switch (extension.type) {
              case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.Dependency:
                {
                  const currentDependency = pkg.dependencies.get(extension.descriptor.identHash);

                  if (typeof currentDependency === `undefined`) {
                    extension.status = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Active;
                    pkg.dependencies.set(extension.descriptor.identHash, extension.descriptor);
                  }
                }
                break;

              case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependency:
                {
                  const currentPeerDependency = pkg.peerDependencies.get(extension.descriptor.identHash);

                  if (typeof currentPeerDependency === `undefined`) {
                    extension.status = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Active;
                    pkg.peerDependencies.set(extension.descriptor.identHash, extension.descriptor);
                  }
                }
                break;

              case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType.PeerDependencyMeta:
                {
                  const currentPeerDependencyMeta = pkg.peerDependenciesMeta.get(extension.selector);

                  if (typeof currentPeerDependencyMeta === `undefined` || !Object.prototype.hasOwnProperty.call(currentPeerDependencyMeta, extension.key) || currentPeerDependencyMeta[extension.key] !== extension.value) {
                    extension.status = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Active;
                    $423262bd9e933160a1646431d9f01697$var$miscUtils.getFactoryWithDefault(pkg.peerDependenciesMeta, extension.selector, () => ({}))[extension.key] = extension.value;
                  }
                }
                break;

              default:
                {
                  $423262bd9e933160a1646431d9f01697$var$miscUtils.assertNever(extension);
                }
                break;
            }
          }
        }
      }
    } // We also add implicit optional @types peer dependencies for each peer
    // dependency. This is for compatibility reason, as many existing packages
    // forget to define their @types/react optional peer dependency when they
    // peer-depend on react.


    // We also add implicit optional @types peer dependencies for each peer
    // dependency. This is for compatibility reason, as many existing packages
    // forget to define their @types/react optional peer dependency when they
    // peer-depend on react.
    const getTypesName = descriptor => {
      return descriptor.scope ? `${descriptor.scope}__${descriptor.name}` : `${descriptor.name}`;
    };

    for (const descriptor of pkg.peerDependencies.values()) {
      if (descriptor.scope === `@types`) continue;
      const typesName = getTypesName(descriptor);
      const typesIdent = $423262bd9e933160a1646431d9f01697$var$structUtils.makeIdent(`types`, typesName);
      if (pkg.peerDependencies.has(typesIdent.identHash) || pkg.peerDependenciesMeta.has(typesIdent.identHash)) continue;
      pkg.peerDependenciesMeta.set($423262bd9e933160a1646431d9f01697$var$structUtils.stringifyIdent(typesIdent), {
        optional: true
      });
    } // I don't like implicit dependencies, but package authors are reluctant to
    // use optional peer dependencies because they would print warnings in older
    // npm releases.


    // I don't like implicit dependencies, but package authors are reluctant to
    // use optional peer dependencies because they would print warnings in older
    // npm releases.
    for (const identString of pkg.peerDependenciesMeta.keys()) {
      const ident = $423262bd9e933160a1646431d9f01697$var$structUtils.parseIdent(identString);

      if (!pkg.peerDependencies.has(ident.identHash)) {
        pkg.peerDependencies.set(ident.identHash, $423262bd9e933160a1646431d9f01697$var$structUtils.makeDescriptor(ident, `*`));
      }
    } // We sort the dependencies so that further iterations always occur in the
    // same order, regardless how the various registries formatted their output


    // We sort the dependencies so that further iterations always occur in the
    // same order, regardless how the various registries formatted their output
    pkg.dependencies = new Map($423262bd9e933160a1646431d9f01697$var$miscUtils.sortMap(pkg.dependencies, ([, descriptor]) => $423262bd9e933160a1646431d9f01697$var$structUtils.stringifyDescriptor(descriptor)));
    pkg.peerDependencies = new Map($423262bd9e933160a1646431d9f01697$var$miscUtils.sortMap(pkg.peerDependencies, ([, descriptor]) => $423262bd9e933160a1646431d9f01697$var$structUtils.stringifyDescriptor(descriptor)));
    return pkg;
  }

  getLimit(key) {
    return $423262bd9e933160a1646431d9f01697$var$miscUtils.getFactoryWithDefault(this.limits, key, () => {
      return $423262bd9e933160a1646431d9f01697$var$p_limit_1.default(this.get(key));
    });
  }

  async triggerHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      await hook(...args);
    }
  }

  async triggerMultipleHooks(get, argsList) {
    for (const args of argsList) {
      await this.triggerHook(get, ...args);
    }
  }

  async reduceHook(get, initialValue, ...args) {
    let value = initialValue;

    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      value = await hook(value, ...args);
    }

    return value;
  }

  async firstHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      const ret = await hook(...args);

      if (typeof ret !== `undefined`) {
        // @ts-expect-error
        return ret;
      }
    }

    return null;
  }
  /**
   * @deprecated Prefer using formatUtils.pretty instead, which is type-safe
   */


  /**
   * @deprecated Prefer using formatUtils.pretty instead, which is type-safe
   */
  format(value, formatType) {
    return $423262bd9e933160a1646431d9f01697$var$formatUtils.pretty(this, value, formatType);
  }

}

$423262bd9e933160a1646431d9f01697$export$Configuration = $423262bd9e933160a1646431d9f01697$var$Configuration;
$423262bd9e933160a1646431d9f01697$exports.Configuration = $423262bd9e933160a1646431d9f01697$export$Configuration;
$423262bd9e933160a1646431d9f01697$var$Configuration.telemetry = null;
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "DEFAULT_RC_FILENAME", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.DEFAULT_RC_FILENAME;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "DEFAULT_LOCK_FILENAME", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.DEFAULT_LOCK_FILENAME;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Configuration", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.Configuration;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "FormatType", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.FormatType;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "ProjectLookup", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.ProjectLookup;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "SettingsType", {
  enumerable: true,
  get: function () {
    return $423262bd9e933160a1646431d9f01697$exports.SettingsType;
  }
});
// ASSET: node_modules/@yarnpkg/core/lib/Installer.js
var $453e822fb82930600943800011f07c5f$exports = {};
Object.defineProperty($453e822fb82930600943800011f07c5f$exports, "__esModule", {
  value: true
});
var $453e822fb82930600943800011f07c5f$export$BuildType = void 0;
$453e822fb82930600943800011f07c5f$exports.BuildType = $453e822fb82930600943800011f07c5f$export$BuildType;
var $453e822fb82930600943800011f07c5f$var$BuildType;

(function (BuildType) {
  BuildType[BuildType["SCRIPT"] = 0] = "SCRIPT";
  BuildType[BuildType["SHELLCODE"] = 1] = "SHELLCODE";
})($453e822fb82930600943800011f07c5f$var$BuildType = $453e822fb82930600943800011f07c5f$exports.BuildType || ($453e822fb82930600943800011f07c5f$export$BuildType = {}, $453e822fb82930600943800011f07c5f$exports.BuildType = $453e822fb82930600943800011f07c5f$export$BuildType));

Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "BuildType", {
  enumerable: true,
  get: function () {
    return $453e822fb82930600943800011f07c5f$exports.BuildType;
  }
});
// ASSET: node_modules/@yarnpkg/core/lib/LightReport.js
var $cc9dfad5a0b53c032edf9cb58d43890d$exports = {};
Object.defineProperty($cc9dfad5a0b53c032edf9cb58d43890d$exports, "__esModule", {
  value: true
});
var $cc9dfad5a0b53c032edf9cb58d43890d$export$LightReport = void 0;
$cc9dfad5a0b53c032edf9cb58d43890d$exports.LightReport = $cc9dfad5a0b53c032edf9cb58d43890d$export$LightReport;
const $cc9dfad5a0b53c032edf9cb58d43890d$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);

class $cc9dfad5a0b53c032edf9cb58d43890d$var$LightReport extends $9baf3138444c7a279b4b3775d56e5534$exports.Report {
  constructor({
    configuration,
    stdout,
    suggestInstall = true
  }) {
    super();
    this.errorCount = 0;
    $cc9dfad5a0b53c032edf9cb58d43890d$var$formatUtils.addLogFilterSupport(this, {
      configuration
    });
    this.configuration = configuration;
    this.stdout = stdout;
    this.suggestInstall = suggestInstall;
  }

  static async start(opts, cb) {
    const report = new this(opts);

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return realCb();
  }

  async startTimerPromise(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return await realCb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {
    this.errorCount += 1;
    this.stdout.write(`${$cc9dfad5a0b53c032edf9cb58d43890d$var$formatUtils.pretty(this.configuration, ``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${text}\n`);
  }

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {
    if (this.errorCount > 0) {
      this.stdout.write(`${$cc9dfad5a0b53c032edf9cb58d43890d$var$formatUtils.pretty(this.configuration, ``, `redBright`)} Errors happened when preparing the environment required to run this command.\n`);

      if (this.suggestInstall) {
        this.stdout.write(`${$cc9dfad5a0b53c032edf9cb58d43890d$var$formatUtils.pretty(this.configuration, ``, `redBright`)} This might be caused by packages being missing from the lockfile, in which case running "yarn install" might help.\n`);
      }
    }
  }

  formatNameWithHyperlink(name) {
    return $4aa00afc119f35e9c4530bef5e53f2e3$exports.formatNameWithHyperlink(name, {
      configuration: this.configuration,
      json: false
    });
  }

}

$cc9dfad5a0b53c032edf9cb58d43890d$export$LightReport = $cc9dfad5a0b53c032edf9cb58d43890d$var$LightReport;
$cc9dfad5a0b53c032edf9cb58d43890d$exports.LightReport = $cc9dfad5a0b53c032edf9cb58d43890d$export$LightReport;
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "LightReport", {
  enumerable: true,
  get: function () {
    return $cc9dfad5a0b53c032edf9cb58d43890d$exports.LightReport;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Manifest", {
  enumerable: true,
  get: function () {
    return $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "MessageName", {
  enumerable: true,
  get: function () {
    return $3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName;
  }
});
// ASSET: node_modules/@yarnpkg/core/lib/Project.js
var $5a1c67a183441e010515e193fca593e1$exports = {};
Object.defineProperty($5a1c67a183441e010515e193fca593e1$exports, "__esModule", {
  value: true
});
var $5a1c67a183441e010515e193fca593e1$export$Project = void 0;
$5a1c67a183441e010515e193fca593e1$exports.Project = $5a1c67a183441e010515e193fca593e1$export$Project;
const $5a1c67a183441e010515e193fca593e1$var$crypto_1 = $455b93f3205ad3b50df264ee7a92e43f$init();
// ASSET: node_modules/diff/dist/diff.js
var $452492225f6c359232a0e384f4797aeb$exports = {};
var $452492225f6c359232a0e384f4797aeb$var$define;

/*!

 diff v4.0.1

Software License Agreement (BSD License)

Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>

All rights reserved.

Redistribution and use of this software in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of Kevin Decker nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@license
*/
(function (global, factory) {
  typeof $452492225f6c359232a0e384f4797aeb$exports === 'object' && "object" !== 'undefined' ? factory($452492225f6c359232a0e384f4797aeb$exports) : typeof $452492225f6c359232a0e384f4797aeb$var$define === 'function' && $452492225f6c359232a0e384f4797aeb$var$define.amd ? $452492225f6c359232a0e384f4797aeb$var$define(['exports'], factory) : (global = global || self, factory(global.Diff = {}));
})($452492225f6c359232a0e384f4797aeb$exports, function (exports) {
  function Diff() {}

  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = options.callback;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = options;
      var self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      } // Allow subclasses to massage the input prior to running


      // Allow subclasses to massage the input prior to running
      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
          oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }]; // Seed editLength = 0, i.e. the content starts with the same values

      // Seed editLength = 0, i.e. the content starts with the same values
      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      } // Main worker method. checks all permutations of a given edit length for acceptance.


      // Main worker method. checks all permutations of a given edit length for acceptance.
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;

          var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          } // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph


          // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list

            // No need to clone, we've pulled it from the list
            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

          // If we have hit the end of both strings, then we are done
          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      } // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.


      // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.
      if (callback) {
        (function exec() {
          setTimeout(function () {
            // This should not happen, but we want to be safe.

            /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();

          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];

      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        };
      } else {
        components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;

      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }

      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }

      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split('');
    },
    join: function join(chars) {
      return chars.join('');
    }
  };

  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];

      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }

        newPos += component.count; // Common case

        // Common case
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.

        // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.
        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    } // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.


    // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.
    var lastComponent = components[componentLen - 1];

    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }

  var characterDiff = new Diff();

  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  function generateOptions(options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }

    return defaults;
  } //
  // Ranges and exceptions:
  // Latin-1 Supplement, 008000FF
  //  - U+00D7   Multiplication sign
  //  - U+00F7   Division sign
  // Latin Extended-A, 0100017F
  // Latin Extended-B, 0180024F
  // IPA Extensions, 025002AF
  // Spacing Modifier Letters, 02B002FF
  //  - U+02C7   &#711;  Caron
  //  - U+02D8   &#728;  Breve
  //  - U+02D9   &#729;  Dot Above
  //  - U+02DA   &#730;  Ring Above
  //  - U+02DB   &#731;  Ogonek
  //  - U+02DC   &#732;  Small Tilde
  //  - U+02DD   &#733;  Double Acute Accent
  // Latin Extended Additional, 1E001EFF


  //
  // Ranges and exceptions:
  // Latin-1 Supplement, 008000FF
  //  - U+00D7   Multiplication sign
  //  - U+00F7   Division sign
  // Latin Extended-A, 0100017F
  // Latin Extended-B, 0180024F
  // IPA Extensions, 025002AF
  // Spacing Modifier Letters, 02B002FF
  //  - U+02C7   &#711;  Caron
  //  - U+02D8   &#728;  Breve
  //  - U+02D9   &#729;  Dot Above
  //  - U+02DA   &#730;  Ring Above
  //  - U+02DB   &#731;  Ogonek
  //  - U+02DC   &#732;  Small Tilde
  //  - U+02DD   &#733;  Double Acute Accent
  // Latin Extended Additional, 1E001EFF
  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();

  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }

    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };

  wordDiff.tokenize = function (value) {
    var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

    // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }

    return tokens;
  };

  function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
      ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
  }

  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }

  var lineDiff = new Diff();

  lineDiff.tokenize = function (value) {
    var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

    // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    } // Merge the content and line separators into single tokens


    // Merge the content and line separators into single tokens
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }

        retLines.push(line);
      }
    }

    return retLines;
  };

  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }

  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
      ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
  }

  var sentenceDiff = new Diff();

  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }

  var cssDiff = new Diff();

  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;

  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
      return typeof v === 'undefined' ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };

  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
  };

  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  } // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer


  // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer
  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];

    if (replacer) {
      obj = replacer(key, obj);
    }

    var i;

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }

    var canonicalizedObj;

    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);

      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }

      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }

    if (_typeof(obj) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);

      var sortedKeys = [],
          _key;

      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }

      sortedKeys.sort();

      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }

      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }

    return canonicalizedObj;
  }

  var arrayDiff = new Diff();

  arrayDiff.tokenize = function (value) {
    return value.slice();
  };

  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }

  function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        list = [],
        i = 0;

    function parseIndex() {
      var index = {};
      list.push(index); // Parse diff metadata

      // Parse diff metadata
      while (i < diffstr.length) {
        var line = diffstr[i]; // File header found, end parsing diff metadata

        // File header found, end parsing diff metadata
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        } // Diff index


        // Diff index
        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

        if (header) {
          index.index = header[1];
        }

        i++;
      } // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header


      // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header
      parseFileHeader(index);
      parseFileHeader(index); // Parse hunks

      // Parse hunks
      index.hunks = [];

      while (i < diffstr.length) {
        var _line = diffstr[i];

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    } // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.


    // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.
    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
        var data = fileHeader[2].split('\t', 2);
        var fileName = data[0].replace(/\\\\/g, '\\');

        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }

        index[keyPrefix + 'FileName'] = fileName;
        index[keyPrefix + 'Header'] = (data[1] || '').trim();
        i++;
      }
    } // Parses a hunk
    // This assumes that we are at the start of a hunk.


    // Parses a hunk
    // This assumes that we are at the start of a hunk.
    function parseHunk() {
      var chunkHeaderIndex = i,
          chunkHeaderLine = diffstr[i++],
          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      };
      var addCount = 0,
          removeCount = 0;

      for (; i < diffstr.length; i++) {
        // Lines starting with '---' could be mistaken for the "remove line" operation
        // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break;
        }

        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || '\n');

          if (operation === '+') {
            addCount++;
          } else if (operation === '-') {
            removeCount++;
          } else if (operation === ' ') {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      } // Handle the empty block count case


      // Handle the empty block count case
      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }

      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      } // Perform optional sanity checking


      // Perform optional sanity checking
      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }

        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
      }

      return hunk;
    }

    while (i < diffstr.length) {
      parseIndex();
    }

    return list;
  } // Iterator that traverses in the range of [min, max], stepping
  // by distance from a given start position. I.e. for [0, 4], with
  // start of 2, this will iterate 2, 3, 1, 4, 0.


  // Iterator that traverses in the range of [min, max], stepping
  // by distance from a given start position. I.e. for [0, 4], with
  // start of 2, this will iterate 2, 3, 1, 4, 0.
  function distanceIterator(start, minLine, maxLine) {
    var wantForward = true,
        backwardExhausted = false,
        forwardExhausted = false,
        localOffset = 1;
    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        } // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)


        // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)
        if (start + localOffset <= maxLine) {
          return localOffset;
        }

        forwardExhausted = true;
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        } // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location


        // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location
        if (minLine <= start - localOffset) {
          return -localOffset++;
        }

        backwardExhausted = true;
        return iterator();
      } // We tried to fit hunk before text beginning and beyond text length, then
      // hunk can't fit on the text. Return undefined

    };
  }

  function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.');
      }

      uniDiff = uniDiff[0];
    } // Apply the diff to the input


    // Apply the diff to the input
    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        hunks = uniDiff.hunks,
        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
      return line === patchContent;
    },
        errorCount = 0,
        fuzzFactor = options.fuzzFactor || 0,
        minLine = 0,
        offset = 0,
        removeEOFNL,
        addEOFNL;
    /**
     * Checks if the hunk exactly fits on the provided location
     */


    /**
     * Checks if the hunk exactly fits on the provided location
     */
    function hunkFits(hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line;

        if (operation === ' ' || operation === '-') {
          // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++;

            if (errorCount > fuzzFactor) {
              return false;
            }
          }

          toPos++;
        }
      }

      return true;
    } // Search best fit offsets for each hunk based on the previous ones


    // Search best fit offsets for each hunk based on the previous ones
    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
          maxLine = lines.length - hunk.oldLines,
          localOffset = 0,
          toPos = offset + hunk.oldStart - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }

      if (localOffset === undefined) {
        return false;
      } // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text


      // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text
      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    } // Apply patch hunks


    // Apply patch hunks
    var diffOffset = 0;

    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

      diffOffset += _hunk.newLines - _hunk.oldLines;

      if (_toPos < 0) {
        // Creating a new file
        _toPos = 0;
      }

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line,
            delimiter = _hunk.linedelimiters[j];

        if (operation === ' ') {
          _toPos++;
        } else if (operation === '-') {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
          /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
      }
    } // Handle EOFNL insertion/removal


    // Handle EOFNL insertion/removal
    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push('');
      delimiters.push('\n');
    }

    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }

    return lines.join('');
  } // Wrapper that supports multiple file patches via callbacks.


  // Wrapper that supports multiple file patches via callbacks.
  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    var currentIndex = 0;

    function processIndex() {
      var index = uniDiff[currentIndex++];

      if (!index) {
        return options.complete();
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err);
        }

        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err);
          }

          processIndex();
        });
      });
    }

    processIndex();
  }

  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }

    if (typeof options.context === 'undefined') {
      options.context = 4;
    }

    var diff = diffLines(oldStr, newStr, options);
    diff.push({
      value: '',
      lines: []
    }); // Append an empty value to make cleanup easier

    // Append an empty value to make cleanup easier
    function contextLines(lines) {
      return lines.map(function (entry) {
        return ' ' + entry;
      });
    }

    var hunks = [];
    var oldRangeStart = 0,
        newRangeStart = 0,
        curRange = [],
        oldLine = 1,
        newLine = 1;

    var _loop = function _loop(i) {
      var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
      current.lines = lines;

      if (current.added || current.removed) {
        var _curRange; // If we have previous context, start with that


        // If we have previous context, start with that
        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        } // Output our changes


        // Output our changes
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry;
        }))); // Track the updated file position


        // Track the updated file position
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        // Identical context lines. Track line changes
        if (oldRangeStart) {
          // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2; // Overlapping


            // Overlapping
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3; // end the range and output


            // end the range and output
            var contextSize = Math.min(lines.length, options.context);

            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };

            if (i >= diff.length - 2 && lines.length <= options.context) {
              // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

              if (!oldEOFNewline && noNlBeforeAdds) {
                // special case: old has no eol and no trailing context; no-nl can end up before adds
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
              }

              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                curRange.push('\\ No newline at end of file');
              }
            }

            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }

        oldLine += lines.length;
        newLine += lines.length;
      }
    };

    for (var i = 0; i < diff.length; i++) {
      _loop(i);
    }

    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }

  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    var ret = [];

    if (oldFileName == newFileName) {
      ret.push('Index: ' + oldFileName);
    }

    ret.push('===================================================================');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i];
      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
      ret.push.apply(ret, hunk.lines);
    }

    return ret.join('\n') + '\n';
  }

  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }

  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return arrayStartsWith(a, b);
  }

  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }

    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
        oldLines = _calcOldNewLineCount.oldLines,
        newLines = _calcOldNewLineCount.newLines;

    if (oldLines !== undefined) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }

    if (newLines !== undefined) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }

  function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.

    // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.
    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }

    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        // No header or no change in ours, use theirs (and ours if theirs does not exist)
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        // No header or no change in theirs, use ours
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        // Both changed... figure it out
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }

    ret.hunks = [];
    var mineIndex = 0,
        theirsIndex = 0,
        mineOffset = 0,
        theirsOffset = 0;

    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || {
        oldStart: Infinity
      },
          theirsCurrent = theirs.hunks[theirsIndex] || {
        oldStart: Infinity
      };

      if (hunkBefore(mineCurrent, theirsCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        // Overlap, merge as best we can
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;
        ret.hunks.push(mergedHunk);
      }
    }

    return ret;
  }

  function loadPatch(param, base) {
    if (typeof param === 'string') {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return parsePatch(param)[0];
      }

      if (!base) {
        throw new Error('Must provide a base reference or pass in a patch');
      }

      return structuredPatch(undefined, undefined, base, param);
    }

    return param;
  }

  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }

  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return {
        mine: mine,
        theirs: theirs
      };
    }
  }

  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }

  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset,
      newLines: hunk.newLines,
      lines: hunk.lines
    };
  }

  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = {
      offset: mineOffset,
      lines: mineLines,
      index: 0
    },
        their = {
      offset: theirOffset,
      lines: theirLines,
      index: 0
    }; // Handle any leading content

    // Handle any leading content
    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

    // Now in the overlap content. Scan through and select the best changes from each.
    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index],
          theirCurrent = their.lines[their.index];

      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
        // Both modified ...
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
        var _hunk$lines; // Mine inserted


        // Mine inserted
        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
        var _hunk$lines2; // Theirs inserted


        // Theirs inserted
        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
        // Mine removed or edited
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
        // Their removed or edited
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        // Context identity
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        // Context mismatch
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    } // Now push anything that may be remaining


    // Now push anything that may be remaining
    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
  }

  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine),
        theirChanges = collectChange(their);

    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      // Special case for remove changes that are supersets of one another
      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        var _hunk$lines3;

        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

        return;
      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        var _hunk$lines4;

        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

        return;
      }
    } else if (arrayEqual(myChanges, theirChanges)) {
      var _hunk$lines5;

      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

      return;
    }

    conflict(hunk, myChanges, theirChanges);
  }

  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine),
        theirChanges = collectContext(their, myChanges);

    if (theirChanges.merged) {
      var _hunk$lines6;

      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }

  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine: mine,
      theirs: their
    });
  }

  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }

  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }

  function collectChange(state) {
    var ret = [],
        operation = state.lines[state.index][0];

    while (state.index < state.lines.length) {
      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

      // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.
      if (operation === '-' && line[0] === '+') {
        operation = '+';
      }

      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }

    return ret;
  }

  function collectContext(state, matchChanges) {
    var changes = [],
        merged = [],
        matchIndex = 0,
        contextChanges = false,
        conflicted = false;

    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index],
          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

      // Once we've hit our add, then we are done
      if (match[0] === '+') {
        break;
      }

      contextChanges = contextChanges || change[0] !== ' ';
      merged.push(match);
      matchIndex++; // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this

      // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this
      if (change[0] === '+') {
        conflicted = true;

        while (change[0] === '+') {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }

      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }

    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
      conflicted = true;
    }

    if (conflicted) {
      return changes;
    }

    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }

    return {
      merged: merged,
      changes: changes
    };
  }

  function allRemoves(changes) {
    return changes.reduce(function (prev, change) {
      return prev && change[0] === '-';
    }, true);
  }

  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

      if (state.lines[state.index + i] !== ' ' + changeContent) {
        return false;
      }
    }

    state.index += delta;
    return true;
  }

  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function (line) {
      if (typeof line !== 'string') {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);

        if (oldLines !== undefined) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = undefined;
          }
        }

        if (newLines !== undefined) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = undefined;
          }
        }
      } else {
        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
          newLines++;
        }

        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
          oldLines++;
        }
      }
    });
    return {
      oldLines: oldLines,
      newLines: newLines
    };
  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API


  // See: http://code.google.com/p/google-diff-match-patch/wiki/API
  function convertChangesToDMP(changes) {
    var ret = [],
        change,
        operation;

    for (var i = 0; i < changes.length; i++) {
      change = changes[i];

      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }

      ret.push([operation, change.value]);
    }

    return ret;
  }

  function convertChangesToXML(changes) {
    var ret = [];

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];

      if (change.added) {
        ret.push('<ins>');
      } else if (change.removed) {
        ret.push('<del>');
      }

      ret.push(escapeHTML(change.value));

      if (change.added) {
        ret.push('</ins>');
      } else if (change.removed) {
        ret.push('</del>');
      }
    }

    return ret.join('');
  }

  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');
    return n;
  }
  /* See LICENSE file for terms of use */


  /* See LICENSE file for terms of use */
  exports.Diff = Diff;
  exports.diffChars = diffChars;
  exports.diffWords = diffWords;
  exports.diffWordsWithSpace = diffWordsWithSpace;
  exports.diffLines = diffLines;
  exports.diffTrimmedLines = diffTrimmedLines;
  exports.diffSentences = diffSentences;
  exports.diffCss = diffCss;
  exports.diffJson = diffJson;
  exports.diffArrays = diffArrays;
  exports.structuredPatch = structuredPatch;
  exports.createTwoFilesPatch = createTwoFilesPatch;
  exports.createPatch = createPatch;
  exports.applyPatch = applyPatch;
  exports.applyPatches = applyPatches;
  exports.parsePatch = parsePatch;
  exports.merge = merge;
  exports.convertChangesToDMP = convertChangesToDMP;
  exports.convertChangesToXML = convertChangesToXML;
  exports.canonicalize = canonicalize;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

// ASSET: node_modules/lodash/pick.js
var $79a9fcf338e1201012794ef34b398195$exports = {};
// ASSET: node_modules/lodash/_basePick.js
var $53a0ce393a618b1f6b8153857a0781ff$exports = {};
// ASSET: node_modules/lodash/_basePickBy.js
var $18f41bfd92e58749701ce9e722f50ce6$exports = {};
// ASSET: node_modules/lodash/_baseGet.js
var $ca380ca36ecb7abd11b55122670072be$exports = {};
// ASSET: node_modules/lodash/_castPath.js
var $f89541f0d7d338a76d1f3c7332d32c8b$exports = {};
// ASSET: node_modules/lodash/_isKey.js
var $0bf0005e52c96c59b9f9b29ea7bda066$exports = {};

/** Used to match property names within property paths. */
var $0bf0005e52c96c59b9f9b29ea7bda066$var$reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    $0bf0005e52c96c59b9f9b29ea7bda066$var$reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function $0bf0005e52c96c59b9f9b29ea7bda066$var$isKey(value, object) {
  if ($a5b9c798e70b67ee906d88343e7b1453$exports(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || $7209b164c4bc19c7fa171e29ac363020$exports(value)) {
    return true;
  }

  return $0bf0005e52c96c59b9f9b29ea7bda066$var$reIsPlainProp.test(value) || !$0bf0005e52c96c59b9f9b29ea7bda066$var$reIsDeepProp.test(value) || object != null && value in Object(object);
}

$0bf0005e52c96c59b9f9b29ea7bda066$exports = $0bf0005e52c96c59b9f9b29ea7bda066$var$isKey;
// ASSET: node_modules/lodash/_stringToPath.js
var $443982e0186abe69aa7fd2d5279afefa$exports = {};
// ASSET: node_modules/lodash/_memoizeCapped.js
var $c65180d81e3d8fbe8f8e903b9039e96d$exports = {};
// ASSET: node_modules/lodash/memoize.js
var $805b82bd2cf0da31c204f8c826805c16$exports = {};
// ASSET: node_modules/lodash/_MapCache.js
var $0cf84776f3a1c3eae96dcbece75d6218$exports = {};
// ASSET: node_modules/lodash/_mapCacheClear.js
var $880b818119013534f3107b69b1b298eb$exports = {};
// ASSET: node_modules/lodash/_Hash.js
var $e7ee39f748a6707da7b0d79aa7e9294d$exports = {};
// ASSET: node_modules/lodash/_hashClear.js
var $a3a97816453f5c21943b2bb7fa120b8a$exports = {};
// ASSET: node_modules/lodash/_nativeCreate.js
var $18ed796eb1963ea7acf00b01e0527580$exports = {};
// ASSET: node_modules/lodash/_getNative.js
var $b07b772d5c4e747e03a548429faacc46$exports = {};
// ASSET: node_modules/lodash/_baseIsNative.js
var $de86edccc2ea1ed868ea6e0c51a7b282$exports = {};
// ASSET: node_modules/lodash/isFunction.js
var $aa5e15ab9befdfa99eefbf040bdbcbda$exports = {};
// ASSET: node_modules/lodash/isObject.js
var $e6a68946d5ada2ae1284f487ea31dcc7$exports = {};

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function $e6a68946d5ada2ae1284f487ea31dcc7$var$isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

$e6a68946d5ada2ae1284f487ea31dcc7$exports = $e6a68946d5ada2ae1284f487ea31dcc7$var$isObject;

/** `Object#toString` result references. */
var $aa5e15ab9befdfa99eefbf040bdbcbda$var$asyncTag = '[object AsyncFunction]',
    $aa5e15ab9befdfa99eefbf040bdbcbda$var$funcTag = '[object Function]',
    $aa5e15ab9befdfa99eefbf040bdbcbda$var$genTag = '[object GeneratorFunction]',
    $aa5e15ab9befdfa99eefbf040bdbcbda$var$proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function $aa5e15ab9befdfa99eefbf040bdbcbda$var$isFunction(value) {
  if (!$e6a68946d5ada2ae1284f487ea31dcc7$exports(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = $ed805bb9c88654724c0b38f8c70e8db8$exports(value);
  return tag == $aa5e15ab9befdfa99eefbf040bdbcbda$var$funcTag || tag == $aa5e15ab9befdfa99eefbf040bdbcbda$var$genTag || tag == $aa5e15ab9befdfa99eefbf040bdbcbda$var$asyncTag || tag == $aa5e15ab9befdfa99eefbf040bdbcbda$var$proxyTag;
}

$aa5e15ab9befdfa99eefbf040bdbcbda$exports = $aa5e15ab9befdfa99eefbf040bdbcbda$var$isFunction;
// ASSET: node_modules/lodash/_isMasked.js
var $17fed8af32b7da2ec1907e1e427189a3$exports = {};
// ASSET: node_modules/lodash/_coreJsData.js
var $f6007c32473b977c332014997039684e$exports = {};

/** Used to detect overreaching core-js shims. */
var $f6007c32473b977c332014997039684e$var$coreJsData = $00278192d9378b6bfd80fd44346289ac$exports['__core-js_shared__'];
$f6007c32473b977c332014997039684e$exports = $f6007c32473b977c332014997039684e$var$coreJsData;

/** Used to detect methods masquerading as native. */
var $17fed8af32b7da2ec1907e1e427189a3$var$maskSrcKey = function () {
  var uid = /[^.]+$/.exec($f6007c32473b977c332014997039684e$exports && $f6007c32473b977c332014997039684e$exports.keys && $f6007c32473b977c332014997039684e$exports.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function $17fed8af32b7da2ec1907e1e427189a3$var$isMasked(func) {
  return !!$17fed8af32b7da2ec1907e1e427189a3$var$maskSrcKey && $17fed8af32b7da2ec1907e1e427189a3$var$maskSrcKey in func;
}

$17fed8af32b7da2ec1907e1e427189a3$exports = $17fed8af32b7da2ec1907e1e427189a3$var$isMasked;
// ASSET: node_modules/lodash/_toSource.js
var $9f2b288133d99e07110eb626c8d2b95b$exports = {};

/** Used for built-in method references. */
var $9f2b288133d99e07110eb626c8d2b95b$var$funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

/** Used to resolve the decompiled source of functions. */
var $9f2b288133d99e07110eb626c8d2b95b$var$funcToString = $9f2b288133d99e07110eb626c8d2b95b$var$funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function $9f2b288133d99e07110eb626c8d2b95b$var$toSource(func) {
  if (func != null) {
    try {
      return $9f2b288133d99e07110eb626c8d2b95b$var$funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

$9f2b288133d99e07110eb626c8d2b95b$exports = $9f2b288133d99e07110eb626c8d2b95b$var$toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

/** Used to detect host constructors (Safari). */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

/** Used for built-in method references. */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$funcProto = Function.prototype,
    $de86edccc2ea1ed868ea6e0c51a7b282$var$objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

/** Used to resolve the decompiled source of functions. */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$funcToString = $de86edccc2ea1ed868ea6e0c51a7b282$var$funcProto.toString;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$hasOwnProperty = $de86edccc2ea1ed868ea6e0c51a7b282$var$objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

/** Used to detect if a method is native. */
var $de86edccc2ea1ed868ea6e0c51a7b282$var$reIsNative = RegExp('^' + $de86edccc2ea1ed868ea6e0c51a7b282$var$funcToString.call($de86edccc2ea1ed868ea6e0c51a7b282$var$hasOwnProperty).replace($de86edccc2ea1ed868ea6e0c51a7b282$var$reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function $de86edccc2ea1ed868ea6e0c51a7b282$var$baseIsNative(value) {
  if (!$e6a68946d5ada2ae1284f487ea31dcc7$exports(value) || $17fed8af32b7da2ec1907e1e427189a3$exports(value)) {
    return false;
  }

  var pattern = $aa5e15ab9befdfa99eefbf040bdbcbda$exports(value) ? $de86edccc2ea1ed868ea6e0c51a7b282$var$reIsNative : $de86edccc2ea1ed868ea6e0c51a7b282$var$reIsHostCtor;
  return pattern.test($9f2b288133d99e07110eb626c8d2b95b$exports(value));
}

$de86edccc2ea1ed868ea6e0c51a7b282$exports = $de86edccc2ea1ed868ea6e0c51a7b282$var$baseIsNative;
// ASSET: node_modules/lodash/_getValue.js
var $4060a637d4f488a1f37b0fcb689b225b$exports = {};

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function $4060a637d4f488a1f37b0fcb689b225b$var$getValue(object, key) {
  return object == null ? undefined : object[key];
}

$4060a637d4f488a1f37b0fcb689b225b$exports = $4060a637d4f488a1f37b0fcb689b225b$var$getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function $b07b772d5c4e747e03a548429faacc46$var$getNative(object, key) {
  var value = $4060a637d4f488a1f37b0fcb689b225b$exports(object, key);
  return $de86edccc2ea1ed868ea6e0c51a7b282$exports(value) ? value : undefined;
}

$b07b772d5c4e747e03a548429faacc46$exports = $b07b772d5c4e747e03a548429faacc46$var$getNative;

/* Built-in method references that are verified to be native. */
var $18ed796eb1963ea7acf00b01e0527580$var$nativeCreate = $b07b772d5c4e747e03a548429faacc46$exports(Object, 'create');
$18ed796eb1963ea7acf00b01e0527580$exports = $18ed796eb1963ea7acf00b01e0527580$var$nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function $a3a97816453f5c21943b2bb7fa120b8a$var$hashClear() {
  this.__data__ = $18ed796eb1963ea7acf00b01e0527580$exports ? $18ed796eb1963ea7acf00b01e0527580$exports(null) : {};
  this.size = 0;
}

$a3a97816453f5c21943b2bb7fa120b8a$exports = $a3a97816453f5c21943b2bb7fa120b8a$var$hashClear;
// ASSET: node_modules/lodash/_hashDelete.js
var $4ea0e36946b13390944b1721afbf0a61$exports = {};

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function $4ea0e36946b13390944b1721afbf0a61$var$hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

$4ea0e36946b13390944b1721afbf0a61$exports = $4ea0e36946b13390944b1721afbf0a61$var$hashDelete;
// ASSET: node_modules/lodash/_hashGet.js
var $98129b887604be83b583e8d528a9ca9b$exports = {};

/** Used to stand-in for `undefined` hash values. */
var $98129b887604be83b583e8d528a9ca9b$var$HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

/** Used for built-in method references. */
var $98129b887604be83b583e8d528a9ca9b$var$objectProto = Object.prototype;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $98129b887604be83b583e8d528a9ca9b$var$hasOwnProperty = $98129b887604be83b583e8d528a9ca9b$var$objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function $98129b887604be83b583e8d528a9ca9b$var$hashGet(key) {
  var data = this.__data__;

  if ($18ed796eb1963ea7acf00b01e0527580$exports) {
    var result = data[key];
    return result === $98129b887604be83b583e8d528a9ca9b$var$HASH_UNDEFINED ? undefined : result;
  }

  return $98129b887604be83b583e8d528a9ca9b$var$hasOwnProperty.call(data, key) ? data[key] : undefined;
}

$98129b887604be83b583e8d528a9ca9b$exports = $98129b887604be83b583e8d528a9ca9b$var$hashGet;
// ASSET: node_modules/lodash/_hashHas.js
var $aeb139866b3f6b2415ad31c674ae3ae9$exports = {};

/** Used for built-in method references. */
var $aeb139866b3f6b2415ad31c674ae3ae9$var$objectProto = Object.prototype;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $aeb139866b3f6b2415ad31c674ae3ae9$var$hasOwnProperty = $aeb139866b3f6b2415ad31c674ae3ae9$var$objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function $aeb139866b3f6b2415ad31c674ae3ae9$var$hashHas(key) {
  var data = this.__data__;
  return $18ed796eb1963ea7acf00b01e0527580$exports ? data[key] !== undefined : $aeb139866b3f6b2415ad31c674ae3ae9$var$hasOwnProperty.call(data, key);
}

$aeb139866b3f6b2415ad31c674ae3ae9$exports = $aeb139866b3f6b2415ad31c674ae3ae9$var$hashHas;
// ASSET: node_modules/lodash/_hashSet.js
var $435cd4cc935b51d9425b263f0748bbe7$exports = {};

/** Used to stand-in for `undefined` hash values. */
var $435cd4cc935b51d9425b263f0748bbe7$var$HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function $435cd4cc935b51d9425b263f0748bbe7$var$hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = $18ed796eb1963ea7acf00b01e0527580$exports && value === undefined ? $435cd4cc935b51d9425b263f0748bbe7$var$HASH_UNDEFINED : value;
  return this;
}

$435cd4cc935b51d9425b263f0748bbe7$exports = $435cd4cc935b51d9425b263f0748bbe7$var$hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function $e7ee39f748a6707da7b0d79aa7e9294d$var$Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


// Add methods to `Hash`.
$e7ee39f748a6707da7b0d79aa7e9294d$var$Hash.prototype.clear = $a3a97816453f5c21943b2bb7fa120b8a$exports;
$e7ee39f748a6707da7b0d79aa7e9294d$var$Hash.prototype['delete'] = $4ea0e36946b13390944b1721afbf0a61$exports;
$e7ee39f748a6707da7b0d79aa7e9294d$var$Hash.prototype.get = $98129b887604be83b583e8d528a9ca9b$exports;
$e7ee39f748a6707da7b0d79aa7e9294d$var$Hash.prototype.has = $aeb139866b3f6b2415ad31c674ae3ae9$exports;
$e7ee39f748a6707da7b0d79aa7e9294d$var$Hash.prototype.set = $435cd4cc935b51d9425b263f0748bbe7$exports;
$e7ee39f748a6707da7b0d79aa7e9294d$exports = $e7ee39f748a6707da7b0d79aa7e9294d$var$Hash;
// ASSET: node_modules/lodash/_ListCache.js
var $61b37c0e654ba488c717a9829ef97a86$exports = {};
// ASSET: node_modules/lodash/_listCacheClear.js
var $a038111db085c2f387d14669d6d08353$exports = {};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function $a038111db085c2f387d14669d6d08353$var$listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

$a038111db085c2f387d14669d6d08353$exports = $a038111db085c2f387d14669d6d08353$var$listCacheClear;
// ASSET: node_modules/lodash/_listCacheDelete.js
var $983ca98c5776cab0f5417ee2588333d6$exports = {};
// ASSET: node_modules/lodash/_assocIndexOf.js
var $088dfc94382aa4dcfd37d3eff06b48c4$exports = {};
// ASSET: node_modules/lodash/eq.js
var $d09b3cf3fb40aa599af12a3df7c58f5e$exports = {};

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function $d09b3cf3fb40aa599af12a3df7c58f5e$var$eq(value, other) {
  return value === other || value !== value && other !== other;
}

$d09b3cf3fb40aa599af12a3df7c58f5e$exports = $d09b3cf3fb40aa599af12a3df7c58f5e$var$eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function $088dfc94382aa4dcfd37d3eff06b48c4$var$assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if ($d09b3cf3fb40aa599af12a3df7c58f5e$exports(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

$088dfc94382aa4dcfd37d3eff06b48c4$exports = $088dfc94382aa4dcfd37d3eff06b48c4$var$assocIndexOf;

/** Used for built-in method references. */
var $983ca98c5776cab0f5417ee2588333d6$var$arrayProto = Array.prototype;
/** Built-in value references. */

/** Built-in value references. */
var $983ca98c5776cab0f5417ee2588333d6$var$splice = $983ca98c5776cab0f5417ee2588333d6$var$arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function $983ca98c5776cab0f5417ee2588333d6$var$listCacheDelete(key) {
  var data = this.__data__,
      index = $088dfc94382aa4dcfd37d3eff06b48c4$exports(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    $983ca98c5776cab0f5417ee2588333d6$var$splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

$983ca98c5776cab0f5417ee2588333d6$exports = $983ca98c5776cab0f5417ee2588333d6$var$listCacheDelete;
// ASSET: node_modules/lodash/_listCacheGet.js
var $644dcf2646861d56413322ada723feb6$exports = {};

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function $644dcf2646861d56413322ada723feb6$var$listCacheGet(key) {
  var data = this.__data__,
      index = $088dfc94382aa4dcfd37d3eff06b48c4$exports(data, key);
  return index < 0 ? undefined : data[index][1];
}

$644dcf2646861d56413322ada723feb6$exports = $644dcf2646861d56413322ada723feb6$var$listCacheGet;
// ASSET: node_modules/lodash/_listCacheHas.js
var $f26bc16d623ec56c75f8e50aac39ce4b$exports = {};

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function $f26bc16d623ec56c75f8e50aac39ce4b$var$listCacheHas(key) {
  return $088dfc94382aa4dcfd37d3eff06b48c4$exports(this.__data__, key) > -1;
}

$f26bc16d623ec56c75f8e50aac39ce4b$exports = $f26bc16d623ec56c75f8e50aac39ce4b$var$listCacheHas;
// ASSET: node_modules/lodash/_listCacheSet.js
var $c306877d9d721aefdcd7b3c1f692ccef$exports = {};

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function $c306877d9d721aefdcd7b3c1f692ccef$var$listCacheSet(key, value) {
  var data = this.__data__,
      index = $088dfc94382aa4dcfd37d3eff06b48c4$exports(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

$c306877d9d721aefdcd7b3c1f692ccef$exports = $c306877d9d721aefdcd7b3c1f692ccef$var$listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function $61b37c0e654ba488c717a9829ef97a86$var$ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


// Add methods to `ListCache`.
$61b37c0e654ba488c717a9829ef97a86$var$ListCache.prototype.clear = $a038111db085c2f387d14669d6d08353$exports;
$61b37c0e654ba488c717a9829ef97a86$var$ListCache.prototype['delete'] = $983ca98c5776cab0f5417ee2588333d6$exports;
$61b37c0e654ba488c717a9829ef97a86$var$ListCache.prototype.get = $644dcf2646861d56413322ada723feb6$exports;
$61b37c0e654ba488c717a9829ef97a86$var$ListCache.prototype.has = $f26bc16d623ec56c75f8e50aac39ce4b$exports;
$61b37c0e654ba488c717a9829ef97a86$var$ListCache.prototype.set = $c306877d9d721aefdcd7b3c1f692ccef$exports;
$61b37c0e654ba488c717a9829ef97a86$exports = $61b37c0e654ba488c717a9829ef97a86$var$ListCache;
// ASSET: node_modules/lodash/_Map.js
var $8f5b78af77a9979c4e49a0a7e37a7f53$exports = {};

/* Built-in method references that are verified to be native. */
var $8f5b78af77a9979c4e49a0a7e37a7f53$var$Map = $b07b772d5c4e747e03a548429faacc46$exports($00278192d9378b6bfd80fd44346289ac$exports, 'Map');
$8f5b78af77a9979c4e49a0a7e37a7f53$exports = $8f5b78af77a9979c4e49a0a7e37a7f53$var$Map;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function $880b818119013534f3107b69b1b298eb$var$mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new $e7ee39f748a6707da7b0d79aa7e9294d$exports(),
    'map': new ($8f5b78af77a9979c4e49a0a7e37a7f53$exports || $61b37c0e654ba488c717a9829ef97a86$exports)(),
    'string': new $e7ee39f748a6707da7b0d79aa7e9294d$exports()
  };
}

$880b818119013534f3107b69b1b298eb$exports = $880b818119013534f3107b69b1b298eb$var$mapCacheClear;
// ASSET: node_modules/lodash/_mapCacheDelete.js
var $50f2fa9b391437ace9cbd66ed3aa15ec$exports = {};
// ASSET: node_modules/lodash/_getMapData.js
var $a5ba5c4429af5f1392405b3f2cf1bb49$exports = {};
// ASSET: node_modules/lodash/_isKeyable.js
var $da67bfab5f22299e034c4c6ba25f52b6$exports = {};

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function $da67bfab5f22299e034c4c6ba25f52b6$var$isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

$da67bfab5f22299e034c4c6ba25f52b6$exports = $da67bfab5f22299e034c4c6ba25f52b6$var$isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function $a5ba5c4429af5f1392405b3f2cf1bb49$var$getMapData(map, key) {
  var data = map.__data__;
  return $da67bfab5f22299e034c4c6ba25f52b6$exports(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

$a5ba5c4429af5f1392405b3f2cf1bb49$exports = $a5ba5c4429af5f1392405b3f2cf1bb49$var$getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function $50f2fa9b391437ace9cbd66ed3aa15ec$var$mapCacheDelete(key) {
  var result = $a5ba5c4429af5f1392405b3f2cf1bb49$exports(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

$50f2fa9b391437ace9cbd66ed3aa15ec$exports = $50f2fa9b391437ace9cbd66ed3aa15ec$var$mapCacheDelete;
// ASSET: node_modules/lodash/_mapCacheGet.js
var $cfe6bff82952c8e4207b17d4013a4b7b$exports = {};

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function $cfe6bff82952c8e4207b17d4013a4b7b$var$mapCacheGet(key) {
  return $a5ba5c4429af5f1392405b3f2cf1bb49$exports(this, key).get(key);
}

$cfe6bff82952c8e4207b17d4013a4b7b$exports = $cfe6bff82952c8e4207b17d4013a4b7b$var$mapCacheGet;
// ASSET: node_modules/lodash/_mapCacheHas.js
var $8c4a67918bc67fef5f34f7b8673e5c47$exports = {};

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function $8c4a67918bc67fef5f34f7b8673e5c47$var$mapCacheHas(key) {
  return $a5ba5c4429af5f1392405b3f2cf1bb49$exports(this, key).has(key);
}

$8c4a67918bc67fef5f34f7b8673e5c47$exports = $8c4a67918bc67fef5f34f7b8673e5c47$var$mapCacheHas;
// ASSET: node_modules/lodash/_mapCacheSet.js
var $83a1710bdd7bf41a7abda7b3938bf28a$exports = {};

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function $83a1710bdd7bf41a7abda7b3938bf28a$var$mapCacheSet(key, value) {
  var data = $a5ba5c4429af5f1392405b3f2cf1bb49$exports(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

$83a1710bdd7bf41a7abda7b3938bf28a$exports = $83a1710bdd7bf41a7abda7b3938bf28a$var$mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function $0cf84776f3a1c3eae96dcbece75d6218$var$MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


// Add methods to `MapCache`.
$0cf84776f3a1c3eae96dcbece75d6218$var$MapCache.prototype.clear = $880b818119013534f3107b69b1b298eb$exports;
$0cf84776f3a1c3eae96dcbece75d6218$var$MapCache.prototype['delete'] = $50f2fa9b391437ace9cbd66ed3aa15ec$exports;
$0cf84776f3a1c3eae96dcbece75d6218$var$MapCache.prototype.get = $cfe6bff82952c8e4207b17d4013a4b7b$exports;
$0cf84776f3a1c3eae96dcbece75d6218$var$MapCache.prototype.has = $8c4a67918bc67fef5f34f7b8673e5c47$exports;
$0cf84776f3a1c3eae96dcbece75d6218$var$MapCache.prototype.set = $83a1710bdd7bf41a7abda7b3938bf28a$exports;
$0cf84776f3a1c3eae96dcbece75d6218$exports = $0cf84776f3a1c3eae96dcbece75d6218$var$MapCache;

/** Error message constants. */
var $805b82bd2cf0da31c204f8c826805c16$var$FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function $805b82bd2cf0da31c204f8c826805c16$var$memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError($805b82bd2cf0da31c204f8c826805c16$var$FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new ($805b82bd2cf0da31c204f8c826805c16$var$memoize.Cache || $0cf84776f3a1c3eae96dcbece75d6218$exports)();
  return memoized;
} // Expose `MapCache`.


// Expose `MapCache`.
$805b82bd2cf0da31c204f8c826805c16$var$memoize.Cache = $0cf84776f3a1c3eae96dcbece75d6218$exports;
$805b82bd2cf0da31c204f8c826805c16$exports = $805b82bd2cf0da31c204f8c826805c16$var$memoize;

/** Used as the maximum memoize cache size. */
var $c65180d81e3d8fbe8f8e903b9039e96d$var$MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function $c65180d81e3d8fbe8f8e903b9039e96d$var$memoizeCapped(func) {
  var result = $805b82bd2cf0da31c204f8c826805c16$exports(func, function (key) {
    if (cache.size === $c65180d81e3d8fbe8f8e903b9039e96d$var$MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

$c65180d81e3d8fbe8f8e903b9039e96d$exports = $c65180d81e3d8fbe8f8e903b9039e96d$var$memoizeCapped;

/** Used to match property names within property paths. */
var $443982e0186abe69aa7fd2d5279afefa$var$rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

/** Used to match backslashes in property paths. */
var $443982e0186abe69aa7fd2d5279afefa$var$reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var $443982e0186abe69aa7fd2d5279afefa$var$stringToPath = $c65180d81e3d8fbe8f8e903b9039e96d$exports(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  )
    /* . */
    {
      result.push('');
    }

  string.replace($443982e0186abe69aa7fd2d5279afefa$var$rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace($443982e0186abe69aa7fd2d5279afefa$var$reEscapeChar, '$1') : number || match);
  });
  return result;
});
$443982e0186abe69aa7fd2d5279afefa$exports = $443982e0186abe69aa7fd2d5279afefa$var$stringToPath;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function $f89541f0d7d338a76d1f3c7332d32c8b$var$castPath(value, object) {
  if ($a5b9c798e70b67ee906d88343e7b1453$exports(value)) {
    return value;
  }

  return $0bf0005e52c96c59b9f9b29ea7bda066$exports(value, object) ? [value] : $443982e0186abe69aa7fd2d5279afefa$exports($527b2e5779250a5bbe79f402e9a29e45$exports(value));
}

$f89541f0d7d338a76d1f3c7332d32c8b$exports = $f89541f0d7d338a76d1f3c7332d32c8b$var$castPath;
// ASSET: node_modules/lodash/_toKey.js
var $aafb492ae83d90eb11a4f3881381c061$exports = {};

/** Used as references for various `Number` constants. */
var $aafb492ae83d90eb11a4f3881381c061$var$INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function $aafb492ae83d90eb11a4f3881381c061$var$toKey(value) {
  if (typeof value == 'string' || $7209b164c4bc19c7fa171e29ac363020$exports(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -$aafb492ae83d90eb11a4f3881381c061$var$INFINITY ? '-0' : result;
}

$aafb492ae83d90eb11a4f3881381c061$exports = $aafb492ae83d90eb11a4f3881381c061$var$toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function $ca380ca36ecb7abd11b55122670072be$var$baseGet(object, path) {
  path = $f89541f0d7d338a76d1f3c7332d32c8b$exports(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[$aafb492ae83d90eb11a4f3881381c061$exports(path[index++])];
  }

  return index && index == length ? object : undefined;
}

$ca380ca36ecb7abd11b55122670072be$exports = $ca380ca36ecb7abd11b55122670072be$var$baseGet;
// ASSET: node_modules/lodash/_baseSet.js
var $a6ba9b27aaceebcc2206a9e7ee216c08$exports = {};
// ASSET: node_modules/lodash/_assignValue.js
var $89cba6c4a1b33536d46a69031601a8b9$exports = {};
// ASSET: node_modules/lodash/_baseAssignValue.js
var $ea7af4322c8c7161b8cb781a7cf8b3b2$exports = {};
// ASSET: node_modules/lodash/_defineProperty.js
var $e90bf74878907e774eb23f8081296e02$exports = {};

var $e90bf74878907e774eb23f8081296e02$var$defineProperty = function () {
  try {
    var func = $b07b772d5c4e747e03a548429faacc46$exports(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

$e90bf74878907e774eb23f8081296e02$exports = $e90bf74878907e774eb23f8081296e02$var$defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function $ea7af4322c8c7161b8cb781a7cf8b3b2$var$baseAssignValue(object, key, value) {
  if (key == '__proto__' && $e90bf74878907e774eb23f8081296e02$exports) {
    $e90bf74878907e774eb23f8081296e02$exports(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

$ea7af4322c8c7161b8cb781a7cf8b3b2$exports = $ea7af4322c8c7161b8cb781a7cf8b3b2$var$baseAssignValue;

/** Used for built-in method references. */
var $89cba6c4a1b33536d46a69031601a8b9$var$objectProto = Object.prototype;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $89cba6c4a1b33536d46a69031601a8b9$var$hasOwnProperty = $89cba6c4a1b33536d46a69031601a8b9$var$objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function $89cba6c4a1b33536d46a69031601a8b9$var$assignValue(object, key, value) {
  var objValue = object[key];

  if (!($89cba6c4a1b33536d46a69031601a8b9$var$hasOwnProperty.call(object, key) && $d09b3cf3fb40aa599af12a3df7c58f5e$exports(objValue, value)) || value === undefined && !(key in object)) {
    $ea7af4322c8c7161b8cb781a7cf8b3b2$exports(object, key, value);
  }
}

$89cba6c4a1b33536d46a69031601a8b9$exports = $89cba6c4a1b33536d46a69031601a8b9$var$assignValue;
// ASSET: node_modules/lodash/_isIndex.js
var $3ca0dd725761b3058f453e7ed1fbdb57$exports = {};

/** Used as references for various `Number` constants. */
var $3ca0dd725761b3058f453e7ed1fbdb57$var$MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

/** Used to detect unsigned integer values. */
var $3ca0dd725761b3058f453e7ed1fbdb57$var$reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function $3ca0dd725761b3058f453e7ed1fbdb57$var$isIndex(value, length) {
  var type = typeof value;
  length = length == null ? $3ca0dd725761b3058f453e7ed1fbdb57$var$MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && $3ca0dd725761b3058f453e7ed1fbdb57$var$reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

$3ca0dd725761b3058f453e7ed1fbdb57$exports = $3ca0dd725761b3058f453e7ed1fbdb57$var$isIndex;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function $a6ba9b27aaceebcc2206a9e7ee216c08$var$baseSet(object, path, value, customizer) {
  if (!$e6a68946d5ada2ae1284f487ea31dcc7$exports(object)) {
    return object;
  }

  path = $f89541f0d7d338a76d1f3c7332d32c8b$exports(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = $aafb492ae83d90eb11a4f3881381c061$exports(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = $e6a68946d5ada2ae1284f487ea31dcc7$exports(objValue) ? objValue : $3ca0dd725761b3058f453e7ed1fbdb57$exports(path[index + 1]) ? [] : {};
      }
    }

    $89cba6c4a1b33536d46a69031601a8b9$exports(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

$a6ba9b27aaceebcc2206a9e7ee216c08$exports = $a6ba9b27aaceebcc2206a9e7ee216c08$var$baseSet;

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function $18f41bfd92e58749701ce9e722f50ce6$var$basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = $ca380ca36ecb7abd11b55122670072be$exports(object, path);

    if (predicate(value, path)) {
      $a6ba9b27aaceebcc2206a9e7ee216c08$exports(result, $f89541f0d7d338a76d1f3c7332d32c8b$exports(path, object), value);
    }
  }

  return result;
}

$18f41bfd92e58749701ce9e722f50ce6$exports = $18f41bfd92e58749701ce9e722f50ce6$var$basePickBy;
// ASSET: node_modules/lodash/hasIn.js
var $79ce0eb33f590c583441a246d12b8296$exports = {};
// ASSET: node_modules/lodash/_baseHasIn.js
var $e07773996290d7991ee02451bcc1155c$exports = {};

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function $e07773996290d7991ee02451bcc1155c$var$baseHasIn(object, key) {
  return object != null && key in Object(object);
}

$e07773996290d7991ee02451bcc1155c$exports = $e07773996290d7991ee02451bcc1155c$var$baseHasIn;
// ASSET: node_modules/lodash/_hasPath.js
var $00799156127ee7f34c1fce10f3f96671$exports = {};
// ASSET: node_modules/lodash/isArguments.js
var $c4c832623895856f871c36a91d727734$exports = {};
// ASSET: node_modules/lodash/_baseIsArguments.js
var $3d73090fa885d0f517cceaa2214c3882$exports = {};

/** `Object#toString` result references. */
var $3d73090fa885d0f517cceaa2214c3882$var$argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function $3d73090fa885d0f517cceaa2214c3882$var$baseIsArguments(value) {
  return $19235f65527b96e6e29ea39c9a223705$exports(value) && $ed805bb9c88654724c0b38f8c70e8db8$exports(value) == $3d73090fa885d0f517cceaa2214c3882$var$argsTag;
}

$3d73090fa885d0f517cceaa2214c3882$exports = $3d73090fa885d0f517cceaa2214c3882$var$baseIsArguments;

/** Used for built-in method references. */
var $c4c832623895856f871c36a91d727734$var$objectProto = Object.prototype;
/** Used to check objects for own properties. */

/** Used to check objects for own properties. */
var $c4c832623895856f871c36a91d727734$var$hasOwnProperty = $c4c832623895856f871c36a91d727734$var$objectProto.hasOwnProperty;
/** Built-in value references. */

/** Built-in value references. */
var $c4c832623895856f871c36a91d727734$var$propertyIsEnumerable = $c4c832623895856f871c36a91d727734$var$objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var $c4c832623895856f871c36a91d727734$var$isArguments = $3d73090fa885d0f517cceaa2214c3882$exports(function () {
  return arguments;
}()) ? $3d73090fa885d0f517cceaa2214c3882$exports : function (value) {
  return $19235f65527b96e6e29ea39c9a223705$exports(value) && $c4c832623895856f871c36a91d727734$var$hasOwnProperty.call(value, 'callee') && !$c4c832623895856f871c36a91d727734$var$propertyIsEnumerable.call(value, 'callee');
};
$c4c832623895856f871c36a91d727734$exports = $c4c832623895856f871c36a91d727734$var$isArguments;
// ASSET: node_modules/lodash/isLength.js
var $da662340667d0220ad20916746439254$exports = {};

/** Used as references for various `Number` constants. */
var $da662340667d0220ad20916746439254$var$MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function $da662340667d0220ad20916746439254$var$isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= $da662340667d0220ad20916746439254$var$MAX_SAFE_INTEGER;
}

$da662340667d0220ad20916746439254$exports = $da662340667d0220ad20916746439254$var$isLength;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function $00799156127ee7f34c1fce10f3f96671$var$hasPath(object, path, hasFunc) {
  path = $f89541f0d7d338a76d1f3c7332d32c8b$exports(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = $aafb492ae83d90eb11a4f3881381c061$exports(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && $da662340667d0220ad20916746439254$exports(length) && $3ca0dd725761b3058f453e7ed1fbdb57$exports(key, length) && ($a5b9c798e70b67ee906d88343e7b1453$exports(object) || $c4c832623895856f871c36a91d727734$exports(object));
}

$00799156127ee7f34c1fce10f3f96671$exports = $00799156127ee7f34c1fce10f3f96671$var$hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function $79ce0eb33f590c583441a246d12b8296$var$hasIn(object, path) {
  return object != null && $00799156127ee7f34c1fce10f3f96671$exports(object, path, $e07773996290d7991ee02451bcc1155c$exports);
}

$79ce0eb33f590c583441a246d12b8296$exports = $79ce0eb33f590c583441a246d12b8296$var$hasIn;

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function $53a0ce393a618b1f6b8153857a0781ff$var$basePick(object, paths) {
  return $18f41bfd92e58749701ce9e722f50ce6$exports(object, paths, function (value, path) {
    return $79ce0eb33f590c583441a246d12b8296$exports(object, path);
  });
}

$53a0ce393a618b1f6b8153857a0781ff$exports = $53a0ce393a618b1f6b8153857a0781ff$var$basePick;
// ASSET: node_modules/lodash/_flatRest.js
var $eaf6433fa1ef1abfa1c1a7fb24a371da$exports = {};
// ASSET: node_modules/lodash/flatten.js
var $103e1188f6d049375e5e7e45e4766cde$exports = {};
// ASSET: node_modules/lodash/_baseFlatten.js
var $704bb6340a4cc6cf1802fa1c49300a1e$exports = {};
// ASSET: node_modules/lodash/_arrayPush.js
var $f2322e7930c1cf1845e475baaafa3ea2$exports = {};

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function $f2322e7930c1cf1845e475baaafa3ea2$var$arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

$f2322e7930c1cf1845e475baaafa3ea2$exports = $f2322e7930c1cf1845e475baaafa3ea2$var$arrayPush;
// ASSET: node_modules/lodash/_isFlattenable.js
var $3f9d2c79b596aef074582d38b77706c3$exports = {};

/** Built-in value references. */
var $3f9d2c79b596aef074582d38b77706c3$var$spreadableSymbol = $53d8a9775bd80cdff9ff16cc102f07a5$exports ? $53d8a9775bd80cdff9ff16cc102f07a5$exports.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function $3f9d2c79b596aef074582d38b77706c3$var$isFlattenable(value) {
  return $a5b9c798e70b67ee906d88343e7b1453$exports(value) || $c4c832623895856f871c36a91d727734$exports(value) || !!($3f9d2c79b596aef074582d38b77706c3$var$spreadableSymbol && value && value[$3f9d2c79b596aef074582d38b77706c3$var$spreadableSymbol]);
}

$3f9d2c79b596aef074582d38b77706c3$exports = $3f9d2c79b596aef074582d38b77706c3$var$isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function $704bb6340a4cc6cf1802fa1c49300a1e$var$baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = $3f9d2c79b596aef074582d38b77706c3$exports);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        $704bb6340a4cc6cf1802fa1c49300a1e$var$baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        $f2322e7930c1cf1845e475baaafa3ea2$exports(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

$704bb6340a4cc6cf1802fa1c49300a1e$exports = $704bb6340a4cc6cf1802fa1c49300a1e$var$baseFlatten;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function $103e1188f6d049375e5e7e45e4766cde$var$flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? $704bb6340a4cc6cf1802fa1c49300a1e$exports(array, 1) : [];
}

$103e1188f6d049375e5e7e45e4766cde$exports = $103e1188f6d049375e5e7e45e4766cde$var$flatten;
// ASSET: node_modules/lodash/_overRest.js
var $9cbd98091a8ebf592fb4c6f76fa8c6cf$exports = {};
// ASSET: node_modules/lodash/_apply.js
var $64731f8c0556bb4a053a1a5366ee5740$exports = {};

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function $64731f8c0556bb4a053a1a5366ee5740$var$apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

$64731f8c0556bb4a053a1a5366ee5740$exports = $64731f8c0556bb4a053a1a5366ee5740$var$apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var $9cbd98091a8ebf592fb4c6f76fa8c6cf$var$nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function $9cbd98091a8ebf592fb4c6f76fa8c6cf$var$overRest(func, start, transform) {
  start = $9cbd98091a8ebf592fb4c6f76fa8c6cf$var$nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = $9cbd98091a8ebf592fb4c6f76fa8c6cf$var$nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return $64731f8c0556bb4a053a1a5366ee5740$exports(func, this, otherArgs);
  };
}

$9cbd98091a8ebf592fb4c6f76fa8c6cf$exports = $9cbd98091a8ebf592fb4c6f76fa8c6cf$var$overRest;
// ASSET: node_modules/lodash/_setToString.js
var $5a257a38ad85f09c1f09323fce7ca9fc$exports = {};
// ASSET: node_modules/lodash/_baseSetToString.js
var $e196280f742949c074f26d8abd31784d$exports = {};
// ASSET: node_modules/lodash/constant.js
var $3a641c6386d27012ded5acbeccc543f2$exports = {};

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function $3a641c6386d27012ded5acbeccc543f2$var$constant(value) {
  return function () {
    return value;
  };
}

$3a641c6386d27012ded5acbeccc543f2$exports = $3a641c6386d27012ded5acbeccc543f2$var$constant;
// ASSET: node_modules/lodash/identity.js
var $14a491079b041097fcf8a8be4cc9d952$exports = {};

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function $14a491079b041097fcf8a8be4cc9d952$var$identity(value) {
  return value;
}

$14a491079b041097fcf8a8be4cc9d952$exports = $14a491079b041097fcf8a8be4cc9d952$var$identity;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var $e196280f742949c074f26d8abd31784d$var$baseSetToString = !$e90bf74878907e774eb23f8081296e02$exports ? $14a491079b041097fcf8a8be4cc9d952$exports : function (func, string) {
  return $e90bf74878907e774eb23f8081296e02$exports(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': $3a641c6386d27012ded5acbeccc543f2$exports(string),
    'writable': true
  });
};
$e196280f742949c074f26d8abd31784d$exports = $e196280f742949c074f26d8abd31784d$var$baseSetToString;
// ASSET: node_modules/lodash/_shortOut.js
var $b36d3732c9b6e4b4404ca0b7e172f723$exports = {};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var $b36d3732c9b6e4b4404ca0b7e172f723$var$HOT_COUNT = 800,
    $b36d3732c9b6e4b4404ca0b7e172f723$var$HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

/* Built-in method references for those with the same name as other `lodash` methods. */
var $b36d3732c9b6e4b4404ca0b7e172f723$var$nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function $b36d3732c9b6e4b4404ca0b7e172f723$var$shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = $b36d3732c9b6e4b4404ca0b7e172f723$var$nativeNow(),
        remaining = $b36d3732c9b6e4b4404ca0b7e172f723$var$HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= $b36d3732c9b6e4b4404ca0b7e172f723$var$HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

$b36d3732c9b6e4b4404ca0b7e172f723$exports = $b36d3732c9b6e4b4404ca0b7e172f723$var$shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var $5a257a38ad85f09c1f09323fce7ca9fc$var$setToString = $b36d3732c9b6e4b4404ca0b7e172f723$exports($e196280f742949c074f26d8abd31784d$exports);
$5a257a38ad85f09c1f09323fce7ca9fc$exports = $5a257a38ad85f09c1f09323fce7ca9fc$var$setToString;

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function $eaf6433fa1ef1abfa1c1a7fb24a371da$var$flatRest(func) {
  return $5a257a38ad85f09c1f09323fce7ca9fc$exports($9cbd98091a8ebf592fb4c6f76fa8c6cf$exports(func, undefined, $103e1188f6d049375e5e7e45e4766cde$exports), func + '');
}

$eaf6433fa1ef1abfa1c1a7fb24a371da$exports = $eaf6433fa1ef1abfa1c1a7fb24a371da$var$flatRest;

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var $79a9fcf338e1201012794ef34b398195$var$pick = $eaf6433fa1ef1abfa1c1a7fb24a371da$exports(function (object, paths) {
  return object == null ? {} : $53a0ce393a618b1f6b8153857a0781ff$exports(object, paths);
});
$79a9fcf338e1201012794ef34b398195$exports = $79a9fcf338e1201012794ef34b398195$var$pick;
const $5a1c67a183441e010515e193fca593e1$var$pick_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($79a9fcf338e1201012794ef34b398195$exports);
const $5a1c67a183441e010515e193fca593e1$var$p_limit_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($e6872599661a671bb42eeb06298de58e$exports);
const $5a1c67a183441e010515e193fca593e1$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $5a1c67a183441e010515e193fca593e1$var$util_1 = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: polyfills/v8.js
var $9a9e90269c602b073b1f23c4f8583eb1$exports = {};
var $e01c297a9e7abe636e632a97817ef114$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
var $e01c297a9e7abe636e632a97817ef114$var$TEXT_ENCODING_AVAILABLE = typeof $e01c297a9e7abe636e632a97817ef114$var$process !== "undefined" && undefined !== "never" && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
var $e01c297a9e7abe636e632a97817ef114$var$STR_SIZE_MAX = 4294967295; // uint32_max

// uint32_max
function $e01c297a9e7abe636e632a97817ef114$export$utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;

  while (pos < strLength) {
    var value = str.charCodeAt(pos++);

    if ((value & 0xffffff80) === 0) {
      // 1-byte
      byteLength++;
      continue;
    } else if ((value & 0xfffff800) === 0) {
      // 2-bytes
      byteLength += 2;
    } else {
      // handle surrogate pair
      if (value >= 0xd800 && value <= 0xdbff) {
        // high surrogate
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);

          if ((extra & 0xfc00) === 0xdc00) {
            ++pos;
            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
          }
        }
      }

      if ((value & 0xffff0000) === 0) {
        // 3-byte
        byteLength += 3;
      } else {
        // 4-byte
        byteLength += 4;
      }
    }
  }

  return byteLength;
}

function $e01c297a9e7abe636e632a97817ef114$export$utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;

  while (pos < strLength) {
    var value = str.charCodeAt(pos++);

    if ((value & 0xffffff80) === 0) {
      // 1-byte
      output[offset++] = value;
      continue;
    } else if ((value & 0xfffff800) === 0) {
      // 2-bytes
      output[offset++] = value >> 6 & 0x1f | 0xc0;
    } else {
      // handle surrogate pair
      if (value >= 0xd800 && value <= 0xdbff) {
        // high surrogate
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);

          if ((extra & 0xfc00) === 0xdc00) {
            ++pos;
            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
          }
        }
      }

      if ((value & 0xffff0000) === 0) {
        // 3-byte
        output[offset++] = value >> 12 & 0x0f | 0xe0;
        output[offset++] = value >> 6 & 0x3f | 0x80;
      } else {
        // 4-byte
        output[offset++] = value >> 18 & 0x07 | 0xf0;
        output[offset++] = value >> 12 & 0x3f | 0x80;
        output[offset++] = value >> 6 & 0x3f | 0x80;
      }
    }

    output[offset++] = value & 0x3f | 0x80;
  }
}

var $e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder = $e01c297a9e7abe636e632a97817ef114$var$TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;
var $e01c297a9e7abe636e632a97817ef114$export$TEXT_ENCODER_THRESHOLD = !$e01c297a9e7abe636e632a97817ef114$var$TEXT_ENCODING_AVAILABLE ? $e01c297a9e7abe636e632a97817ef114$var$STR_SIZE_MAX : typeof $e01c297a9e7abe636e632a97817ef114$var$process !== "undefined" && undefined !== "force" ? 200 : 0;

function $e01c297a9e7abe636e632a97817ef114$var$utf8EncodeTEencode(str, output, outputOffset) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  output.set($e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder.encode(str), outputOffset);
}

function $e01c297a9e7abe636e632a97817ef114$var$utf8EncodeTEencodeInto(str, output, outputOffset) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  $e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}

var $e01c297a9e7abe636e632a97817ef114$export$utf8EncodeTE = ($e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder === null || $e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder === void 0 ? void 0 : $e01c297a9e7abe636e632a97817ef114$var$sharedTextEncoder.encodeInto) ? $e01c297a9e7abe636e632a97817ef114$var$utf8EncodeTEencodeInto : $e01c297a9e7abe636e632a97817ef114$var$utf8EncodeTEencode;
var $e01c297a9e7abe636e632a97817ef114$var$CHUNK_SIZE = 4096;

function $e01c297a9e7abe636e632a97817ef114$export$utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";

  while (offset < end) {
    var byte1 = bytes[offset++];

    if ((byte1 & 0x80) === 0) {
      // 1 byte
      units.push(byte1);
    } else if ((byte1 & 0xe0) === 0xc0) {
      // 2 bytes
      var byte2 = bytes[offset++] & 0x3f;
      units.push((byte1 & 0x1f) << 6 | byte2);
    } else if ((byte1 & 0xf0) === 0xe0) {
      // 3 bytes
      var byte2 = bytes[offset++] & 0x3f;
      var byte3 = bytes[offset++] & 0x3f;
      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 0xf8) === 0xf0) {
      // 4 bytes
      var byte2 = bytes[offset++] & 0x3f;
      var byte3 = bytes[offset++] & 0x3f;
      var byte4 = bytes[offset++] & 0x3f;
      var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;

      if (unit > 0xffff) {
        unit -= 0x10000;
        units.push(unit >>> 10 & 0x3ff | 0xd800);
        unit = 0xdc00 | unit & 0x3ff;
      }

      units.push(unit);
    } else {
      units.push(byte1);
    }

    if (units.length >= $e01c297a9e7abe636e632a97817ef114$var$CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }

  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }

  return result;
}

var $e01c297a9e7abe636e632a97817ef114$var$sharedTextDecoder = $e01c297a9e7abe636e632a97817ef114$var$TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
var $e01c297a9e7abe636e632a97817ef114$export$TEXT_DECODER_THRESHOLD = !$e01c297a9e7abe636e632a97817ef114$var$TEXT_ENCODING_AVAILABLE ? $e01c297a9e7abe636e632a97817ef114$var$STR_SIZE_MAX : typeof $e01c297a9e7abe636e632a97817ef114$var$process !== "undefined" && undefined !== "force" ? 200 : 0;

function $e01c297a9e7abe636e632a97817ef114$export$utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return $e01c297a9e7abe636e632a97817ef114$var$sharedTextDecoder.decode(stringBytes);
}

/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */
var $9a34029004b0a14a63aed83a8b464c61$export$ExtData =
/** @class */
function () {
  function ExtData(type, data) {
    this.type = type;
    this.data = data;
  }

  return ExtData;
}();

// DataView extension to handle int64 / uint64,
// where the actual range is 53-bits integer (a.k.a. safe integer)
function $4bab5f83444a6ec28f7820e6ff37453c$export$setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value; // high bits are truncated by DataView

  // high bits are truncated by DataView
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}

function $4bab5f83444a6ec28f7820e6ff37453c$export$setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value; // high bits are truncated by DataView

  // high bits are truncated by DataView
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}

function $4bab5f83444a6ec28f7820e6ff37453c$export$getInt64(view, offset) {
  var high = view.getInt32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}

function $4bab5f83444a6ec28f7820e6ff37453c$export$getUint64(view, offset) {
  var high = view.getUint32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}

var $2d1e72b7d201289f68b8e45371966944$export$EXT_TIMESTAMP = -1;
var $2d1e72b7d201289f68b8e45371966944$var$TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int

// 32-bit unsigned int
var $2d1e72b7d201289f68b8e45371966944$var$TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int

// 34-bit unsigned int
function $2d1e72b7d201289f68b8e45371966944$export$encodeTimeSpecToTimestamp(_a) {
  var sec = _a.sec,
      nsec = _a.nsec;

  if (sec >= 0 && nsec >= 0 && sec <= $2d1e72b7d201289f68b8e45371966944$var$TIMESTAMP64_MAX_SEC) {
    // Here sec >= 0 && nsec >= 0
    if (nsec === 0 && sec <= $2d1e72b7d201289f68b8e45371966944$var$TIMESTAMP32_MAX_SEC) {
      // timestamp 32 = { sec32 (unsigned) }
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
      var secHigh = sec / 0x100000000;
      var secLow = sec & 0xffffffff;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer); // nsec30 | secHigh2

      // nsec30 | secHigh2
      view.setUint32(0, nsec << 2 | secHigh & 0x3); // secLow32

      // secLow32
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    $4bab5f83444a6ec28f7820e6ff37453c$export$setInt64(view, 4, sec);
    return rv;
  }
}

function $2d1e72b7d201289f68b8e45371966944$export$encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6; // Normalizes { sec, nsec } to ensure nsec is unsigned.

  // Normalizes { sec, nsec } to ensure nsec is unsigned.
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}

function $2d1e72b7d201289f68b8e45371966944$export$encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = $2d1e72b7d201289f68b8e45371966944$export$encodeDateToTimeSpec(object);
    return $2d1e72b7d201289f68b8e45371966944$export$encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}

function $2d1e72b7d201289f68b8e45371966944$export$decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength); // data may be 32, 64, or 96 bits

  // data may be 32, 64, or 96 bits
  switch (data.byteLength) {
    case 4:
      {
        // timestamp 32 = { sec32 }
        var sec = view.getUint32(0);
        var nsec = 0;
        return {
          sec: sec,
          nsec: nsec
        };
      }

    case 8:
      {
        // timestamp 64 = { nsec30, sec34 }
        var nsec30AndSecHigh2 = view.getUint32(0);
        var secLow32 = view.getUint32(4);
        var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
        var nsec = nsec30AndSecHigh2 >>> 2;
        return {
          sec: sec,
          nsec: nsec
        };
      }

    case 12:
      {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        var sec = $4bab5f83444a6ec28f7820e6ff37453c$export$getInt64(view, 4);
        var nsec = view.getUint32(0);
        return {
          sec: sec,
          nsec: nsec
        };
      }

    default:
      throw new Error("Unrecognized data size for timestamp: " + data.length);
  }
}

function $2d1e72b7d201289f68b8e45371966944$export$decodeTimestampExtension(data) {
  var timeSpec = $2d1e72b7d201289f68b8e45371966944$export$decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}

var $2d1e72b7d201289f68b8e45371966944$export$timestampExtension = {
  type: $2d1e72b7d201289f68b8e45371966944$export$EXT_TIMESTAMP,
  encode: $2d1e72b7d201289f68b8e45371966944$export$encodeTimestampExtension,
  decode: $2d1e72b7d201289f68b8e45371966944$export$decodeTimestampExtension
};

var $aa17591d8af49a0e38eb8b042333e882$export$ExtensionCodec =
/** @class */
function () {
  function ExtensionCodec() {
    // built-in extensions
    this.builtInEncoders = [];
    this.builtInDecoders = []; // custom extensions

    // custom extensions
    this.encoders = [];
    this.decoders = [];
    this.register($2d1e72b7d201289f68b8e45371966944$export$timestampExtension);
  }

  ExtensionCodec.prototype.register = function (_a) {
    var type = _a.type,
        encode = _a.encode,
        decode = _a.decode;

    if (type >= 0) {
      // custom extensions
      this.encoders[type] = encode;
      this.decoders[type] = decode;
    } else {
      // built-in extensions
      var index = 1 + type;
      this.builtInEncoders[index] = encode;
      this.builtInDecoders[index] = decode;
    }
  };

  ExtensionCodec.prototype.tryToEncode = function (object, context) {
    // built-in extensions
    for (var i = 0; i < this.builtInEncoders.length; i++) {
      var encoder = this.builtInEncoders[i];

      if (encoder != null) {
        var data = encoder(object, context);

        if (data != null) {
          var type = -1 - i;
          return new $9a34029004b0a14a63aed83a8b464c61$export$ExtData(type, data);
        }
      }
    } // custom extensions


    // custom extensions
    for (var i = 0; i < this.encoders.length; i++) {
      var encoder = this.encoders[i];

      if (encoder != null) {
        var data = encoder(object, context);

        if (data != null) {
          var type = i;
          return new $9a34029004b0a14a63aed83a8b464c61$export$ExtData(type, data);
        }
      }
    }

    if (object instanceof $9a34029004b0a14a63aed83a8b464c61$export$ExtData) {
      // to keep ExtData as is
      return object;
    }

    return null;
  };

  ExtensionCodec.prototype.decode = function (data, type, context) {
    var decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];

    if (decoder) {
      return decoder(data, type, context);
    } else {
      // decode() does not fail, returns ExtData instead.
      return new $9a34029004b0a14a63aed83a8b464c61$export$ExtData(type, data);
    }
  };

  ExtensionCodec.defaultCodec = new ExtensionCodec();
  return ExtensionCodec;
}();

function $27475139092d232d2c653796041d9d66$export$ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    // ArrayLike<number>
    return Uint8Array.from(buffer);
  }
}

function $27475139092d232d2c653796041d9d66$export$createDataView(buffer) {
  if (buffer instanceof ArrayBuffer) {
    return new DataView(buffer);
  }

  var bufferView = $27475139092d232d2c653796041d9d66$export$ensureUint8Array(buffer);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}

var $c867fb08cd590dedba33d5f9441a10aa$export$DEFAULT_MAX_DEPTH = 100;
var $c867fb08cd590dedba33d5f9441a10aa$export$DEFAULT_INITIAL_BUFFER_SIZE = 2048;

var $c867fb08cd590dedba33d5f9441a10aa$export$Encoder =
/** @class */
function () {
  function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
    if (extensionCodec === void 0) {
      extensionCodec = $aa17591d8af49a0e38eb8b042333e882$export$ExtensionCodec.defaultCodec;
    }

    if (context === void 0) {
      context = undefined;
    }

    if (maxDepth === void 0) {
      maxDepth = $c867fb08cd590dedba33d5f9441a10aa$export$DEFAULT_MAX_DEPTH;
    }

    if (initialBufferSize === void 0) {
      initialBufferSize = $c867fb08cd590dedba33d5f9441a10aa$export$DEFAULT_INITIAL_BUFFER_SIZE;
    }

    if (sortKeys === void 0) {
      sortKeys = false;
    }

    if (forceFloat32 === void 0) {
      forceFloat32 = false;
    }

    if (ignoreUndefined === void 0) {
      ignoreUndefined = false;
    }

    if (forceIntegerToFloat === void 0) {
      forceIntegerToFloat = false;
    }

    this.extensionCodec = extensionCodec;
    this.context = context;
    this.maxDepth = maxDepth;
    this.initialBufferSize = initialBufferSize;
    this.sortKeys = sortKeys;
    this.forceFloat32 = forceFloat32;
    this.ignoreUndefined = ignoreUndefined;
    this.forceIntegerToFloat = forceIntegerToFloat;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }

  Encoder.prototype.getUint8Array = function () {
    return this.bytes.subarray(0, this.pos);
  };

  Encoder.prototype.reinitializeState = function () {
    this.pos = 0;
  };

  Encoder.prototype.encode = function (object) {
    this.reinitializeState();
    this.doEncode(object, 1);
    return this.getUint8Array();
  };

  Encoder.prototype.doEncode = function (object, depth) {
    if (depth > this.maxDepth) {
      throw new Error("Too deep objects in depth " + depth);
    }

    if (object == null) {
      this.encodeNil();
    } else if (typeof object === "boolean") {
      this.encodeBoolean(object);
    } else if (typeof object === "number") {
      this.encodeNumber(object);
    } else if (typeof object === "string") {
      this.encodeString(object);
    } else {
      this.encodeObject(object, depth);
    }
  };

  Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {
    var requiredSize = this.pos + sizeToWrite;

    if (this.view.byteLength < requiredSize) {
      this.resizeBuffer(requiredSize * 2);
    }
  };

  Encoder.prototype.resizeBuffer = function (newSize) {
    var newBuffer = new ArrayBuffer(newSize);
    var newBytes = new Uint8Array(newBuffer);
    var newView = new DataView(newBuffer);
    newBytes.set(this.bytes);
    this.view = newView;
    this.bytes = newBytes;
  };

  Encoder.prototype.encodeNil = function () {
    this.writeU8(0xc0);
  };

  Encoder.prototype.encodeBoolean = function (object) {
    if (object === false) {
      this.writeU8(0xc2);
    } else {
      this.writeU8(0xc3);
    }
  };

  Encoder.prototype.encodeNumber = function (object) {
    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
      if (object >= 0) {
        if (object < 0x80) {
          // positive fixint
          this.writeU8(object);
        } else if (object < 0x100) {
          // uint 8
          this.writeU8(0xcc);
          this.writeU8(object);
        } else if (object < 0x10000) {
          // uint 16
          this.writeU8(0xcd);
          this.writeU16(object);
        } else if (object < 0x100000000) {
          // uint 32
          this.writeU8(0xce);
          this.writeU32(object);
        } else {
          // uint 64
          this.writeU8(0xcf);
          this.writeU64(object);
        }
      } else {
        if (object >= -0x20) {
          // nagative fixint
          this.writeU8(0xe0 | object + 0x20);
        } else if (object >= -0x80) {
          // int 8
          this.writeU8(0xd0);
          this.writeI8(object);
        } else if (object >= -0x8000) {
          // int 16
          this.writeU8(0xd1);
          this.writeI16(object);
        } else if (object >= -0x80000000) {
          // int 32
          this.writeU8(0xd2);
          this.writeI32(object);
        } else {
          // int 64
          this.writeU8(0xd3);
          this.writeI64(object);
        }
      }
    } else {
      // non-integer numbers
      if (this.forceFloat32) {
        // float 32
        this.writeU8(0xca);
        this.writeF32(object);
      } else {
        // float 64
        this.writeU8(0xcb);
        this.writeF64(object);
      }
    }
  };

  Encoder.prototype.writeStringHeader = function (byteLength) {
    if (byteLength < 32) {
      // fixstr
      this.writeU8(0xa0 + byteLength);
    } else if (byteLength < 0x100) {
      // str 8
      this.writeU8(0xd9);
      this.writeU8(byteLength);
    } else if (byteLength < 0x10000) {
      // str 16
      this.writeU8(0xda);
      this.writeU16(byteLength);
    } else if (byteLength < 0x100000000) {
      // str 32
      this.writeU8(0xdb);
      this.writeU32(byteLength);
    } else {
      throw new Error("Too long string: " + byteLength + " bytes in UTF-8");
    }
  };

  Encoder.prototype.encodeString = function (object) {
    var maxHeaderSize = 1 + 4;
    var strLength = object.length;

    if (strLength > $e01c297a9e7abe636e632a97817ef114$export$TEXT_ENCODER_THRESHOLD) {
      var byteLength = $e01c297a9e7abe636e632a97817ef114$export$utf8Count(object);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      $e01c297a9e7abe636e632a97817ef114$export$utf8EncodeTE(object, this.bytes, this.pos);
      this.pos += byteLength;
    } else {
      var byteLength = $e01c297a9e7abe636e632a97817ef114$export$utf8Count(object);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      $e01c297a9e7abe636e632a97817ef114$export$utf8EncodeJs(object, this.bytes, this.pos);
      this.pos += byteLength;
    }
  };

  Encoder.prototype.encodeObject = function (object, depth) {
    // try to encode objects with custom codec first of non-primitives
    var ext = this.extensionCodec.tryToEncode(object, this.context);

    if (ext != null) {
      this.encodeExtension(ext);
    } else if (Array.isArray(object)) {
      this.encodeArray(object, depth);
    } else if (ArrayBuffer.isView(object)) {
      this.encodeBinary(object);
    } else if (typeof object === "object") {
      this.encodeMap(object, depth);
    } else {
      // symbol, function and other special object come here unless extensionCodec handles them.
      throw new Error("Unrecognized object: " + Object.prototype.toString.apply(object));
    }
  };

  Encoder.prototype.encodeBinary = function (object) {
    var size = object.byteLength;

    if (size < 0x100) {
      // bin 8
      this.writeU8(0xc4);
      this.writeU8(size);
    } else if (size < 0x10000) {
      // bin 16
      this.writeU8(0xc5);
      this.writeU16(size);
    } else if (size < 0x100000000) {
      // bin 32
      this.writeU8(0xc6);
      this.writeU32(size);
    } else {
      throw new Error("Too large binary: " + size);
    }

    var bytes = $27475139092d232d2c653796041d9d66$export$ensureUint8Array(object);
    this.writeU8a(bytes);
  };

  Encoder.prototype.encodeArray = function (object, depth) {
    var size = object.length;

    if (size < 16) {
      // fixarray
      this.writeU8(0x90 + size);
    } else if (size < 0x10000) {
      // array 16
      this.writeU8(0xdc);
      this.writeU16(size);
    } else if (size < 0x100000000) {
      // array 32
      this.writeU8(0xdd);
      this.writeU32(size);
    } else {
      throw new Error("Too large array: " + size);
    }

    for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
      var item = object_1[_i];
      this.doEncode(item, depth + 1);
    }
  };

  Encoder.prototype.countWithoutUndefined = function (object, keys) {
    var count = 0;

    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];

      if (object[key] !== undefined) {
        count++;
      }
    }

    return count;
  };

  Encoder.prototype.encodeMap = function (object, depth) {
    var keys = Object.keys(object);

    if (this.sortKeys) {
      keys.sort();
    }

    var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;

    if (size < 16) {
      // fixmap
      this.writeU8(0x80 + size);
    } else if (size < 0x10000) {
      // map 16
      this.writeU8(0xde);
      this.writeU16(size);
    } else if (size < 0x100000000) {
      // map 32
      this.writeU8(0xdf);
      this.writeU32(size);
    } else {
      throw new Error("Too large map object: " + size);
    }

    for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
      var key = keys_2[_i];
      var value = object[key];

      if (!(this.ignoreUndefined && value === undefined)) {
        this.encodeString(key);
        this.doEncode(value, depth + 1);
      }
    }
  };

  Encoder.prototype.encodeExtension = function (ext) {
    var size = ext.data.length;

    if (size === 1) {
      // fixext 1
      this.writeU8(0xd4);
    } else if (size === 2) {
      // fixext 2
      this.writeU8(0xd5);
    } else if (size === 4) {
      // fixext 4
      this.writeU8(0xd6);
    } else if (size === 8) {
      // fixext 8
      this.writeU8(0xd7);
    } else if (size === 16) {
      // fixext 16
      this.writeU8(0xd8);
    } else if (size < 0x100) {
      // ext 8
      this.writeU8(0xc7);
      this.writeU8(size);
    } else if (size < 0x10000) {
      // ext 16
      this.writeU8(0xc8);
      this.writeU16(size);
    } else if (size < 0x100000000) {
      // ext 32
      this.writeU8(0xc9);
      this.writeU32(size);
    } else {
      throw new Error("Too large extension object: " + size);
    }

    this.writeI8(ext.type);
    this.writeU8a(ext.data);
  };

  Encoder.prototype.writeU8 = function (value) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, value);
    this.pos++;
  };

  Encoder.prototype.writeU8a = function (values) {
    var size = values.length;
    this.ensureBufferSizeToWrite(size);
    this.bytes.set(values, this.pos);
    this.pos += size;
  };

  Encoder.prototype.writeI8 = function (value) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, value);
    this.pos++;
  };

  Encoder.prototype.writeU16 = function (value) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, value);
    this.pos += 2;
  };

  Encoder.prototype.writeI16 = function (value) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, value);
    this.pos += 2;
  };

  Encoder.prototype.writeU32 = function (value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, value);
    this.pos += 4;
  };

  Encoder.prototype.writeI32 = function (value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, value);
    this.pos += 4;
  };

  Encoder.prototype.writeF32 = function (value) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, value);
    this.pos += 4;
  };

  Encoder.prototype.writeF64 = function (value) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, value);
    this.pos += 8;
  };

  Encoder.prototype.writeU64 = function (value) {
    this.ensureBufferSizeToWrite(8);
    $4bab5f83444a6ec28f7820e6ff37453c$export$setUint64(this.view, this.pos, value);
    this.pos += 8;
  };

  Encoder.prototype.writeI64 = function (value) {
    this.ensureBufferSizeToWrite(8);
    $4bab5f83444a6ec28f7820e6ff37453c$export$setInt64(this.view, this.pos, value);
    this.pos += 8;
  };

  return Encoder;
}();

var $10bb79daa998575678b5334c3adf6fa5$var$defaultEncodeOptions = {};
/**
 * It encodes `value` in the MessagePack format and
 * returns a byte buffer.
 *
 * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.
 */

/**
 * It encodes `value` in the MessagePack format and
 * returns a byte buffer.
 *
 * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.
 */
function $10bb79daa998575678b5334c3adf6fa5$export$encode(value, options) {
  if (options === void 0) {
    options = $10bb79daa998575678b5334c3adf6fa5$var$defaultEncodeOptions;
  }

  var encoder = new $c867fb08cd590dedba33d5f9441a10aa$export$Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
  return encoder.encode(value);
}

function $fb74aab91ab5efff8d340b5f4378ded9$export$prettyByte(byte) {
  return (byte < 0 ? "-" : "") + "0x" + Math.abs(byte).toString(16).padStart(2, "0");
}

var $d4f62b0833b2d8c2ae8323635e2b9a88$var$DEFAULT_MAX_KEY_LENGTH = 16;
var $d4f62b0833b2d8c2ae8323635e2b9a88$var$DEFAULT_MAX_LENGTH_PER_KEY = 16;

var $d4f62b0833b2d8c2ae8323635e2b9a88$export$CachedKeyDecoder =
/** @class */
function () {
  function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {
    if (maxKeyLength === void 0) {
      maxKeyLength = $d4f62b0833b2d8c2ae8323635e2b9a88$var$DEFAULT_MAX_KEY_LENGTH;
    }

    if (maxLengthPerKey === void 0) {
      maxLengthPerKey = $d4f62b0833b2d8c2ae8323635e2b9a88$var$DEFAULT_MAX_LENGTH_PER_KEY;
    }

    this.maxKeyLength = maxKeyLength;
    this.maxLengthPerKey = maxLengthPerKey;
    this.hit = 0;
    this.miss = 0; // avoid `new Array(N)` to create a non-sparse array for performance.

    // avoid `new Array(N)` to create a non-sparse array for performance.
    this.caches = [];

    for (var i = 0; i < this.maxKeyLength; i++) {
      this.caches.push([]);
    }
  }

  CachedKeyDecoder.prototype.canBeCached = function (byteLength) {
    return byteLength > 0 && byteLength <= this.maxKeyLength;
  };

  CachedKeyDecoder.prototype.get = function (bytes, inputOffset, byteLength) {
    var records = this.caches[byteLength - 1];
    var recordsLength = records.length;

    FIND_CHUNK: for (var i = 0; i < recordsLength; i++) {
      var record = records[i];
      var recordBytes = record.bytes;

      for (var j = 0; j < byteLength; j++) {
        if (recordBytes[j] !== bytes[inputOffset + j]) {
          continue FIND_CHUNK;
        }
      }

      return record.value;
    }

    return null;
  };

  CachedKeyDecoder.prototype.store = function (bytes, value) {
    var records = this.caches[bytes.length - 1];
    var record = {
      bytes: bytes,
      value: value
    };

    if (records.length >= this.maxLengthPerKey) {
      // `records` are full!
      // Set `record` to a randomized position.
      records[Math.random() * records.length | 0] = record;
    } else {
      records.push(record);
    }
  };

  CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {
    var cachedValue = this.get(bytes, inputOffset, byteLength);

    if (cachedValue != null) {
      this.hit++;
      return cachedValue;
    }

    this.miss++;
    var value = $e01c297a9e7abe636e632a97817ef114$export$utf8DecodeJs(bytes, inputOffset, byteLength); // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.

    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
    var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
    this.store(slicedCopyOfBytes, value);
    return value;
  };

  return CachedKeyDecoder;
}();

var $840b8fbcd277371e7795bbe8ae4d151d$var$__awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$__generator = undefined && undefined.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$__asyncValues = undefined && undefined.__asyncValues || function (o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$__await = undefined && undefined.__await || function (v) {
  return this instanceof $840b8fbcd277371e7795bbe8ae4d151d$var$__await ? (this.v = v, this) : new $840b8fbcd277371e7795bbe8ae4d151d$var$__await(v);
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$__asyncGenerator = undefined && undefined.__asyncGenerator || function (thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof $840b8fbcd277371e7795bbe8ae4d151d$var$__await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$isValidMapKeyType = function (key) {
  var keyType = typeof key;
  return keyType === "string" || keyType === "number";
};

var $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED = -1;
var $840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var $840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_BYTES = new Uint8Array($840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_VIEW.buffer); // IE11: Hack to support IE11.
// IE11: Drop this hack and just use RangeError when IE11 is obsolete.

// IE11: Hack to support IE11.
// IE11: Drop this hack and just use RangeError when IE11 is obsolete.
var $840b8fbcd277371e7795bbe8ae4d151d$export$DataViewIndexOutOfBoundsError = function () {
  try {
    // IE11: The spec says it should throw RangeError,
    // IE11: but in IE11 it throws TypeError.
    $840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_VIEW.getInt8(0);
  } catch (e) {
    return e.constructor;
  }

  throw new Error("never reached");
}();

var $840b8fbcd277371e7795bbe8ae4d151d$var$MORE_DATA = new $840b8fbcd277371e7795bbe8ae4d151d$export$DataViewIndexOutOfBoundsError("Insufficient data");
var $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH = 4294967295; // uint32_max

// uint32_max
var $840b8fbcd277371e7795bbe8ae4d151d$var$sharedCachedKeyDecoder = new $d4f62b0833b2d8c2ae8323635e2b9a88$export$CachedKeyDecoder();

var $840b8fbcd277371e7795bbe8ae4d151d$export$Decoder =
/** @class */
function () {
  function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {
    if (extensionCodec === void 0) {
      extensionCodec = $aa17591d8af49a0e38eb8b042333e882$export$ExtensionCodec.defaultCodec;
    }

    if (context === void 0) {
      context = undefined;
    }

    if (maxStrLength === void 0) {
      maxStrLength = $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH;
    }

    if (maxBinLength === void 0) {
      maxBinLength = $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH;
    }

    if (maxArrayLength === void 0) {
      maxArrayLength = $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH;
    }

    if (maxMapLength === void 0) {
      maxMapLength = $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH;
    }

    if (maxExtLength === void 0) {
      maxExtLength = $840b8fbcd277371e7795bbe8ae4d151d$var$DEFAULT_MAX_LENGTH;
    }

    if (keyDecoder === void 0) {
      keyDecoder = $840b8fbcd277371e7795bbe8ae4d151d$var$sharedCachedKeyDecoder;
    }

    this.extensionCodec = extensionCodec;
    this.context = context;
    this.maxStrLength = maxStrLength;
    this.maxBinLength = maxBinLength;
    this.maxArrayLength = maxArrayLength;
    this.maxMapLength = maxMapLength;
    this.maxExtLength = maxExtLength;
    this.keyDecoder = keyDecoder;
    this.totalPos = 0;
    this.pos = 0;
    this.view = $840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_VIEW;
    this.bytes = $840b8fbcd277371e7795bbe8ae4d151d$var$EMPTY_BYTES;
    this.headByte = $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED;
    this.stack = [];
  }

  Decoder.prototype.reinitializeState = function () {
    this.totalPos = 0;
    this.headByte = $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED;
  };

  Decoder.prototype.setBuffer = function (buffer) {
    this.bytes = $27475139092d232d2c653796041d9d66$export$ensureUint8Array(buffer);
    this.view = $27475139092d232d2c653796041d9d66$export$createDataView(this.bytes);
    this.pos = 0;
  };

  Decoder.prototype.appendBuffer = function (buffer) {
    if (this.headByte === $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED && !this.hasRemaining()) {
      this.setBuffer(buffer);
    } else {
      // retried because data is insufficient
      var remainingData = this.bytes.subarray(this.pos);
      var newData = $27475139092d232d2c653796041d9d66$export$ensureUint8Array(buffer);
      var concated = new Uint8Array(remainingData.length + newData.length);
      concated.set(remainingData);
      concated.set(newData, remainingData.length);
      this.setBuffer(concated);
    }
  };

  Decoder.prototype.hasRemaining = function (size) {
    if (size === void 0) {
      size = 1;
    }

    return this.view.byteLength - this.pos >= size;
  };

  Decoder.prototype.createExtraByteError = function (posToShow) {
    var _a = this,
        view = _a.view,
        pos = _a.pos;

    return new RangeError("Extra " + (view.byteLength - pos) + " of " + view.byteLength + " byte(s) found at buffer[" + posToShow + "]");
  };

  Decoder.prototype.decode = function (buffer) {
    this.reinitializeState();
    this.setBuffer(buffer);
    var object = this.doDecodeSync();

    if (this.hasRemaining()) {
      throw this.createExtraByteError(this.pos);
    }

    return object;
  };

  Decoder.prototype.decodeAsync = function (stream) {
    var stream_1, stream_1_1;

    var e_1, _a;

    return $840b8fbcd277371e7795bbe8ae4d151d$var$__awaiter(this, void 0, void 0, function () {
      var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;

      return $840b8fbcd277371e7795bbe8ae4d151d$var$__generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            decoded = false;
            _c.label = 1;

          case 1:
            _c.trys.push([1, 6, 7, 12]);

            stream_1 = $840b8fbcd277371e7795bbe8ae4d151d$var$__asyncValues(stream);
            _c.label = 2;

          case 2:
            return [4
            /*yield*/
            ,
            /*yield*/
            stream_1.next()];

          case 3:
            if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3
            /*break*/
            ,
            /*break*/
            5];
            buffer = stream_1_1.value;

            if (decoded) {
              throw this.createExtraByteError(this.totalPos);
            }

            this.appendBuffer(buffer);

            try {
              object = this.doDecodeSync();
              decoded = true;
            } catch (e) {
              if (!(e instanceof $840b8fbcd277371e7795bbe8ae4d151d$export$DataViewIndexOutOfBoundsError)) {
                throw e; // rethrow
              } // fallthrough

            }

            this.totalPos += this.pos;
            _c.label = 4;

          case 4:
            return [3
            /*break*/
            ,
            /*break*/
            2];

          case 5:
            return [3
            /*break*/
            ,
            /*break*/
            12];

          case 6:
            e_1_1 = _c.sent();
            e_1 = {
              error: e_1_1
            };
            return [3
            /*break*/
            ,
            /*break*/
            12];

          case 7:
            _c.trys.push([7,, 10, 11]);

            if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3
            /*break*/
            ,
            /*break*/
            9];
            return [4
            /*yield*/
            ,
            /*yield*/
            _a.call(stream_1)];

          case 8:
            _c.sent();

            _c.label = 9;

          case 9:
            return [3
            /*break*/
            ,
            /*break*/
            11];

          case 10:
            if (e_1) throw e_1.error;
            return [7
            /*endfinally*/
            ];

          case 11:
            return [7
            /*endfinally*/
            ];

          case 12:
            if (decoded) {
              if (this.hasRemaining()) {
                throw this.createExtraByteError(this.totalPos);
              }

              return [2
              /*return*/
              ,
              /*return*/
              object];
            }

            _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;
            throw new RangeError("Insufficient data in parsing " + $fb74aab91ab5efff8d340b5f4378ded9$export$prettyByte(headByte) + " at " + totalPos + " (" + pos + " in the current buffer)");
        }
      });
    });
  };

  Decoder.prototype.decodeArrayStream = function (stream) {
    return this.decodeMultiAsync(stream, true);
  };

  Decoder.prototype.decodeStream = function (stream) {
    return this.decodeMultiAsync(stream, false);
  };

  Decoder.prototype.decodeMultiAsync = function (stream, isArray) {
    return $840b8fbcd277371e7795bbe8ae4d151d$var$__asyncGenerator(this, arguments, function decodeMultiAsync_1() {
      var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;

      var e_3, _a;

      return $840b8fbcd277371e7795bbe8ae4d151d$var$__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            isArrayHeaderRequired = isArray;
            arrayItemsLeft = -1;
            _b.label = 1;

          case 1:
            _b.trys.push([1, 13, 14, 19]);

            stream_2 = $840b8fbcd277371e7795bbe8ae4d151d$var$__asyncValues(stream);
            _b.label = 2;

          case 2:
            return [4
            /*yield*/
            ,
            /*yield*/
            $840b8fbcd277371e7795bbe8ae4d151d$var$__await(stream_2.next())];

          case 3:
            if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3
            /*break*/
            ,
            /*break*/
            12];
            buffer = stream_2_1.value;

            if (isArray && arrayItemsLeft === 0) {
              throw this.createExtraByteError(this.totalPos);
            }

            this.appendBuffer(buffer);

            if (isArrayHeaderRequired) {
              arrayItemsLeft = this.readArraySize();
              isArrayHeaderRequired = false;
              this.complete();
            }

            _b.label = 4;

          case 4:
            _b.trys.push([4, 9,, 10]);

            _b.label = 5;

          case 5:
            if (!true) return [3
            /*break*/
            ,
            /*break*/
            8];
            return [4
            /*yield*/
            ,
            /*yield*/
            $840b8fbcd277371e7795bbe8ae4d151d$var$__await(this.doDecodeSync())];

          case 6:
            return [4
            /*yield*/
            ,
            /*yield*/
            _b.sent()];

          case 7:
            _b.sent();

            if (--arrayItemsLeft === 0) {
              return [3
              /*break*/
              ,
              /*break*/
              8];
            }

            return [3
            /*break*/
            ,
            /*break*/
            5];

          case 8:
            return [3
            /*break*/
            ,
            /*break*/
            10];

          case 9:
            e_2 = _b.sent();

            if (!(e_2 instanceof $840b8fbcd277371e7795bbe8ae4d151d$export$DataViewIndexOutOfBoundsError)) {
              throw e_2; // rethrow
            }

            // rethrow
            return [3
            /*break*/
            ,
            /*break*/
            10];

          case 10:
            this.totalPos += this.pos;
            _b.label = 11;

          case 11:
            return [3
            /*break*/
            ,
            /*break*/
            2];

          case 12:
            return [3
            /*break*/
            ,
            /*break*/
            19];

          case 13:
            e_3_1 = _b.sent();
            e_3 = {
              error: e_3_1
            };
            return [3
            /*break*/
            ,
            /*break*/
            19];

          case 14:
            _b.trys.push([14,, 17, 18]);

            if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3
            /*break*/
            ,
            /*break*/
            16];
            return [4
            /*yield*/
            ,
            /*yield*/
            $840b8fbcd277371e7795bbe8ae4d151d$var$__await(_a.call(stream_2))];

          case 15:
            _b.sent();

            _b.label = 16;

          case 16:
            return [3
            /*break*/
            ,
            /*break*/
            18];

          case 17:
            if (e_3) throw e_3.error;
            return [7
            /*endfinally*/
            ];

          case 18:
            return [7
            /*endfinally*/
            ];

          case 19:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  Decoder.prototype.doDecodeSync = function () {
    DECODE: while (true) {
      var headByte = this.readHeadByte();
      var object = void 0;

      if (headByte >= 0xe0) {
        // negative fixint (111x xxxx) 0xe0 - 0xff
        object = headByte - 0x100;
      } else if (headByte < 0xc0) {
        if (headByte < 0x80) {
          // positive fixint (0xxx xxxx) 0x00 - 0x7f
          object = headByte;
        } else if (headByte < 0x90) {
          // fixmap (1000 xxxx) 0x80 - 0x8f
          var size = headByte - 0x80;

          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte < 0xa0) {
          // fixarray (1001 xxxx) 0x90 - 0x9f
          var size = headByte - 0x90;

          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else {
          // fixstr (101x xxxx) 0xa0 - 0xbf
          var byteLength = headByte - 0xa0;
          object = this.decodeUtf8String(byteLength, 0);
        }
      } else if (headByte === 0xc0) {
        // nil
        object = null;
      } else if (headByte === 0xc2) {
        // false
        object = false;
      } else if (headByte === 0xc3) {
        // true
        object = true;
      } else if (headByte === 0xca) {
        // float 32
        object = this.readF32();
      } else if (headByte === 0xcb) {
        // float 64
        object = this.readF64();
      } else if (headByte === 0xcc) {
        // uint 8
        object = this.readU8();
      } else if (headByte === 0xcd) {
        // uint 16
        object = this.readU16();
      } else if (headByte === 0xce) {
        // uint 32
        object = this.readU32();
      } else if (headByte === 0xcf) {
        // uint 64
        object = this.readU64();
      } else if (headByte === 0xd0) {
        // int 8
        object = this.readI8();
      } else if (headByte === 0xd1) {
        // int 16
        object = this.readI16();
      } else if (headByte === 0xd2) {
        // int 32
        object = this.readI32();
      } else if (headByte === 0xd3) {
        // int 64
        object = this.readI64();
      } else if (headByte === 0xd9) {
        // str 8
        var byteLength = this.lookU8();
        object = this.decodeUtf8String(byteLength, 1);
      } else if (headByte === 0xda) {
        // str 16
        var byteLength = this.lookU16();
        object = this.decodeUtf8String(byteLength, 2);
      } else if (headByte === 0xdb) {
        // str 32
        var byteLength = this.lookU32();
        object = this.decodeUtf8String(byteLength, 4);
      } else if (headByte === 0xdc) {
        // array 16
        var size = this.readU16();

        if (size !== 0) {
          this.pushArrayState(size);
          this.complete();
          continue DECODE;
        } else {
          object = [];
        }
      } else if (headByte === 0xdd) {
        // array 32
        var size = this.readU32();

        if (size !== 0) {
          this.pushArrayState(size);
          this.complete();
          continue DECODE;
        } else {
          object = [];
        }
      } else if (headByte === 0xde) {
        // map 16
        var size = this.readU16();

        if (size !== 0) {
          this.pushMapState(size);
          this.complete();
          continue DECODE;
        } else {
          object = {};
        }
      } else if (headByte === 0xdf) {
        // map 32
        var size = this.readU32();

        if (size !== 0) {
          this.pushMapState(size);
          this.complete();
          continue DECODE;
        } else {
          object = {};
        }
      } else if (headByte === 0xc4) {
        // bin 8
        var size = this.lookU8();
        object = this.decodeBinary(size, 1);
      } else if (headByte === 0xc5) {
        // bin 16
        var size = this.lookU16();
        object = this.decodeBinary(size, 2);
      } else if (headByte === 0xc6) {
        // bin 32
        var size = this.lookU32();
        object = this.decodeBinary(size, 4);
      } else if (headByte === 0xd4) {
        // fixext 1
        object = this.decodeExtension(1, 0);
      } else if (headByte === 0xd5) {
        // fixext 2
        object = this.decodeExtension(2, 0);
      } else if (headByte === 0xd6) {
        // fixext 4
        object = this.decodeExtension(4, 0);
      } else if (headByte === 0xd7) {
        // fixext 8
        object = this.decodeExtension(8, 0);
      } else if (headByte === 0xd8) {
        // fixext 16
        object = this.decodeExtension(16, 0);
      } else if (headByte === 0xc7) {
        // ext 8
        var size = this.lookU8();
        object = this.decodeExtension(size, 1);
      } else if (headByte === 0xc8) {
        // ext 16
        var size = this.lookU16();
        object = this.decodeExtension(size, 2);
      } else if (headByte === 0xc9) {
        // ext 32
        var size = this.lookU32();
        object = this.decodeExtension(size, 4);
      } else {
        throw new Error("Unrecognized type byte: " + $fb74aab91ab5efff8d340b5f4378ded9$export$prettyByte(headByte));
      }

      this.complete();
      var stack = this.stack;

      while (stack.length > 0) {
        // arrays and maps
        var state = stack[stack.length - 1];

        if (state.type === 0
        /* ARRAY */
        )
          /* ARRAY */
          {
            state.array[state.position] = object;
            state.position++;

            if (state.position === state.size) {
              stack.pop();
              object = state.array;
            } else {
              continue DECODE;
            }
          } else if (state.type === 1
        /* MAP_KEY */
        )
          /* MAP_KEY */
          {
            if (!$840b8fbcd277371e7795bbe8ae4d151d$var$isValidMapKeyType(object)) {
              throw new Error("The type of key must be string or number but " + typeof object);
            }

            state.key = object;
            state.type = 2
            /* MAP_VALUE */
            ;
            continue DECODE;
          } else {
          // it must be `state.type === State.MAP_VALUE` here
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          state.map[state.key] = object;
          state.readCount++;

          if (state.readCount === state.size) {
            stack.pop();
            object = state.map;
          } else {
            state.key = null;
            state.type = 1
            /* MAP_KEY */
            ;
            continue DECODE;
          }
        }
      }

      return object;
    }
  };

  Decoder.prototype.readHeadByte = function () {
    if (this.headByte === $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED) {
      this.headByte = this.readU8(); // console.log("headByte", prettyByte(this.headByte));
    }

    return this.headByte;
  };

  Decoder.prototype.complete = function () {
    this.headByte = $840b8fbcd277371e7795bbe8ae4d151d$var$HEAD_BYTE_REQUIRED;
  };

  Decoder.prototype.readArraySize = function () {
    var headByte = this.readHeadByte();

    switch (headByte) {
      case 0xdc:
        return this.readU16();

      case 0xdd:
        return this.readU32();

      default:
        {
          if (headByte < 0xa0) {
            return headByte - 0x90;
          } else {
            throw new Error("Unrecognized array type byte: " + $fb74aab91ab5efff8d340b5f4378ded9$export$prettyByte(headByte));
          }
        }
    }
  };

  Decoder.prototype.pushMapState = function (size) {
    if (size > this.maxMapLength) {
      throw new Error("Max length exceeded: map length (" + size + ") > maxMapLengthLength (" + this.maxMapLength + ")");
    }

    this.stack.push({
      type: 1
      /* MAP_KEY */
      ,

      /* MAP_KEY */
      size: size,
      key: null,
      readCount: 0,
      map: {}
    });
  };

  Decoder.prototype.pushArrayState = function (size) {
    if (size > this.maxArrayLength) {
      throw new Error("Max length exceeded: array length (" + size + ") > maxArrayLength (" + this.maxArrayLength + ")");
    }

    this.stack.push({
      type: 0
      /* ARRAY */
      ,

      /* ARRAY */
      size: size,
      array: new Array(size),
      position: 0
    });
  };

  Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {
    var _a;

    if (byteLength > this.maxStrLength) {
      throw new Error("Max length exceeded: UTF-8 byte length (" + byteLength + ") > maxStrLength (" + this.maxStrLength + ")");
    }

    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
      throw $840b8fbcd277371e7795bbe8ae4d151d$var$MORE_DATA;
    }

    var offset = this.pos + headerOffset;
    var object;

    if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
      object = this.keyDecoder.decode(this.bytes, offset, byteLength);
    } else if (byteLength > $e01c297a9e7abe636e632a97817ef114$export$TEXT_DECODER_THRESHOLD) {
      object = $e01c297a9e7abe636e632a97817ef114$export$utf8DecodeTD(this.bytes, offset, byteLength);
    } else {
      object = $e01c297a9e7abe636e632a97817ef114$export$utf8DecodeJs(this.bytes, offset, byteLength);
    }

    this.pos += headerOffset + byteLength;
    return object;
  };

  Decoder.prototype.stateIsMapKey = function () {
    if (this.stack.length > 0) {
      var state = this.stack[this.stack.length - 1];
      return state.type === 1
      /* MAP_KEY */
      ;
    }

    return false;
  };

  Decoder.prototype.decodeBinary = function (byteLength, headOffset) {
    if (byteLength > this.maxBinLength) {
      throw new Error("Max length exceeded: bin length (" + byteLength + ") > maxBinLength (" + this.maxBinLength + ")");
    }

    if (!this.hasRemaining(byteLength + headOffset)) {
      throw $840b8fbcd277371e7795bbe8ae4d151d$var$MORE_DATA;
    }

    var offset = this.pos + headOffset;
    var object = this.bytes.subarray(offset, offset + byteLength);
    this.pos += headOffset + byteLength;
    return object;
  };

  Decoder.prototype.decodeExtension = function (size, headOffset) {
    if (size > this.maxExtLength) {
      throw new Error("Max length exceeded: ext length (" + size + ") > maxExtLength (" + this.maxExtLength + ")");
    }

    var extType = this.view.getInt8(this.pos + headOffset);
    var data = this.decodeBinary(size, headOffset + 1
    /* extType */
    );
    return this.extensionCodec.decode(data, extType, this.context);
  };

  Decoder.prototype.lookU8 = function () {
    return this.view.getUint8(this.pos);
  };

  Decoder.prototype.lookU16 = function () {
    return this.view.getUint16(this.pos);
  };

  Decoder.prototype.lookU32 = function () {
    return this.view.getUint32(this.pos);
  };

  Decoder.prototype.readU8 = function () {
    var value = this.view.getUint8(this.pos);
    this.pos++;
    return value;
  };

  Decoder.prototype.readI8 = function () {
    var value = this.view.getInt8(this.pos);
    this.pos++;
    return value;
  };

  Decoder.prototype.readU16 = function () {
    var value = this.view.getUint16(this.pos);
    this.pos += 2;
    return value;
  };

  Decoder.prototype.readI16 = function () {
    var value = this.view.getInt16(this.pos);
    this.pos += 2;
    return value;
  };

  Decoder.prototype.readU32 = function () {
    var value = this.view.getUint32(this.pos);
    this.pos += 4;
    return value;
  };

  Decoder.prototype.readI32 = function () {
    var value = this.view.getInt32(this.pos);
    this.pos += 4;
    return value;
  };

  Decoder.prototype.readU64 = function () {
    var value = $4bab5f83444a6ec28f7820e6ff37453c$export$getUint64(this.view, this.pos);
    this.pos += 8;
    return value;
  };

  Decoder.prototype.readI64 = function () {
    var value = $4bab5f83444a6ec28f7820e6ff37453c$export$getInt64(this.view, this.pos);
    this.pos += 8;
    return value;
  };

  Decoder.prototype.readF32 = function () {
    var value = this.view.getFloat32(this.pos);
    this.pos += 4;
    return value;
  };

  Decoder.prototype.readF64 = function () {
    var value = this.view.getFloat64(this.pos);
    this.pos += 8;
    return value;
  };

  return Decoder;
}();

var $437758109c82b68623cb7bbc30bfd4d4$export$defaultDecodeOptions = {};
/**
 * It decodes a MessagePack-encoded buffer.
 *
 * This is a synchronous decoding function. See other variants for asynchronous decoding: `decodeAsync()`, `decodeStream()`, `decodeArrayStream()`.
 */

/**
 * It decodes a MessagePack-encoded buffer.
 *
 * This is a synchronous decoding function. See other variants for asynchronous decoding: `decodeAsync()`, `decodeStream()`, `decodeArrayStream()`.
 */
function $437758109c82b68623cb7bbc30bfd4d4$export$decode(buffer, options) {
  if (options === void 0) {
    options = $437758109c82b68623cb7bbc30bfd4d4$export$defaultDecodeOptions;
  }

  var decoder = new $840b8fbcd277371e7795bbe8ae4d151d$export$Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
  return decoder.decode(buffer);
}

const {
  Buffer: $9a9e90269c602b073b1f23c4f8583eb1$var$Buffer
} = $4bb8553ea3f2a3c18bc67044f716b1cc$init();

let $9a9e90269c602b073b1f23c4f8583eb1$export$serialize = v => $9a9e90269c602b073b1f23c4f8583eb1$var$Buffer.from($10bb79daa998575678b5334c3adf6fa5$export$encode(v, {
  extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
}));

$parcel$export($9a9e90269c602b073b1f23c4f8583eb1$exports, "serialize", function () {
  return $9a9e90269c602b073b1f23c4f8583eb1$export$serialize;
});

let $9a9e90269c602b073b1f23c4f8583eb1$export$deserialize = v => $437758109c82b68623cb7bbc30bfd4d4$export$decode(v, {
  extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
}); // Derived from
// https://github.com/msgpack/msgpack-javascript#extension-types


$parcel$export($9a9e90269c602b073b1f23c4f8583eb1$exports, "deserialize", function () {
  return $9a9e90269c602b073b1f23c4f8583eb1$export$deserialize;
});
// Derived from
// https://github.com/msgpack/msgpack-javascript#extension-types
const $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec = new $aa17591d8af49a0e38eb8b042333e882$export$ExtensionCodec();
$9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec.register({
  type: 0,

  decode(value) {
    return new Set($437758109c82b68623cb7bbc30bfd4d4$export$decode(value, {
      extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
    }));
  },

  encode(value) {
    return value instanceof Set ? $10bb79daa998575678b5334c3adf6fa5$export$encode([...value], {
      extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
    }) : null;
  }

});
$9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec.register({
  type: 1,

  decode(value) {
    return new Map($437758109c82b68623cb7bbc30bfd4d4$export$decode(value, {
      extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
    }));
  },

  encode(value) {
    return value instanceof Map ? $10bb79daa998575678b5334c3adf6fa5$export$encode([...value], {
      extensionCodec: $9a9e90269c602b073b1f23c4f8583eb1$var$extensionCodec
    }) : null;
  }

});
const $5a1c67a183441e010515e193fca593e1$var$v8_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($9a9e90269c602b073b1f23c4f8583eb1$exports);
const $5a1c67a183441e010515e193fca593e1$var$zlib_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($5051c00e87739024f780cb19cb94c308$exports);
// ASSET: node_modules/@yarnpkg/core/lib/LegacyMigrationResolver.js
var $01b78508755abe2bb439b7640e54eb06$exports = {};
Object.defineProperty($01b78508755abe2bb439b7640e54eb06$exports, "__esModule", {
  value: true
});
var $01b78508755abe2bb439b7640e54eb06$export$LegacyMigrationResolver = void 0;
$01b78508755abe2bb439b7640e54eb06$exports.LegacyMigrationResolver = $01b78508755abe2bb439b7640e54eb06$export$LegacyMigrationResolver;
const $01b78508755abe2bb439b7640e54eb06$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $01b78508755abe2bb439b7640e54eb06$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
const $01b78508755abe2bb439b7640e54eb06$var$IMPORTED_PATTERNS = [// These ones come from Git urls
[/^(git(?:\+(?:https|ssh))?:\/\/.*(?:\.git)?)#(.*)$/, (version, $0, $1, $2) => `${$1}#commit=${$2}`], // These ones come from the GitHub HTTP endpoints
[/^https:\/\/((?:[^/]+?)@)?codeload\.github\.com\/([^/]+\/[^/]+)\/tar\.gz\/([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`], [/^https:\/\/((?:[^/]+?)@)?github\.com\/([^/]+\/[^/]+?)(?:\.git)?#([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`], // These ones come from the npm registry
// Note: /download/ is used by custom registries like Taobao
[/^https?:\/\/[^/]+\/(?:[^/]+\/)*(?:@[^/]+\/)?([^/]+)\/(?:-|download)\/\1-[^/]+\.tgz(?:#|$)/, version => `npm:${version}`], // The GitHub package registry uses a different style of URLs
[/^https:\/\/npm\.pkg\.github\.com\/download\/(?:@[^/]+)\/(?:[^/]+)\/(?:[^/]+)\/(?:[0-9a-f]+)$/, version => `npm:${version}`], // FontAwesome too; what is it with these registries that made them think using a different url pattern was a good idea?
[/^https:\/\/npm\.fontawesome\.com\/(?:@[^/]+)\/([^/]+)\/-\/([^/]+)\/\1-\2.tgz(?:#|$)/, version => `npm:${version}`], // These ones come from the old Yarn offline mirror - we assume they came from npm
[/^[^/]+\.tgz#[0-9a-f]+$/, version => `npm:${version}`]];

class $01b78508755abe2bb439b7640e54eb06$var$LegacyMigrationResolver {
  constructor() {
    this.resolutions = null;
  }

  async setup(project, {
    report
  }) {
    const lockfilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(project.cwd, project.configuration.get(`lockfileFilename`)); // No need to enable it if the lockfile doesn't exist

    // No need to enable it if the lockfile doesn't exist
    if (!$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(lockfilePath)) return;
    const content = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(lockfilePath, `utf8`);
    const parsed = $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(content); // No need to enable it either if the lockfile is modern

    // No need to enable it either if the lockfile is modern
    if (Object.prototype.hasOwnProperty.call(parsed, `__metadata`)) return;
    const resolutions = this.resolutions = new Map();

    for (const key of Object.keys(parsed)) {
      let descriptor = $01b78508755abe2bb439b7640e54eb06$var$structUtils.tryParseDescriptor(key);

      if (!descriptor) {
        report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.YARN_IMPORT_FAILED, `Failed to parse the string "${key}" into a proper descriptor`);
        continue;
      }

      if ($01b78508755abe2bb439b7640e54eb06$var$semver_1.default.validRange(descriptor.range)) descriptor = $01b78508755abe2bb439b7640e54eb06$var$structUtils.makeDescriptor(descriptor, `npm:${descriptor.range}`);
      const {
        version,
        resolved
      } = parsed[key]; // Workspaces don't have the "resolved" key; we can skip them, as their
      // resolution will be recomputed when needed anyway

      // Workspaces don't have the "resolved" key; we can skip them, as their
      // resolution will be recomputed when needed anyway
      if (!resolved) continue;
      let reference;

      for (const [pattern, matcher] of $01b78508755abe2bb439b7640e54eb06$var$IMPORTED_PATTERNS) {
        const match = resolved.match(pattern);

        if (match) {
          reference = matcher(version, ...match);
          break;
        }
      }

      if (!reference) {
        report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.YARN_IMPORT_FAILED, `${$01b78508755abe2bb439b7640e54eb06$var$structUtils.prettyDescriptor(project.configuration, descriptor)}: Only some patterns can be imported from legacy lockfiles (not "${resolved}")`);
        continue;
      }

      const resolution = $01b78508755abe2bb439b7640e54eb06$var$structUtils.makeLocator(descriptor, reference);
      resolutions.set(descriptor.descriptorHash, resolution);
    }
  }

  supportsDescriptor(descriptor, opts) {
    if (!this.resolutions) return false;
    return this.resolutions.has(descriptor.descriptorHash);
  }

  supportsLocator(locator, opts) {
    // This resolver only supports the descriptor -> locator part of the
    // resolution, not the locator -> package one.
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!this.resolutions) throw new Error(`Assertion failed: The resolution store should have been setup`);
    const resolution = this.resolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
    return [resolution];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

}

$01b78508755abe2bb439b7640e54eb06$export$LegacyMigrationResolver = $01b78508755abe2bb439b7640e54eb06$var$LegacyMigrationResolver;
$01b78508755abe2bb439b7640e54eb06$exports.LegacyMigrationResolver = $01b78508755abe2bb439b7640e54eb06$export$LegacyMigrationResolver;
// ASSET: node_modules/@yarnpkg/core/lib/LockfileResolver.js
var $41fc59c540da3d69523b50ee969f0281$exports = {};
Object.defineProperty($41fc59c540da3d69523b50ee969f0281$exports, "__esModule", {
  value: true
});
var $41fc59c540da3d69523b50ee969f0281$export$LockfileResolver = void 0;
$41fc59c540da3d69523b50ee969f0281$exports.LockfileResolver = $41fc59c540da3d69523b50ee969f0281$export$LockfileResolver;
const $41fc59c540da3d69523b50ee969f0281$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $41fc59c540da3d69523b50ee969f0281$var$LockfileResolver {
  supportsDescriptor(descriptor, opts) {
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (resolution) return true; // If the descriptor matches a package that's already been used, we can just use it even if we never resolved the range before
    // Ex: foo depends on bar@^1.0.0 that we resolved to foo@1.1.0, then we add a package qux that depends on foo@1.1.0 (without the caret)

    // If the descriptor matches a package that's already been used, we can just use it even if we never resolved the range before
    // Ex: foo depends on bar@^1.0.0 that we resolved to foo@1.1.0, then we add a package qux that depends on foo@1.1.0 (without the caret)
    if (opts.project.originalPackages.has($41fc59c540da3d69523b50ee969f0281$var$structUtils.convertDescriptorToLocator(descriptor).locatorHash)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (opts.project.originalPackages.has(locator.locatorHash)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let pkg = opts.project.originalPackages.get($41fc59c540da3d69523b50ee969f0281$var$structUtils.convertDescriptorToLocator(descriptor).locatorHash);
    if (pkg) return [pkg];
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Expected the resolution to have been successful - resolution not found`);
    pkg = opts.project.originalPackages.get(resolution);
    if (!pkg) throw new Error(`Expected the resolution to have been successful - package not found`);
    return [pkg];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    const pkg = opts.project.originalPackages.get(locator.locatorHash);
    if (!pkg) throw new Error(`The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache`);
    return pkg;
  }

}

$41fc59c540da3d69523b50ee969f0281$export$LockfileResolver = $41fc59c540da3d69523b50ee969f0281$var$LockfileResolver;
$41fc59c540da3d69523b50ee969f0281$exports.LockfileResolver = $41fc59c540da3d69523b50ee969f0281$export$LockfileResolver;
// ASSET: node_modules/@yarnpkg/core/lib/RunInstallPleaseResolver.js
var $2caff672a17c5a2dde5fca8b93db09a0$exports = {};
Object.defineProperty($2caff672a17c5a2dde5fca8b93db09a0$exports, "__esModule", {
  value: true
});
var $2caff672a17c5a2dde5fca8b93db09a0$export$RunInstallPleaseResolver = void 0;
$2caff672a17c5a2dde5fca8b93db09a0$exports.RunInstallPleaseResolver = $2caff672a17c5a2dde5fca8b93db09a0$export$RunInstallPleaseResolver;

class $2caff672a17c5a2dde5fca8b93db09a0$var$RunInstallPleaseResolver {
  constructor(resolver) {
    this.resolver = resolver;
  }

  supportsDescriptor(descriptor, opts) {
    return this.resolver.supportsDescriptor(descriptor, opts);
  }

  supportsLocator(locator, opts) {
    return this.resolver.supportsLocator(locator, opts);
  }

  shouldPersistResolution(locator, opts) {
    return this.resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return this.resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return this.resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

  async getSatisfying(descriptor, references, opts) {
    throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

  async resolve(locator, opts) {
    throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

}

$2caff672a17c5a2dde5fca8b93db09a0$export$RunInstallPleaseResolver = $2caff672a17c5a2dde5fca8b93db09a0$var$RunInstallPleaseResolver;
$2caff672a17c5a2dde5fca8b93db09a0$exports.RunInstallPleaseResolver = $2caff672a17c5a2dde5fca8b93db09a0$export$RunInstallPleaseResolver;
// ASSET: node_modules/@yarnpkg/core/lib/ThrowReport.js
var $5f04f86dd2d8bf5d53be16d63b07475f$exports = {};
Object.defineProperty($5f04f86dd2d8bf5d53be16d63b07475f$exports, "__esModule", {
  value: true
});
var $5f04f86dd2d8bf5d53be16d63b07475f$export$ThrowReport = void 0;
$5f04f86dd2d8bf5d53be16d63b07475f$exports.ThrowReport = $5f04f86dd2d8bf5d53be16d63b07475f$export$ThrowReport;

class $5f04f86dd2d8bf5d53be16d63b07475f$var$ThrowReport extends $9baf3138444c7a279b4b3775d56e5534$exports.Report {
  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return realCb();
  }

  async startTimerPromise(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return await realCb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {}

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {}

}

$5f04f86dd2d8bf5d53be16d63b07475f$export$ThrowReport = $5f04f86dd2d8bf5d53be16d63b07475f$var$ThrowReport;
$5f04f86dd2d8bf5d53be16d63b07475f$exports.ThrowReport = $5f04f86dd2d8bf5d53be16d63b07475f$export$ThrowReport;
// ASSET: node_modules/@yarnpkg/core/lib/Workspace.js
var $53a1bf8d1aa816c3899ae1d956d5c1fc$exports = {};
Object.defineProperty($53a1bf8d1aa816c3899ae1d956d5c1fc$exports, "__esModule", {
  value: true
});
var $53a1bf8d1aa816c3899ae1d956d5c1fc$export$Workspace = void 0;
$53a1bf8d1aa816c3899ae1d956d5c1fc$exports.Workspace = $53a1bf8d1aa816c3899ae1d956d5c1fc$export$Workspace;
const $53a1bf8d1aa816c3899ae1d956d5c1fc$var$globby_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($c4246b2a105057577586469a990ffddf$exports);
const $53a1bf8d1aa816c3899ae1d956d5c1fc$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $53a1bf8d1aa816c3899ae1d956d5c1fc$var$hashUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($d8692e28e950b48ea4715ab19e9bf9a1$exports);
const $53a1bf8d1aa816c3899ae1d956d5c1fc$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);

class $53a1bf8d1aa816c3899ae1d956d5c1fc$var$Workspace {
  constructor(workspaceCwd, {
    project
  }) {
    this.workspacesCwds = new Set(); // Generated at resolution; basically dependencies + devDependencies + child workspaces

    // Generated at resolution; basically dependencies + devDependencies + child workspaces
    this.dependencies = new Map();
    this.project = project;
    this.cwd = workspaceCwd;
  }

  async setup() {
    // @ts-expect-error: It's ok to initialize it now
    this.manifest = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(this.cwd, $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest.fileName)) ? await $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest.find(this.cwd) : new $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest(); // We use ppath.relative to guarantee that the default hash will be consistent even if the project is installed on different OS / path
    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    // We use ppath.relative to guarantee that the default hash will be consistent even if the project is installed on different OS / path
    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    this.relativeCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative(this.project.cwd, this.cwd) || $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot;
    const ident = this.manifest.name ? this.manifest.name : $53a1bf8d1aa816c3899ae1d956d5c1fc$var$structUtils.makeIdent(null, `${this.computeCandidateName()}-${$53a1bf8d1aa816c3899ae1d956d5c1fc$var$hashUtils.makeHash(this.relativeCwd).substr(0, 6)}`);
    const reference = this.manifest.version ? this.manifest.version : `0.0.0`; // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    this.locator = $53a1bf8d1aa816c3899ae1d956d5c1fc$var$structUtils.makeLocator(ident, reference); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    this.anchoredDescriptor = $53a1bf8d1aa816c3899ae1d956d5c1fc$var$structUtils.makeDescriptor(this.locator, `${$e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol}${this.relativeCwd}`); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    this.anchoredLocator = $53a1bf8d1aa816c3899ae1d956d5c1fc$var$structUtils.makeLocator(this.locator, `${$e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol}${this.relativeCwd}`);
    const patterns = this.manifest.workspaceDefinitions.map(({
      pattern
    }) => pattern);
    const relativeCwds = await $53a1bf8d1aa816c3899ae1d956d5c1fc$var$globby_1.default(patterns, {
      absolute: true,
      cwd: $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(this.cwd),
      expandDirectories: false,
      onlyDirectories: true,
      onlyFiles: false,
      ignore: [`**/node_modules`, `**/.git`, `**/.yarn`]
    }); // It seems that the return value of globby isn't in any guaranteed order - not even the directory listing order

    // It seems that the return value of globby isn't in any guaranteed order - not even the directory listing order
    relativeCwds.sort();

    for (const relativeCwd of relativeCwds) {
      const candidateCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(this.cwd, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(relativeCwd));

      if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(candidateCwd, `package.json`))) {
        this.workspacesCwds.add(candidateCwd);
      }
    }
  }

  accepts(range) {
    const protocolIndex = range.indexOf(`:`);
    const protocol = protocolIndex !== -1 ? range.slice(0, protocolIndex + 1) : null;
    const pathname = protocolIndex !== -1 ? range.slice(protocolIndex + 1) : range;
    if (protocol === $e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol && $ea9c1e38c3e8cca334929a597a084311$exports.ppath.normalize(pathname) === this.relativeCwd) return true;
    if (protocol === $e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol && pathname === `*`) return true;
    if (!$53a1bf8d1aa816c3899ae1d956d5c1fc$var$semver_1.default.validRange(pathname)) return false;
    if (protocol === $e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver.protocol) return $53a1bf8d1aa816c3899ae1d956d5c1fc$var$semver_1.default.satisfies(this.manifest.version !== null ? this.manifest.version : `0.0.0`, pathname);
    if (!this.project.configuration.get(`enableTransparentWorkspaces`)) return false;
    if (this.manifest.version !== null) return $53a1bf8d1aa816c3899ae1d956d5c1fc$var$semver_1.default.satisfies(this.manifest.version, pathname);
    return false;
  }

  computeCandidateName() {
    if (this.cwd === this.project.cwd) {
      return `root-workspace`;
    } else {
      return `${$ea9c1e38c3e8cca334929a597a084311$exports.ppath.basename(this.cwd)}` || `unnamed-workspace`;
    }
  }

  async persistManifest() {
    const data = {};
    this.manifest.exportTo(data);
    const path = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(this.cwd, $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest.fileName);
    const content = `${JSON.stringify(data, null, this.manifest.indent)}\n`;
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(path, content, {
      automaticNewlines: true
    });
  }

}

$53a1bf8d1aa816c3899ae1d956d5c1fc$export$Workspace = $53a1bf8d1aa816c3899ae1d956d5c1fc$var$Workspace;
$53a1bf8d1aa816c3899ae1d956d5c1fc$exports.Workspace = $53a1bf8d1aa816c3899ae1d956d5c1fc$export$Workspace;
const $5a1c67a183441e010515e193fca593e1$var$formatUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b0a0c0c8655104e8248dfbd97bf5098e$exports);
const $5a1c67a183441e010515e193fca593e1$var$hashUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($d8692e28e950b48ea4715ab19e9bf9a1$exports);
const $5a1c67a183441e010515e193fca593e1$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
const $5a1c67a183441e010515e193fca593e1$var$scriptUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($6881e9a961a5fe3922a1e41f40f331a3$exports);
const $5a1c67a183441e010515e193fca593e1$var$semverUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($4b3129d95390e44c4289200276bae532$exports);
const $5a1c67a183441e010515e193fca593e1$var$structUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($1cd0a18ca6ebf8e9e9c7770e206c865e$exports);
// When upgraded, the lockfile entries have to be resolved again (but the specific
// versions are still pinned, no worry). Bump it when you change the fields within
// the Package type; no more no less.
const $5a1c67a183441e010515e193fca593e1$var$LOCKFILE_VERSION = 4; // Same thing but must be bumped when the members of the Project class changes (we
// don't recommend our users to check-in this file, so it's fine to bump it even
// between patch or minor releases).

// Same thing but must be bumped when the members of the Project class changes (we
// don't recommend our users to check-in this file, so it's fine to bump it even
// between patch or minor releases).
const $5a1c67a183441e010515e193fca593e1$var$INSTALL_STATE_VERSION = 1;
const $5a1c67a183441e010515e193fca593e1$var$MULTIPLE_KEYS_REGEXP = / *, */g;
const $5a1c67a183441e010515e193fca593e1$var$TRAILING_SLASH_REGEXP = /\/$/;
const $5a1c67a183441e010515e193fca593e1$var$FETCHER_CONCURRENCY = 32;
const $5a1c67a183441e010515e193fca593e1$var$gzip = $5a1c67a183441e010515e193fca593e1$var$util_1.promisify($5a1c67a183441e010515e193fca593e1$var$zlib_1.default.gzip);
const $5a1c67a183441e010515e193fca593e1$var$gunzip = $5a1c67a183441e010515e193fca593e1$var$util_1.promisify($5a1c67a183441e010515e193fca593e1$var$zlib_1.default.gunzip);
const $5a1c67a183441e010515e193fca593e1$var$INSTALL_STATE_FIELDS = {
  restoreInstallersCustomData: [`installersCustomData`],
  restoreResolutions: [`accessibleLocators`, `optionalBuilds`, `storedDescriptors`, `storedResolutions`, `storedPackages`, `lockFileChecksum`]
};

class $5a1c67a183441e010515e193fca593e1$var$Project {
  constructor(projectCwd, {
    configuration
  }) {
    /**
     * Is meant to be populated by the consumer. Should the descriptor referenced
     * by the key be requested, the descriptor referenced in the value will be
     * resolved instead. The resolved data will then be used as final resolution
     * for the initial descriptor.
     *
     * Note that the lockfile will contain the second descriptor but not the
     * first one (meaning that if you remove the alias during a subsequent
     * install, it'll be lost and the real package will be resolved / installed).
     */
    this.resolutionAliases = new Map();
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.storedChecksums = new Map();
    this.accessibleLocators = new Set();
    this.originalPackages = new Map();
    this.optionalBuilds = new Set();
    /**
     * Populated by the `resolveEverything` method.
     * *Not* stored inside the install state.
     *
     * The map keys are 6 hexadecimal characters except the first one, always `p`.
     */

    /**
     * Populated by the `resolveEverything` method.
     * *Not* stored inside the install state.
     *
     * The map keys are 6 hexadecimal characters except the first one, always `p`.
     */
    this.peerRequirements = new Map();
    this.installersCustomData = new Map();
    this.lockFileChecksum = null;
    this.configuration = configuration;
    this.cwd = projectCwd;
  }

  static async find(configuration, startingCwd) {
    var _a, _b, _c;

    if (!configuration.projectCwd) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`No project found in ${startingCwd}`);
    let packageCwd = configuration.projectCwd;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (currentCwd !== configuration.projectCwd) {
      currentCwd = nextCwd;

      if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(currentCwd, $ea9c1e38c3e8cca334929a597a084311$exports.Filename.manifest))) {
        packageCwd = currentCwd;
        break;
      }

      nextCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(currentCwd);
    }

    const project = new $5a1c67a183441e010515e193fca593e1$var$Project(configuration.projectCwd, {
      configuration
    });
    (_a = $423262bd9e933160a1646431d9f01697$exports.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportProject(project.cwd);
    await project.setupResolutions();
    await project.setupWorkspaces();
    (_b = $423262bd9e933160a1646431d9f01697$exports.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportWorkspaceCount(project.workspaces.length);
    (_c = $423262bd9e933160a1646431d9f01697$exports.Configuration.telemetry) === null || _c === void 0 ? void 0 : _c.reportDependencyCount(project.workspaces.reduce((sum, workspace) => sum + workspace.manifest.dependencies.size + workspace.manifest.devDependencies.size, 0)); // If we're in a workspace, no need to go any further to find which package we're in

    // If we're in a workspace, no need to go any further to find which package we're in
    const workspace = project.tryWorkspaceByCwd(packageCwd);
    if (workspace) return {
      project,
      workspace,
      locator: workspace.anchoredLocator
    }; // Otherwise, we need to ask the project (which will in turn ask the linkers for help)
    // Note: the trailing slash is caused by a quirk in the PnP implementation that requires folders to end with a trailing slash to disambiguate them from regular files

    // Otherwise, we need to ask the project (which will in turn ask the linkers for help)
    // Note: the trailing slash is caused by a quirk in the PnP implementation that requires folders to end with a trailing slash to disambiguate them from regular files
    const locator = await project.findLocatorForLocation(`${packageCwd}/`, {
      strict: true
    });
    if (locator) return {
      project,
      locator,
      workspace: null
    };
    throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`The nearest package directory (${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(configuration, packageCwd, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PATH)}) doesn't seem to be part of the project declared in ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(configuration, project.cwd, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PATH)}.\n\n- If the project directory is right, it might be that you forgot to list ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(configuration, $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative(project.cwd, packageCwd), $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PATH)} as a workspace.\n- If it isn't, it's likely because you have a yarn.lock or package.json file there, confusing the project root detection.`);
  }

  static generateBuildStateFile(buildState, locatorStore) {
    let bstateFile = `# Warning: This file is automatically generated. Removing it is fine, but will\n# cause all your builds to become invalidated.\n`;
    const bstateData = [...buildState].map(([locatorHash, hash]) => {
      const locator = locatorStore.get(locatorHash);
      if (typeof locator === `undefined`) throw new Error(`Assertion failed: The locator should have been registered`);
      return [$5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyLocator(locator), locator.locatorHash, hash];
    });

    for (const [locatorString, locatorHash, buildHash] of $5a1c67a183441e010515e193fca593e1$var$miscUtils.sortMap(bstateData, [d => d[0], d => d[1]])) {
      bstateFile += `\n`;
      bstateFile += `# ${locatorString}\n`;
      bstateFile += `${JSON.stringify(locatorHash)}:\n`;
      bstateFile += `  ${buildHash}\n`;
    }

    return bstateFile;
  }

  async setupResolutions() {
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.lockFileChecksum = null;
    const lockfilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const defaultLanguageName = this.configuration.get(`defaultLanguageName`);

    if ($ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(lockfilePath)) {
      const content = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(lockfilePath, `utf8`); // We store the salted checksum of the lockfile in order to invalidate the install state when needed

      // We store the salted checksum of the lockfile in order to invalidate the install state when needed
      this.lockFileChecksum = $5a1c67a183441e010515e193fca593e1$var$hashUtils.makeHash(`${$5a1c67a183441e010515e193fca593e1$var$INSTALL_STATE_VERSION}`, content);
      const parsed = $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(content); // Protects against v1 lockfiles

      // Protects against v1 lockfiles
      if (parsed.__metadata) {
        const lockfileVersion = parsed.__metadata.version;
        const cacheKey = parsed.__metadata.cacheKey;

        for (const key of Object.keys(parsed)) {
          if (key === `__metadata`) continue;
          const data = parsed[key];
          if (typeof data.resolution === `undefined`) throw new Error(`Assertion failed: Expected the lockfile entry to have a resolution field (${key})`);
          const locator = $5a1c67a183441e010515e193fca593e1$var$structUtils.parseLocator(data.resolution, true);
          const manifest = new $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest();
          manifest.load(data, {
            yamlCompatibilityMode: true
          });
          const version = manifest.version;
          const languageName = manifest.languageName || defaultLanguageName;
          const linkType = data.linkType.toUpperCase();
          const dependencies = manifest.dependencies;
          const peerDependencies = manifest.peerDependencies;
          const dependenciesMeta = manifest.dependenciesMeta;
          const peerDependenciesMeta = manifest.peerDependenciesMeta;
          const bin = manifest.bin;

          if (data.checksum != null) {
            const checksum = typeof cacheKey !== `undefined` && !data.checksum.includes(`/`) ? `${cacheKey}/${data.checksum}` : data.checksum;
            this.storedChecksums.set(locator.locatorHash, checksum);
          }

          if (lockfileVersion >= $5a1c67a183441e010515e193fca593e1$var$LOCKFILE_VERSION) {
            const pkg = { ...locator,
              version,
              languageName,
              linkType,
              dependencies,
              peerDependencies,
              dependenciesMeta,
              peerDependenciesMeta,
              bin
            };
            this.originalPackages.set(pkg.locatorHash, pkg);
          }

          for (const entry of key.split($5a1c67a183441e010515e193fca593e1$var$MULTIPLE_KEYS_REGEXP)) {
            const descriptor = $5a1c67a183441e010515e193fca593e1$var$structUtils.parseDescriptor(entry);
            this.storedDescriptors.set(descriptor.descriptorHash, descriptor);

            if (lockfileVersion >= $5a1c67a183441e010515e193fca593e1$var$LOCKFILE_VERSION) {
              // If the lockfile is up-to-date, we can simply register the
              // resolution as a done deal.
              this.storedResolutions.set(descriptor.descriptorHash, locator.locatorHash);
            } else {
              // But if it isn't, then we instead setup an alias so that the
              // descriptor will be re-resolved (so that we get to retrieve the
              // new fields) while still resolving to the same locators.
              const resolutionDescriptor = $5a1c67a183441e010515e193fca593e1$var$structUtils.convertLocatorToDescriptor(locator);

              if (resolutionDescriptor.descriptorHash !== descriptor.descriptorHash) {
                this.storedDescriptors.set(resolutionDescriptor.descriptorHash, resolutionDescriptor);
                this.resolutionAliases.set(descriptor.descriptorHash, resolutionDescriptor.descriptorHash);
              }
            }
          }
        }
      }
    }
  }

  async setupWorkspaces() {
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    let workspaceCwds = [this.cwd];

    while (workspaceCwds.length > 0) {
      const passCwds = workspaceCwds;
      workspaceCwds = [];

      for (const workspaceCwd of passCwds) {
        if (this.workspacesByCwd.has(workspaceCwd)) continue;
        const workspace = await this.addWorkspace(workspaceCwd);
        const workspacePkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (workspacePkg) workspace.dependencies = workspacePkg.dependencies;

        for (const workspaceCwd of workspace.workspacesCwds) {
          workspaceCwds.push(workspaceCwd);
        }
      }
    }
  }

  async addWorkspace(workspaceCwd) {
    const workspace = new $53a1bf8d1aa816c3899ae1d956d5c1fc$exports.Workspace(workspaceCwd, {
      project: this
    });
    await workspace.setup();
    const dup = this.workspacesByIdent.get(workspace.locator.identHash);
    if (typeof dup !== `undefined`) throw new Error(`Duplicate workspace name ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(this.configuration, workspace.locator)}: ${workspaceCwd} conflicts with ${dup.cwd}`);
    this.workspaces.push(workspace);
    this.workspacesByCwd.set(workspaceCwd, workspace);
    this.workspacesByIdent.set(workspace.locator.identHash, workspace);
    return workspace;
  }

  get topLevelWorkspace() {
    return this.getWorkspaceByCwd(this.cwd);
  }

  tryWorkspaceByCwd(workspaceCwd) {
    if (!$ea9c1e38c3e8cca334929a597a084311$exports.ppath.isAbsolute(workspaceCwd)) workspaceCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(this.cwd, workspaceCwd);
    workspaceCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.normalize(workspaceCwd).replace(/\/+$/, ``);
    const workspace = this.workspacesByCwd.get(workspaceCwd);
    if (!workspace) return null;
    return workspace;
  }

  getWorkspaceByCwd(workspaceCwd) {
    const workspace = this.tryWorkspaceByCwd(workspaceCwd);
    if (!workspace) throw new Error(`Workspace not found (${workspaceCwd})`);
    return workspace;
  }

  tryWorkspaceByFilePath(filePath) {
    let bestWorkspace = null;

    for (const workspace of this.workspaces) {
      const rel = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative(workspace.cwd, filePath);
      if (rel.startsWith(`../`)) continue;
      if (bestWorkspace && bestWorkspace.cwd.length >= workspace.cwd.length) continue;
      bestWorkspace = workspace;
    }

    if (!bestWorkspace) return null;
    return bestWorkspace;
  }

  getWorkspaceByFilePath(filePath) {
    const workspace = this.tryWorkspaceByFilePath(filePath);
    if (!workspace) throw new Error(`Workspace not found (${filePath})`);
    return workspace;
  }

  tryWorkspaceByIdent(ident) {
    const workspace = this.workspacesByIdent.get(ident.identHash);
    if (typeof workspace === `undefined`) return null;
    return workspace;
  }

  getWorkspaceByIdent(ident) {
    const workspace = this.tryWorkspaceByIdent(ident);
    if (!workspace) throw new Error(`Workspace not found (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(this.configuration, ident)})`);
    return workspace;
  }

  tryWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByIdent(descriptor);
    if (workspace === null || !workspace.accepts(descriptor.range)) return null;
    return workspace;
  }

  getWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByDescriptor(descriptor);
    if (workspace === null) throw new Error(`Workspace not found (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)})`);
    return workspace;
  }

  tryWorkspaceByLocator(locator) {
    if ($5a1c67a183441e010515e193fca593e1$var$structUtils.isVirtualLocator(locator)) locator = $5a1c67a183441e010515e193fca593e1$var$structUtils.devirtualizeLocator(locator);
    const workspace = this.tryWorkspaceByIdent(locator);
    if (workspace === null || workspace.locator.locatorHash !== locator.locatorHash && workspace.anchoredLocator.locatorHash !== locator.locatorHash) return null;
    return workspace;
  }

  getWorkspaceByLocator(locator) {
    const workspace = this.tryWorkspaceByLocator(locator);
    if (!workspace) throw new Error(`Workspace not found (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, locator)})`);
    return workspace;
  }
  /**
   * Import the dependencies of each resolved workspace into their own
   * `Workspace` instance.
   */


  /**
   * Import the dependencies of each resolved workspace into their own
   * `Workspace` instance.
   */
  refreshWorkspaceDependencies() {
    for (const workspace of this.workspaces) {
      const pkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg) throw new Error(`Assertion failed: Expected workspace to have been resolved`);
      workspace.dependencies = new Map(pkg.dependencies);
    }
  }

  forgetResolution(dataStructure) {
    const deleteDescriptor = descriptorHash => {
      this.storedResolutions.delete(descriptorHash);
      this.storedDescriptors.delete(descriptorHash);
    };

    const deleteLocator = locatorHash => {
      this.originalPackages.delete(locatorHash);
      this.storedPackages.delete(locatorHash);
      this.accessibleLocators.delete(locatorHash);
    };

    if (`descriptorHash` in dataStructure) {
      const locatorHash = this.storedResolutions.get(dataStructure.descriptorHash);
      deleteDescriptor(dataStructure.descriptorHash); // We delete unused locators

      // We delete unused locators
      const remainingResolutions = new Set(this.storedResolutions.values());

      if (typeof locatorHash !== `undefined` && !remainingResolutions.has(locatorHash)) {
        deleteLocator(locatorHash);
      }
    }

    if (`locatorHash` in dataStructure) {
      deleteLocator(dataStructure.locatorHash); // We delete all of the descriptors that have been resolved to the locator

      // We delete all of the descriptors that have been resolved to the locator
      for (const [descriptorHash, locatorHash] of this.storedResolutions) {
        if (locatorHash === dataStructure.locatorHash) {
          deleteDescriptor(descriptorHash);
        }
      }
    }
  }

  forgetTransientResolutions() {
    const resolver = this.configuration.makeResolver();

    for (const pkg of this.originalPackages.values()) {
      let shouldPersistResolution;

      try {
        shouldPersistResolution = resolver.shouldPersistResolution(pkg, {
          project: this,
          resolver
        });
      } catch (_a) {
        shouldPersistResolution = false;
      }

      if (!shouldPersistResolution) {
        this.forgetResolution(pkg);
      }
    }
  }

  forgetVirtualResolutions() {
    for (const pkg of this.storedPackages.values()) {
      for (const [dependencyHash, dependency] of pkg.dependencies) {
        if ($5a1c67a183441e010515e193fca593e1$var$structUtils.isVirtualDescriptor(dependency)) {
          pkg.dependencies.set(dependencyHash, $5a1c67a183441e010515e193fca593e1$var$structUtils.devirtualizeDescriptor(dependency));
        }
      }
    }
  }

  getDependencyMeta(ident, version) {
    const dependencyMeta = {};
    const dependenciesMeta = this.topLevelWorkspace.manifest.dependenciesMeta;
    const dependencyMetaSet = dependenciesMeta.get($5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyIdent(ident));
    if (!dependencyMetaSet) return dependencyMeta;
    const defaultMeta = dependencyMetaSet.get(null);
    if (defaultMeta) Object.assign(dependencyMeta, defaultMeta);
    if (version === null || !$5a1c67a183441e010515e193fca593e1$var$semver_1.default.valid(version)) return dependencyMeta;

    for (const [range, meta] of dependencyMetaSet) if (range !== null && range === version) Object.assign(dependencyMeta, meta);

    return dependencyMeta;
  }

  async findLocatorForLocation(cwd, {
    strict = false
  } = {}) {
    const report = new $5f04f86dd2d8bf5d53be16d63b07475f$exports.ThrowReport();
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };

    for (const linker of linkers) {
      const locator = await linker.findPackageLocator(cwd, linkerOptions);

      if (locator) {
        // If strict mode, the specified cwd must be a package,
        // not merely contained in a package.
        if (strict) {
          const location = await linker.findPackageLocation(locator, linkerOptions);

          if (location.replace($5a1c67a183441e010515e193fca593e1$var$TRAILING_SLASH_REGEXP, ``) !== cwd.replace($5a1c67a183441e010515e193fca593e1$var$TRAILING_SLASH_REGEXP, ``)) {
            continue;
          }
        }

        return locator;
      }
    }

    return null;
  }

  async resolveEverything(opts) {
    if (!this.workspacesByCwd || !this.workspacesByIdent) throw new Error(`Workspaces must have been setup before calling this function`); // Reverts the changes that have been applied to the tree because of any previous virtual resolution pass

    // Reverts the changes that have been applied to the tree because of any previous virtual resolution pass
    this.forgetVirtualResolutions(); // Ensures that we notice it when dependencies are added / removed from all sources coming from the filesystem

    // Ensures that we notice it when dependencies are added / removed from all sources coming from the filesystem
    if (!opts.lockfileOnly) this.forgetTransientResolutions(); // Note that the resolution process is "offline" until everything has been
    // successfully resolved; all the processing is expected to have zero side
    // effects until we're ready to set all the variables at once (the one
    // exception being when a resolver needs to fetch a package, in which case
    // we might need to populate the cache).
    //
    // This makes it possible to use the same Project instance for multiple
    // purposes at the same time (since `resolveEverything` is async, it might
    // happen that we want to do something while waiting for it to end; if we
    // were to mutate the project then it would end up in a partial state that
    // could lead to hard-to-debug issues).

    // Note that the resolution process is "offline" until everything has been
    // successfully resolved; all the processing is expected to have zero side
    // effects until we're ready to set all the variables at once (the one
    // exception being when a resolver needs to fetch a package, in which case
    // we might need to populate the cache).
    //
    // This makes it possible to use the same Project instance for multiple
    // purposes at the same time (since `resolveEverything` is async, it might
    // happen that we want to do something while waiting for it to end; if we
    // were to mutate the project then it would end up in a partial state that
    // could lead to hard-to-debug issues).
    const realResolver = opts.resolver || this.configuration.makeResolver();
    const legacyMigrationResolver = new $01b78508755abe2bb439b7640e54eb06$exports.LegacyMigrationResolver();
    await legacyMigrationResolver.setup(this, {
      report: opts.report
    });
    const resolver = opts.lockfileOnly ? new $d87b895bfcf6a6f21386ff7ce5f5276b$exports.MultiResolver([new $41fc59c540da3d69523b50ee969f0281$exports.LockfileResolver(), new $2caff672a17c5a2dde5fca8b93db09a0$exports.RunInstallPleaseResolver(realResolver)]) : new $d87b895bfcf6a6f21386ff7ce5f5276b$exports.MultiResolver([new $41fc59c540da3d69523b50ee969f0281$exports.LockfileResolver(), legacyMigrationResolver, realResolver]);
    const fetcher = this.configuration.makeFetcher();
    const resolveOptions = opts.lockfileOnly ? {
      project: this,
      report: opts.report,
      resolver
    } : {
      project: this,
      report: opts.report,
      resolver,
      fetchOptions: {
        project: this,
        cache: opts.cache,
        checksums: this.storedChecksums,
        report: opts.report,
        fetcher
      }
    };
    const allDescriptors = new Map();
    const allPackages = new Map();
    const allResolutions = new Map();
    const originalPackages = new Map();
    const packageResolutionPromises = new Map();
    const descriptorResolutionPromises = new Map();
    const resolutionQueue = [];

    const startPackageResolution = async locator => {
      const originalPkg = await $5a1c67a183441e010515e193fca593e1$var$miscUtils.prettifyAsyncErrors(async () => {
        return await resolver.resolve(locator, resolveOptions);
      }, message => {
        return `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, locator)}: ${message}`;
      });
      if (!$5a1c67a183441e010515e193fca593e1$var$structUtils.areLocatorsEqual(locator, originalPkg)) throw new Error(`Assertion failed: The locator cannot be changed by the resolver (went from ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, locator)} to ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, originalPkg)})`);
      originalPackages.set(originalPkg.locatorHash, originalPkg);
      const pkg = this.configuration.normalizePackage(originalPkg);

      for (const [identHash, descriptor] of pkg.dependencies) {
        const dependency = await this.configuration.reduceHook(hooks => {
          return hooks.reduceDependency;
        }, descriptor, this, pkg, descriptor, {
          resolver,
          resolveOptions
        });
        if (!$5a1c67a183441e010515e193fca593e1$var$structUtils.areIdentsEqual(descriptor, dependency)) throw new Error(`Assertion failed: The descriptor ident cannot be changed through aliases`);
        const bound = resolver.bindDescriptor(dependency, locator, resolveOptions);
        pkg.dependencies.set(identHash, bound);
      }

      resolutionQueue.push(Promise.all([...pkg.dependencies.values()].map(descriptor => {
        return scheduleDescriptorResolution(descriptor);
      })));
      allPackages.set(pkg.locatorHash, pkg);
      return pkg;
    };

    const schedulePackageResolution = async locator => {
      const promise = packageResolutionPromises.get(locator.locatorHash);
      if (typeof promise !== `undefined`) return promise;
      const newPromise = Promise.resolve().then(() => startPackageResolution(locator));
      packageResolutionPromises.set(locator.locatorHash, newPromise);
      return newPromise;
    };

    const startDescriptorAliasing = async (descriptor, alias) => {
      const resolution = await scheduleDescriptorResolution(alias);
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      allResolutions.set(descriptor.descriptorHash, resolution.locatorHash);
      return resolution;
    };

    const startDescriptorResolution = async descriptor => {
      const alias = this.resolutionAliases.get(descriptor.descriptorHash);
      if (typeof alias !== `undefined`) return startDescriptorAliasing(descriptor, this.storedDescriptors.get(alias));
      const resolutionDependencies = resolver.getResolutionDependencies(descriptor, resolveOptions);
      const resolvedDependencies = new Map(await Promise.all(resolutionDependencies.map(async dependency => {
        return [dependency.descriptorHash, await scheduleDescriptorResolution(dependency)];
      })));
      const candidateResolutions = await $5a1c67a183441e010515e193fca593e1$var$miscUtils.prettifyAsyncErrors(async () => {
        return await resolver.getCandidates(descriptor, resolvedDependencies, resolveOptions);
      }, message => {
        return `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}: ${message}`;
      });
      const finalResolution = candidateResolutions[0];
      if (typeof finalResolution === `undefined`) throw new Error(`${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}: No candidates found`);
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      allResolutions.set(descriptor.descriptorHash, finalResolution.locatorHash);
      return schedulePackageResolution(finalResolution);
    };

    const scheduleDescriptorResolution = descriptor => {
      const promise = descriptorResolutionPromises.get(descriptor.descriptorHash);
      if (typeof promise !== `undefined`) return promise;
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      const newPromise = Promise.resolve().then(() => startDescriptorResolution(descriptor));
      descriptorResolutionPromises.set(descriptor.descriptorHash, newPromise);
      return newPromise;
    };

    for (const workspace of this.workspaces) {
      const workspaceDescriptor = workspace.anchoredDescriptor;
      resolutionQueue.push(scheduleDescriptorResolution(workspaceDescriptor));
    }

    while (resolutionQueue.length > 0) {
      const copy = [...resolutionQueue];
      resolutionQueue.length = 0;
      await Promise.all(copy);
    } // In this step we now create virtual packages for each package with at
    // least one peer dependency. We also use it to search for the alias
    // descriptors that aren't depended upon by anything and can be safely
    // pruned.


    // In this step we now create virtual packages for each package with at
    // least one peer dependency. We also use it to search for the alias
    // descriptors that aren't depended upon by anything and can be safely
    // pruned.
    const volatileDescriptors = new Set(this.resolutionAliases.values());
    const optionalBuilds = new Set(allPackages.keys());
    const accessibleLocators = new Set();
    const peerRequirements = new Map();
    $5a1c67a183441e010515e193fca593e1$var$applyVirtualResolutionMutations({
      project: this,
      report: opts.report,
      accessibleLocators,
      volatileDescriptors,
      optionalBuilds,
      peerRequirements,
      allDescriptors,
      allResolutions,
      allPackages
    }); // All descriptors still referenced within the volatileDescriptors set are
    // descriptors that aren't depended upon by anything in the dependency tree.

    // All descriptors still referenced within the volatileDescriptors set are
    // descriptors that aren't depended upon by anything in the dependency tree.
    for (const descriptorHash of volatileDescriptors) {
      allDescriptors.delete(descriptorHash);
      allResolutions.delete(descriptorHash);
    } // Everything is done, we can now update our internal resolutions to
    // reference the new ones


    // Everything is done, we can now update our internal resolutions to
    // reference the new ones
    this.storedResolutions = allResolutions;
    this.storedDescriptors = allDescriptors;
    this.storedPackages = allPackages;
    this.accessibleLocators = accessibleLocators;
    this.originalPackages = originalPackages;
    this.optionalBuilds = optionalBuilds;
    this.peerRequirements = peerRequirements; // Now that the internal resolutions have been updated, we can refresh the
    // dependencies of each resolved workspace's `Workspace` instance.

    // Now that the internal resolutions have been updated, we can refresh the
    // dependencies of each resolved workspace's `Workspace` instance.
    this.refreshWorkspaceDependencies();
  }

  async fetchEverything({
    cache,
    report,
    fetcher: userFetcher
  }) {
    const fetcher = userFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report
    };
    const locatorHashes = Array.from(new Set($5a1c67a183441e010515e193fca593e1$var$miscUtils.sortMap(this.storedResolutions.values(), [locatorHash => {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      return $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyLocator(pkg);
    }])));
    let firstError = false;
    const progress = $9baf3138444c7a279b4b3775d56e5534$exports.Report.progressViaCounter(locatorHashes.length);
    report.reportProgress(progress);
    const limit = $5a1c67a183441e010515e193fca593e1$var$p_limit_1.default($5a1c67a183441e010515e193fca593e1$var$FETCHER_CONCURRENCY);
    await report.startCacheReport(async () => {
      await Promise.all(locatorHashes.map(locatorHash => limit(async () => {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
        if ($5a1c67a183441e010515e193fca593e1$var$structUtils.isVirtualLocator(pkg)) return;
        let fetchResult;

        try {
          fetchResult = await fetcher.fetch(pkg, fetcherOptions);
        } catch (error) {
          error.message = `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)}: ${error.message}`;
          report.reportExceptionOnce(error);
          firstError = error;
          return;
        }

        if (fetchResult.checksum) this.storedChecksums.set(pkg.locatorHash, fetchResult.checksum);else this.storedChecksums.delete(pkg.locatorHash);

        if (fetchResult.releaseFs) {
          fetchResult.releaseFs();
        }
      }).finally(() => {
        progress.tick();
      })));
    });

    if (firstError) {
      throw firstError;
    }
  }

  async linkEverything({
    cache,
    report,
    fetcher: optFetcher,
    skipBuild
  }) {
    var _a;

    const fetcher = optFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report,
      skipIntegrityCheck: true
    };
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };
    const installers = new Map(linkers.map(linker => {
      const installer = linker.makeInstaller(linkerOptions);
      const customDataKey = installer.getCustomDataKey();
      const customData = this.installersCustomData.get(customDataKey);
      if (typeof customData !== `undefined`) installer.attachCustomData(customData);
      return [linker, installer];
    }));
    const packageLinkers = new Map();
    const packageLocations = new Map();
    const packageBuildDirectives = new Map();
    const fetchResultsPerPackage = new Map(await Promise.all([...this.accessibleLocators].map(async locatorHash => {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      return [locatorHash, await fetcher.fetch(pkg, fetcherOptions)];
    }))); // Step 1: Installing the packages on the disk

    // Step 1: Installing the packages on the disk
    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The locator should have been registered`);
      const fetchResult = fetchResultsPerPackage.get(pkg.locatorHash);
      if (typeof fetchResult === `undefined`) throw new Error(`Assertion failed: The fetch result should have been registered`);
      const workspace = this.tryWorkspaceByLocator(pkg);

      if (workspace !== null) {
        const buildScripts = [];
        const {
          scripts
        } = workspace.manifest;

        for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (scripts.has(scriptName)) buildScripts.push([$453e822fb82930600943800011f07c5f$exports.BuildType.SCRIPT, scriptName]);

        try {
          for (const installer of installers.values()) {
            const result = await installer.installPackage(pkg, fetchResult);

            if (result.buildDirective !== null) {
              throw new Error(`Assertion failed: Linkers can't return build directives for workspaces; this responsibility befalls to the Yarn core`);
            }
          }
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        const location = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
        packageLocations.set(pkg.locatorHash, location);

        if (buildScripts.length > 0) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: buildScripts,
            buildLocations: [location]
          });
        }
      } else {
        const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
        if (!linker) throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.LINKER_NOT_FOUND, `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)} isn't supported by any available linker`);
        const installer = installers.get(linker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        let installStatus;

        try {
          installStatus = await installer.installPackage(pkg, fetchResult);
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        packageLinkers.set(pkg.locatorHash, linker);
        packageLocations.set(pkg.locatorHash, installStatus.packageLocation);

        if (installStatus.buildDirective && installStatus.packageLocation) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: installStatus.buildDirective,
            buildLocations: [installStatus.packageLocation]
          });
        }
      }
    } // Step 2: Link packages together


    // Step 2: Link packages together
    const externalDependents = new Map();

    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      const isWorkspace = this.tryWorkspaceByLocator(pkg) !== null;

      const linkPackage = async (packageLinker, installer) => {
        const packageLocation = packageLocations.get(pkg.locatorHash);
        if (typeof packageLocation === `undefined`) throw new Error(`Assertion failed: The package (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)}) should have been registered`);
        const internalDependencies = [];

        for (const descriptor of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}, from ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)})should have been registered`);
          const dependency = this.storedPackages.get(resolution);
          if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const dependencyLinker = this.tryWorkspaceByLocator(dependency) === null ? packageLinkers.get(resolution) : null;
          if (typeof dependencyLinker === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const isWorkspaceDependency = dependencyLinker === null;

          if (dependencyLinker === packageLinker || isWorkspace || isWorkspaceDependency) {
            if (packageLocations.get(dependency.locatorHash) !== null) {
              internalDependencies.push([descriptor, dependency]);
            }
          } else if (packageLocation !== null) {
            const externalEntry = $5a1c67a183441e010515e193fca593e1$var$miscUtils.getArrayWithDefault(externalDependents, resolution);
            externalEntry.push(packageLocation);
          }
        }

        if (packageLocation !== null) {
          await installer.attachInternalDependencies(pkg, internalDependencies);
        }
      };

      if (isWorkspace) {
        for (const [packageLinker, installer] of installers) {
          await linkPackage(packageLinker, installer);
        }
      } else {
        const packageLinker = packageLinkers.get(pkg.locatorHash);
        if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
        const installer = installers.get(packageLinker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        await linkPackage(packageLinker, installer);
      }
    }

    for (const [locatorHash, dependentPaths] of externalDependents) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
      const packageLinker = packageLinkers.get(pkg.locatorHash);
      if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
      const installer = installers.get(packageLinker);
      if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
      await installer.attachExternalDependents(pkg, dependentPaths);
    } // Step 3: Inform our linkers that they should have all the info needed


    // Step 3: Inform our linkers that they should have all the info needed
    const installersCustomData = new Map();

    for (const installer of installers.values()) {
      const finalizeInstallData = await installer.finalizeInstall();

      for (const installStatus of (_a = finalizeInstallData === null || finalizeInstallData === void 0 ? void 0 : finalizeInstallData.records) !== null && _a !== void 0 ? _a : []) {
        packageBuildDirectives.set(installStatus.locatorHash, {
          directives: installStatus.buildDirective,
          buildLocations: installStatus.buildLocations
        });
      }

      if (typeof (finalizeInstallData === null || finalizeInstallData === void 0 ? void 0 : finalizeInstallData.customData) !== `undefined`) {
        installersCustomData.set(installer.getCustomDataKey(), finalizeInstallData.customData);
      }
    }

    this.installersCustomData = installersCustomData;
    await this.persistInstallStateFile(); // Step 4: Build the packages in multiple steps

    // Step 4: Build the packages in multiple steps
    if (skipBuild) return;
    const readyPackages = new Set(this.storedPackages.keys());
    const buildablePackages = new Set(packageBuildDirectives.keys());

    for (const locatorHash of buildablePackages) readyPackages.delete(locatorHash);

    const globalHashGenerator = $5a1c67a183441e010515e193fca593e1$var$crypto_1.createHash(`sha512`); // globalHashGenerator.update(process.versions.node);

    // globalHashGenerator.update(process.versions.node);
    this.configuration.triggerHook(hooks => {
      return hooks.globalHashGeneration;
    }, this, data => {
      globalHashGenerator.update(`\0`);
      globalHashGenerator.update(data);
    });
    const globalHash = globalHashGenerator.digest(`hex`);
    const packageHashMap = new Map(); // We'll use this function is order to compute a hash for each package
    // that exposes a build directive. If the hash changes compared to the
    // previous run, the package is rebuilt. This has the advantage of making
    // the rebuilds much more predictable than before, and to give us the tools
    // later to improve this further by explaining *why* a rebuild happened.

    // We'll use this function is order to compute a hash for each package
    // that exposes a build directive. If the hash changes compared to the
    // previous run, the package is rebuilt. This has the advantage of making
    // the rebuilds much more predictable than before, and to give us the tools
    // later to improve this further by explaining *why* a rebuild happened.
    const getBaseHash = locator => {
      let hash = packageHashMap.get(locator.locatorHash);
      if (typeof hash !== `undefined`) return hash;
      const pkg = this.storedPackages.get(locator.locatorHash);
      if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
      const builder = $5a1c67a183441e010515e193fca593e1$var$crypto_1.createHash(`sha512`);
      builder.update(locator.locatorHash); // To avoid the case where one dependency depends on itself somehow

      // To avoid the case where one dependency depends on itself somehow
      packageHashMap.set(locator.locatorHash, `<recursive>`);

      for (const descriptor of pkg.dependencies.values()) {
        const resolution = this.storedResolutions.get(descriptor.descriptorHash);
        if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
        const dependency = this.storedPackages.get(resolution);
        if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
        builder.update(getBaseHash(dependency));
      }

      hash = builder.digest(`hex`);
      packageHashMap.set(locator.locatorHash, hash);
      return hash;
    };

    const getBuildHash = (locator, buildLocations) => {
      const builder = $5a1c67a183441e010515e193fca593e1$var$crypto_1.createHash(`sha512`);
      builder.update(globalHash);
      builder.update(getBaseHash(locator));

      for (const location of buildLocations) builder.update(location);

      return builder.digest(`hex`);
    };

    const bstatePath = this.configuration.get(`bstatePath`);
    const bstate = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(bstatePath) ? $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(bstatePath, `utf8`)) : {}; // We reconstruct the build state from an empty object because we want to
    // remove the state from packages that got removed

    // We reconstruct the build state from an empty object because we want to
    // remove the state from packages that got removed
    const nextBState = new Map();

    while (buildablePackages.size > 0) {
      const savedSize = buildablePackages.size;
      const buildPromises = [];

      for (const locatorHash of buildablePackages) {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
        let isBuildable = true;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(dependency.descriptorHash);
          if (!resolution) throw new Error(`Assertion failed: The resolution (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(this.configuration, dependency)}) should have been registered`);

          if (buildablePackages.has(resolution)) {
            isBuildable = false;
            break;
          }
        } // Wait until all dependencies of the current package have been built
        // before trying to build it (since it might need them to build itself)


        // Wait until all dependencies of the current package have been built
        // before trying to build it (since it might need them to build itself)
        if (!isBuildable) continue;
        buildablePackages.delete(locatorHash);
        const buildInfo = packageBuildDirectives.get(pkg.locatorHash);
        if (!buildInfo) throw new Error(`Assertion failed: The build directive should have been registered`);
        const buildHash = getBuildHash(pkg, buildInfo.buildLocations); // No need to rebuild the package if its hash didn't change

        // No need to rebuild the package if its hash didn't change
        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash) && bstate[pkg.locatorHash] === buildHash) {
          nextBState.set(pkg.locatorHash, buildHash);
          continue;
        }

        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash)) report.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MUST_REBUILD, `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)} must be rebuilt because its dependency tree changed`);else report.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MUST_BUILD, `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)} must be built because it never did before or the last one failed`);

        for (const location of buildInfo.buildLocations) {
          if (!$ea9c1e38c3e8cca334929a597a084311$exports.ppath.isAbsolute(location)) throw new Error(`Assertion failed: Expected the build location to be absolute (not ${location})`);
          buildPromises.push((async () => {
            for (const [buildType, scriptName] of buildInfo.directives) {
              let header = `# This file contains the result of Yarn building a package (${$5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyLocator(pkg)})\n`;

              switch (buildType) {
                case $453e822fb82930600943800011f07c5f$exports.BuildType.SCRIPT:
                  {
                    header += `# Script name: ${scriptName}\n`;
                  }
                  break;

                case $453e822fb82930600943800011f07c5f$exports.BuildType.SHELLCODE:
                  {
                    header += `# Script code: ${scriptName}\n`;
                  }
                  break;
              }

              const stdin = null;
              await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempPromise(async logDir => {
                const logFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(logDir, `build.log`);
                const {
                  stdout,
                  stderr
                } = this.configuration.getSubprocessStreams(logFile, {
                  header,
                  prefix: $5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg),
                  report
                });
                let exitCode;

                try {
                  switch (buildType) {
                    case $453e822fb82930600943800011f07c5f$exports.BuildType.SCRIPT:
                      {
                        exitCode = await $5a1c67a183441e010515e193fca593e1$var$scriptUtils.executePackageScript(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;

                    case $453e822fb82930600943800011f07c5f$exports.BuildType.SHELLCODE:
                      {
                        exitCode = await $5a1c67a183441e010515e193fca593e1$var$scriptUtils.executePackageShellcode(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;
                  }
                } catch (error) {
                  stderr.write(error.stack);
                  exitCode = 1;
                }

                stdout.end();
                stderr.end();

                if (exitCode === 0) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                $ea9c1e38c3e8cca334929a597a084311$exports.xfs.detachTemp(logDir);
                const buildMessage = `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg)} couldn't be built successfully (exit code ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, exitCode, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.NUMBER)}, logs can be found here: ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, logFile, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PATH)})`;
                report.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.BUILD_FAILED, buildMessage);

                if (this.optionalBuilds.has(pkg.locatorHash)) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.BUILD_FAILED, buildMessage);
                return false;
              });
            }
          })());
        }
      }

      await Promise.all(buildPromises); // If we reach this code, it means that we have circular dependencies
      // somewhere. Worst, it means that the circular dependencies both have
      // build scripts, making them unsatisfiable.

      // If we reach this code, it means that we have circular dependencies
      // somewhere. Worst, it means that the circular dependencies both have
      // build scripts, making them unsatisfiable.
      if (savedSize === buildablePackages.size) {
        const prettyLocators = Array.from(buildablePackages).map(locatorHash => {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
          return $5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(this.configuration, pkg);
        }).join(`, `);
        report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.CYCLIC_DEPENDENCIES, `Some packages have circular dependencies that make their build order unsatisfiable - as a result they won't be built (affected packages are: ${prettyLocators})`);
        break;
      }
    } // We can now generate the bstate file, which will allow us to "remember"
    // what's the dependency tree subset that we used to build a specific
    // package (and avoid rebuilding it later if it didn't change).


    // We can now generate the bstate file, which will allow us to "remember"
    // what's the dependency tree subset that we used to build a specific
    // package (and avoid rebuilding it later if it didn't change).
    if (nextBState.size > 0) {
      const bstatePath = this.configuration.get(`bstatePath`);
      const bstateFile = $5a1c67a183441e010515e193fca593e1$var$Project.generateBuildStateFile(nextBState, this.storedPackages);
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(bstatePath), {
        recursive: true
      });
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(bstatePath, bstateFile, {
        automaticNewlines: true
      });
    } else {
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(bstatePath);
    }
  }

  async install(opts) {
    var _a, _b;

    const nodeLinker = this.configuration.get(`nodeLinker`);
    (_a = $423262bd9e933160a1646431d9f01697$exports.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportInstall(nodeLinker);
    await opts.report.startTimerPromise(`Project validation`, {
      skipIfEmpty: true
    }, async () => {
      await this.configuration.triggerHook(hooks => {
        return hooks.validateProject;
      }, this, {
        reportWarning: opts.report.reportWarning.bind(opts.report),
        reportError: opts.report.reportError.bind(opts.report)
      });
    });

    for (const extensionsByIdent of this.configuration.packageExtensions.values()) for (const [, extensionsByRange] of extensionsByIdent) for (const extension of extensionsByRange) extension.status = $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Inactive;

    const lockfilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`)); // If we operate with a frozen lockfile, we take a snapshot of it to later make sure it didn't change

    // If we operate with a frozen lockfile, we take a snapshot of it to later make sure it didn't change
    let initialLockfile = null;

    if (opts.immutable) {
      try {
        initialLockfile = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(lockfilePath, `utf8`);
      } catch (error) {
        if (error.code === `ENOENT`) {
          throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been created by this install, which is explicitly forbidden.`);
        } else {
          throw error;
        }
      }
    }

    await opts.report.startTimerPromise(`Resolution step`, async () => {
      await this.resolveEverything(opts);
    });
    await opts.report.startTimerPromise(`Post-resolution validation`, {
      skipIfEmpty: true
    }, async () => {
      for (const [, extensionsPerRange] of this.configuration.packageExtensions) {
        for (const [, extensions] of extensionsPerRange) {
          for (const extension of extensions) {
            if (extension.userProvided) {
              const prettyPackageExtension = $5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, extension, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PACKAGE_EXTENSION);

              switch (extension.status) {
                case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Inactive:
                  {
                    opts.report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNUSED_PACKAGE_EXTENSION, `${prettyPackageExtension}: No matching package in the dependency tree; you may not need this rule anymore.`);
                  }
                  break;

                case $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Redundant:
                  {
                    opts.report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.REDUNDANT_PACKAGE_EXTENSION, `${prettyPackageExtension}: This rule seems redundant when applied on the original package; the extension may have been applied upstream.`);
                  }
                  break;
              }
            }
          }
        }
      }

      if (initialLockfile !== null) {
        const newLockfile = $ea9c1e38c3e8cca334929a597a084311$exports.normalizeLineEndings(initialLockfile, this.generateLockfile());

        if (newLockfile !== initialLockfile) {
          const diff = $452492225f6c359232a0e384f4797aeb$exports.structuredPatch(lockfilePath, lockfilePath, initialLockfile, newLockfile);
          opts.report.reportSeparator();

          for (const hunk of diff.hunks) {
            opts.report.reportInfo(null, `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`);

            for (const line of hunk.lines) {
              if (line.startsWith(`+`)) {
                opts.report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FROZEN_LOCKFILE_EXCEPTION, $5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, line, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.ADDED));
              } else if (line.startsWith(`-`)) {
                opts.report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FROZEN_LOCKFILE_EXCEPTION, $5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, line, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.REMOVED));
              } else {
                opts.report.reportInfo(null, $5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, line, `grey`));
              }
            }
          }

          opts.report.reportSeparator();
          throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been modified by this install, which is explicitly forbidden.`);
        }
      }
    });

    for (const extensionsByIdent of this.configuration.packageExtensions.values()) for (const [, extensionsByRange] of extensionsByIdent) for (const extension of extensionsByRange) if (extension.userProvided && extension.status === $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus.Active) (_b = $423262bd9e933160a1646431d9f01697$exports.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportPackageExtension($5a1c67a183441e010515e193fca593e1$var$formatUtils.json(extension, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.PACKAGE_EXTENSION));

    await opts.report.startTimerPromise(`Fetch step`, async () => {
      await this.fetchEverything(opts);

      if (typeof opts.persistProject === `undefined` || opts.persistProject) {
        await this.cacheCleanup(opts);
      }
    });
    if (typeof opts.persistProject === `undefined` || opts.persistProject) await this.persist();
    await opts.report.startTimerPromise(`Link step`, async () => {
      const immutablePatterns = opts.immutable ? [...new Set(this.configuration.get(`immutablePatterns`))].sort() : [];
      const before = await Promise.all(immutablePatterns.map(async pattern => {
        return $5a1c67a183441e010515e193fca593e1$var$hashUtils.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));
      await this.linkEverything(opts);
      const after = await Promise.all(immutablePatterns.map(async pattern => {
        return $5a1c67a183441e010515e193fca593e1$var$hashUtils.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));

      for (let t = 0; t < immutablePatterns.length; ++t) {
        if (before[t] !== after[t]) {
          opts.report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.FROZEN_ARTIFACT_EXCEPTION, `The checksum for ${immutablePatterns[t]} has been modified by this install, which is explicitly forbidden.`);
        }
      }
    });
    await this.persistInstallStateFile();
    await this.configuration.triggerHook(hooks => {
      return hooks.afterAllInstalled;
    }, this, opts);
  }

  generateLockfile() {
    // We generate the data structure that will represent our lockfile. To do this, we create a
    // reverse lookup table, where the key will be the resolved locator and the value will be a set
    // of all the descriptors that resolved to it. Then we use it to construct an optimized version
    // if the final object.
    const reverseLookup = new Map();

    for (const [descriptorHash, locatorHash] of this.storedResolutions.entries()) {
      let descriptorHashes = reverseLookup.get(locatorHash);
      if (!descriptorHashes) reverseLookup.set(locatorHash, descriptorHashes = new Set());
      descriptorHashes.add(descriptorHash);
    }

    const optimizedLockfile = {};
    optimizedLockfile.__metadata = {
      version: $5a1c67a183441e010515e193fca593e1$var$LOCKFILE_VERSION
    };

    for (const [locatorHash, descriptorHashes] of reverseLookup.entries()) {
      const pkg = this.originalPackages.get(locatorHash); // A resolution that isn't in `originalPackages` is a virtual packages.
      // Since virtual packages can be derived from the information stored in
      // the rest of the lockfile we don't want to bother storing them.

      // A resolution that isn't in `originalPackages` is a virtual packages.
      // Since virtual packages can be derived from the information stored in
      // the rest of the lockfile we don't want to bother storing them.
      if (!pkg) continue;
      const descriptors = [];

      for (const descriptorHash of descriptorHashes) {
        const descriptor = this.storedDescriptors.get(descriptorHash);
        if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been registered`);
        descriptors.push(descriptor);
      }

      const key = descriptors.map(descriptor => {
        return $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyDescriptor(descriptor);
      }).sort().join(`, `);
      const manifest = new $e51f99366c3d7ff19a0ceeed21bc69c1$exports.Manifest();
      manifest.version = pkg.linkType === $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType.HARD ? pkg.version : `0.0.0-use.local`;
      manifest.languageName = pkg.languageName;
      manifest.dependencies = new Map(pkg.dependencies);
      manifest.peerDependencies = new Map(pkg.peerDependencies);
      manifest.dependenciesMeta = new Map(pkg.dependenciesMeta);
      manifest.peerDependenciesMeta = new Map(pkg.peerDependenciesMeta);
      manifest.bin = new Map(pkg.bin);
      let entryChecksum;
      const checksum = this.storedChecksums.get(pkg.locatorHash);

      if (typeof checksum !== `undefined`) {
        const cacheKeyIndex = checksum.indexOf(`/`);
        if (cacheKeyIndex === -1) throw new Error(`Assertion failed: Expecte the checksum to reference its cache key`);
        const cacheKey = checksum.slice(0, cacheKeyIndex);
        const hash = checksum.slice(cacheKeyIndex + 1);
        if (typeof optimizedLockfile.__metadata.cacheKey === `undefined`) optimizedLockfile.__metadata.cacheKey = cacheKey;

        if (cacheKey === optimizedLockfile.__metadata.cacheKey) {
          entryChecksum = hash;
        } else {
          entryChecksum = checksum;
        }
      }

      optimizedLockfile[key] = { ...manifest.exportTo({}, {
          compatibilityMode: false
        }),
        linkType: pkg.linkType.toLowerCase(),
        resolution: $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyLocator(pkg),
        checksum: entryChecksum
      };
    }

    const header = `${[`# This file is generated by running "yarn install" inside your project.\n`, `# Manual changes might be lost - proceed with caution!\n`].join(``)}\n`;
    return header + $0e609d03a5066ebec776a5ec6a49b084$exports.stringifySyml(optimizedLockfile);
  }

  async persistLockfile() {
    const lockfilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const lockfileContent = this.generateLockfile();
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(lockfilePath, lockfileContent, {
      automaticNewlines: true
    });
  }

  async persistInstallStateFile() {
    const fields = [];

    for (const category of Object.values($5a1c67a183441e010515e193fca593e1$var$INSTALL_STATE_FIELDS)) fields.push(...category);

    const installState = $5a1c67a183441e010515e193fca593e1$var$pick_1.default(this, fields);
    const serializedState = await $5a1c67a183441e010515e193fca593e1$var$gzip($5a1c67a183441e010515e193fca593e1$var$v8_1.default.serialize(installState));
    const installStatePath = this.configuration.get(`installStatePath`);
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(installStatePath), {
      recursive: true
    });
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(installStatePath, serializedState);
  }

  async restoreInstallState({
    restoreInstallersCustomData = true,
    restoreResolutions = true
  } = {}) {
    const installStatePath = this.configuration.get(`installStatePath`);

    if (!$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(installStatePath)) {
      if (restoreResolutions) await this.applyLightResolution();
      return;
    }

    const serializedState = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(installStatePath);
    const installState = $5a1c67a183441e010515e193fca593e1$var$v8_1.default.deserialize(await $5a1c67a183441e010515e193fca593e1$var$gunzip(serializedState));
    if (restoreInstallersCustomData) if (typeof installState.installersCustomData !== `undefined`) this.installersCustomData = installState.installersCustomData;

    if (restoreResolutions) {
      if (installState.lockFileChecksum === this.lockFileChecksum) {
        Object.assign(this, $5a1c67a183441e010515e193fca593e1$var$pick_1.default(installState, $5a1c67a183441e010515e193fca593e1$var$INSTALL_STATE_FIELDS.restoreResolutions));
        this.refreshWorkspaceDependencies();
      } else {
        await this.applyLightResolution();
      }
    }
  }

  async applyLightResolution() {
    await this.resolveEverything({
      lockfileOnly: true,
      report: new $5f04f86dd2d8bf5d53be16d63b07475f$exports.ThrowReport()
    });
    await this.persistInstallStateFile();
  }

  async persist() {
    await this.persistLockfile();

    for (const workspace of this.workspacesByCwd.values()) {
      await workspace.persistManifest();
    }
  }

  async cacheCleanup({
    cache,
    report
  }) {
    const PRESERVED_FILES = new Set([`.gitignore`]);
    if (!$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(cache.cwd)) return;
    if (!$4e053bc37466537c5bd23b074c01d016$exports.isFolderInside(cache.cwd, this.cwd)) return;

    for (const entry of await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readdirPromise(cache.cwd)) {
      if (PRESERVED_FILES.has(entry)) continue;
      const entryPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(cache.cwd, entry);
      if (cache.markedFiles.has(entryPath)) continue;

      if (cache.immutable) {
        report.reportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.IMMUTABLE_CACHE, `${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, $ea9c1e38c3e8cca334929a597a084311$exports.ppath.basename(entryPath), `magenta`)} appears to be unused and would marked for deletion, but the cache is immutable`);
      } else {
        report.reportInfo($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNUSED_CACHE_ENTRY, `${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(this.configuration, $ea9c1e38c3e8cca334929a597a084311$exports.ppath.basename(entryPath), `magenta`)} appears to be unused - removing`);
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(entryPath);
      }
    }

    cache.markedFiles.clear();
  }

}

$5a1c67a183441e010515e193fca593e1$export$Project = $5a1c67a183441e010515e193fca593e1$var$Project;
$5a1c67a183441e010515e193fca593e1$exports.Project = $5a1c67a183441e010515e193fca593e1$export$Project;
/**
 * This function is worth some documentation. It takes a set of packages,
 * traverses them all, and generates virtual packages for each package that
 * lists peer dependencies.
 *
 * We also take advantage of the tree traversal to detect which packages are
 * actually used and which have disappeared, and to know which packages truly
 * have an optional build (since a package may be optional in one part of the
 * tree but not another).
 */

/**
 * This function is worth some documentation. It takes a set of packages,
 * traverses them all, and generates virtual packages for each package that
 * lists peer dependencies.
 *
 * We also take advantage of the tree traversal to detect which packages are
 * actually used and which have disappeared, and to know which packages truly
 * have an optional build (since a package may be optional in one part of the
 * tree but not another).
 */
function $5a1c67a183441e010515e193fca593e1$var$applyVirtualResolutionMutations({
  project,
  allDescriptors,
  allResolutions,
  allPackages,
  accessibleLocators = new Set(),
  optionalBuilds = new Set(),
  volatileDescriptors = new Set(),
  peerRequirements = new Map(),
  report,
  tolerateMissingPackages = false
}) {
  var _a;

  const virtualStack = new Map();
  const resolutionStack = [];
  const allIdents = new Map(); // We'll be keeping track of all virtual descriptors; once they have all
  // been generated we'll check whether they can be consolidated into one.

  // We'll be keeping track of all virtual descriptors; once they have all
  // been generated we'll check whether they can be consolidated into one.
  const allVirtualInstances = new Map();
  const allVirtualDependents = new Map(); // First key is the first package that requests the peer dependency. Second
  // key is the name of the package in the peer dependency. Value is the list
  // of all packages that extend the original peer requirement.

  // First key is the first package that requests the peer dependency. Second
  // key is the name of the package in the peer dependency. Value is the list
  // of all packages that extend the original peer requirement.
  const peerDependencyLinks = new Map(); // We keep track on which package depend on which other package with peer
  // dependencies; this way we can emit warnings for them later on.

  // We keep track on which package depend on which other package with peer
  // dependencies; this way we can emit warnings for them later on.
  const peerDependencyDependents = new Map(); // We must keep a copy of the workspaces original dependencies, because they
  // may be overriden during the virtual package resolution - cf Dragon Test #5

  // We must keep a copy of the workspaces original dependencies, because they
  // may be overriden during the virtual package resolution - cf Dragon Test #5
  const originalWorkspaceDefinitions = new Map(project.workspaces.map(workspace => {
    const locatorHash = workspace.anchoredLocator.locatorHash;
    const pkg = allPackages.get(locatorHash);

    if (typeof pkg === `undefined`) {
      if (tolerateMissingPackages) {
        return [locatorHash, null];
      } else {
        throw new Error(`Assertion failed: The workspace should have an associated package`);
      }
    }

    return [locatorHash, $5a1c67a183441e010515e193fca593e1$var$structUtils.copyPackage(pkg)];
  }));

  const reportStackOverflow = () => {
    const logDir = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mktempSync();
    const logFile = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(logDir, `stacktrace.log`);
    const maxSize = String(resolutionStack.length + 1).length;
    const content = resolutionStack.map((locator, index) => {
      const prefix = `${index + 1}.`.padStart(maxSize, ` `);
      return `${prefix} ${$5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyLocator(locator)}\n`;
    }).join(``);
    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeFileSync(logFile, content);
    throw new $9baf3138444c7a279b4b3775d56e5534$exports.ReportError($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.STACK_OVERFLOW_RESOLUTION, `Encountered a stack overflow when resolving peer dependencies; cf ${logFile}`);
  };

  const getPackageFromDescriptor = descriptor => {
    const resolution = allResolutions.get(descriptor.descriptorHash);
    if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution should have been registered`);
    const pkg = allPackages.get(resolution);
    if (!pkg) throw new Error(`Assertion failed: The package could not be found`);
    return pkg;
  };

  const resolvePeerDependencies = (parentLocator, peerSlots, {
    first,
    optional
  }) => {
    if (resolutionStack.length > 1000) reportStackOverflow();
    resolutionStack.push(parentLocator);
    const result = resolvePeerDependenciesImpl(parentLocator, peerSlots, {
      first,
      optional
    });
    resolutionStack.pop();
    return result;
  };

  const resolvePeerDependenciesImpl = (parentLocator, peerSlots, {
    first,
    optional
  }) => {
    if (accessibleLocators.has(parentLocator.locatorHash)) return;
    accessibleLocators.add(parentLocator.locatorHash);
    if (!optional) optionalBuilds.delete(parentLocator.locatorHash);
    const parentPackage = allPackages.get(parentLocator.locatorHash);

    if (!parentPackage) {
      if (tolerateMissingPackages) {
        return;
      } else {
        throw new Error(`Assertion failed: The package (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(project.configuration, parentLocator)}) should have been registered`);
      }
    }

    const newVirtualInstances = [];
    const firstPass = [];
    const secondPass = [];
    const thirdPass = [];
    const fourthPass = []; // During this first pass we virtualize the descriptors. This allows us
    // to reference them from their sibling without being order-dependent,
    // which is required to solve cases where packages with peer dependencies
    // have peer dependencies themselves.

    // During this first pass we virtualize the descriptors. This allows us
    // to reference them from their sibling without being order-dependent,
    // which is required to solve cases where packages with peer dependencies
    // have peer dependencies themselves.
    for (const descriptor of Array.from(parentPackage.dependencies.values())) {
      // We shouldn't virtualize the package if it was obtained through a peer
      // dependency (which can't be the case for workspaces when resolved
      // through their top-level)
      if (parentPackage.peerDependencies.has(descriptor.identHash) && !first) continue; // We had some issues where virtual packages were incorrectly set inside
      // workspaces, causing leaks. Check the Dragon Test #5 for more details.

      // We had some issues where virtual packages were incorrectly set inside
      // workspaces, causing leaks. Check the Dragon Test #5 for more details.
      if ($5a1c67a183441e010515e193fca593e1$var$structUtils.isVirtualDescriptor(descriptor)) throw new Error(`Assertion failed: Virtual packages shouldn't be encountered when virtualizing a branch`); // Mark this package as being used (won't be removed from the lockfile)

      // Mark this package as being used (won't be removed from the lockfile)
      volatileDescriptors.delete(descriptor.descriptorHash); // Detect whether this package is being required

      // Detect whether this package is being required
      let isOptional = optional;

      if (!isOptional) {
        const dependencyMetaSet = parentPackage.dependenciesMeta.get($5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyIdent(descriptor));

        if (typeof dependencyMetaSet !== `undefined`) {
          const dependencyMeta = dependencyMetaSet.get(null);

          if (typeof dependencyMeta !== `undefined` && dependencyMeta.optional) {
            isOptional = true;
          }
        }
      }

      const resolution = allResolutions.get(descriptor.descriptorHash);

      if (!resolution) {
        // Note that we can't use `getPackageFromDescriptor` (defined below,
        // because when doing the initial tree building right after loading the
        // project it's possible that we get some entries that haven't been
        // registered into the lockfile yet - for example when the user has
        // manually changed the package.json dependencies)
        if (tolerateMissingPackages) {
          continue;
        } else {
          throw new Error(`Assertion failed: The resolution (${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
        }
      }

      const pkg = originalWorkspaceDefinitions.get(resolution) || allPackages.get(resolution);
      if (!pkg) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);

      if (pkg.peerDependencies.size === 0) {
        resolvePeerDependencies(pkg, new Map(), {
          first: false,
          optional: isOptional
        });
        continue;
      } // The stack overflow is checked against two level because a workspace
      // may have a dev dependency on another workspace that lists the first
      // one as a regular dependency. In this case the loop will break so we
      // don't need to throw an exception.


      // The stack overflow is checked against two level because a workspace
      // may have a dev dependency on another workspace that lists the first
      // one as a regular dependency. In this case the loop will break so we
      // don't need to throw an exception.
      const stackDepth = virtualStack.get(pkg.locatorHash);
      if (typeof stackDepth === `number` && stackDepth >= 2) reportStackOverflow();
      let virtualizedDescriptor;
      let virtualizedPackage;
      const missingPeerDependencies = new Set();
      let nextPeerSlots;
      firstPass.push(() => {
        virtualizedDescriptor = $5a1c67a183441e010515e193fca593e1$var$structUtils.virtualizeDescriptor(descriptor, parentLocator.locatorHash);
        virtualizedPackage = $5a1c67a183441e010515e193fca593e1$var$structUtils.virtualizePackage(pkg, parentLocator.locatorHash);
        parentPackage.dependencies.delete(descriptor.identHash);
        parentPackage.dependencies.set(virtualizedDescriptor.identHash, virtualizedDescriptor);
        allResolutions.set(virtualizedDescriptor.descriptorHash, virtualizedPackage.locatorHash);
        allDescriptors.set(virtualizedDescriptor.descriptorHash, virtualizedDescriptor);
        allPackages.set(virtualizedPackage.locatorHash, virtualizedPackage); // Keep track of all new virtual packages since we'll want to dedupe them

        // Keep track of all new virtual packages since we'll want to dedupe them
        newVirtualInstances.push([pkg, virtualizedDescriptor, virtualizedPackage]);
      });
      secondPass.push(() => {
        var _a;

        nextPeerSlots = new Map();

        for (const peerRequest of virtualizedPackage.peerDependencies.values()) {
          let peerDescriptor = parentPackage.dependencies.get(peerRequest.identHash);

          if (!peerDescriptor && $5a1c67a183441e010515e193fca593e1$var$structUtils.areIdentsEqual(parentLocator, peerRequest)) {
            peerDescriptor = $5a1c67a183441e010515e193fca593e1$var$structUtils.convertLocatorToDescriptor(parentLocator);
            allDescriptors.set(peerDescriptor.descriptorHash, peerDescriptor);
            allResolutions.set(peerDescriptor.descriptorHash, parentLocator.locatorHash);
            volatileDescriptors.delete(peerDescriptor.descriptorHash);
          }

          if (!peerDescriptor && virtualizedPackage.dependencies.has(peerRequest.identHash)) {
            virtualizedPackage.peerDependencies.delete(peerRequest.identHash);
            continue;
          }

          if (!peerDescriptor) peerDescriptor = $5a1c67a183441e010515e193fca593e1$var$structUtils.makeDescriptor(peerRequest, `missing:`);
          virtualizedPackage.dependencies.set(peerDescriptor.identHash, peerDescriptor); // Need to track when a virtual descriptor is set as a dependency in case
          // the descriptor will be consolidated.

          // Need to track when a virtual descriptor is set as a dependency in case
          // the descriptor will be consolidated.
          if ($5a1c67a183441e010515e193fca593e1$var$structUtils.isVirtualDescriptor(peerDescriptor)) {
            const dependents = $5a1c67a183441e010515e193fca593e1$var$miscUtils.getSetWithDefault(allVirtualDependents, peerDescriptor.descriptorHash);
            dependents.add(virtualizedPackage.locatorHash);
          }

          allIdents.set(peerDescriptor.identHash, peerDescriptor);
          if (peerDescriptor.range === `missing:`) missingPeerDependencies.add(peerDescriptor.identHash);
          nextPeerSlots.set(peerRequest.identHash, (_a = peerSlots.get(peerRequest.identHash)) !== null && _a !== void 0 ? _a : virtualizedPackage.locatorHash);
        } // Since we've had to add new dependencies we need to sort them all over again


        // Since we've had to add new dependencies we need to sort them all over again
        virtualizedPackage.dependencies = new Map($5a1c67a183441e010515e193fca593e1$var$miscUtils.sortMap(virtualizedPackage.dependencies, ([identHash, descriptor]) => {
          return $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyIdent(descriptor);
        }));
      });
      thirdPass.push(() => {
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;
        const current = virtualStack.get(pkg.locatorHash);
        const next = typeof current !== `undefined` ? current + 1 : 1;
        virtualStack.set(pkg.locatorHash, next);
        resolvePeerDependencies(virtualizedPackage, nextPeerSlots, {
          first: false,
          optional: isOptional
        });
        virtualStack.set(pkg.locatorHash, next - 1);
      });
      fourthPass.push(() => {
        // Regardless of whether the initial virtualized package got deduped
        // or not, we now register that *this* package is now a dependent on
        // whatever its peer dependencies have been resolved to. We'll later
        // use this information to generate warnings.
        const finalDescriptor = parentPackage.dependencies.get(descriptor.identHash);
        if (typeof finalDescriptor === `undefined`) throw new Error(`Assertion failed: Expected the peer dependency to have been turned into a dependency`);
        const finalResolution = allResolutions.get(finalDescriptor.descriptorHash);
        if (typeof finalResolution === `undefined`) throw new Error(`Assertion failed: Expected the descriptor to be registered`);
        $5a1c67a183441e010515e193fca593e1$var$miscUtils.getSetWithDefault(peerDependencyDependents, finalResolution).add(parentLocator.locatorHash);
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;

        for (const descriptor of virtualizedPackage.peerDependencies.values()) {
          const root = nextPeerSlots.get(descriptor.identHash);
          if (typeof root === `undefined`) throw new Error(`Assertion failed: Expected the peer dependency ident to be registered`);
          $5a1c67a183441e010515e193fca593e1$var$miscUtils.getArrayWithDefault($5a1c67a183441e010515e193fca593e1$var$miscUtils.getMapWithDefault(peerDependencyLinks, root), $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyIdent(descriptor)).push(virtualizedPackage.locatorHash);
        }

        for (const missingPeerDependency of missingPeerDependencies) {
          virtualizedPackage.dependencies.delete(missingPeerDependency);
        }
      });
    }

    for (const fn of [...firstPass, ...secondPass]) fn();

    let stable;

    do {
      stable = true;

      for (const [physicalLocator, virtualDescriptor, virtualPackage] of newVirtualInstances) {
        if (!allPackages.has(virtualPackage.locatorHash)) continue;
        const otherVirtualInstances = $5a1c67a183441e010515e193fca593e1$var$miscUtils.getMapWithDefault(allVirtualInstances, physicalLocator.locatorHash); // We take all the dependencies from the new virtual instance and
        // generate a hash from it. By checking if this hash is already
        // registered, we know whether we can trim the new version.

        // We take all the dependencies from the new virtual instance and
        // generate a hash from it. By checking if this hash is already
        // registered, we know whether we can trim the new version.
        const dependencyHash = $5a1c67a183441e010515e193fca593e1$var$hashUtils.makeHash(...[...virtualPackage.dependencies.values()].map(descriptor => {
          const resolution = descriptor.range !== `missing:` ? allResolutions.get(descriptor.descriptorHash) : `missing:`;
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: Expected the resolution for ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyDescriptor(project.configuration, descriptor)} to have been registered`);
          return resolution;
        }), // We use the identHash to disambiguate between virtual descriptors
        // with different base idents being resolved to the same virtual package.
        // Note: We don't use the descriptorHash because the whole point of duplicate
        // virtual descriptors is that they have different `virtual:` ranges.
        // This causes the virtual descriptors with different base idents
        // to be preserved, while the virtual package they resolve to gets deduped.
        virtualDescriptor.identHash);
        const masterDescriptor = otherVirtualInstances.get(dependencyHash);

        if (typeof masterDescriptor === `undefined`) {
          otherVirtualInstances.set(dependencyHash, virtualDescriptor);
          continue;
        } // Since we're applying multiple pass, we might have already registered
        // ourselves as the "master" descriptor in the previous pass.


        // Since we're applying multiple pass, we might have already registered
        // ourselves as the "master" descriptor in the previous pass.
        if (masterDescriptor === virtualDescriptor) continue;
        stable = false;
        allPackages.delete(virtualPackage.locatorHash);
        allDescriptors.delete(virtualDescriptor.descriptorHash);
        allResolutions.delete(virtualDescriptor.descriptorHash);
        accessibleLocators.delete(virtualPackage.locatorHash);
        const dependents = allVirtualDependents.get(virtualDescriptor.descriptorHash) || [];
        const allDependents = [parentPackage.locatorHash, ...dependents];
        allVirtualDependents.delete(virtualDescriptor.descriptorHash);

        for (const dependent of allDependents) {
          const pkg = allPackages.get(dependent);
          if (typeof pkg === `undefined`) continue;
          pkg.dependencies.set(virtualDescriptor.identHash, masterDescriptor);
        }
      }
    } while (!stable);

    for (const fn of [...thirdPass, ...fourthPass]) {
      fn();
    }
  };

  for (const workspace of project.workspaces) {
    volatileDescriptors.delete(workspace.anchoredDescriptor.descriptorHash);
    resolvePeerDependencies(workspace.anchoredLocator, new Map(), {
      first: true,
      optional: false
    });
  }

  let WarningType;

  (function (WarningType) {
    WarningType[WarningType["NotProvided"] = 0] = "NotProvided";
    WarningType[WarningType["NotCompatible"] = 1] = "NotCompatible";
  })(WarningType || (WarningType = {}));

  const warnings = [];

  for (const [rootHash, dependents] of peerDependencyDependents) {
    const root = allPackages.get(rootHash);
    if (typeof root === `undefined`) throw new Error(`Assertion failed: Expected the root to be registered`); // We retrieve the set of packages that provide complementary peer
    // dependencies to the one already offered by our root package, and to
    // whom other package.
    //
    // We simply skip if the record doesn't exist because a package may not
    // have any records if it didn't contribute any new peer (it only exists
    // if the package has at least one peer that isn't listed by its parent
    // packages).
    //

    // We retrieve the set of packages that provide complementary peer
    // dependencies to the one already offered by our root package, and to
    // whom other package.
    //
    // We simply skip if the record doesn't exist because a package may not
    // have any records if it didn't contribute any new peer (it only exists
    // if the package has at least one peer that isn't listed by its parent
    // packages).
    //
    const rootLinks = peerDependencyLinks.get(rootHash);
    if (typeof rootLinks === `undefined`) continue;

    for (const dependentHash of dependents) {
      const dependent = allPackages.get(dependentHash); // The package may have been pruned during a deduplication

      // The package may have been pruned during a deduplication
      if (typeof dependent === `undefined`) continue;

      for (const [identStr, linkHashes] of rootLinks) {
        const ident = $5a1c67a183441e010515e193fca593e1$var$structUtils.parseIdent(identStr); // This dependent may have a peer dep itself, in which case it's not
        // the true root, and we can ignore it

        // This dependent may have a peer dep itself, in which case it's not
        // the true root, and we can ignore it
        if (dependent.peerDependencies.has(ident.identHash)) continue;
        const hash = `p${$5a1c67a183441e010515e193fca593e1$var$hashUtils.makeHash(dependentHash, identStr, rootHash).slice(0, 5)}`;
        peerRequirements.set(hash, {
          subject: dependentHash,
          requested: ident,
          rootRequester: rootHash,
          allRequesters: linkHashes
        }); // Note: this can be undefined when the peer dependency isn't provided at all

        // Note: this can be undefined when the peer dependency isn't provided at all
        const resolvedDescriptor = root.dependencies.get(ident.identHash);

        if (typeof resolvedDescriptor !== `undefined`) {
          const peerResolution = getPackageFromDescriptor(resolvedDescriptor);
          const peerVersion = (_a = peerResolution.version) !== null && _a !== void 0 ? _a : `0.0.0`;
          const ranges = new Set();

          for (const linkHash of linkHashes) {
            const link = allPackages.get(linkHash);
            if (typeof link === `undefined`) throw new Error(`Assertion failed: Expected the link to be registered`);
            const peerDependency = link.peerDependencies.get(ident.identHash);
            if (typeof peerDependency === `undefined`) throw new Error(`Assertion failed: Expected the ident to be registered`);
            ranges.add(peerDependency.range);
          }

          const satisfiesAll = [...ranges].every(range => {
            return $5a1c67a183441e010515e193fca593e1$var$semverUtils.satisfiesWithPrereleases(peerVersion, range);
          });

          if (!satisfiesAll) {
            warnings.push({
              type: WarningType.NotCompatible,
              subject: dependent,
              requested: ident,
              requester: root,
              version: peerVersion,
              hash,
              requirementCount: linkHashes.length
            });
          }
        } else {
          const peerDependencyMeta = root.peerDependenciesMeta.get(identStr);

          if (!(peerDependencyMeta === null || peerDependencyMeta === void 0 ? void 0 : peerDependencyMeta.optional)) {
            warnings.push({
              type: WarningType.NotProvided,
              subject: dependent,
              requested: ident,
              requester: root,
              hash
            });
          }
        }
      }
    }
  }

  const warningSortCriterias = [warning => $5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocatorNoColors(warning.subject), warning => $5a1c67a183441e010515e193fca593e1$var$structUtils.stringifyIdent(warning.requested), warning => `${warning.type}`];

  for (const warning of $5a1c67a183441e010515e193fca593e1$var$miscUtils.sortMap(warnings, warningSortCriterias)) {
    switch (warning.type) {
      case WarningType.NotProvided:
        {
          report === null || report === void 0 ? void 0 : report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.MISSING_PEER_DEPENDENCY, `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(project.configuration, warning.subject)} doesn't provide ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(project.configuration, warning.requested)} (${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(project.configuration, warning.hash, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.CODE)}), requested by ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(project.configuration, warning.requester)}`);
        }
        break;

      case WarningType.NotCompatible:
        {
          const andDescendants = warning.requirementCount > 1 ? `and some of its descendants request` : `requests`;
          report === null || report === void 0 ? void 0 : report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.INCOMPATIBLE_PEER_DEPENDENCY, `${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyLocator(project.configuration, warning.subject)} provides ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(project.configuration, warning.requested)} (${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(project.configuration, warning.hash, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.CODE)}) with version ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyReference(project.configuration, warning.version)}, which doesn't satisfy what ${$5a1c67a183441e010515e193fca593e1$var$structUtils.prettyIdent(project.configuration, warning.requester)} ${andDescendants}`);
        }
        break;
    }
  }

  if (warnings.length > 0) {
    report === null || report === void 0 ? void 0 : report.reportWarning($3d67898ffca54ab381ec6b3d32821fc7$exports.MessageName.UNNAMED, `Some peer dependencies are incorrectly met; run ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(project.configuration, `yarn explain peer-requirements <hash>`, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.CODE)} for details, where ${$5a1c67a183441e010515e193fca593e1$var$formatUtils.pretty(project.configuration, `<hash>`, $5a1c67a183441e010515e193fca593e1$var$formatUtils.Type.CODE)} is the six-letter p-prefixed code`);
  }
}

Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Project", {
  enumerable: true,
  get: function () {
    return $5a1c67a183441e010515e193fca593e1$exports.Project;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "TAG_REGEXP", {
  enumerable: true,
  get: function () {
    return $75d39c0c5e08a7896c4fa0e540ce7c49$exports.TAG_REGEXP;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "ReportError", {
  enumerable: true,
  get: function () {
    return $9baf3138444c7a279b4b3775d56e5534$exports.ReportError;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Report", {
  enumerable: true,
  get: function () {
    return $9baf3138444c7a279b4b3775d56e5534$exports.Report;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "StreamReport", {
  enumerable: true,
  get: function () {
    return $4aa00afc119f35e9c4530bef5e53f2e3$exports.StreamReport;
  }
});
// ASSET: node_modules/@yarnpkg/core/lib/TelemetryManager.js
var $02123eea8263fe2d8714fb7cf43fcbfd$export$MetricName,
    $02123eea8263fe2d8714fb7cf43fcbfd$exports = {};
var $02123eea8263fe2d8714fb7cf43fcbfd$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($02123eea8263fe2d8714fb7cf43fcbfd$exports, "__esModule", {
  value: true
});
var $02123eea8263fe2d8714fb7cf43fcbfd$export$TelemetryManager = ($02123eea8263fe2d8714fb7cf43fcbfd$export$MetricName = void 0, $02123eea8263fe2d8714fb7cf43fcbfd$exports.MetricName = $02123eea8263fe2d8714fb7cf43fcbfd$export$MetricName);
$02123eea8263fe2d8714fb7cf43fcbfd$exports.TelemetryManager = $02123eea8263fe2d8714fb7cf43fcbfd$export$TelemetryManager;
const $02123eea8263fe2d8714fb7cf43fcbfd$var$httpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($c3e5d886185f7e0081994c42f78051e1$exports);
const $02123eea8263fe2d8714fb7cf43fcbfd$var$miscUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($dcb6c32e8116e2ce740eb0f8758d7b31$exports);
var $02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName;

(function (MetricName) {
  MetricName["VERSION"] = "version";
  MetricName["COMMAND_NAME"] = "commandName";
  MetricName["PLUGIN_NAME"] = "pluginName";
  MetricName["INSTALL_COUNT"] = "installCount";
  MetricName["PROJECT_COUNT"] = "projectCount";
  MetricName["WORKSPACE_COUNT"] = "workspaceCount";
  MetricName["DEPENDENCY_COUNT"] = "dependencyCount";
  MetricName["EXTENSION"] = "packageExtension";
})($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName = $02123eea8263fe2d8714fb7cf43fcbfd$exports.MetricName || ($02123eea8263fe2d8714fb7cf43fcbfd$export$MetricName = {}, $02123eea8263fe2d8714fb7cf43fcbfd$exports.MetricName = $02123eea8263fe2d8714fb7cf43fcbfd$export$MetricName));

class $02123eea8263fe2d8714fb7cf43fcbfd$var$TelemetryManager {
  constructor(configuration, accountId) {
    this.values = new Map();
    this.hits = new Map();
    this.enumerators = new Map();
    this.configuration = configuration;
    const registryFile = this.getRegistryPath();
    this.isNew = !$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(registryFile);
    this.sendReport(accountId);
    this.startBuffer();
  }

  reportVersion(value) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.VERSION, value);
  }

  reportCommandName(value) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.COMMAND_NAME, value || `<none>`);
  }

  reportPluginName(value) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.PLUGIN_NAME, value);
  }

  reportProject(cwd) {
    this.reportEnumerator($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.PROJECT_COUNT, cwd);
  }

  reportInstall(nodeLinker) {
    this.reportHit($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.INSTALL_COUNT, nodeLinker);
  }

  reportPackageExtension(value) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.EXTENSION, value);
  }

  reportWorkspaceCount(count) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.WORKSPACE_COUNT, String(count));
  }

  reportDependencyCount(count) {
    this.reportValue($02123eea8263fe2d8714fb7cf43fcbfd$var$MetricName.DEPENDENCY_COUNT, String(count));
  }

  reportValue(metric, value) {
    $02123eea8263fe2d8714fb7cf43fcbfd$var$miscUtils.getSetWithDefault(this.values, metric).add(value);
  }

  reportEnumerator(metric, value) {
    $02123eea8263fe2d8714fb7cf43fcbfd$var$miscUtils.getSetWithDefault(this.enumerators, metric).add(value);
  }

  reportHit(metric, extra = `*`) {
    const ns = $02123eea8263fe2d8714fb7cf43fcbfd$var$miscUtils.getMapWithDefault(this.hits, metric);
    const current = $02123eea8263fe2d8714fb7cf43fcbfd$var$miscUtils.getFactoryWithDefault(ns, extra, () => 0);
    ns.set(extra, current + 1);
  }

  getRegistryPath() {
    const registryFile = this.configuration.get(`globalFolder`);
    return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(registryFile, `telemetry.json`);
  }

  sendReport(accountId) {
    var _a, _b, _c;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readJsonSync(registryFile);
    } catch (_d) {
      content = {};
    }

    const now = Date.now();
    const interval = this.configuration.get(`telemetryInterval`) * 24 * 60 * 60 * 1000;
    const lastUpdate = (_a = content.lastUpdate) !== null && _a !== void 0 ? _a : now + interval + Math.floor(interval * Math.random());
    const nextUpdate = lastUpdate + interval;
    if (nextUpdate > now && content.lastUpdate != null) return;

    try {
      $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(registryFile), {
        recursive: true
      });
      $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeJsonSync(registryFile, {
        lastUpdate: now
      });
    } catch (_e) {
      // In some cases this location is read-only. Too bad 
      return;
    }

    if (nextUpdate > now) return;
    if (!content.blocks) return;

    for (const [userId, block] of Object.entries((_b = content.blocks) !== null && _b !== void 0 ? _b : {})) {
      if (Object.keys(block).length === 0) continue;
      const upload = block;
      upload.userId = userId;

      for (const key of Object.keys((_c = upload.enumerators) !== null && _c !== void 0 ? _c : {})) upload.enumerators[key] = upload.enumerators[key].length;

      const rawUrl = `https://browser-http-intake.logs.datadoghq.eu/v1/input/${accountId}?ddsource=yarn`;
      $02123eea8263fe2d8714fb7cf43fcbfd$var$httpUtils.post(rawUrl, upload, {
        configuration: this.configuration
      }).catch(() => {// Nothing we can do
      });
    }
  }

  applyChanges() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readJsonSync(registryFile);
    } catch (_k) {
      content = {};
    }

    const userId = (_a = this.configuration.get(`telemetryUserId`)) !== null && _a !== void 0 ? _a : `*`;
    const blocks = content.blocks = (_b = content.blocks) !== null && _b !== void 0 ? _b : {};
    const block = blocks[userId] = (_c = blocks[userId]) !== null && _c !== void 0 ? _c : {};

    for (const key of this.hits.keys()) {
      const store = block.hits = (_d = block.hits) !== null && _d !== void 0 ? _d : {};
      const ns = store[key] = (_e = store[key]) !== null && _e !== void 0 ? _e : {};

      for (const [extra, value] of this.hits.get(key)) {
        ns[extra] = ((_f = ns[extra]) !== null && _f !== void 0 ? _f : 0) + value;
      }
    }

    for (const field of [`values`, `enumerators`]) {
      for (const key of this[field].keys()) {
        const store = block[field] = (_g = block[field]) !== null && _g !== void 0 ? _g : {};
        store[key] = [...new Set([...((_h = store[key]) !== null && _h !== void 0 ? _h : []), ...((_j = this[field].get(key)) !== null && _j !== void 0 ? _j : [])])];
      }
    }

    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(registryFile), {
      recursive: true
    });
    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.writeJsonSync(registryFile, content);
  }

  startBuffer() {
    $02123eea8263fe2d8714fb7cf43fcbfd$var$process.on(`exit`, () => {
      try {
        this.applyChanges();
      } catch (_a) {// Explicitly ignore errors
      }
    });
  }

}

$02123eea8263fe2d8714fb7cf43fcbfd$export$TelemetryManager = $02123eea8263fe2d8714fb7cf43fcbfd$var$TelemetryManager;
$02123eea8263fe2d8714fb7cf43fcbfd$exports.TelemetryManager = $02123eea8263fe2d8714fb7cf43fcbfd$export$TelemetryManager;
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "TelemetryManager", {
  enumerable: true,
  get: function () {
    return $02123eea8263fe2d8714fb7cf43fcbfd$exports.TelemetryManager;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "ThrowReport", {
  enumerable: true,
  get: function () {
    return $5f04f86dd2d8bf5d53be16d63b07475f$exports.ThrowReport;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "VirtualFetcher", {
  enumerable: true,
  get: function () {
    return $fc50e50f7b33bbd0cc6647e8b74fa144$exports.VirtualFetcher;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "WorkspaceResolver", {
  enumerable: true,
  get: function () {
    return $e51615528f8e8c3722173c3f23aaa762$exports.WorkspaceResolver;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "Workspace", {
  enumerable: true,
  get: function () {
    return $53a1bf8d1aa816c3899ae1d956d5c1fc$exports.Workspace;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "YarnVersion", {
  enumerable: true,
  get: function () {
    return $20f6fdfeae1ebf083311e47fc70a4ef9$exports.YarnVersion;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "LinkType", {
  enumerable: true,
  get: function () {
    return $f987e6a0bb0b2110da898bacaa7fa048$exports.LinkType;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "PackageExtensionType", {
  enumerable: true,
  get: function () {
    return $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionType;
  }
});
Object.defineProperty($b0ffa420366ed37c7cf8ff798018d16e$exports, "PackageExtensionStatus", {
  enumerable: true,
  get: function () {
    return $f987e6a0bb0b2110da898bacaa7fa048$exports.PackageExtensionStatus;
  }
});
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/index.js
var $48439b5f02e9ef8477201a3c8a138bf4$exports = {};
Object.defineProperty($48439b5f02e9ef8477201a3c8a138bf4$exports, "__esModule", {
  value: true
});
var $48439b5f02e9ef8477201a3c8a138bf4$export$npmPublishUtils = ($48439b5f02e9ef8477201a3c8a138bf4$export$npmHttpUtils = ($48439b5f02e9ef8477201a3c8a138bf4$export$npmConfigUtils = void 0, $48439b5f02e9ef8477201a3c8a138bf4$exports.npmConfigUtils = $48439b5f02e9ef8477201a3c8a138bf4$export$npmConfigUtils), $48439b5f02e9ef8477201a3c8a138bf4$exports.npmHttpUtils = $48439b5f02e9ef8477201a3c8a138bf4$export$npmHttpUtils);
$48439b5f02e9ef8477201a3c8a138bf4$exports.npmPublishUtils = $48439b5f02e9ef8477201a3c8a138bf4$export$npmPublishUtils;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/NpmHttpFetcher.js
var $37285373e8fb0da7ee7b67f42e20ca03$exports = {};
Object.defineProperty($37285373e8fb0da7ee7b67f42e20ca03$exports, "__esModule", {
  value: true
});
var $37285373e8fb0da7ee7b67f42e20ca03$export$NpmHttpFetcher = void 0;
$37285373e8fb0da7ee7b67f42e20ca03$exports.NpmHttpFetcher = $37285373e8fb0da7ee7b67f42e20ca03$export$NpmHttpFetcher;
const $37285373e8fb0da7ee7b67f42e20ca03$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/constants.js
var $73afd262738593261faf4a38ff3c6e04$exports = {};
Object.defineProperty($73afd262738593261faf4a38ff3c6e04$exports, "__esModule", {
  value: true
});
var $73afd262738593261faf4a38ff3c6e04$export$PROTOCOL = void 0;
$73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL = $73afd262738593261faf4a38ff3c6e04$export$PROTOCOL;
$73afd262738593261faf4a38ff3c6e04$export$PROTOCOL = `npm:`;
$73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL = $73afd262738593261faf4a38ff3c6e04$export$PROTOCOL;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/npmHttpUtils.js
var $41a32cdc447deb2a4ab2d241e28dfd00$export$AuthType,
    $41a32cdc447deb2a4ab2d241e28dfd00$exports = {};
var $41a32cdc447deb2a4ab2d241e28dfd00$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($41a32cdc447deb2a4ab2d241e28dfd00$exports, "__esModule", {
  value: true
});
var $41a32cdc447deb2a4ab2d241e28dfd00$export$del = ($41a32cdc447deb2a4ab2d241e28dfd00$export$put = ($41a32cdc447deb2a4ab2d241e28dfd00$export$post = ($41a32cdc447deb2a4ab2d241e28dfd00$export$get = ($41a32cdc447deb2a4ab2d241e28dfd00$export$getIdentUrl = ($41a32cdc447deb2a4ab2d241e28dfd00$export$handleInvalidAuthenticationError = ($41a32cdc447deb2a4ab2d241e28dfd00$export$AuthType = void 0, $41a32cdc447deb2a4ab2d241e28dfd00$exports.AuthType = $41a32cdc447deb2a4ab2d241e28dfd00$export$AuthType), $41a32cdc447deb2a4ab2d241e28dfd00$exports.handleInvalidAuthenticationError = $41a32cdc447deb2a4ab2d241e28dfd00$export$handleInvalidAuthenticationError), $41a32cdc447deb2a4ab2d241e28dfd00$exports.getIdentUrl = $41a32cdc447deb2a4ab2d241e28dfd00$export$getIdentUrl), $41a32cdc447deb2a4ab2d241e28dfd00$exports.get = $41a32cdc447deb2a4ab2d241e28dfd00$export$get), $41a32cdc447deb2a4ab2d241e28dfd00$exports.post = $41a32cdc447deb2a4ab2d241e28dfd00$export$post), $41a32cdc447deb2a4ab2d241e28dfd00$exports.put = $41a32cdc447deb2a4ab2d241e28dfd00$export$put);
$41a32cdc447deb2a4ab2d241e28dfd00$exports.del = $41a32cdc447deb2a4ab2d241e28dfd00$export$del;
const $41a32cdc447deb2a4ab2d241e28dfd00$var$enquirer_1 = {};
const $41a32cdc447deb2a4ab2d241e28dfd00$var$url_1 = $01fe9125d93857b2c37f913e6e158a9e$init();
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/npmConfigUtils.js
var $3d4ee1be33d8fcfcf3355ad19314ad10$export$RegistryType,
    $3d4ee1be33d8fcfcf3355ad19314ad10$exports = {};
Object.defineProperty($3d4ee1be33d8fcfcf3355ad19314ad10$exports, "__esModule", {
  value: true
});
var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getAuthConfiguration = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeConfiguration = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$getRegistryConfiguration = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$getDefaultRegistry = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeRegistry = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$getPublishRegistry = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$normalizeRegistry = ($3d4ee1be33d8fcfcf3355ad19314ad10$export$RegistryType = void 0, $3d4ee1be33d8fcfcf3355ad19314ad10$exports.RegistryType = $3d4ee1be33d8fcfcf3355ad19314ad10$export$RegistryType), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.normalizeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$normalizeRegistry), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.getPublishRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getPublishRegistry), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.getScopeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeRegistry), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.getDefaultRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getDefaultRegistry), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.getRegistryConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getRegistryConfiguration), $3d4ee1be33d8fcfcf3355ad19314ad10$exports.getScopeConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeConfiguration);
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getAuthConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getAuthConfiguration;
var $3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType;

(function (RegistryType) {
  RegistryType["FETCH_REGISTRY"] = "npmRegistryServer";
  RegistryType["PUBLISH_REGISTRY"] = "npmPublishRegistry";
})($3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType = $3d4ee1be33d8fcfcf3355ad19314ad10$exports.RegistryType || ($3d4ee1be33d8fcfcf3355ad19314ad10$export$RegistryType = {}, $3d4ee1be33d8fcfcf3355ad19314ad10$exports.RegistryType = $3d4ee1be33d8fcfcf3355ad19314ad10$export$RegistryType));

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry(registry) {
  return registry.replace(/\/$/, ``);
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$normalizeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.normalizeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$normalizeRegistry;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getPublishRegistry(manifest, {
  configuration
}) {
  if (manifest.publishConfig && manifest.publishConfig.registry) return $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry(manifest.publishConfig.registry);
  if (manifest.name) return $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeRegistry(manifest.name.scope, {
    configuration,
    type: $3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType.PUBLISH_REGISTRY
  });
  return $3d4ee1be33d8fcfcf3355ad19314ad10$var$getDefaultRegistry({
    configuration,
    type: $3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType.PUBLISH_REGISTRY
  });
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getPublishRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getPublishRegistry;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getPublishRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getPublishRegistry;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeRegistry(scope, {
  configuration,
  type = $3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType.FETCH_REGISTRY
}) {
  const scopeConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeConfiguration(scope, {
    configuration
  });
  if (scopeConfiguration === null) return $3d4ee1be33d8fcfcf3355ad19314ad10$var$getDefaultRegistry({
    configuration,
    type
  });
  const scopeRegistry = scopeConfiguration.get(type);
  if (scopeRegistry === null) return $3d4ee1be33d8fcfcf3355ad19314ad10$var$getDefaultRegistry({
    configuration,
    type
  });
  return $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry(scopeRegistry);
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeRegistry;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getScopeRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeRegistry;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getDefaultRegistry({
  configuration,
  type = $3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType.FETCH_REGISTRY
}) {
  const defaultRegistry = configuration.get(type);
  if (defaultRegistry !== null) return $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry(defaultRegistry);
  return $3d4ee1be33d8fcfcf3355ad19314ad10$var$normalizeRegistry(configuration.get($3d4ee1be33d8fcfcf3355ad19314ad10$var$RegistryType.FETCH_REGISTRY));
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getDefaultRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getDefaultRegistry;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getDefaultRegistry = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getDefaultRegistry;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getRegistryConfiguration(registry, {
  configuration
}) {
  const registryConfigurations = configuration.get(`npmRegistries`);
  const exactEntry = registryConfigurations.get(registry);
  if (typeof exactEntry !== `undefined`) return exactEntry;
  const noProtocolEntry = registryConfigurations.get(registry.replace(/^[a-z]+:/, ``));
  if (typeof noProtocolEntry !== `undefined`) return noProtocolEntry;
  return null;
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getRegistryConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getRegistryConfiguration;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getRegistryConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getRegistryConfiguration;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeConfiguration(scope, {
  configuration
}) {
  if (scope === null) return null;
  const scopeConfigurations = configuration.get(`npmScopes`);
  const scopeConfiguration = scopeConfigurations.get(scope);
  if (!scopeConfiguration) return null;
  return scopeConfiguration;
}

var $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeConfiguration;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getScopeConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getScopeConfiguration;

function $3d4ee1be33d8fcfcf3355ad19314ad10$var$getAuthConfiguration(registry, {
  configuration,
  ident
}) {
  const scopeConfiguration = ident && $3d4ee1be33d8fcfcf3355ad19314ad10$var$getScopeConfiguration(ident.scope, {
    configuration
  });
  if ((scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthIdent`)) || (scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthToken`))) return scopeConfiguration;
  const registryConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getRegistryConfiguration(registry, {
    configuration
  });
  return registryConfiguration || configuration;
}

$3d4ee1be33d8fcfcf3355ad19314ad10$export$getAuthConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$var$getAuthConfiguration;
$3d4ee1be33d8fcfcf3355ad19314ad10$exports.getAuthConfiguration = $3d4ee1be33d8fcfcf3355ad19314ad10$export$getAuthConfiguration;
const $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($3d4ee1be33d8fcfcf3355ad19314ad10$exports);
var $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType;

(function (AuthType) {
  AuthType[AuthType["NO_AUTH"] = 0] = "NO_AUTH";
  AuthType[AuthType["BEST_EFFORT"] = 1] = "BEST_EFFORT";
  AuthType[AuthType["CONFIGURATION"] = 2] = "CONFIGURATION";
  AuthType[AuthType["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
})($41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType = $41a32cdc447deb2a4ab2d241e28dfd00$exports.AuthType || ($41a32cdc447deb2a4ab2d241e28dfd00$export$AuthType = {}, $41a32cdc447deb2a4ab2d241e28dfd00$exports.AuthType = $41a32cdc447deb2a4ab2d241e28dfd00$export$AuthType));
/**
 * Consumes all 401 Unauthorized errors and reports them as `AUTHENTICATION_INVALID`.
 *
 * It doesn't handle 403 Forbidden, as the npm registry uses it when the user attempts
 * a prohibited action, such as publishing a package with a similar name to an existing package.
 */


/**
 * Consumes all 401 Unauthorized errors and reports them as `AUTHENTICATION_INVALID`.
 *
 * It doesn't handle 403 Forbidden, as the npm registry uses it when the user attempts
 * a prohibited action, such as publishing a package with a similar name to an existing package.
 */
async function $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
  attemptedAs,
  registry,
  headers,
  configuration
}) {
  if (error.name === `HTTPError` && error.response.statusCode === 401) {
    throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await $41a32cdc447deb2a4ab2d241e28dfd00$var$whoami(registry, headers, {
      configuration
    })}` : `attempted as ${attemptedAs}`})`);
  }
}

var $41a32cdc447deb2a4ab2d241e28dfd00$export$handleInvalidAuthenticationError = $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.handleInvalidAuthenticationError = $41a32cdc447deb2a4ab2d241e28dfd00$export$handleInvalidAuthenticationError;

function $41a32cdc447deb2a4ab2d241e28dfd00$var$getIdentUrl(ident) {
  if (ident.scope) {
    return `/@${ident.scope}%2f${ident.name}`;
  } else {
    return `/${ident.name}`;
  }
}

var $41a32cdc447deb2a4ab2d241e28dfd00$export$getIdentUrl = $41a32cdc447deb2a4ab2d241e28dfd00$var$getIdentUrl;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.getIdentUrl = $41a32cdc447deb2a4ab2d241e28dfd00$export$getIdentUrl;

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$get(path, {
  configuration,
  headers,
  ident,
  authType,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils.getScopeRegistry(ident.scope, {
    configuration
  });
  if (ident && ident.scope && typeof authType === `undefined`) authType = $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.BEST_EFFORT;
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = $41a32cdc447deb2a4ab2d241e28dfd00$var$getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };
  let url;

  try {
    url = new $41a32cdc447deb2a4ab2d241e28dfd00$var$url_1.URL(path);
  } catch (e) {
    url = new $41a32cdc447deb2a4ab2d241e28dfd00$var$url_1.URL(registry + path);
  }

  try {
    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.get(url.href, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
      registry,
      configuration,
      headers
    });
    throw error;
  }
}

var $41a32cdc447deb2a4ab2d241e28dfd00$export$get = $41a32cdc447deb2a4ab2d241e28dfd00$var$get;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.get = $41a32cdc447deb2a4ab2d241e28dfd00$export$get;

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$post(path, body, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = $41a32cdc447deb2a4ab2d241e28dfd00$var$getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.post(registry + path, body, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!$41a32cdc447deb2a4ab2d241e28dfd00$var$isOtpError(error)) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await $41a32cdc447deb2a4ab2d241e28dfd00$var$askForOtp();
    const headersWithOtp = { ...headers,
      ...$41a32cdc447deb2a4ab2d241e28dfd00$var$getOtpHeaders(otp)
    }; // Retrying request with OTP

    // Retrying request with OTP
    try {
      return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.post(`${registry}${path}`, body, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}

var $41a32cdc447deb2a4ab2d241e28dfd00$export$post = $41a32cdc447deb2a4ab2d241e28dfd00$var$post;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.post = $41a32cdc447deb2a4ab2d241e28dfd00$export$post;

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$put(path, body, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = $41a32cdc447deb2a4ab2d241e28dfd00$var$getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.put(registry + path, body, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!$41a32cdc447deb2a4ab2d241e28dfd00$var$isOtpError(error)) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await $41a32cdc447deb2a4ab2d241e28dfd00$var$askForOtp();
    const headersWithOtp = { ...headers,
      ...$41a32cdc447deb2a4ab2d241e28dfd00$var$getOtpHeaders(otp)
    }; // Retrying request with OTP

    // Retrying request with OTP
    try {
      return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.put(`${registry}${path}`, body, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}

var $41a32cdc447deb2a4ab2d241e28dfd00$export$put = $41a32cdc447deb2a4ab2d241e28dfd00$var$put;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.put = $41a32cdc447deb2a4ab2d241e28dfd00$export$put;

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$del(path, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = $41a32cdc447deb2a4ab2d241e28dfd00$var$getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.del(registry + path, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!$41a32cdc447deb2a4ab2d241e28dfd00$var$isOtpError(error)) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await $41a32cdc447deb2a4ab2d241e28dfd00$var$askForOtp();
    const headersWithOtp = { ...headers,
      ...$41a32cdc447deb2a4ab2d241e28dfd00$var$getOtpHeaders(otp)
    }; // Retrying request with OTP

    // Retrying request with OTP
    try {
      return await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.del(`${registry}${path}`, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await $41a32cdc447deb2a4ab2d241e28dfd00$var$handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}

$41a32cdc447deb2a4ab2d241e28dfd00$export$del = $41a32cdc447deb2a4ab2d241e28dfd00$var$del;
$41a32cdc447deb2a4ab2d241e28dfd00$exports.del = $41a32cdc447deb2a4ab2d241e28dfd00$export$del;

function $41a32cdc447deb2a4ab2d241e28dfd00$var$getAuthenticationHeader(registry, {
  authType = $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.CONFIGURATION,
  configuration,
  ident
}) {
  const effectiveConfiguration = $41a32cdc447deb2a4ab2d241e28dfd00$var$npmConfigUtils.getAuthConfiguration(registry, {
    configuration,
    ident
  });
  const mustAuthenticate = $41a32cdc447deb2a4ab2d241e28dfd00$var$shouldAuthenticate(effectiveConfiguration, authType);
  if (!mustAuthenticate) return null;
  if (effectiveConfiguration.get(`npmAuthToken`)) return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
  if (effectiveConfiguration.get(`npmAuthIdent`)) return `Basic ${effectiveConfiguration.get(`npmAuthIdent`)}`;

  if (mustAuthenticate && authType !== $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.BEST_EFFORT) {
    throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
  } else {
    return null;
  }
}

function $41a32cdc447deb2a4ab2d241e28dfd00$var$shouldAuthenticate(authConfiguration, authType) {
  switch (authType) {
    case $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.CONFIGURATION:
      return authConfiguration.get(`npmAlwaysAuth`);

    case $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.BEST_EFFORT:
    case $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.ALWAYS_AUTH:
      return true;

    case $41a32cdc447deb2a4ab2d241e28dfd00$var$AuthType.NO_AUTH:
      return false;

    default:
      throw new Error(`Unreachable`);
  }
}

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$whoami(registry, headers, {
  configuration
}) {
  var _a;

  if (typeof headers === `undefined` || typeof headers.authorization === `undefined`) return `an anonymous user`;

  try {
    const response = await $b0ffa420366ed37c7cf8ff798018d16e$exports.httpUtils.get(new $41a32cdc447deb2a4ab2d241e28dfd00$var$url_1.URL(`${registry}/-/whoami`).href, {
      configuration,
      headers,
      jsonResponse: true
    });
    return (_a = response.username) !== null && _a !== void 0 ? _a : `an unknown user`;
  } catch (_b) {
    return `an unknown user`;
  }
}

async function $41a32cdc447deb2a4ab2d241e28dfd00$var$askForOtp() {
  if (undefined) return undefined || ``;
  const {
    otp
  } = await $41a32cdc447deb2a4ab2d241e28dfd00$var$enquirer_1.prompt({
    type: `password`,
    name: `otp`,
    message: `One-time password:`,
    required: true,
    onCancel: () => $41a32cdc447deb2a4ab2d241e28dfd00$var$process.exit(130)
  });
  return otp;
}

function $41a32cdc447deb2a4ab2d241e28dfd00$var$isOtpError(error) {
  if (error.name !== `HTTPError`) return false;

  try {
    const authMethods = error.response.headers[`www-authenticate`].split(/,\s*/).map(s => s.toLowerCase());
    return authMethods.includes(`otp`);
  } catch (e) {
    return false;
  }
}

function $41a32cdc447deb2a4ab2d241e28dfd00$var$getOtpHeaders(otp) {
  return {
    [`npm-otp`]: otp
  };
}

const $37285373e8fb0da7ee7b67f42e20ca03$var$npmHttpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($41a32cdc447deb2a4ab2d241e28dfd00$exports);

class $37285373e8fb0da7ee7b67f42e20ca03$var$NpmHttpFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    const {
      selector,
      params
    } = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseRange(locator.reference);
    if (!$37285373e8fb0da7ee7b67f42e20ca03$var$semver_1.default.valid(selector)) return false;
    if (params === null || typeof params.__archiveUrl !== `string`) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const {
      params
    } = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseRange(locator.reference);
    if (params === null || typeof params.__archiveUrl !== `string`) throw new Error(`Assertion failed: The archiveUrl querystring parameter should have been available`);
    const sourceBuffer = await $37285373e8fb0da7ee7b67f42e20ca03$var$npmHttpUtils.get(params.__archiveUrl, {
      configuration: opts.project.configuration,
      ident: locator
    });
    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.tgzUtils.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

}

$37285373e8fb0da7ee7b67f42e20ca03$export$NpmHttpFetcher = $37285373e8fb0da7ee7b67f42e20ca03$var$NpmHttpFetcher;
$37285373e8fb0da7ee7b67f42e20ca03$exports.NpmHttpFetcher = $37285373e8fb0da7ee7b67f42e20ca03$export$NpmHttpFetcher;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/NpmRemapResolver.js
var $7930d92abce34c437972be833fa09f4b$exports = {};
Object.defineProperty($7930d92abce34c437972be833fa09f4b$exports, "__esModule", {
  value: true
});
var $7930d92abce34c437972be833fa09f4b$export$NpmRemapResolver = void 0;
$7930d92abce34c437972be833fa09f4b$exports.NpmRemapResolver = $7930d92abce34c437972be833fa09f4b$export$NpmRemapResolver;

class $7930d92abce34c437972be833fa09f4b$var$NpmRemapResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    if (!$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.tryParseDescriptor(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length), true)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    const nextDescriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseDescriptor(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length), true);
    return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const nextDescriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseDescriptor(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length), true);
    return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    const nextDescriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseDescriptor(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length), true);
    return opts.resolver.getSatisfying(nextDescriptor, references, opts);
  }

  resolve(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

$7930d92abce34c437972be833fa09f4b$export$NpmRemapResolver = $7930d92abce34c437972be833fa09f4b$var$NpmRemapResolver;
$7930d92abce34c437972be833fa09f4b$exports.NpmRemapResolver = $7930d92abce34c437972be833fa09f4b$export$NpmRemapResolver;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/NpmSemverFetcher.js
var $4a2bacec51c22649330d52c82b205226$exports = {};
Object.defineProperty($4a2bacec51c22649330d52c82b205226$exports, "__esModule", {
  value: true
});
var $4a2bacec51c22649330d52c82b205226$export$NpmSemverFetcher = void 0;
$4a2bacec51c22649330d52c82b205226$exports.NpmSemverFetcher = $4a2bacec51c22649330d52c82b205226$export$NpmSemverFetcher;
const $4a2bacec51c22649330d52c82b205226$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $4a2bacec51c22649330d52c82b205226$var$url_1 = $01fe9125d93857b2c37f913e6e158a9e$init();
const $4a2bacec51c22649330d52c82b205226$var$npmConfigUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($3d4ee1be33d8fcfcf3355ad19314ad10$exports);
const $4a2bacec51c22649330d52c82b205226$var$npmHttpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($41a32cdc447deb2a4ab2d241e28dfd00$exports);

class $4a2bacec51c22649330d52c82b205226$var$NpmSemverFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    const url = new $4a2bacec51c22649330d52c82b205226$var$url_1.URL(locator.reference);
    if (!$4a2bacec51c22649330d52c82b205226$var$semver_1.default.valid(url.pathname)) return false;
    if (url.searchParams.has(`__archiveUrl`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    let sourceBuffer;

    try {
      sourceBuffer = await $4a2bacec51c22649330d52c82b205226$var$npmHttpUtils.get($4a2bacec51c22649330d52c82b205226$var$NpmSemverFetcher.getLocatorUrl(locator), {
        configuration: opts.project.configuration,
        ident: locator
      });
    } catch (error) {
      // The npm registry doesn't always support %2f when fetching the package tarballs 
      // OK: https://registry.yarnpkg.com/@emotion%2fbabel-preset-css-prop/-/babel-preset-css-prop-10.0.7.tgz
      // KO: https://registry.yarnpkg.com/@xtuc%2fieee754/-/ieee754-1.2.0.tgz
      sourceBuffer = await $4a2bacec51c22649330d52c82b205226$var$npmHttpUtils.get($4a2bacec51c22649330d52c82b205226$var$NpmSemverFetcher.getLocatorUrl(locator).replace(/%2f/g, `/`), {
        configuration: opts.project.configuration,
        ident: locator
      });
    }

    return await $b0ffa420366ed37c7cf8ff798018d16e$exports.tgzUtils.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

  static isConventionalTarballUrl(locator, url, {
    configuration
  }) {
    let registry = $4a2bacec51c22649330d52c82b205226$var$npmConfigUtils.getScopeRegistry(locator.scope, {
      configuration
    });
    const path = $4a2bacec51c22649330d52c82b205226$var$NpmSemverFetcher.getLocatorUrl(locator); // From time to time the npm registry returns http urls instead of https 

    // From time to time the npm registry returns http urls instead of https 
    url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`); // The yarnpkg and npmjs registries are interchangeable for that matter, so we uniformize them

    // The yarnpkg and npmjs registries are interchangeable for that matter, so we uniformize them
    registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    if (url === registry + path) return true;
    if (url === registry + path.replace(/%2f/g, `/`)) return true;
    return false;
  }

  static getLocatorUrl(locator) {
    const version = $4a2bacec51c22649330d52c82b205226$var$semver_1.default.clean(locator.reference.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length));
    if (version === null) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    return `${$4a2bacec51c22649330d52c82b205226$var$npmHttpUtils.getIdentUrl(locator)}/-/${locator.name}-${version}.tgz`;
  }

}

$4a2bacec51c22649330d52c82b205226$export$NpmSemverFetcher = $4a2bacec51c22649330d52c82b205226$var$NpmSemverFetcher;
$4a2bacec51c22649330d52c82b205226$exports.NpmSemverFetcher = $4a2bacec51c22649330d52c82b205226$export$NpmSemverFetcher;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/NpmSemverResolver.js
var $4c5d5650c24d666361cb767380779aec$exports = {};
Object.defineProperty($4c5d5650c24d666361cb767380779aec$exports, "__esModule", {
  value: true
});
var $4c5d5650c24d666361cb767380779aec$export$NpmSemverResolver = void 0;
$4c5d5650c24d666361cb767380779aec$exports.NpmSemverResolver = $4c5d5650c24d666361cb767380779aec$export$NpmSemverResolver;
const $4c5d5650c24d666361cb767380779aec$var$semver_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($472287880c3e8d04bc38855fbd388e1f$exports);
const $4c5d5650c24d666361cb767380779aec$var$npmHttpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($41a32cdc447deb2a4ab2d241e28dfd00$exports);
const $4c5d5650c24d666361cb767380779aec$var$NODE_GYP_IDENT = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeIdent(null, `node-gyp`);
const $4c5d5650c24d666361cb767380779aec$var$NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;

class $4c5d5650c24d666361cb767380779aec$var$NpmSemverResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    return !!$b0ffa420366ed37c7cf8ff798018d16e$exports.semverUtils.validRange(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length));
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    const {
      selector
    } = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseRange(locator.reference);
    if (!$4c5d5650c24d666361cb767380779aec$var$semver_1.default.valid(selector)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const range = $b0ffa420366ed37c7cf8ff798018d16e$exports.semverUtils.validRange(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length));
    if (range === null) throw new Error(`Expected a valid range, got ${descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length)}`);
    const registryData = await $4c5d5650c24d666361cb767380779aec$var$npmHttpUtils.get($4c5d5650c24d666361cb767380779aec$var$npmHttpUtils.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      jsonResponse: true
    });
    const candidates = Object.keys(registryData.versions).map(version => new $4c5d5650c24d666361cb767380779aec$var$semver_1.default.SemVer(version)).filter(version => range.test(version));
    const noDeprecatedCandidates = candidates.filter(version => {
      return !registryData.versions[version.raw].deprecated;
    }); // If there are versions that aren't deprecated, use them

    // If there are versions that aren't deprecated, use them
    const finalCandidates = noDeprecatedCandidates.length > 0 ? noDeprecatedCandidates : candidates;
    finalCandidates.sort((a, b) => {
      return -a.compare(b);
    });
    return finalCandidates.map(version => {
      const versionLocator = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeLocator(descriptor, `${$73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL}${version.raw}`);
      const archiveUrl = registryData.versions[version.raw].dist.tarball;

      if ($4a2bacec51c22649330d52c82b205226$exports.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
        configuration: opts.project.configuration
      })) {
        return versionLocator;
      } else {
        return $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.bindLocator(versionLocator, {
          __archiveUrl: archiveUrl
        });
      }
    });
  }

  async getSatisfying(descriptor, references, opts) {
    const range = $b0ffa420366ed37c7cf8ff798018d16e$exports.semverUtils.validRange(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length));
    if (range === null) throw new Error(`Expected a valid range, got ${descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length)}`);
    return references.map(reference => {
      try {
        return new $4c5d5650c24d666361cb767380779aec$var$semver_1.default.SemVer(reference.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length));
      } catch (_a) {
        return null;
      }
    }).filter(version => version !== null).filter(version => range.test(version)).sort((a, b) => -a.compare(b)).map(version => $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeLocator(descriptor, `${$73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL}${version.raw}`));
  }

  async resolve(locator, opts) {
    const {
      selector
    } = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseRange(locator.reference);
    const version = $4c5d5650c24d666361cb767380779aec$var$semver_1.default.clean(selector);
    if (version === null) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    const registryData = await $4c5d5650c24d666361cb767380779aec$var$npmHttpUtils.get($4c5d5650c24d666361cb767380779aec$var$npmHttpUtils.getIdentUrl(locator), {
      configuration: opts.project.configuration,
      ident: locator,
      jsonResponse: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `versions`)) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
    if (!Object.prototype.hasOwnProperty.call(registryData.versions, version)) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
    const manifest = new $b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest();
    manifest.load(registryData.versions[version]); // Manually add node-gyp dependency if there is a script using it and not already set
    // This is because the npm registry will automatically add a `node-gyp rebuild` install script
    // in the metadata if there is not already an install script and a binding.gyp file exists.
    // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.

    // Manually add node-gyp dependency if there is a script using it and not already set
    // This is because the npm registry will automatically add a `node-gyp rebuild` install script
    // in the metadata if there is not already an install script and a binding.gyp file exists.
    // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.
    if (!manifest.dependencies.has($4c5d5650c24d666361cb767380779aec$var$NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has($4c5d5650c24d666361cb767380779aec$var$NODE_GYP_IDENT.identHash)) {
      for (const value of manifest.scripts.values()) {
        if (value.match($4c5d5650c24d666361cb767380779aec$var$NODE_GYP_MATCH)) {
          manifest.dependencies.set($4c5d5650c24d666361cb767380779aec$var$NODE_GYP_IDENT.identHash, $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeDescriptor($4c5d5650c24d666361cb767380779aec$var$NODE_GYP_IDENT, `latest`));
          opts.report.reportWarning($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.NODE_GYP_INJECTED, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
          break;
        }
      }
    } // Show deprecation warnings


    // Show deprecation warnings
    if (typeof manifest.raw.deprecated === `string`) opts.report.reportWarning($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.DEPRECATED_PACKAGE, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
    return { ...locator,
      version,
      languageName: `node`,
      linkType: $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

$4c5d5650c24d666361cb767380779aec$export$NpmSemverResolver = $4c5d5650c24d666361cb767380779aec$var$NpmSemverResolver;
$4c5d5650c24d666361cb767380779aec$exports.NpmSemverResolver = $4c5d5650c24d666361cb767380779aec$export$NpmSemverResolver;
// ASSET: node_modules/@yarnpkg/plugin-npm/lib/NpmTagResolver.js
var $c875185c49a740130cb8e551fa0434bd$exports = {};
Object.defineProperty($c875185c49a740130cb8e551fa0434bd$exports, "__esModule", {
  value: true
});
var $c875185c49a740130cb8e551fa0434bd$export$NpmTagResolver = void 0;
$c875185c49a740130cb8e551fa0434bd$exports.NpmTagResolver = $c875185c49a740130cb8e551fa0434bd$export$NpmTagResolver;
const $c875185c49a740130cb8e551fa0434bd$var$npmHttpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($41a32cdc447deb2a4ab2d241e28dfd00$exports);

class $c875185c49a740130cb8e551fa0434bd$var$NpmTagResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL)) return false;
    if (!$b0ffa420366ed37c7cf8ff798018d16e$exports.TAG_REGEXP.test(descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length))) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const tag = descriptor.range.slice($73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL.length);
    const registryData = await $c875185c49a740130cb8e551fa0434bd$var$npmHttpUtils.get($c875185c49a740130cb8e551fa0434bd$var$npmHttpUtils.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      jsonResponse: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`)) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
    const distTags = registryData[`dist-tags`];
    if (!Object.prototype.hasOwnProperty.call(distTags, tag)) throw new $b0ffa420366ed37c7cf8ff798018d16e$exports.ReportError($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
    const version = distTags[tag];
    const versionLocator = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeLocator(descriptor, `${$73afd262738593261faf4a38ff3c6e04$exports.PROTOCOL}${version}`);
    const archiveUrl = registryData.versions[version].dist.tarball;

    if ($4a2bacec51c22649330d52c82b205226$exports.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
      configuration: opts.project.configuration
    })) {
      return [versionLocator];
    } else {
      return [$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.bindLocator(versionLocator, {
        __archiveUrl: archiveUrl
      })];
    }
  }

  async getSatisfying(descriptor, references, opts) {
    // We can't statically know if a tag resolves to a specific version without using the network
    return null;
  }

  async resolve(locator, opts) {
    // Once transformed into locators (through getCandidates), the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

$c875185c49a740130cb8e551fa0434bd$export$NpmTagResolver = $c875185c49a740130cb8e551fa0434bd$var$NpmTagResolver;
$c875185c49a740130cb8e551fa0434bd$exports.NpmTagResolver = $c875185c49a740130cb8e551fa0434bd$export$NpmTagResolver;
const $48439b5f02e9ef8477201a3c8a138bf4$var$npmConfigUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($3d4ee1be33d8fcfcf3355ad19314ad10$exports);
var $48439b5f02e9ef8477201a3c8a138bf4$export$npmConfigUtils = $48439b5f02e9ef8477201a3c8a138bf4$var$npmConfigUtils;
$48439b5f02e9ef8477201a3c8a138bf4$exports.npmConfigUtils = $48439b5f02e9ef8477201a3c8a138bf4$export$npmConfigUtils;
const $48439b5f02e9ef8477201a3c8a138bf4$var$npmHttpUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($41a32cdc447deb2a4ab2d241e28dfd00$exports);
var $48439b5f02e9ef8477201a3c8a138bf4$export$npmHttpUtils = $48439b5f02e9ef8477201a3c8a138bf4$var$npmHttpUtils;
$48439b5f02e9ef8477201a3c8a138bf4$exports.npmHttpUtils = $48439b5f02e9ef8477201a3c8a138bf4$export$npmHttpUtils; // const npmPublishUtils = tslib_1.__importStar(require("./npmPublishUtils"));
// exports.npmPublishUtils = npmPublishUtils;

// const npmPublishUtils = tslib_1.__importStar(require("./npmPublishUtils"));
// exports.npmPublishUtils = npmPublishUtils;
const $48439b5f02e9ef8477201a3c8a138bf4$var$authSettings = {
  npmAlwaysAuth: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.BOOLEAN,
    default: false
  },
  npmAuthIdent: {
    description: `Authentication identity for the npm registry (_auth in npm and yarn v1)`,
    type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.SECRET,
    default: null
  },
  npmAuthToken: {
    description: `Authentication token for the npm registry (_authToken in npm and yarn v1)`,
    type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.SECRET,
    default: null
  }
};
const $48439b5f02e9ef8477201a3c8a138bf4$var$registrySettings = {
  npmPublishRegistry: {
    description: `Registry to push packages to`,
    type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.STRING,
    default: null
  },
  npmRegistryServer: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.STRING,
    default: `https://registry.yarnpkg.com`
  }
};
const $48439b5f02e9ef8477201a3c8a138bf4$var$plugin = {
  configuration: { ...$48439b5f02e9ef8477201a3c8a138bf4$var$authSettings,
    ...$48439b5f02e9ef8477201a3c8a138bf4$var$registrySettings,
    npmScopes: {
      description: `Settings per package scope`,
      type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.SHAPE,
        properties: { ...$48439b5f02e9ef8477201a3c8a138bf4$var$authSettings,
          ...$48439b5f02e9ef8477201a3c8a138bf4$var$registrySettings
        }
      }
    },
    npmRegistries: {
      description: `Settings per registry`,
      type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.MAP,
      normalizeKeys: $48439b5f02e9ef8477201a3c8a138bf4$var$npmConfigUtils.normalizeRegistry,
      valueDefinition: {
        description: ``,
        type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.SHAPE,
        properties: { ...$48439b5f02e9ef8477201a3c8a138bf4$var$authSettings
        }
      }
    }
  },
  fetchers: [$37285373e8fb0da7ee7b67f42e20ca03$exports.NpmHttpFetcher, $4a2bacec51c22649330d52c82b205226$exports.NpmSemverFetcher],
  resolvers: [$7930d92abce34c437972be833fa09f4b$exports.NpmRemapResolver, $4c5d5650c24d666361cb767380779aec$exports.NpmSemverResolver, $c875185c49a740130cb8e551fa0434bd$exports.NpmTagResolver]
}; // eslint-disable-next-line arca/no-default-export

var $48439b5f02e9ef8477201a3c8a138bf4$export$default = $48439b5f02e9ef8477201a3c8a138bf4$var$plugin;
// eslint-disable-next-line arca/no-default-export
$48439b5f02e9ef8477201a3c8a138bf4$exports.default = $48439b5f02e9ef8477201a3c8a138bf4$export$default;
// ASSET: node_modules/@yarnpkg/plugin-node-modules/lib/index.js
var $6fc135850ae258e138149086dfb3680c$exports = {};
Object.defineProperty($6fc135850ae258e138149086dfb3680c$exports, "__esModule", {
  value: true
});
var $6fc135850ae258e138149086dfb3680c$export$getPnpPath = void 0;
$6fc135850ae258e138149086dfb3680c$exports.getPnpPath = $6fc135850ae258e138149086dfb3680c$export$getPnpPath;
// ASSET: node_modules/@yarnpkg/pnpify/lib/index.js
var $aeb9334011cb4a85c526c27a96f15906$export$buildLocatorMap,
    $aeb9334011cb4a85c526c27a96f15906$export$buildNodeModulesTree,
    $aeb9334011cb4a85c526c27a96f15906$export$NodeModulesFS,
    $aeb9334011cb4a85c526c27a96f15906$export$NodeModulesHoistingLimits,
    $aeb9334011cb4a85c526c27a96f15906$exports = {};
var $aeb9334011cb4a85c526c27a96f15906$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "__esModule", {
  value: true
});
var $aeb9334011cb4a85c526c27a96f15906$export$getArchivePath = ($aeb9334011cb4a85c526c27a96f15906$export$buildLocatorMap = ($aeb9334011cb4a85c526c27a96f15906$export$buildNodeModulesTree = ($aeb9334011cb4a85c526c27a96f15906$export$NodeModulesFS = ($aeb9334011cb4a85c526c27a96f15906$export$NodeModulesHoistingLimits = ($aeb9334011cb4a85c526c27a96f15906$export$patchFs = void 0, $aeb9334011cb4a85c526c27a96f15906$exports.patchFs = $aeb9334011cb4a85c526c27a96f15906$export$patchFs), $aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits = $aeb9334011cb4a85c526c27a96f15906$export$NodeModulesHoistingLimits), $aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesFS = $aeb9334011cb4a85c526c27a96f15906$export$NodeModulesFS), $aeb9334011cb4a85c526c27a96f15906$exports.buildNodeModulesTree = $aeb9334011cb4a85c526c27a96f15906$export$buildNodeModulesTree), $aeb9334011cb4a85c526c27a96f15906$exports.buildLocatorMap = $aeb9334011cb4a85c526c27a96f15906$export$buildLocatorMap);
$aeb9334011cb4a85c526c27a96f15906$exports.getArchivePath = $aeb9334011cb4a85c526c27a96f15906$export$getArchivePath;
const $aeb9334011cb4a85c526c27a96f15906$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
// ASSET: node_modules/@yarnpkg/pnpify/lib/NodeModulesFS.js
var $aab18957f0790a522fff57d99f99195a$exports = {};
Object.defineProperty($aab18957f0790a522fff57d99f99195a$exports, "__esModule", {
  value: true
});
var $aab18957f0790a522fff57d99f99195a$export$PortableNodeModulesFS = ($aab18957f0790a522fff57d99f99195a$export$NodeModulesFS = void 0, $aab18957f0790a522fff57d99f99195a$exports.NodeModulesFS = $aab18957f0790a522fff57d99f99195a$export$NodeModulesFS);
$aab18957f0790a522fff57d99f99195a$exports.PortableNodeModulesFS = $aab18957f0790a522fff57d99f99195a$export$PortableNodeModulesFS;
const $aab18957f0790a522fff57d99f99195a$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
// ASSET: node_modules/@yarnpkg/pnpify/lib/WatchManager.js
var $68684487393849ce2e99cad7c7cb9f86$exports = {};
Object.defineProperty($68684487393849ce2e99cad7c7cb9f86$exports, "__esModule", {
  value: true
});
var $68684487393849ce2e99cad7c7cb9f86$export$WatchManager = void 0;
$68684487393849ce2e99cad7c7cb9f86$exports.WatchManager = $68684487393849ce2e99cad7c7cb9f86$export$WatchManager;

class $68684487393849ce2e99cad7c7cb9f86$var$WatchEventEmitter extends $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter {
  constructor(dirWatchers, watchPath, watcherId) {
    super();
    this.dirWatchers = dirWatchers;
    this.watchPath = watchPath;
    this.watcherId = watcherId;
  }

  close() {
    const dirWatcher = this.dirWatchers.get(this.watchPath);
    dirWatcher.eventEmitters.delete(this.watcherId);

    if (dirWatcher.eventEmitters.size === 0) {
      this.dirWatchers.delete(this.watchPath);
    }
  }

}

class $68684487393849ce2e99cad7c7cb9f86$var$WatchManager extends $2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter {
  constructor() {
    super(...arguments);
    this.dirWatchers = new Map();
    this.lastWatcherId = 0;
  }

  registerWatcher(watchPath, dirList, callback) {
    let dirWatcher = this.dirWatchers.get(watchPath);

    if (!dirWatcher) {
      dirWatcher = {
        eventEmitters: new Map(),
        dirEntries: dirList
      };
      this.dirWatchers.set(watchPath, dirWatcher);
    }

    const watcherId = this.lastWatcherId++;
    const watchEventEmitter = new $68684487393849ce2e99cad7c7cb9f86$var$WatchEventEmitter(this.dirWatchers, watchPath, watcherId);
    dirWatcher.eventEmitters.set(watcherId, watchEventEmitter);
    watchEventEmitter.on(`rename`, filename => callback(`rename`, filename));
    return watchEventEmitter;
  }

  notifyWatchers(resolvePath) {
    for (const [watchPath, dirWatcher] of this.dirWatchers) {
      const newDirEntries = resolvePath(watchPath).dirList || new Set(); // Difference between new and old directory contents

      // Difference between new and old directory contents
      const dirEntryDiff = new Set();

      for (const entry of newDirEntries) {
        if (!dirWatcher.dirEntries.has(entry)) {
          dirEntryDiff.add(entry);
        }
      }

      for (const entry of dirWatcher.dirEntries) {
        if (!newDirEntries.has(entry)) {
          dirEntryDiff.add(entry);
        }
      }

      for (const entry of dirEntryDiff) {
        for (const watchEventEmitter of dirWatcher.eventEmitters.values()) {
          watchEventEmitter.emit(`rename`, entry);
        }
      }

      dirWatcher.dirEntries = newDirEntries;
    }
  }

}

$68684487393849ce2e99cad7c7cb9f86$export$WatchManager = $68684487393849ce2e99cad7c7cb9f86$var$WatchManager;
$68684487393849ce2e99cad7c7cb9f86$exports.WatchManager = $68684487393849ce2e99cad7c7cb9f86$export$WatchManager;
// ASSET: node_modules/@yarnpkg/pnpify/lib/buildNodeModulesTree.js
var $c48eab9aff432f7e57ac88ccc8550c1d$export$LinkType,
    $c48eab9aff432f7e57ac88ccc8550c1d$export$NodeModulesHoistingLimits,
    $c48eab9aff432f7e57ac88ccc8550c1d$exports = {};
Object.defineProperty($c48eab9aff432f7e57ac88ccc8550c1d$exports, "__esModule", {
  value: true
});
var $c48eab9aff432f7e57ac88ccc8550c1d$export$buildLocatorMap = ($c48eab9aff432f7e57ac88ccc8550c1d$export$buildNodeModulesTree = ($c48eab9aff432f7e57ac88ccc8550c1d$export$getArchivePath = ($c48eab9aff432f7e57ac88ccc8550c1d$export$NodeModulesHoistingLimits = ($c48eab9aff432f7e57ac88ccc8550c1d$export$LinkType = void 0, $c48eab9aff432f7e57ac88ccc8550c1d$exports.LinkType = $c48eab9aff432f7e57ac88ccc8550c1d$export$LinkType), $c48eab9aff432f7e57ac88ccc8550c1d$exports.NodeModulesHoistingLimits = $c48eab9aff432f7e57ac88ccc8550c1d$export$NodeModulesHoistingLimits), $c48eab9aff432f7e57ac88ccc8550c1d$exports.getArchivePath = $c48eab9aff432f7e57ac88ccc8550c1d$export$getArchivePath), $c48eab9aff432f7e57ac88ccc8550c1d$exports.buildNodeModulesTree = $c48eab9aff432f7e57ac88ccc8550c1d$export$buildNodeModulesTree);
$c48eab9aff432f7e57ac88ccc8550c1d$exports.buildLocatorMap = $c48eab9aff432f7e57ac88ccc8550c1d$export$buildLocatorMap;
// ASSET: node_modules/@yarnpkg/pnpify/lib/hoist.js
var $d1108f9b4ee2c91020cfb3c0d442add3$exports = {};
Object.defineProperty($d1108f9b4ee2c91020cfb3c0d442add3$exports, "__esModule", {
  value: true
});
var $d1108f9b4ee2c91020cfb3c0d442add3$export$hoist = void 0;
$d1108f9b4ee2c91020cfb3c0d442add3$exports.hoist = $d1108f9b4ee2c91020cfb3c0d442add3$export$hoist;
var $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable;

(function (Hoistable) {
  Hoistable[Hoistable["YES"] = 0] = "YES";
  Hoistable[Hoistable["NO"] = 1] = "NO";
  Hoistable[Hoistable["DEPENDS"] = 2] = "DEPENDS";
})($d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable || ($d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable = {}));

const $d1108f9b4ee2c91020cfb3c0d442add3$var$makeLocator = (name, reference) => `${name}@${reference}`;

const $d1108f9b4ee2c91020cfb3c0d442add3$var$makeIdent = (name, reference) => {
  const hashIdx = reference.indexOf(`#`); // Strip virtual reference part, we don't need it for hoisting purposes

  // Strip virtual reference part, we don't need it for hoisting purposes
  const realReference = hashIdx >= 0 ? reference.substring(hashIdx + 1) : reference;
  return $d1108f9b4ee2c91020cfb3c0d442add3$var$makeLocator(name, realReference);
};

var $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel;

(function (DebugLevel) {
  DebugLevel[DebugLevel["NONE"] = -1] = "NONE";
  DebugLevel[DebugLevel["PERF"] = 0] = "PERF";
  DebugLevel[DebugLevel["CHECK"] = 1] = "CHECK";
  DebugLevel[DebugLevel["REASONS"] = 2] = "REASONS";
  DebugLevel[DebugLevel["INTENSIVE_CHECK"] = 9] = "INTENSIVE_CHECK";
})($d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel || ($d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel = {}));
/**
 * Hoists package tree.
 *
 * The root node of a tree must has id: '.'.
 * This function does not mutate its arguments, it hoists and returns tree copy.
 *
 * @param tree package tree (cycles in the tree are allowed)
 *
 * @returns hoisted tree copy
 */


/**
 * Hoists package tree.
 *
 * The root node of a tree must has id: '.'.
 * This function does not mutate its arguments, it hoists and returns tree copy.
 *
 * @param tree package tree (cycles in the tree are allowed)
 *
 * @returns hoisted tree copy
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$hoist = (tree, opts = {}) => {
  const debugLevel = opts.debugLevel || Number(undefined || $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.NONE);
  const check = opts.check || debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.INTENSIVE_CHECK;
  const hoistingLimits = opts.hoistingLimits || new Map();
  const options = {
    check,
    debugLevel,
    hoistingLimits
  };
  if (options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.PERF) console.time(`hoist`);
  const treeCopy = $d1108f9b4ee2c91020cfb3c0d442add3$var$cloneTree(tree, options);
  $d1108f9b4ee2c91020cfb3c0d442add3$var$hoistTo(treeCopy, [treeCopy], new Set([treeCopy.locator]), options);
  if (options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.PERF) console.timeEnd(`hoist`);

  if (options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.CHECK) {
    const checkLog = $d1108f9b4ee2c91020cfb3c0d442add3$var$selfCheck(treeCopy);

    if (checkLog) {
      throw new Error(`${checkLog}, after hoisting finished:\n${$d1108f9b4ee2c91020cfb3c0d442add3$var$dumpDepTree(treeCopy)}`);
    }
  }

  if (options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.REASONS) console.log($d1108f9b4ee2c91020cfb3c0d442add3$var$dumpDepTree(treeCopy));
  return $d1108f9b4ee2c91020cfb3c0d442add3$var$shrinkTree(treeCopy);
};

$d1108f9b4ee2c91020cfb3c0d442add3$export$hoist = $d1108f9b4ee2c91020cfb3c0d442add3$var$hoist;
$d1108f9b4ee2c91020cfb3c0d442add3$exports.hoist = $d1108f9b4ee2c91020cfb3c0d442add3$export$hoist;

const $d1108f9b4ee2c91020cfb3c0d442add3$var$getHoistedDependencies = rootNode => {
  const hoistedDependencies = new Map();
  const seenNodes = new Set();

  const addHoistedDependencies = node => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);

    for (const dep of node.hoistedDependencies.values()) if (!rootNode.dependencies.has(dep.name)) hoistedDependencies.set(dep.name, dep);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        addHoistedDependencies(dep);
      }
    }
  };

  addHoistedDependencies(rootNode);
  return hoistedDependencies;
};
/**
 * This method clones the node and returns cloned node copy, if the node was not previously decoupled.
 *
 * The node is considered decoupled if there is no multiple parents to any node
 * on the path from the dependency graph root up to this node. This means that there are no other
 * nodes in dependency graph that somehow transitively use this node and hence node can be hoisted without
 * side effects.
 *
 * The process of node decoupling is done by going from root node of the graph up to the node in concern
 * and decoupling each node on this graph path.
 *
 * @param node original node
 *
 * @returns decoupled node
 */


/**
 * This method clones the node and returns cloned node copy, if the node was not previously decoupled.
 *
 * The node is considered decoupled if there is no multiple parents to any node
 * on the path from the dependency graph root up to this node. This means that there are no other
 * nodes in dependency graph that somehow transitively use this node and hence node can be hoisted without
 * side effects.
 *
 * The process of node decoupling is done by going from root node of the graph up to the node in concern
 * and decoupling each node on this graph path.
 *
 * @param node original node
 *
 * @returns decoupled node
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$decoupleGraphNode = (parent, node) => {
  if (node.decoupled) return node;
  const {
    name,
    references,
    ident,
    locator,
    dependencies,
    originalDependencies,
    hoistedDependencies,
    peerNames,
    reasons,
    isHoistBorder
  } = node; // To perform node hoisting from parent node we must clone parent nodes up to the root node,
  // because some other package in the tree might depend on the parent package where hoisting
  // cannot be performed

  // To perform node hoisting from parent node we must clone parent nodes up to the root node,
  // because some other package in the tree might depend on the parent package where hoisting
  // cannot be performed
  const clone = {
    name,
    references: new Set(references),
    ident,
    locator,
    dependencies: new Map(dependencies),
    originalDependencies: new Map(originalDependencies),
    hoistedDependencies: new Map(hoistedDependencies),
    peerNames: new Set(peerNames),
    reasons: new Map(reasons),
    decoupled: true,
    isHoistBorder
  };
  const selfDep = clone.dependencies.get(name);
  if (selfDep && selfDep.ident == clone.ident) // Update self-reference
    clone.dependencies.set(name, clone);
  parent.dependencies.set(clone.name, clone);
  return clone;
};
/**
 * Builds a map of most preferred packages that might be hoisted to the root node.
 *
 * The values in the map are idents sorted by preference from most preferred to less preferred.
 * If the root node has already some version of a package, the value array will contain only
 * one element, since it is not possible for other versions of a package to be hoisted.
 *
 * @param rootNode root node
 * @param preferenceMap preference map
 */


/**
 * Builds a map of most preferred packages that might be hoisted to the root node.
 *
 * The values in the map are idents sorted by preference from most preferred to less preferred.
 * If the root node has already some version of a package, the value array will contain only
 * one element, since it is not possible for other versions of a package to be hoisted.
 *
 * @param rootNode root node
 * @param preferenceMap preference map
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$getHoistIdentMap = (rootNode, preferenceMap) => {
  const identMap = new Map([[rootNode.name, [rootNode.ident]]]);

  for (const dep of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dep.name)) {
      identMap.set(dep.name, [dep.ident]);
    }
  }

  const keyList = Array.from(preferenceMap.keys());
  keyList.sort((key1, key2) => {
    const entry1 = preferenceMap.get(key1);
    const entry2 = preferenceMap.get(key2);

    if (entry2.peerDependents.size !== entry1.peerDependents.size) {
      return entry2.peerDependents.size - entry1.peerDependents.size;
    } else {
      return entry2.dependents.size - entry1.dependents.size;
    }
  });

  for (const key of keyList) {
    const name = key.substring(0, key.indexOf(`@`, 1));
    const ident = key.substring(name.length + 1);

    if (!rootNode.peerNames.has(name)) {
      let idents = identMap.get(name);

      if (!idents) {
        idents = [];
        identMap.set(name, idents);
      }

      if (idents.indexOf(ident) < 0) {
        idents.push(ident);
      }
    }
  }

  return identMap;
};
/**
 * Gets regular node dependencies only and sorts them in the order so that
 * peer dependencies come before the dependency that rely on them.
 *
 * @param node graph node
 * @returns sorted regular dependencies
 */


/**
 * Gets regular node dependencies only and sorts them in the order so that
 * peer dependencies come before the dependency that rely on them.
 *
 * @param node graph node
 * @returns sorted regular dependencies
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$getSortedRegularDependencies = node => {
  const dependencies = new Set();

  const addDep = (dep, seenDeps = new Set()) => {
    if (seenDeps.has(dep)) return;
    seenDeps.add(dep);

    for (const peerName of dep.peerNames) {
      if (!node.peerNames.has(peerName)) {
        const peerDep = node.dependencies.get(peerName);

        if (peerDep && !dependencies.has(peerDep)) {
          addDep(peerDep, seenDeps);
        }
      }
    }

    dependencies.add(dep);
  };

  for (const dep of node.dependencies.values()) {
    if (!node.peerNames.has(dep.name)) {
      addDep(dep);
    }
  }

  return dependencies;
};
/**
 * Performs hoisting all the dependencies down the tree to the root node.
 *
 * The algorithm used here reduces dependency graph by deduplicating
 * instances of the packages while keeping:
 * 1. Regular dependency promise: the package should require the exact version of the dependency
 * that was declared in its `package.json`
 * 2. Peer dependency promise: the package and its direct parent package
 * must use the same instance of the peer dependency
 *
 * The regular and peer dependency promises are kept while performing transform
 * on tree branches of packages at a time:
 * `root package` -> `parent package 1` ... `parent package n` -> `dependency`
 * We check wether we can hoist `dependency` to `root package`, this boils down basically
 * to checking:
 * 1. Wether `root package` does not depend on other version of `dependency`
 * 2. Wether all the peer dependencies of a `dependency` had already been hoisted from all `parent packages`
 *
 * If many versions of the `dependency` can be hoisted to the `root package` we choose the most used
 * `dependency` version in the project among them.
 *
 * This function mutates the tree.
 *
 * @param tree package dependencies graph
 * @param rootNode root node to hoist to
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param options hoisting options
 */


/**
 * Performs hoisting all the dependencies down the tree to the root node.
 *
 * The algorithm used here reduces dependency graph by deduplicating
 * instances of the packages while keeping:
 * 1. Regular dependency promise: the package should require the exact version of the dependency
 * that was declared in its `package.json`
 * 2. Peer dependency promise: the package and its direct parent package
 * must use the same instance of the peer dependency
 *
 * The regular and peer dependency promises are kept while performing transform
 * on tree branches of packages at a time:
 * `root package` -> `parent package 1` ... `parent package n` -> `dependency`
 * We check wether we can hoist `dependency` to `root package`, this boils down basically
 * to checking:
 * 1. Wether `root package` does not depend on other version of `dependency`
 * 2. Wether all the peer dependencies of a `dependency` had already been hoisted from all `parent packages`
 *
 * If many versions of the `dependency` can be hoisted to the `root package` we choose the most used
 * `dependency` version in the project among them.
 *
 * This function mutates the tree.
 *
 * @param tree package dependencies graph
 * @param rootNode root node to hoist to
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param options hoisting options
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$hoistTo = (tree, rootNodePath, rootNodePathLocators, options, seenNodes = new Set()) => {
  const rootNode = rootNodePath[rootNodePath.length - 1];
  if (seenNodes.has(rootNode)) return;
  seenNodes.add(rootNode);
  const preferenceMap = $d1108f9b4ee2c91020cfb3c0d442add3$var$buildPreferenceMap(rootNode);
  const hoistIdentMap = $d1108f9b4ee2c91020cfb3c0d442add3$var$getHoistIdentMap(rootNode, preferenceMap);
  const hoistIdents = new Map(Array.from(hoistIdentMap.entries()).map(([k, v]) => [k, v[0]]));
  const hoistedDependencies = rootNode === tree ? new Map() : $d1108f9b4ee2c91020cfb3c0d442add3$var$getHoistedDependencies(rootNode);
  let wasStateChanged;

  do {
    $d1108f9b4ee2c91020cfb3c0d442add3$var$hoistGraph(tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options);
    wasStateChanged = false;

    for (const [name, idents] of hoistIdentMap) {
      if (idents.length > 1 && !rootNode.dependencies.has(name)) {
        hoistIdents.delete(name);
        idents.shift();
        hoistIdents.set(name, idents[0]);
        wasStateChanged = true;
      }
    }
  } while (wasStateChanged);

  for (const dependency of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dependency.name) && !rootNodePathLocators.has(dependency.locator)) {
      rootNodePathLocators.add(dependency.locator);
      $d1108f9b4ee2c91020cfb3c0d442add3$var$hoistTo(tree, [...rootNodePath, dependency], rootNodePathLocators, options);
      rootNodePathLocators.delete(dependency.locator);
    }
  }
};

const $d1108f9b4ee2c91020cfb3c0d442add3$var$getNodeHoistInfo = (rootNodePathLocators, nodePath, node, hoistedDependencies, hoistIdents, hoistIdentMap, {
  outputReason
}) => {
  let reasonRoot;
  let reason = null;
  let dependsOn = new Set();
  if (outputReason) reasonRoot = `${Array.from(rootNodePathLocators).map(x => $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(x)).join(``)}`;
  const parentNode = nodePath[nodePath.length - 1]; // We cannot hoist self-references

  // We cannot hoist self-references
  const isSelfReference = node.ident === parentNode.ident;
  const hoistedIdent = hoistIdents.get(node.name);
  let isHoistable = hoistedIdent === node.ident && !isSelfReference;
  if (outputReason && !isHoistable && hoistedIdent && !isSelfReference) reason = `- filled by: ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(hoistIdentMap.get(node.name)[0])} at ${reasonRoot}`;

  if (isHoistable) {
    let isNameAvailable = false;
    const hoistedDep = hoistedDependencies.get(node.name);
    isNameAvailable = !hoistedDep || hoistedDep.ident === node.ident;
    if (outputReason && !isNameAvailable) reason = `- filled by: ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(hoistedDep.locator)} at ${reasonRoot}`;

    if (isNameAvailable) {
      for (let idx = 1; idx < nodePath.length - 1; idx++) {
        const parent = nodePath[idx];
        const parentDep = parent.dependencies.get(node.name);

        if (parentDep && parentDep.ident !== node.ident) {
          isNameAvailable = false;
          if (outputReason) reason = `- filled by: ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(parentDep.locator)} at ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(parent.locator)}`;
          break;
        }
      }
    }

    isHoistable = isNameAvailable;
  }

  if (isHoistable) {
    let arePeerDepsSatisfied = true;
    const checkList = new Set(node.peerNames);

    for (let idx = nodePath.length - 1; idx >= 1; idx--) {
      const parent = nodePath[idx];

      for (const name of checkList) {
        if (parent.peerNames.has(name) && parent.originalDependencies.has(name)) continue;
        const parentDepNode = parent.dependencies.get(name);

        if (parentDepNode) {
          if (idx === nodePath.length - 1) {
            dependsOn.add(parentDepNode);
          } else {
            dependsOn = null;
            arePeerDepsSatisfied = false;

            if (outputReason) {
              reason = `- peer dependency ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(parentDepNode.locator)} from parent ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(parent.locator)} was not hoisted to ${reasonRoot}`;
            }
          }
        }

        checkList.delete(name);
      }

      if (!arePeerDepsSatisfied) {
        break;
      }
    }

    isHoistable = arePeerDepsSatisfied;
  }

  if (dependsOn !== null && dependsOn.size > 0) {
    return {
      isHoistable: $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.DEPENDS,
      dependsOn,
      reason
    };
  } else {
    return {
      isHoistable: isHoistable ? $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.YES : $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.NO,
      reason
    };
  }
};
/**
 * Performs actual graph transformation, by hoisting packages to the root node.
 *
 * @param tree dependency tree
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param hoistedDependencies map of dependencies that were hoisted to parent nodes
 * @param hoistIdents idents that should be attempted to be hoisted to the root node
 */


/**
 * Performs actual graph transformation, by hoisting packages to the root node.
 *
 * @param tree dependency tree
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param hoistedDependencies map of dependencies that were hoisted to parent nodes
 * @param hoistIdents idents that should be attempted to be hoisted to the root node
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$hoistGraph = (tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options) => {
  const rootNode = rootNodePath[rootNodePath.length - 1];
  const seenNodes = new Set();

  const hoistNodeDependencies = (nodePath, locatorPath, parentNode, newNodes) => {
    if (seenNodes.has(parentNode)) return;
    const nextLocatorPath = [...locatorPath, parentNode.locator];
    const dependantTree = new Map();
    const hoistInfos = new Map();

    for (const subDependency of $d1108f9b4ee2c91020cfb3c0d442add3$var$getSortedRegularDependencies(parentNode)) {
      let hoistInfo = null;
      if (!hoistInfo) hoistInfo = $d1108f9b4ee2c91020cfb3c0d442add3$var$getNodeHoistInfo(rootNodePathLocators, [rootNode, ...nodePath, parentNode], subDependency, hoistedDependencies, hoistIdents, hoistIdentMap, {
        outputReason: options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.REASONS
      });
      hoistInfos.set(subDependency, hoistInfo);

      if (hoistInfo.isHoistable === $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.DEPENDS) {
        for (const node of hoistInfo.dependsOn) {
          const nodeDependants = dependantTree.get(node.name) || new Set();
          nodeDependants.add(subDependency.name);
          dependantTree.set(node.name, nodeDependants);
        }
      }
    }

    const unhoistableNodes = new Set();

    const addUnhoistableNode = (node, hoistInfo, reason) => {
      if (!unhoistableNodes.has(node)) {
        unhoistableNodes.add(node);
        if (node.ident !== parentNode.ident) hoistInfos.set(node, {
          isHoistable: $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.NO,
          reason
        });

        for (const dependantName of dependantTree.get(node.name) || []) {
          addUnhoistableNode(parentNode.dependencies.get(dependantName), hoistInfo, reason);
        }
      }
    };

    let reasonRoot;
    if (options.debugLevel >= $d1108f9b4ee2c91020cfb3c0d442add3$var$DebugLevel.REASONS) reasonRoot = `${Array.from(rootNodePathLocators).map(x => $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(x)).join(``)}`;

    for (const [node, hoistInfo] of hoistInfos) if (hoistInfo.isHoistable === $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.NO) addUnhoistableNode(node, hoistInfo, `- peer dependency ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(node.locator)} from parent ${$d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(parentNode.locator)} was not hoisted to ${reasonRoot}`);

    for (const node of hoistInfos.keys()) {
      if (!unhoistableNodes.has(node)) {
        parentNode.dependencies.delete(node.name);
        parentNode.hoistedDependencies.set(node.name, node);
        parentNode.reasons.delete(node.name);
        const hoistedNode = rootNode.dependencies.get(node.name); // Add hoisted node to root node, in case it is not already there

        // Add hoisted node to root node, in case it is not already there
        if (!hoistedNode) {
          // Avoid adding other version of root node to itself
          if (rootNode.ident !== node.ident) {
            rootNode.dependencies.set(node.name, node);
            newNodes.add(node);
          }
        } else {
          for (const reference of node.references) {
            hoistedNode.references.add(reference);
          }
        }
      }
    }

    if (options.check) {
      const checkLog = $d1108f9b4ee2c91020cfb3c0d442add3$var$selfCheck(tree);

      if (checkLog) {
        throw new Error(`${checkLog}, after hoisting dependencies of ${[rootNode, ...nodePath, parentNode].map(x => $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(x.locator)).join(``)}:\n${$d1108f9b4ee2c91020cfb3c0d442add3$var$dumpDepTree(tree)}`);
      }
    }

    const children = $d1108f9b4ee2c91020cfb3c0d442add3$var$getSortedRegularDependencies(parentNode);

    for (const node of children) {
      if (unhoistableNodes.has(node) && nextLocatorPath.indexOf(node.locator) < 0) {
        const hoistInfo = hoistInfos.get(node);
        if (hoistInfo.isHoistable !== $d1108f9b4ee2c91020cfb3c0d442add3$var$Hoistable.YES) parentNode.reasons.set(node.name, hoistInfo.reason);

        if (!node.isHoistBorder) {
          seenNodes.add(parentNode);
          const decoupledNode = $d1108f9b4ee2c91020cfb3c0d442add3$var$decoupleGraphNode(parentNode, node);
          hoistNodeDependencies([...nodePath, parentNode], [...locatorPath, parentNode.locator], decoupledNode, nextNewNodes);
          seenNodes.delete(parentNode);
        }
      }
    }
  };

  let newNodes;
  let nextNewNodes = new Set($d1108f9b4ee2c91020cfb3c0d442add3$var$getSortedRegularDependencies(rootNode));

  do {
    newNodes = nextNewNodes;
    nextNewNodes = new Set();

    for (const dep of newNodes) {
      if (dep.locator === rootNode.locator || dep.isHoistBorder) continue;
      const decoupledDependency = $d1108f9b4ee2c91020cfb3c0d442add3$var$decoupleGraphNode(rootNode, dep);
      hoistNodeDependencies([], Array.from(rootNodePathLocators), decoupledDependency, nextNewNodes);
    }
  } while (nextNewNodes.size > 0);
};

const $d1108f9b4ee2c91020cfb3c0d442add3$var$selfCheck = tree => {
  const log = [];
  const seenNodes = new Set();
  const parents = new Set();

  const checkNode = (node, parentDeps) => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);
    if (parents.has(node)) return;
    const dependencies = new Map(parentDeps);

    for (const dep of node.dependencies.values()) if (!node.peerNames.has(dep.name)) dependencies.set(dep.name, dep);

    for (const origDep of node.originalDependencies.values()) {
      const dep = dependencies.get(origDep.name);

      const prettyPrintTreePath = () => `${Array.from(parents).concat([node]).map(x => $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(x.locator)).join(``)}`;

      if (node.peerNames.has(origDep.name)) {
        const parentDep = parentDeps.get(origDep.name);

        if (parentDep !== dep || !parentDep || parentDep.ident !== origDep.ident) {
          log.push(`${prettyPrintTreePath()} - broken peer promise: expected ${origDep.ident} but found ${parentDep ? parentDep.ident : parentDep}`);
        }
      } else {
        if (!dep) {
          log.push(`${prettyPrintTreePath()} - broken require promise: no required dependency ${origDep.locator} found`);
        } else if (dep.ident !== origDep.ident) {
          log.push(`${prettyPrintTreePath()} - broken require promise for ${origDep.name}: expected ${origDep.ident}, but found: ${dep.ident}`);
        }
      }
    }

    parents.add(node);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        checkNode(dep, dependencies);
      }
    }

    parents.delete(node);
  };

  checkNode(tree, tree.dependencies);
  return log.join(`\n`);
};
/**
 * Creates a clone of package tree with extra fields used for hoisting purposes.
 *
 * @param tree package tree clone
 */


/**
 * Creates a clone of package tree with extra fields used for hoisting purposes.
 *
 * @param tree package tree clone
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$cloneTree = (tree, options) => {
  const {
    identName,
    name,
    reference,
    peerNames
  } = tree;
  const treeCopy = {
    name,
    references: new Set([reference]),
    locator: $d1108f9b4ee2c91020cfb3c0d442add3$var$makeLocator(identName, reference),
    ident: $d1108f9b4ee2c91020cfb3c0d442add3$var$makeIdent(identName, reference),
    dependencies: new Map(),
    originalDependencies: new Map(),
    hoistedDependencies: new Map(),
    peerNames: new Set(peerNames),
    reasons: new Map(),
    decoupled: true,
    isHoistBorder: true
  };
  const seenNodes = new Map([[tree, treeCopy]]);

  const addNode = (node, parentNode) => {
    let workNode = seenNodes.get(node);
    const isSeen = !!workNode;

    if (!workNode) {
      const {
        name,
        identName,
        reference,
        peerNames
      } = node;
      const dependenciesNmHoistingLimits = options.hoistingLimits.get(parentNode.locator);
      workNode = {
        name,
        references: new Set([reference]),
        locator: $d1108f9b4ee2c91020cfb3c0d442add3$var$makeLocator(identName, reference),
        ident: $d1108f9b4ee2c91020cfb3c0d442add3$var$makeIdent(identName, reference),
        dependencies: new Map(),
        originalDependencies: new Map(),
        hoistedDependencies: new Map(),
        peerNames: new Set(peerNames),
        reasons: new Map(),
        decoupled: true,
        isHoistBorder: dependenciesNmHoistingLimits ? dependenciesNmHoistingLimits.has(name) : false
      };
      seenNodes.set(node, workNode);
    }

    parentNode.dependencies.set(node.name, workNode);
    parentNode.originalDependencies.set(node.name, workNode);

    if (!isSeen) {
      for (const dep of node.dependencies) {
        addNode(dep, workNode);
      }
    } else {
      const seenCoupledNodes = new Set();

      const markNodeCoupled = node => {
        if (seenCoupledNodes.has(node)) return;
        seenCoupledNodes.add(node);
        node.decoupled = false;

        for (const dep of node.dependencies.values()) {
          if (!node.peerNames.has(dep.name)) {
            markNodeCoupled(dep);
          }
        }
      };

      markNodeCoupled(workNode);
    }
  };

  for (const dep of tree.dependencies) addNode(dep, treeCopy);

  return treeCopy;
};

const $d1108f9b4ee2c91020cfb3c0d442add3$var$getIdentName = locator => locator.substring(0, locator.indexOf(`@`, 1));
/**
 * Creates a clone of hoisted package tree with extra fields removed
 *
 * @param tree stripped down hoisted package tree clone
 */


/**
 * Creates a clone of hoisted package tree with extra fields removed
 *
 * @param tree stripped down hoisted package tree clone
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$shrinkTree = tree => {
  const treeCopy = {
    name: tree.name,
    identName: $d1108f9b4ee2c91020cfb3c0d442add3$var$getIdentName(tree.locator),
    references: new Set(tree.references),
    dependencies: new Set()
  };
  const seenNodes = new Set([tree]);

  const addNode = (node, parentWorkNode, parentNode) => {
    const isSeen = seenNodes.has(node);
    let resultNode;

    if (parentWorkNode === node) {
      resultNode = parentNode;
    } else {
      const {
        name,
        references,
        locator
      } = node;
      resultNode = {
        name,
        identName: $d1108f9b4ee2c91020cfb3c0d442add3$var$getIdentName(locator),
        references,
        dependencies: new Set()
      };
    }

    parentNode.dependencies.add(resultNode);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          addNode(dep, node, resultNode);
        }
      }

      seenNodes.delete(node);
    }
  };

  for (const dep of tree.dependencies.values()) addNode(dep, tree, treeCopy);

  return treeCopy;
};
/**
 * Builds mapping, where key is an alias + dependent package ident and the value is the list of
 * parent package idents who depend on this package.
 *
 * @param rootNode package tree root node
 *
 * @returns preference map
 */


/**
 * Builds mapping, where key is an alias + dependent package ident and the value is the list of
 * parent package idents who depend on this package.
 *
 * @param rootNode package tree root node
 *
 * @returns preference map
 */
const $d1108f9b4ee2c91020cfb3c0d442add3$var$buildPreferenceMap = rootNode => {
  const preferenceMap = new Map();
  const seenNodes = new Set([rootNode]);

  const getPreferenceKey = node => `${node.name}@${node.ident}`;

  const getOrCreatePreferenceEntry = node => {
    const key = getPreferenceKey(node);
    let entry = preferenceMap.get(key);

    if (!entry) {
      entry = {
        dependents: new Set(),
        peerDependents: new Set()
      };
      preferenceMap.set(key, entry);
    }

    return entry;
  };

  const addDependent = (dependent, node) => {
    const isSeen = !!seenNodes.has(node);
    const entry = getOrCreatePreferenceEntry(node);
    entry.dependents.add(dependent.ident);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (node.peerNames.has(dep.name)) {
          const entry = getOrCreatePreferenceEntry(dep);
          entry.peerDependents.add(node.ident);
        } else {
          addDependent(node, dep);
        }
      }
    }
  };

  for (const dep of rootNode.dependencies.values()) if (!rootNode.peerNames.has(dep.name)) addDependent(rootNode, dep);

  return preferenceMap;
};

const $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator = locator => {
  const idx = locator.indexOf(`@`, 1);
  const name = locator.substring(0, idx);
  const reference = locator.substring(idx + 1);

  if (reference === `workspace:.`) {
    return `.`;
  } else if (!reference) {
    return `${name}`;
  } else {
    const version = (reference.indexOf(`#`) > 0 ? reference.split(`#`)[1] : reference).replace(`npm:`, ``);

    if (reference.startsWith(`virtual`)) {
      return `v:${name}@${version}`;
    } else {
      return `${name}@${version}`;
    }
  }
};

const $d1108f9b4ee2c91020cfb3c0d442add3$var$MAX_NODES_TO_DUMP = 50000;
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const $d1108f9b4ee2c91020cfb3c0d442add3$var$dumpDepTree = tree => {
  let nodeCount = 0;

  const dumpPackage = (pkg, parents, prefix = ``) => {
    if (nodeCount > $d1108f9b4ee2c91020cfb3c0d442add3$var$MAX_NODES_TO_DUMP || parents.has(pkg)) return ``;
    nodeCount++;
    const dependencies = Array.from(pkg.dependencies.values());
    let str = ``;
    parents.add(pkg);

    for (let idx = 0; idx < dependencies.length; idx++) {
      const dep = dependencies[idx];

      if (!pkg.peerNames.has(dep.name)) {
        const reason = pkg.reasons.get(dep.name);
        const identName = $d1108f9b4ee2c91020cfb3c0d442add3$var$getIdentName(dep.locator);
        str += `${prefix}${idx < dependencies.length - 1 ? `` : ``}${(parents.has(dep) ? `>` : ``) + (identName !== dep.name ? `a:${dep.name}:` : ``) + $d1108f9b4ee2c91020cfb3c0d442add3$var$prettyPrintLocator(dep.locator) + (reason ? ` ${reason}` : ``)}\n`;
        str += dumpPackage(dep, parents, `${prefix}${idx < dependencies.length - 1 ? ` ` : `  `}`);
      }
    }

    parents.delete(pkg);
    return str;
  };

  const treeDump = dumpPackage(tree, new Set());
  return treeDump + (nodeCount > $d1108f9b4ee2c91020cfb3c0d442add3$var$MAX_NODES_TO_DUMP ? `\nTree is too large, part of the tree has been dunped\n` : ``);
};

// Babel doesn't support const enums, thats why we use non-const enum for LinkType in @yarnpkg/pnp
// But because of this TypeScript requires @yarnpkg/pnp during runtime
// To prevent this we redeclare LinkType enum here, to not depend on @yarnpkg/pnp during runtime
var $c48eab9aff432f7e57ac88ccc8550c1d$var$LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})($c48eab9aff432f7e57ac88ccc8550c1d$var$LinkType = $c48eab9aff432f7e57ac88ccc8550c1d$exports.LinkType || ($c48eab9aff432f7e57ac88ccc8550c1d$export$LinkType = {}, $c48eab9aff432f7e57ac88ccc8550c1d$exports.LinkType = $c48eab9aff432f7e57ac88ccc8550c1d$export$LinkType));

var $c48eab9aff432f7e57ac88ccc8550c1d$var$NodeModulesHoistingLimits;

(function (NodeModulesHoistingLimits) {
  NodeModulesHoistingLimits["WORKSPACES"] = "workspaces";
  NodeModulesHoistingLimits["DEPENDENCIES"] = "dependencies";
  NodeModulesHoistingLimits["NONE"] = "none";
})($c48eab9aff432f7e57ac88ccc8550c1d$var$NodeModulesHoistingLimits = $c48eab9aff432f7e57ac88ccc8550c1d$exports.NodeModulesHoistingLimits || ($c48eab9aff432f7e57ac88ccc8550c1d$export$NodeModulesHoistingLimits = {}, $c48eab9aff432f7e57ac88ccc8550c1d$exports.NodeModulesHoistingLimits = $c48eab9aff432f7e57ac88ccc8550c1d$export$NodeModulesHoistingLimits));
/** node_modules path segment */


/** node_modules path segment */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$NODE_MODULES = `node_modules`;
/**
 * The workspace name suffix used internally by this implementation and appeneded to the name of workspace package.
 * It is needed to create and distinguuish special nodes for workspaces
 */

/**
 * The workspace name suffix used internally by this implementation and appeneded to the name of workspace package.
 * It is needed to create and distinguuish special nodes for workspaces
 */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX = `$wsroot$`;
/**
 * Returns path to archive, if package location is inside the archive.
 *
 * @param packagePath package location
 *
 * @returns path to archive is location is insde the archive or null otherwise
 */

/**
 * Returns path to archive, if package location is inside the archive.
 *
 * @param packagePath package location
 *
 * @returns path to archive is location is insde the archive or null otherwise
 */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$getArchivePath = packagePath => packagePath.indexOf(`.zip/${$c48eab9aff432f7e57ac88ccc8550c1d$var$NODE_MODULES}/`) >= 0 ? $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(packagePath.split(`/${$c48eab9aff432f7e57ac88ccc8550c1d$var$NODE_MODULES}/`)[0]) : null;

var $c48eab9aff432f7e57ac88ccc8550c1d$export$getArchivePath = $c48eab9aff432f7e57ac88ccc8550c1d$var$getArchivePath;
$c48eab9aff432f7e57ac88ccc8550c1d$exports.getArchivePath = $c48eab9aff432f7e57ac88ccc8550c1d$export$getArchivePath;
/**
 * Retrieve full package list and build hoisted `node_modules` directories
 * representation in-memory.
 *
 * @param pnp PnP API
 *
 * @returns hoisted `node_modules` directories representation in-memory
 */

/**
 * Retrieve full package list and build hoisted `node_modules` directories
 * representation in-memory.
 *
 * @param pnp PnP API
 *
 * @returns hoisted `node_modules` directories representation in-memory
 */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$buildNodeModulesTree = (pnp, options) => {
  const {
    packageTree,
    hoistingLimits
  } = $c48eab9aff432f7e57ac88ccc8550c1d$var$buildPackageTree(pnp, options);
  const hoistedTree = $d1108f9b4ee2c91020cfb3c0d442add3$exports.hoist(packageTree, {
    hoistingLimits
  });
  return $c48eab9aff432f7e57ac88ccc8550c1d$var$populateNodeModulesTree(pnp, hoistedTree, options);
};

var $c48eab9aff432f7e57ac88ccc8550c1d$export$buildNodeModulesTree = $c48eab9aff432f7e57ac88ccc8550c1d$var$buildNodeModulesTree;
$c48eab9aff432f7e57ac88ccc8550c1d$exports.buildNodeModulesTree = $c48eab9aff432f7e57ac88ccc8550c1d$export$buildNodeModulesTree;

const $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator = locator => `${locator.name}@${locator.reference}`;

const $c48eab9aff432f7e57ac88ccc8550c1d$var$buildLocatorMap = nodeModulesTree => {
  const map = new Map();

  for (const [location, val] of nodeModulesTree.entries()) {
    if (!val.dirList) {
      let entry = map.get(val.locator);

      if (!entry) {
        entry = {
          target: val.target,
          linkType: val.linkType,
          locations: [],
          aliases: val.aliases
        };
        map.set(val.locator, entry);
      }

      entry.locations.push(location);
    }
  }

  for (const val of map.values()) {
    // Sort locations by depth first and then alphabetically for determinism
    val.locations = val.locations.sort((loc1, loc2) => {
      const len1 = loc1.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.delimiter).length;
      const len2 = loc2.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.delimiter).length;
      return len1 !== len2 ? len2 - len1 : loc2.localeCompare(loc1);
    });
  }

  return map;
};

$c48eab9aff432f7e57ac88ccc8550c1d$export$buildLocatorMap = $c48eab9aff432f7e57ac88ccc8550c1d$var$buildLocatorMap;
$c48eab9aff432f7e57ac88ccc8550c1d$exports.buildLocatorMap = $c48eab9aff432f7e57ac88ccc8550c1d$export$buildLocatorMap;

function $c48eab9aff432f7e57ac88ccc8550c1d$var$isPortalLocator(locatorKey) {
  let descriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseDescriptor(locatorKey);
  if ($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.isVirtualDescriptor(descriptor)) descriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`portal:`);
}
/**
 * Traverses PnP tree and produces input for the `RawHoister`
 *
 * @param pnp PnP API
 *
 * @returns package tree, packages info and locators
 */


/**
 * Traverses PnP tree and produces input for the `RawHoister`
 *
 * @param pnp PnP API
 *
 * @returns package tree, packages info and locators
 */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$buildPackageTree = (pnp, options) => {
  const pnpRoots = pnp.getDependencyTreeRoots();
  const hoistingLimits = new Map();
  const workspaceDependenciesMap = new Map();
  const topPkg = pnp.getPackageInformation(pnp.topLevel);
  if (topPkg === null) throw new Error(`Assertion failed: Expected the top-level package to have been registered`);
  const topLocator = pnp.findPackageLocator(topPkg.packageLocation);
  if (topLocator === null) throw new Error(`Assertion failed: Expected the top-level package to have a physical locator`);
  const topPkgPortableLocation = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(topPkg.packageLocation);
  const topLocatorKey = $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator(topLocator);

  if (options.project) {
    const workspaceTree = {
      children: new Map()
    };
    const cwdSegments = options.project.cwd.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep);

    for (const [cwd, workspace] of options.project.workspacesByCwd) {
      const segments = cwd.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep).slice(cwdSegments.length);
      let node = workspaceTree;

      for (const segment of segments) {
        let nextNode = node.children.get(segment);

        if (!nextNode) {
          nextNode = {
            children: new Map()
          };
          node.children.set(segment, nextNode);
        }

        node = nextNode;
      }

      node.workspaceLocator = {
        name: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(workspace.anchoredLocator),
        reference: workspace.anchoredLocator.reference
      };
    }

    const addWorkspace = (node, parentWorkspaceLocator) => {
      if (node.workspaceLocator) {
        const parentLocatorKey = $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator(parentWorkspaceLocator);
        let dependencies = workspaceDependenciesMap.get(parentLocatorKey);

        if (!dependencies) {
          dependencies = new Set();
          workspaceDependenciesMap.set(parentLocatorKey, dependencies);
        }

        dependencies.add(node.workspaceLocator);
      }

      for (const child of node.children.values()) {
        addWorkspace(child, node.workspaceLocator || parentWorkspaceLocator);
      }
    };

    for (const child of workspaceTree.children.values()) {
      addWorkspace(child, workspaceTree.workspaceLocator);
    }
  } else {
    for (const locator of pnpRoots) {
      if (locator.name !== topLocator.name || locator.reference !== topLocator.reference) {
        let dependencies = workspaceDependenciesMap.get(topLocatorKey);

        if (!dependencies) {
          dependencies = new Set();
          workspaceDependenciesMap.set(topLocatorKey, dependencies);
        }

        dependencies.add(locator);
      }
    }
  }

  const packageTree = {
    name: topLocator.name,
    identName: topLocator.name,
    reference: topLocator.reference,
    peerNames: topPkg.packagePeers,
    dependencies: new Set()
  };
  const nodes = new Map();

  const getNodeKey = (name, locator) => `${$c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator(locator)}:${name}`;

  const addPackageToTree = (name, pkg, locator, parent, parentDependencies, parentRelativeCwd, isHoistBorder) => {
    var _a, _b;

    const nodeKey = getNodeKey(name, locator);
    let node = nodes.get(nodeKey);
    const isSeen = !!node;

    if (!isSeen && locator.name === topLocator.name && locator.reference === topLocator.reference) {
      node = packageTree;
      nodes.set(nodeKey, packageTree);
    }

    if (!node) {
      node = {
        name,
        identName: locator.name,
        reference: locator.reference,
        dependencies: new Set(),
        peerNames: pkg.packagePeers
      };
      nodes.set(nodeKey, node);
    }

    if (isHoistBorder) {
      const parentLocatorKey = $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator({
        name: parent.identName,
        reference: parent.reference
      });
      const dependencyBorders = hoistingLimits.get(parentLocatorKey) || new Set();
      hoistingLimits.set(parentLocatorKey, dependencyBorders);
      dependencyBorders.add(node.name);
    }

    const allDependencies = new Map(pkg.packageDependencies);

    if (options.project) {
      const workspace = options.project.workspacesByCwd.get($ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(pkg.packageLocation.slice(0, -1)));

      if (workspace) {
        const peerCandidates = new Set([...Array.from(workspace.manifest.peerDependencies.values(), x => $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(x)), ...Array.from(workspace.manifest.peerDependenciesMeta.keys())]);

        for (const peerName of peerCandidates) {
          if (!allDependencies.has(peerName)) {
            allDependencies.set(peerName, parentDependencies.get(peerName) || null);
            node.peerNames.add(peerName);
          }
        }
      }
    }

    const locatorKey = $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator(locator);
    const workspaceDependencies = workspaceDependenciesMap.get(locatorKey);

    if (workspaceDependencies) {
      for (const workspaceLocator of workspaceDependencies) {
        allDependencies.set(`${workspaceLocator.name}${$c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX}`, workspaceLocator.reference);
      }
    }

    parent.dependencies.add(node); // If we link dependencies to file system we must not try to install children dependencies inside portal folders

    // If we link dependencies to file system we must not try to install children dependencies inside portal folders
    const shouldAddChildrenDependencies = options.pnpifyFs || !$c48eab9aff432f7e57ac88ccc8550c1d$var$isPortalLocator(nodeKey);

    if (!isSeen && shouldAddChildrenDependencies) {
      for (const [depName, referencish] of allDependencies) {
        if (referencish !== null) {
          const depLocator = pnp.getLocator(depName, referencish);
          const pkgLocator = pnp.getLocator(depName.replace($c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX, ``), referencish);
          const depPkg = pnp.getPackageInformation(pkgLocator);
          if (depPkg === null) throw new Error(`Assertion failed: Expected the package to have been registered`);
          const parentHoistingLimits = (_a = options.hoistingLimitsByCwd) === null || _a === void 0 ? void 0 : _a.get(parentRelativeCwd);
          const relativeDepCwd = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative(topPkgPortableLocation, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(depPkg.packageLocation)) || $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot;
          const depHoistingLimits = (_b = options.hoistingLimitsByCwd) === null || _b === void 0 ? void 0 : _b.get(relativeDepCwd);
          const isHoistBorder = parentHoistingLimits === $c48eab9aff432f7e57ac88ccc8550c1d$var$NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === $c48eab9aff432f7e57ac88ccc8550c1d$var$NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === $c48eab9aff432f7e57ac88ccc8550c1d$var$NodeModulesHoistingLimits.WORKSPACES;
          addPackageToTree(depName, depPkg, depLocator, node, allDependencies, relativeDepCwd, isHoistBorder);
        }
      }
    }
  };

  addPackageToTree(topLocator.name, topPkg, topLocator, packageTree, topPkg.packageDependencies, $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot, false);
  return {
    packageTree,
    hoistingLimits
  };
};

function $c48eab9aff432f7e57ac88ccc8550c1d$var$getTargetLocatorPath(locator, pnp, options) {
  const pkgLocator = pnp.getLocator(locator.name.replace($c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX, ``), locator.reference);
  const info = pnp.getPackageInformation(pkgLocator);
  if (info === null) throw new Error(`Assertion failed: Expected the package to be registered`);
  let linkType;
  let target;

  if (options.pnpifyFs) {
    // In case of pnpifyFs we represent modules as symlinks to archives in NodeModulesFS
    // `/home/user/project/foo` is a symlink to `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo`
    // To make this fs layout work with legacy tools we make
    // `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo/node_modules` (which normally does not exist inside archive) a symlink to:
    // `/home/user/project/node_modules/foo/node_modules`, so that the tools were able to access it
    target = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(info.packageLocation);
    linkType = $c48eab9aff432f7e57ac88ccc8550c1d$var$LinkType.SOFT;
  } else {
    const truePath = pnp.resolveVirtual && locator.reference && locator.reference.startsWith(`virtual:`) ? pnp.resolveVirtual(info.packageLocation) : info.packageLocation;
    target = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(truePath || info.packageLocation);
    linkType = info.linkType;
  }

  return {
    linkType,
    target
  };
}
/**
 * Converts hoisted tree to node modules map
 *
 * @param pnp PnP API
 * @param hoistedTree hoisted package tree from `RawHoister`
 * @param locators locators
 * @param packages package weights
 *
 * @returns node modules map
 */


/**
 * Converts hoisted tree to node modules map
 *
 * @param pnp PnP API
 * @param hoistedTree hoisted package tree from `RawHoister`
 * @param locators locators
 * @param packages package weights
 *
 * @returns node modules map
 */
const $c48eab9aff432f7e57ac88ccc8550c1d$var$populateNodeModulesTree = (pnp, hoistedTree, options) => {
  const tree = new Map();

  const makeLeafNode = (locator, aliases) => {
    const {
      linkType,
      target
    } = $c48eab9aff432f7e57ac88ccc8550c1d$var$getTargetLocatorPath(locator, pnp, options);
    return {
      locator: $c48eab9aff432f7e57ac88ccc8550c1d$var$stringifyLocator(locator),
      target,
      linkType,
      aliases
    };
  };

  const getPackageName = identName => {
    const [nameOrScope, name] = identName.split(`/`);
    return name ? {
      scope: $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(nameOrScope),
      name: $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(name)
    } : {
      scope: null,
      name: $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(nameOrScope)
    };
  };

  const seenNodes = new Set();

  const buildTree = (pkg, locationPrefix) => {
    if (seenNodes.has(pkg)) return;
    seenNodes.add(pkg);

    for (const dep of pkg.dependencies) {
      // We do not want self-references in node_modules, since they confuse existing tools
      if (dep === pkg || pkg.identName.endsWith($c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX) && dep.identName === pkg.identName.replace($c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX, ``)) continue;
      const references = Array.from(dep.references).sort();
      const locator = {
        name: dep.identName,
        reference: references[0]
      };
      const {
        name,
        scope
      } = getPackageName(dep.name);
      const packageNameParts = scope ? [scope, name] : [name];
      const nodeModulesDirPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(locationPrefix, $c48eab9aff432f7e57ac88ccc8550c1d$var$NODE_MODULES);
      const nodeModulesLocation = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(nodeModulesDirPath, ...packageNameParts);
      const leafNode = makeLeafNode(locator, references.slice(1));

      if (!dep.name.endsWith($c48eab9aff432f7e57ac88ccc8550c1d$var$WORKSPACE_NAME_SUFFIX)) {
        const prevNode = tree.get(nodeModulesLocation);

        if (prevNode) {
          if (prevNode.dirList) {
            throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge dir node with leaf node`);
          } else {
            const locator1 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(prevNode.locator);
            const locator2 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(leafNode.locator);
            if (prevNode.linkType !== leafNode.linkType) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different link types`);else if (locator1.identHash !== locator2.identHash) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different idents ${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyLocator(locator1)} and ${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyLocator(locator2)}`);
            leafNode.aliases = [...leafNode.aliases, ...prevNode.aliases, $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(prevNode.locator).reference];
          }
        }

        tree.set(nodeModulesLocation, leafNode);
        const segments = nodeModulesLocation.split(`/`);
        const nodeModulesIdx = segments.indexOf($c48eab9aff432f7e57ac88ccc8550c1d$var$NODE_MODULES);
        let segCount = segments.length - 1;

        while (nodeModulesIdx >= 0 && segCount > nodeModulesIdx) {
          const dirPath = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(segments.slice(0, segCount).join($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep));
          const targetDir = $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(segments[segCount]);
          const subdirs = tree.get(dirPath);

          if (!subdirs) {
            tree.set(dirPath, {
              dirList: new Set([targetDir])
            });
          } else if (subdirs.dirList) {
            if (subdirs.dirList.has(targetDir)) {
              break;
            } else {
              subdirs.dirList.add(targetDir);
            }
          }

          segCount--;
        }
      }

      buildTree(dep, leafNode.linkType === $c48eab9aff432f7e57ac88ccc8550c1d$var$LinkType.SOFT ? leafNode.target : nodeModulesLocation);
    }
  };

  const rootNode = makeLeafNode({
    name: hoistedTree.name,
    reference: Array.from(hoistedTree.references)[0]
  }, []);
  const rootPath = rootNode.target;
  tree.set(rootPath, rootNode);
  buildTree(hoistedTree, rootPath);
  return tree;
};
/**
 * Benchmarks raw hoisting performance.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


// ASSET: node_modules/@yarnpkg/pnpify/lib/resolveNodeModulesPath.js
var $2f43bba94fb547c016a918197eff148b$exports = {};
Object.defineProperty($2f43bba94fb547c016a918197eff148b$exports, "__esModule", {
  value: true
});
var $2f43bba94fb547c016a918197eff148b$export$resolveNodeModulesPath = void 0;
$2f43bba94fb547c016a918197eff148b$exports.resolveNodeModulesPath = $2f43bba94fb547c016a918197eff148b$export$resolveNodeModulesPath;
const $2f43bba94fb547c016a918197eff148b$var$NODE_MODULES = `node_modules`;
/**
 * Resolves paths containing `/node_modules` inside PnP projects. If path is outside PnP
 * project it is not changed.
 *
 * @param inputPath full path containing `node_modules`
 *
 * @returns resolved path
 */

/**
 * Resolves paths containing `/node_modules` inside PnP projects. If path is outside PnP
 * project it is not changed.
 *
 * @param inputPath full path containing `node_modules`
 *
 * @returns resolved path
 */
const $2f43bba94fb547c016a918197eff148b$var$resolveNodeModulesPath = (inputPath, nodeModulesTree) => {
  const result = {
    resolvedPath: inputPath
  };
  const segments = inputPath.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep);
  const firstIdx = segments.indexOf($2f43bba94fb547c016a918197eff148b$var$NODE_MODULES);
  if (firstIdx < 0) return result;
  let lastIdx = segments.lastIndexOf($2f43bba94fb547c016a918197eff148b$var$NODE_MODULES);
  if (typeof segments[lastIdx + 1] !== `undefined`) // We have the situation .../node_modules/{something or @something}
    lastIdx++;
  if (segments[lastIdx][0] === `@` && typeof segments[lastIdx + 1] !== `undefined`) // We have the situation .../node_modules/@something/{foo}
    lastIdx++; // We lookup all the path substrings that end on [firstIdx..lastIdx] in the node_modules tree
  // and follow them if they are symlinks

  // We lookup all the path substrings that end on [firstIdx..lastIdx] in the node_modules tree
  // and follow them if they are symlinks
  let locationCandidate = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(segments.slice(0, firstIdx).join($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep));
  let node, lastNode, lastNodeLocation;
  let curIdx = firstIdx;
  let request = $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot;

  while (curIdx <= lastIdx) {
    const curSegment = $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(segments[curIdx]);
    locationCandidate = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(locationCandidate, curSegment);
    node = nodeModulesTree.get(locationCandidate);

    if (node) {
      if (node.linkType === $c48eab9aff432f7e57ac88ccc8550c1d$exports.LinkType.SOFT) locationCandidate = node.target;
      lastNode = node;
      request = $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot;
      lastNodeLocation = node.dirList ? locationCandidate : node.target;
    } else {
      request = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(request, curSegment);
    }

    curIdx++;
  }

  request = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(request, ...segments.slice(lastIdx + 1).map(x => $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(x)));

  if (lastNode) {
    if (!lastNode.dirList || request !== $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot) {
      result.resolvedPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(lastNodeLocation, request);
      result.isSymlink = lastNode && lastNode.linkType === $c48eab9aff432f7e57ac88ccc8550c1d$exports.LinkType.SOFT && request === $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot;
    } else if (request === $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot) {
      result.dirList = lastNode.dirList;
      result.forwardedDirPath = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(segments.slice(0, firstIdx).join($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep)); // If node_modules is inside .zip archive, we use parent folder as a statPath instead

      // If node_modules is inside .zip archive, we use parent folder as a statPath instead
      if (result.forwardedDirPath.endsWith(`.zip`)) {
        result.forwardedDirPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(result.forwardedDirPath);
      }
    }
  }

  return result;
};

$2f43bba94fb547c016a918197eff148b$export$resolveNodeModulesPath = $2f43bba94fb547c016a918197eff148b$var$resolveNodeModulesPath;
$2f43bba94fb547c016a918197eff148b$exports.resolveNodeModulesPath = $2f43bba94fb547c016a918197eff148b$export$resolveNodeModulesPath;

class $aab18957f0790a522fff57d99f99195a$var$NodeModulesFS extends $ea9c1e38c3e8cca334929a597a084311$exports.ProxiedFS {
  constructor(pnp, {
    realFs = $aab18957f0790a522fff57d99f99195a$var$fs_1.default,
    pnpifyFs = true
  } = {}) {
    super($ea9c1e38c3e8cca334929a597a084311$exports.npath);
    this.baseFs = new $aab18957f0790a522fff57d99f99195a$var$PortableNodeModulesFS(pnp, {
      baseFs: new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS(realFs),
      pnpifyFs
    });
  }

  mapFromBase(path) {
    return $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(path);
  }

  mapToBase(path) {
    return $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(path);
  }

}

var $aab18957f0790a522fff57d99f99195a$export$NodeModulesFS = $aab18957f0790a522fff57d99f99195a$var$NodeModulesFS;
$aab18957f0790a522fff57d99f99195a$exports.NodeModulesFS = $aab18957f0790a522fff57d99f99195a$export$NodeModulesFS;
const $aab18957f0790a522fff57d99f99195a$var$WRITE_FLAGS_REGEX = /[+wa]/;

class $aab18957f0790a522fff57d99f99195a$var$PortableNodeModulesFS extends $ea9c1e38c3e8cca334929a597a084311$exports.FakeFS {
  constructor(pnp, {
    baseFs = new $ea9c1e38c3e8cca334929a597a084311$exports.NodeFS(),
    pnpifyFs = true
  } = {}) {
    super($ea9c1e38c3e8cca334929a597a084311$exports.ppath);
    if (!pnp.getDependencyTreeRoots) throw new Error(`NodeModulesFS supports PnP API versions 3+, please upgrade your PnP API provider`);
    this.options = {
      baseFs,
      pnpifyFs
    };
    this.baseFs = baseFs;
    this.nodeModulesTree = $c48eab9aff432f7e57ac88ccc8550c1d$exports.buildNodeModulesTree(pnp, this.options);
    this.watchManager = new $68684487393849ce2e99cad7c7cb9f86$exports.WatchManager();
    const pnpRootPath = $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(pnp.getPackageInformation(pnp.topLevel).packageLocation);
    this.pnpFilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(pnpRootPath, `.pnp.js`);
    this.watchPnpFile(pnpRootPath);
  }

  watchPnpFile(pnpRootPath) {
    this.baseFs.watch(pnpRootPath, {
      persistent: false
    }, (_, filename) => {
      if (filename === `.pnp.js`) {
        delete require.cache[this.pnpFilePath];

        const pnp = require(this.pnpFilePath);

        this.nodeModulesTree = $c48eab9aff432f7e57ac88ccc8550c1d$exports.buildNodeModulesTree(pnp, this.options);
        this.watchManager.notifyWatchers(nodePath => $2f43bba94fb547c016a918197eff148b$exports.resolveNodeModulesPath(nodePath, this.nodeModulesTree));
      }
    });
  }

  persistPath(dir) {
    const pathStack = [];
    let curPath = dir;

    while (!this.baseFs.existsSync(curPath)) {
      pathStack.push(curPath);
      curPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(curPath);
    }

    for (const fullPath of pathStack.reverse()) {
      this.baseFs.mkdirSync(fullPath);
    }
  }

  persistVirtualParentFolder(p) {
    if (typeof p !== `number`) {
      const parentPath = this.resolvePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(p));

      if (parentPath.dirList) {
        this.persistPath(parentPath.resolvedPath);
      }
    }
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  resolve(path) {
    return this.baseFs.resolve(this.resolvePath(path).resolvedPath);
  }

  getBaseFs() {
    return this.baseFs;
  }

  resolvePath(p) {
    if (typeof p === `number`) {
      return {
        resolvedPath: p,
        fullOriginalPath: p
      };
    } else {
      const fullOriginalPath = this.pathUtils.resolve(p);
      return { ...$2f43bba94fb547c016a918197eff148b$exports.resolveNodeModulesPath(fullOriginalPath, this.nodeModulesTree),
        fullOriginalPath
      };
    }
  }

  resolveFilePath(p) {
    if (typeof p === `number`) return p;
    const pnpPath = this.resolvePath(p);
    return pnpPath.resolvedPath;
  }

  resolveDirOrFilePath(p) {
    if (typeof p === `number`) return p;
    const pnpPath = this.resolvePath(p);
    return pnpPath.forwardedDirPath || pnpPath.resolvedPath;
  }

  resolveLink(p, op, onSymlink, onRealPath) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.isSymlink) {
      let stat;

      try {
        stat = this.baseFs.lstatSync(pnpPath.resolvedPath);
      } catch (e) {}

      if (stat) {
        return onSymlink(stat, this.pathUtils.relative(this.pathUtils.dirname(pnpPath.fullOriginalPath), pnpPath.resolvedPath));
      }
    }

    return onRealPath(pnpPath.forwardedDirPath || pnpPath.resolvedPath);
  }

  static makeSymlinkStats(stats) {
    return Object.assign(stats, {
      isFile: () => false,
      isDirectory: () => false,
      isSymbolicLink: () => true
    });
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  async openPromise(p, flags, mode) {
    if ($aab18957f0790a522fff57d99f99195a$var$WRITE_FLAGS_REGEX.test(flags)) this.persistVirtualParentFolder(p);
    return await this.baseFs.openPromise(this.resolveFilePath(p), flags, mode);
  }

  openSync(p, flags, mode) {
    if ($aab18957f0790a522fff57d99f99195a$var$WRITE_FLAGS_REGEX.test(flags)) this.persistVirtualParentFolder(p);
    return this.baseFs.openSync(this.resolveFilePath(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList || this.resolvePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, `node_modules`)).dirList) {
      let fsDirList = [];

      try {
        fsDirList = await this.baseFs.readdirPromise(pnpPath.resolvedPath);
      } catch (e) {// Ignore errors
      }

      const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
      return $ea9c1e38c3e8cca334929a597a084311$exports.opendir(this, p, entries);
    } else {
      return await this.baseFs.opendirPromise(pnpPath.resolvedPath, opts);
    }
  }

  opendirSync(p, opts) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList || this.resolvePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, `node_modules`)).dirList) {
      let fsDirList = [];

      try {
        fsDirList = this.baseFs.readdirSync(pnpPath.resolvedPath);
      } catch (e) {// Ignore errors
      }

      const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
      return $ea9c1e38c3e8cca334929a597a084311$exports.opendir(this, p, entries);
    } else {
      return this.baseFs.opendirSync(pnpPath.resolvedPath, opts);
    }
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.resolveFilePath(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.resolveDirOrFilePath(p) : p, opts);
  }

  async realpathPromise(p) {
    const pnpPath = this.resolvePath(p);
    return pnpPath.dirList ? pnpPath.resolvedPath : this.baseFs.realpathPromise(pnpPath.resolvedPath);
  }

  realpathSync(p) {
    const pnpPath = this.resolvePath(p);
    return pnpPath.dirList ? pnpPath.resolvedPath : this.baseFs.realpathSync(pnpPath.resolvedPath);
  }

  async existsPromise(p) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList) {
      return true;
    } else {
      return await this.baseFs.existsPromise(pnpPath.resolvedPath);
    }
  }

  existsSync(p) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList) {
      return true;
    } else {
      return this.baseFs.existsSync(pnpPath.resolvedPath);
    }
  }

  async accessPromise(p, mode) {
    return await this.baseFs.accessPromise(this.resolveDirOrFilePath(p), mode);
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.resolveDirOrFilePath(p), mode);
  }

  async statPromise(p) {
    return await this.baseFs.statPromise(this.resolveDirOrFilePath(p));
  }

  statSync(p) {
    return this.baseFs.statSync(this.resolveDirOrFilePath(p));
  }

  async lstatPromise(p) {
    return this.resolveLink(p, `lstat`, stats => $aab18957f0790a522fff57d99f99195a$var$PortableNodeModulesFS.makeSymlinkStats(stats), async resolvedPath => await this.baseFs.lstatPromise(resolvedPath));
  }

  lstatSync(p) {
    return this.resolveLink(p, `lstat`, stats => $aab18957f0790a522fff57d99f99195a$var$PortableNodeModulesFS.makeSymlinkStats(stats), resolvedPath => this.baseFs.lstatSync(this.resolveDirOrFilePath(resolvedPath)));
  }

  async chmodPromise(p, mask) {
    return await this.baseFs.chmodPromise(this.resolveDirOrFilePath(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.resolveDirOrFilePath(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return await this.baseFs.chownPromise(this.resolveDirOrFilePath(p), uid, gid);
  }

  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.resolveDirOrFilePath(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return await this.baseFs.renamePromise(this.resolveDirOrFilePath(oldP), this.resolveDirOrFilePath(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.resolveDirOrFilePath(oldP), this.resolveDirOrFilePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags) {
    return await this.baseFs.copyFilePromise(this.resolveFilePath(sourceP), this.resolveDirOrFilePath(destP), flags);
  }

  copyFileSync(sourceP, destP, flags) {
    return this.baseFs.copyFileSync(this.resolveFilePath(sourceP), this.resolveDirOrFilePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await this.baseFs.appendFilePromise(this.resolveDirOrFilePath(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.resolveDirOrFilePath(p), content, opts);
  }

  async writeFilePromise(p, content, opts) {
    return await this.baseFs.writeFilePromise(this.resolveDirOrFilePath(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.resolveDirOrFilePath(p), content, opts);
  }

  async unlinkPromise(p) {
    return await this.baseFs.unlinkPromise(this.resolveDirOrFilePath(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.resolveDirOrFilePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await this.baseFs.utimesPromise(this.resolveDirOrFilePath(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.resolveDirOrFilePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    const pnpPath = this.resolvePath(p);
    this.persistVirtualParentFolder(p);
    return this.baseFs.mkdirPromise(pnpPath.resolvedPath, opts);
  }

  mkdirSync(p, opts) {
    const pnpPath = this.resolvePath(p);
    this.persistVirtualParentFolder(p);
    return this.baseFs.mkdirSync(pnpPath.resolvedPath, opts);
  }

  async rmdirPromise(p, opts) {
    return await this.baseFs.rmdirPromise(this.resolveDirOrFilePath(p), opts);
  }

  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.resolveDirOrFilePath(p), opts);
  }

  async linkPromise(existingP, newP) {
    return await this.baseFs.linkPromise(this.resolveDirOrFilePath(existingP), this.resolveDirOrFilePath(newP));
  }

  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.resolveDirOrFilePath(existingP), this.resolveDirOrFilePath(newP));
  }

  async symlinkPromise(target, p) {
    return await this.baseFs.symlinkPromise(this.resolveDirOrFilePath(target), this.resolveDirOrFilePath(p));
  }

  symlinkSync(target, p) {
    return this.baseFs.symlinkSync(this.resolveDirOrFilePath(target), this.resolveDirOrFilePath(p));
  }

  async readFilePromise(p, encoding) {
    // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    switch (encoding) {
      case `utf8`:
        return await this.baseFs.readFilePromise(this.resolveFilePath(p), encoding);

      default:
        return await this.baseFs.readFilePromise(this.resolveFilePath(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    switch (encoding) {
      case `utf8`:
        return this.baseFs.readFileSync(this.resolveFilePath(p), encoding);

      default:
        return this.baseFs.readFileSync(this.resolveFilePath(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList || this.resolvePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, `node_modules`)).dirList) {
      let fsDirList = [];

      try {
        fsDirList = await this.baseFs.readdirPromise(pnpPath.resolvedPath);
      } catch (e) {// Ignore errors
      }

      const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
      if (!withFileTypes) return entries;
      return entries.map(name => {
        return Object.assign(this.lstatSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, name)), {
          name
        });
      });
    } else {
      return await this.baseFs.readdirPromise(pnpPath.resolvedPath, {
        withFileTypes: withFileTypes
      });
    }
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    const pnpPath = this.resolvePath(p);

    if (pnpPath.dirList || this.resolvePath($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, `node_modules`)).dirList) {
      let fsDirList = [];

      try {
        fsDirList = this.baseFs.readdirSync(pnpPath.resolvedPath);
      } catch (e) {// Ignore errors
      }

      const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
      if (!withFileTypes) return entries;
      return entries.map(name => {
        return Object.assign(this.lstatSync($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(p, name)), {
          name
        });
      });
    } else {
      return this.baseFs.readdirSync(pnpPath.resolvedPath, {
        withFileTypes: withFileTypes
      });
    }
  }

  async readlinkPromise(p) {
    return this.resolveLink(p, `readlink`, (_stats, targetPath) => targetPath, async targetPath => await this.baseFs.readlinkPromise(this.resolveDirOrFilePath(targetPath)));
  }

  readlinkSync(p) {
    return this.resolveLink(p, `readlink`, (_stats, targetPath) => targetPath, targetPath => this.baseFs.readlinkSync(this.resolveDirOrFilePath(targetPath)));
  }

  async truncatePromise(p, len) {
    return await this.baseFs.truncatePromise(this.resolveDirOrFilePath(p), len);
  }

  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.resolveDirOrFilePath(p), len);
  }

  watch(p, a, b) {
    const pnpPath = this.resolvePath(p);
    const watchPath = pnpPath.resolvedPath;

    if (watchPath && pnpPath.dirList) {
      const callback = typeof a === `function` ? a : typeof b === `function` ? b : () => {};
      return this.watchManager.registerWatcher(watchPath, pnpPath.dirList, callback);
    } else {
      return this.baseFs.watch(this.resolveDirOrFilePath(p), // @ts-expect-error
      a, b);
    }
  }

  watchFile(p, a, b) {
    return this.baseFs.watchFile(this.resolveDirOrFilePath(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.resolveDirOrFilePath(p), cb);
  }

}

$aab18957f0790a522fff57d99f99195a$export$PortableNodeModulesFS = $aab18957f0790a522fff57d99f99195a$var$PortableNodeModulesFS;
$aab18957f0790a522fff57d99f99195a$exports.PortableNodeModulesFS = $aab18957f0790a522fff57d99f99195a$export$PortableNodeModulesFS;
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "NodeModulesFS", {
  enumerable: true,
  get: function () {
    return $aab18957f0790a522fff57d99f99195a$exports.NodeModulesFS;
  }
});
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "getArchivePath", {
  enumerable: true,
  get: function () {
    return $c48eab9aff432f7e57ac88ccc8550c1d$exports.getArchivePath;
  }
});
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "buildNodeModulesTree", {
  enumerable: true,
  get: function () {
    return $c48eab9aff432f7e57ac88ccc8550c1d$exports.buildNodeModulesTree;
  }
});
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "buildLocatorMap", {
  enumerable: true,
  get: function () {
    return $c48eab9aff432f7e57ac88ccc8550c1d$exports.buildLocatorMap;
  }
}); // const dynamicRequire_1 = require("./dynamicRequire");

// const dynamicRequire_1 = require("./dynamicRequire");
let $aeb9334011cb4a85c526c27a96f15906$var$fsPatched = false;
let $aeb9334011cb4a85c526c27a96f15906$var$pnp;

try {// pnp = dynamicRequire_1.dynamicRequire(`pnpapi`);
} catch (e) {}

const $aeb9334011cb4a85c526c27a96f15906$var$patchFs = () => {
  if ($aeb9334011cb4a85c526c27a96f15906$var$pnp && !$aeb9334011cb4a85c526c27a96f15906$var$fsPatched) {
    const realFs = { ...$aeb9334011cb4a85c526c27a96f15906$var$fs_1.default
    };
    const nodeModulesFS = new $aab18957f0790a522fff57d99f99195a$exports.NodeModulesFS($aeb9334011cb4a85c526c27a96f15906$var$pnp, {
      realFs
    });
    $ea9c1e38c3e8cca334929a597a084311$exports.patchFs($aeb9334011cb4a85c526c27a96f15906$var$fs_1.default, nodeModulesFS);
    $aeb9334011cb4a85c526c27a96f15906$var$fsPatched = true;
  }
};

var $aeb9334011cb4a85c526c27a96f15906$export$patchFs = $aeb9334011cb4a85c526c27a96f15906$var$patchFs;
$aeb9334011cb4a85c526c27a96f15906$exports.patchFs = $aeb9334011cb4a85c526c27a96f15906$export$patchFs;
if (!$aeb9334011cb4a85c526c27a96f15906$var$process.mainModule) $aeb9334011cb4a85c526c27a96f15906$exports.patchFs();
Object.defineProperty($aeb9334011cb4a85c526c27a96f15906$exports, "NodeModulesHoistingLimits", {
  enumerable: true,
  get: function () {
    return $c48eab9aff432f7e57ac88ccc8550c1d$exports.NodeModulesHoistingLimits;
  }
});
// ASSET: node_modules/@yarnpkg/plugin-node-modules/lib/NodeModulesLinker.js
var $727321b616b6b83fee27ff1a2a90cf03$exports = {};
var $727321b616b6b83fee27ff1a2a90cf03$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($727321b616b6b83fee27ff1a2a90cf03$exports, "__esModule", {
  value: true
});
var $727321b616b6b83fee27ff1a2a90cf03$export$NodeModulesLinker = void 0;
$727321b616b6b83fee27ff1a2a90cf03$exports.NodeModulesLinker = $727321b616b6b83fee27ff1a2a90cf03$export$NodeModulesLinker;
// ASSET: node_modules/@yarnpkg/plugin-pnp/lib/jsInstallUtils.js
var $b550ef5ee52404c1344fb94da2ce2aaa$exports = {};
var $b550ef5ee52404c1344fb94da2ce2aaa$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
Object.defineProperty($b550ef5ee52404c1344fb94da2ce2aaa$exports, "__esModule", {
  value: true
});
var $b550ef5ee52404c1344fb94da2ce2aaa$export$hasBindingGyp = ($b550ef5ee52404c1344fb94da2ce2aaa$export$getExtractHint = ($b550ef5ee52404c1344fb94da2ce2aaa$export$extractBuildScripts = ($b550ef5ee52404c1344fb94da2ce2aaa$export$checkAndReportManifestCompatibility = void 0, $b550ef5ee52404c1344fb94da2ce2aaa$exports.checkAndReportManifestCompatibility = $b550ef5ee52404c1344fb94da2ce2aaa$export$checkAndReportManifestCompatibility), $b550ef5ee52404c1344fb94da2ce2aaa$exports.extractBuildScripts = $b550ef5ee52404c1344fb94da2ce2aaa$export$extractBuildScripts), $b550ef5ee52404c1344fb94da2ce2aaa$exports.getExtractHint = $b550ef5ee52404c1344fb94da2ce2aaa$export$getExtractHint);
$b550ef5ee52404c1344fb94da2ce2aaa$exports.hasBindingGyp = $b550ef5ee52404c1344fb94da2ce2aaa$export$hasBindingGyp;

function $b550ef5ee52404c1344fb94da2ce2aaa$var$checkAndReportManifestCompatibility(pkg, requirements, label, {
  configuration,
  report
}) {
  if (!$b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest.isManifestFieldCompatible(requirements.manifest.os, $b550ef5ee52404c1344fb94da2ce2aaa$var$process.platform)) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.INCOMPATIBLE_OS, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(configuration, pkg)} The platform ${$b550ef5ee52404c1344fb94da2ce2aaa$var$process.platform} is incompatible with this module, ${label} skipped.`);
    return false;
  }

  if (!$b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest.isManifestFieldCompatible(requirements.manifest.cpu, $b550ef5ee52404c1344fb94da2ce2aaa$var$process.arch)) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.INCOMPATIBLE_CPU, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(configuration, pkg)} The CPU architecture ${$b550ef5ee52404c1344fb94da2ce2aaa$var$process.arch} is incompatible with this module, ${label} skipped.`);
    return false;
  }

  return true;
}

var $b550ef5ee52404c1344fb94da2ce2aaa$export$checkAndReportManifestCompatibility = $b550ef5ee52404c1344fb94da2ce2aaa$var$checkAndReportManifestCompatibility;
$b550ef5ee52404c1344fb94da2ce2aaa$exports.checkAndReportManifestCompatibility = $b550ef5ee52404c1344fb94da2ce2aaa$export$checkAndReportManifestCompatibility;

function $b550ef5ee52404c1344fb94da2ce2aaa$var$extractBuildScripts(pkg, requirements, dependencyMeta, {
  configuration,
  report
}) {
  const buildScripts = [];

  for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (requirements.manifest.scripts.has(scriptName)) buildScripts.push([$b0ffa420366ed37c7cf8ff798018d16e$exports.BuildType.SCRIPT, scriptName]); // Detect cases where a package has a binding.gyp but no install script


  // Detect cases where a package has a binding.gyp but no install script
  if (!requirements.manifest.scripts.has(`install`) && requirements.misc.hasBindingGyp) buildScripts.push([$b0ffa420366ed37c7cf8ff798018d16e$exports.BuildType.SHELLCODE, `node-gyp rebuild`]);
  if (buildScripts.length === 0) return [];

  if (!configuration.get(`enableScripts`) && !dependencyMeta.built) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.DISABLED_BUILD_SCRIPTS, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
    return [];
  }

  if (pkg.linkType !== $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.SOFT_LINK_BUILD, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
    return [];
  }

  if (dependencyMeta && dependencyMeta.built === false) {
    report === null || report === void 0 ? void 0 : report.reportInfoOnce($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.BUILD_DISABLED, `${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
    return [];
  }

  const isManifestCompatible = $b550ef5ee52404c1344fb94da2ce2aaa$var$checkAndReportManifestCompatibility(pkg, requirements, `build`, {
    configuration,
    report
  });
  if (!isManifestCompatible) return [];
  return buildScripts;
}

var $b550ef5ee52404c1344fb94da2ce2aaa$export$extractBuildScripts = $b550ef5ee52404c1344fb94da2ce2aaa$var$extractBuildScripts;
$b550ef5ee52404c1344fb94da2ce2aaa$exports.extractBuildScripts = $b550ef5ee52404c1344fb94da2ce2aaa$export$extractBuildScripts;
const $b550ef5ee52404c1344fb94da2ce2aaa$var$FORCED_EXTRACT_FILETYPES = new Set([// Windows can't execute exe files inside zip archives
`.exe`, // The c/c++ compiler can't read files from zip archives
`.h`, `.hh`, `.hpp`, `.c`, `.cc`, `.cpp`, // The java runtime can't read files from zip archives
`.java`, `.jar`, // Node opens these through dlopen
`.node`]);

function $b550ef5ee52404c1344fb94da2ce2aaa$var$getExtractHint(fetchResult) {
  return fetchResult.packageFs.getExtractHint({
    relevantExtensions: $b550ef5ee52404c1344fb94da2ce2aaa$var$FORCED_EXTRACT_FILETYPES
  });
}

var $b550ef5ee52404c1344fb94da2ce2aaa$export$getExtractHint = $b550ef5ee52404c1344fb94da2ce2aaa$var$getExtractHint;
$b550ef5ee52404c1344fb94da2ce2aaa$exports.getExtractHint = $b550ef5ee52404c1344fb94da2ce2aaa$export$getExtractHint;

function $b550ef5ee52404c1344fb94da2ce2aaa$var$hasBindingGyp(fetchResult) {
  const bindingFilePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(fetchResult.prefixPath, `binding.gyp`);
  return fetchResult.packageFs.existsSync(bindingFilePath);
}

$b550ef5ee52404c1344fb94da2ce2aaa$export$hasBindingGyp = $b550ef5ee52404c1344fb94da2ce2aaa$var$hasBindingGyp;
$b550ef5ee52404c1344fb94da2ce2aaa$exports.hasBindingGyp = $b550ef5ee52404c1344fb94da2ce2aaa$export$hasBindingGyp;
const $7793a39caad07442396d48d8137825bd$var$jsInstallUtils = $4d80ac9757769a55b72ee4f0926c5df8$export$__importStar($b550ef5ee52404c1344fb94da2ce2aaa$exports);
var $7793a39caad07442396d48d8137825bd$export$jsInstallUtils = $7793a39caad07442396d48d8137825bd$var$jsInstallUtils;
// ASSET: node_modules/@zkochan/cmd-shim/index.js
var $4d937f14251171092a30224d5e15791b$exports = {};
$4d937f14251171092a30224d5e15791b$var$cmdShim.ifExists = $4d937f14251171092a30224d5e15791b$var$cmdShimIfExists;
const $4d937f14251171092a30224d5e15791b$var$util_1 = $69678d3e0618202337016e1b4ed76965$init();
// ASSET: node_modules/make-dir/index.js
var $99c8a793939774842586544f37cf7eb3$exports = {};
var $99c8a793939774842586544f37cf7eb3$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
const $99c8a793939774842586544f37cf7eb3$var$fs = $4b4b2ca65c544aeebbd8703f9d50bd90$init();
const $99c8a793939774842586544f37cf7eb3$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
const {
  promisify: $99c8a793939774842586544f37cf7eb3$var$promisify
} = $69678d3e0618202337016e1b4ed76965$init();
const $99c8a793939774842586544f37cf7eb3$var$useNativeRecursiveOption = $472287880c3e8d04bc38855fbd388e1f$exports.satisfies($99c8a793939774842586544f37cf7eb3$var$process.version, '>=10.12.0'); // https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const $99c8a793939774842586544f37cf7eb3$var$checkPath = pth => {
  if ($99c8a793939774842586544f37cf7eb3$var$process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace($99c8a793939774842586544f37cf7eb3$var$path.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = 'EINVAL';
      throw error;
    }
  }
};

const $99c8a793939774842586544f37cf7eb3$var$processOptions = options => {
  // https://github.com/sindresorhus/make-dir/issues/18
  const defaults = {
    mode: 0o777,
    fs: $99c8a793939774842586544f37cf7eb3$var$fs
  };
  return { ...defaults,
    ...options
  };
};

const $99c8a793939774842586544f37cf7eb3$var$permissionError = pth => {
  // This replicates the exception of `fs.mkdir` with native the
  // `recusive` option when run on an invalid drive under Windows.
  const error = new Error(`operation not permitted, mkdir '${pth}'`);
  error.code = 'EPERM';
  error.errno = -4048;
  error.path = pth;
  error.syscall = 'mkdir';
  return error;
};

const $99c8a793939774842586544f37cf7eb3$var$makeDir = async (input, options) => {
  $99c8a793939774842586544f37cf7eb3$var$checkPath(input);
  options = $99c8a793939774842586544f37cf7eb3$var$processOptions(options);
  const mkdir = $99c8a793939774842586544f37cf7eb3$var$promisify(options.fs.mkdir);
  const stat = $99c8a793939774842586544f37cf7eb3$var$promisify(options.fs.stat);

  if ($99c8a793939774842586544f37cf7eb3$var$useNativeRecursiveOption && options.fs.mkdir === $99c8a793939774842586544f37cf7eb3$var$fs.mkdir) {
    const pth = $99c8a793939774842586544f37cf7eb3$var$path.resolve(input);
    await mkdir(pth, {
      mode: options.mode,
      recursive: true
    });
    return pth;
  }

  const make = async pth => {
    try {
      await mkdir(pth, options.mode);
      return pth;
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error;
      }

      if (error.code === 'ENOENT') {
        if ($99c8a793939774842586544f37cf7eb3$var$path.dirname(pth) === pth) {
          throw $99c8a793939774842586544f37cf7eb3$var$permissionError(pth);
        }

        if (error.message.includes('null bytes')) {
          throw error;
        }

        await make($99c8a793939774842586544f37cf7eb3$var$path.dirname(pth));
        return make(pth);
      }

      try {
        const stats = await stat(pth);

        if (!stats.isDirectory()) {
          throw new Error('The path is not a directory');
        }
      } catch (_) {
        throw error;
      }

      return pth;
    }
  };

  return make($99c8a793939774842586544f37cf7eb3$var$path.resolve(input));
};

$99c8a793939774842586544f37cf7eb3$exports = $99c8a793939774842586544f37cf7eb3$var$makeDir;

var $99c8a793939774842586544f37cf7eb3$export$sync = (input, options) => {
  $99c8a793939774842586544f37cf7eb3$var$checkPath(input);
  options = $99c8a793939774842586544f37cf7eb3$var$processOptions(options);

  if ($99c8a793939774842586544f37cf7eb3$var$useNativeRecursiveOption && options.fs.mkdirSync === $99c8a793939774842586544f37cf7eb3$var$fs.mkdirSync) {
    const pth = $99c8a793939774842586544f37cf7eb3$var$path.resolve(input);
    $99c8a793939774842586544f37cf7eb3$var$fs.mkdirSync(pth, {
      mode: options.mode,
      recursive: true
    });
    return pth;
  }

  const make = pth => {
    try {
      options.fs.mkdirSync(pth, options.mode);
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error;
      }

      if (error.code === 'ENOENT') {
        if ($99c8a793939774842586544f37cf7eb3$var$path.dirname(pth) === pth) {
          throw $99c8a793939774842586544f37cf7eb3$var$permissionError(pth);
        }

        if (error.message.includes('null bytes')) {
          throw error;
        }

        make($99c8a793939774842586544f37cf7eb3$var$path.dirname(pth));
        return make(pth);
      }

      try {
        if (!options.fs.statSync(pth).isDirectory()) {
          throw new Error('The path is not a directory');
        }
      } catch (_) {
        throw error;
      }
    }

    return pth;
  };

  return make($99c8a793939774842586544f37cf7eb3$var$path.resolve(input));
};

$99c8a793939774842586544f37cf7eb3$exports.sync = $99c8a793939774842586544f37cf7eb3$export$sync;
const $4d937f14251171092a30224d5e15791b$var$path = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
// ASSET: node_modules/is-windows/index.js
var $08aafa3f9f314e53b79fadb3cb6b0bf5$exports = {};
var $08aafa3f9f314e53b79fadb3cb6b0bf5$var$define;
var $08aafa3f9f314e53b79fadb3cb6b0bf5$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();

/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
(function (factory) {
  if ($08aafa3f9f314e53b79fadb3cb6b0bf5$exports && typeof $08aafa3f9f314e53b79fadb3cb6b0bf5$exports === 'object' && "object" !== 'undefined') {
    $08aafa3f9f314e53b79fadb3cb6b0bf5$exports = factory();
  } else if (typeof $08aafa3f9f314e53b79fadb3cb6b0bf5$var$define === 'function' && $08aafa3f9f314e53b79fadb3cb6b0bf5$var$define.amd) {
    $08aafa3f9f314e53b79fadb3cb6b0bf5$var$define([], factory);
  } else if (typeof window !== 'undefined') {
    window.isWindows = factory();
  } else if (typeof $parcel$global !== 'undefined') {
    $parcel$global.isWindows = factory();
  } else if (typeof self !== 'undefined') {
    self.isWindows = factory();
  } else {
    this.isWindows = factory();
  }
})(function () {
  return function isWindows() {
    return $08aafa3f9f314e53b79fadb3cb6b0bf5$var$process && ($08aafa3f9f314e53b79fadb3cb6b0bf5$var$process.platform === 'win32' || /^(msys|cygwin)$/.test(undefined));
  };
});

const $4d937f14251171092a30224d5e15791b$var$shebangExpr = /^#!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+)(.*)$/;
const $4d937f14251171092a30224d5e15791b$var$DEFAULT_OPTIONS = {
  // Create PowerShell file by default if the option hasn't been specified
  createPwshFile: true,
  createCmdFile: $08aafa3f9f314e53b79fadb3cb6b0bf5$exports(),
  fs: $4b4b2ca65c544aeebbd8703f9d50bd90$init()
};
/**
 * Map from extensions of files that this module is frequently used for to their runtime.
 * @type {Map<string, string>}
 */

/**
 * Map from extensions of files that this module is frequently used for to their runtime.
 * @type {Map<string, string>}
 */
const $4d937f14251171092a30224d5e15791b$var$extensionToProgramMap = new Map([['.js', 'node'], ['.cmd', 'cmd'], ['.bat', 'cmd'], ['.ps1', 'pwsh'], ['.sh', 'sh']]);

function $4d937f14251171092a30224d5e15791b$var$ingestOptions(opts) {
  const opts_ = { ...$4d937f14251171092a30224d5e15791b$var$DEFAULT_OPTIONS,
    ...opts
  };
  const fs = opts_.fs;
  opts_.fs_ = {
    chmod: fs.chmod ? $4d937f14251171092a30224d5e15791b$var$util_1.promisify(fs.chmod) : async () => {},
    stat: $4d937f14251171092a30224d5e15791b$var$util_1.promisify(fs.stat),
    unlink: $4d937f14251171092a30224d5e15791b$var$util_1.promisify(fs.unlink),
    readFile: $4d937f14251171092a30224d5e15791b$var$util_1.promisify(fs.readFile),
    writeFile: $4d937f14251171092a30224d5e15791b$var$util_1.promisify(fs.writeFile)
  };
  return opts_;
}
/**
 * Try to create shims.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 * @throws If `src` is missing.
 */


/**
 * Try to create shims.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 * @throws If `src` is missing.
 */
async function $4d937f14251171092a30224d5e15791b$var$cmdShim(src, to, opts) {
  const opts_ = $4d937f14251171092a30224d5e15791b$var$ingestOptions(opts);
  await opts_.fs_.stat(src);
  await $4d937f14251171092a30224d5e15791b$var$cmdShim_(src, to, opts_);
}
/**
 * Try to create shims.
 *
 * Does nothing if `src` doesn't exist.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */


/**
 * Try to create shims.
 *
 * Does nothing if `src` doesn't exist.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
function $4d937f14251171092a30224d5e15791b$var$cmdShimIfExists(src, to, opts) {
  return $4d937f14251171092a30224d5e15791b$var$cmdShim(src, to, opts).catch(() => {});
}
/**
 * Try to unlink, but ignore errors.
 * Any problems will surface later.
 *
 * @param path File to be removed.
 */


/**
 * Try to unlink, but ignore errors.
 * Any problems will surface later.
 *
 * @param path File to be removed.
 */
function $4d937f14251171092a30224d5e15791b$var$rm(path, opts) {
  return opts.fs_.unlink(path).catch(() => {});
}
/**
 * Try to create shims **even if `src` is missing**.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */


/**
 * Try to create shims **even if `src` is missing**.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
async function $4d937f14251171092a30224d5e15791b$var$cmdShim_(src, to, opts) {
  const srcRuntimeInfo = await $4d937f14251171092a30224d5e15791b$var$searchScriptRuntime(src, opts); // Always tries to create all types of shims by calling `writeAllShims` as of now.
  // Append your code here to change the behavior in response to `srcRuntimeInfo`.
  // Create 3 shims for (Ba)sh in Cygwin / MSYS, no extension) & CMD (.cmd) & PowerShell (.ps1)

  // Always tries to create all types of shims by calling `writeAllShims` as of now.
  // Append your code here to change the behavior in response to `srcRuntimeInfo`.
  // Create 3 shims for (Ba)sh in Cygwin / MSYS, no extension) & CMD (.cmd) & PowerShell (.ps1)
  await $4d937f14251171092a30224d5e15791b$var$writeShimsPreCommon(to, opts);
  return $4d937f14251171092a30224d5e15791b$var$writeAllShims(src, to, srcRuntimeInfo, opts);
}
/**
 * Do processes before **all** shims are created.
 * This must be called **only once** for one call of `cmdShim(IfExists)`.
 *
 * @param target Path of shims that are going to be created.
 */


/**
 * Do processes before **all** shims are created.
 * This must be called **only once** for one call of `cmdShim(IfExists)`.
 *
 * @param target Path of shims that are going to be created.
 */
function $4d937f14251171092a30224d5e15791b$var$writeShimsPreCommon(target, opts) {
  return $99c8a793939774842586544f37cf7eb3$exports($4d937f14251171092a30224d5e15791b$var$path.dirname(target), {
    fs: opts.fs
  });
}
/**
 * Write all types (sh & cmd & pwsh) of shims to files.
 * Extensions (`.cmd` and `.ps1`) are appended to cmd and pwsh shims.
 *
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims **without extensions**.
 * Extensions are added for CMD and PowerShell shims.
 * @param srcRuntimeInfo Return value of `await searchScriptRuntime(src)`.
 * @param opts Options.
 */


/**
 * Write all types (sh & cmd & pwsh) of shims to files.
 * Extensions (`.cmd` and `.ps1`) are appended to cmd and pwsh shims.
 *
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims **without extensions**.
 * Extensions are added for CMD and PowerShell shims.
 * @param srcRuntimeInfo Return value of `await searchScriptRuntime(src)`.
 * @param opts Options.
 */
function $4d937f14251171092a30224d5e15791b$var$writeAllShims(src, to, srcRuntimeInfo, opts) {
  const opts_ = $4d937f14251171092a30224d5e15791b$var$ingestOptions(opts);
  const generatorAndExts = [{
    generator: $4d937f14251171092a30224d5e15791b$var$generateShShim,
    extension: ''
  }];

  if (opts_.createCmdFile) {
    generatorAndExts.push({
      generator: $4d937f14251171092a30224d5e15791b$var$generateCmdShim,
      extension: '.cmd'
    });
  }

  if (opts_.createPwshFile) {
    generatorAndExts.push({
      generator: $4d937f14251171092a30224d5e15791b$var$generatePwshShim,
      extension: '.ps1'
    });
  }

  return Promise.all(generatorAndExts.map(generatorAndExt => $4d937f14251171092a30224d5e15791b$var$writeShim(src, to + generatorAndExt.extension, srcRuntimeInfo, generatorAndExt.generator, opts_)));
}
/**
 * Do processes before writing shim.
 *
 * @param target Path to shim that is going to be created.
 */


/**
 * Do processes before writing shim.
 *
 * @param target Path to shim that is going to be created.
 */
function $4d937f14251171092a30224d5e15791b$var$writeShimPre(target, opts) {
  return $4d937f14251171092a30224d5e15791b$var$rm(target, opts);
}
/**
 * Do processes after writing the shim.
 *
 * @param target Path to just created shim.
 */


/**
 * Do processes after writing the shim.
 *
 * @param target Path to just created shim.
 */
function $4d937f14251171092a30224d5e15791b$var$writeShimPost(target, opts) {
  // Only chmoding shims as of now.
  // Some other processes may be appended.
  return $4d937f14251171092a30224d5e15791b$var$chmodShim(target, opts);
}
/**
 * Look into runtime (e.g. `node` & `sh` & `pwsh`) and its arguments
 * of the target program (script or executable).
 *
 * @param target Path to the executable or script.
 * @return Promise of infomation of runtime of `target`.
 */


/**
 * Look into runtime (e.g. `node` & `sh` & `pwsh`) and its arguments
 * of the target program (script or executable).
 *
 * @param target Path to the executable or script.
 * @return Promise of infomation of runtime of `target`.
 */
async function $4d937f14251171092a30224d5e15791b$var$searchScriptRuntime(target, opts) {
  const data = await opts.fs_.readFile(target, 'utf8'); // First, check if the bin is a #! of some sort.

  // First, check if the bin is a #! of some sort.
  const firstLine = data.trim().split(/\r*\n/)[0];
  const shebang = firstLine.match($4d937f14251171092a30224d5e15791b$var$shebangExpr);

  if (!shebang) {
    // If not, infer script type from its extension.
    // If the inference fails, it's something that'll be compiled, or some other
    // sort of script, and just call it directly.
    const targetExtension = $4d937f14251171092a30224d5e15791b$var$path.extname(target).toLowerCase();
    return {
      // undefined if extension is unknown but it's converted to null.
      program: $4d937f14251171092a30224d5e15791b$var$extensionToProgramMap.get(targetExtension) || null,
      additionalArgs: ''
    };
  }

  return {
    program: shebang[1],
    additionalArgs: shebang[2]
  };
}
/**
 * Write shim to the file system while executing the pre- and post-processes
 * defined in `WriteShimPre` and `WriteShimPost`.
 *
 * @param src Path to the executable or script.
 * @param to Path to the (sh) shim(s) that is going to be created.
 * @param srcRuntimeInfo Result of `await searchScriptRuntime(src)`.
 * @param generateShimScript Generator of shim script.
 * @param opts Other options.
 */


/**
 * Write shim to the file system while executing the pre- and post-processes
 * defined in `WriteShimPre` and `WriteShimPost`.
 *
 * @param src Path to the executable or script.
 * @param to Path to the (sh) shim(s) that is going to be created.
 * @param srcRuntimeInfo Result of `await searchScriptRuntime(src)`.
 * @param generateShimScript Generator of shim script.
 * @param opts Other options.
 */
async function $4d937f14251171092a30224d5e15791b$var$writeShim(src, to, srcRuntimeInfo, generateShimScript, opts) {
  const defaultArgs = opts.preserveSymlinks ? '--preserve-symlinks' : ''; // `Array.prototype.filter` removes ''.
  // ['--foo', '--bar'].join(' ') and [].join(' ') returns '--foo --bar' and '' respectively.

  // `Array.prototype.filter` removes ''.
  // ['--foo', '--bar'].join(' ') and [].join(' ') returns '--foo --bar' and '' respectively.
  const args = [srcRuntimeInfo.additionalArgs, defaultArgs].filter(arg => arg).join(' ');
  opts = Object.assign({}, opts, {
    prog: srcRuntimeInfo.program,
    args: args
  });
  await $4d937f14251171092a30224d5e15791b$var$writeShimPre(to, opts);
  await opts.fs_.writeFile(to, generateShimScript(src, to, opts), 'utf8');
  return $4d937f14251171092a30224d5e15791b$var$writeShimPost(to, opts);
}
/**
 * Generate the content of a shim for CMD.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.cmd` (or `.bat`).
 * @param opts Options.
 * @return The content of shim.
 */


/**
 * Generate the content of a shim for CMD.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.cmd` (or `.bat`).
 * @param opts Options.
 * @return The content of shim.
 */
function $4d937f14251171092a30224d5e15791b$var$generateCmdShim(src, to, opts) {
  // `shTarget` is not used to generate the content.
  const shTarget = $4d937f14251171092a30224d5e15791b$var$path.relative($4d937f14251171092a30224d5e15791b$var$path.dirname(to), src);
  let target = shTarget.split('/').join('\\');
  const quotedPathToTarget = $4d937f14251171092a30224d5e15791b$var$path.isAbsolute(target) ? `"${target}"` : `"%~dp0\\${target}"`;
  let longProg;
  let prog = opts.prog;
  let args = opts.args || '';
  const nodePath = $4d937f14251171092a30224d5e15791b$var$normalizePathEnvVar(opts.nodePath).win32;

  if (!prog) {
    prog = quotedPathToTarget;
    args = '';
    target = '';
  } else {
    longProg = `"%~dp0\\${prog}.exe"`;
    target = quotedPathToTarget;
  }

  let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : ''; // @IF EXIST "%~dp0\node.exe" (
  //   "%~dp0\node.exe" "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
  // ) ELSE (
  //   SETLOCAL
  //   SET PATHEXT=%PATHEXT:;.JS;=;%
  //   node "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
  // )

  // @IF EXIST "%~dp0\node.exe" (
  //   "%~dp0\node.exe" "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
  // ) ELSE (
  //   SETLOCAL
  //   SET PATHEXT=%PATHEXT:;.JS;=;%
  //   node "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
  // )
  let cmd = nodePath ? `@SET NODE_PATH=${nodePath}\r\n` : '';

  if (longProg) {
    cmd += `@IF EXIST ${longProg} (\r\n` + `  ${longProg} ${args} ${target} ${progArgs}%*\r\n` + ') ELSE (\r\n' + '  @SETLOCAL\r\n' + '  @SET PATHEXT=%PATHEXT:;.JS;=;%\r\n' + `  ${prog} ${args} ${target} ${progArgs}%*\r\n` + ')';
  } else {
    cmd += `@${prog} ${args} ${target} ${progArgs}%*\r\n`;
  }

  return cmd;
}
/**
 * Generate the content of a shim for (Ba)sh in, for example, Cygwin and MSYS(2).
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.sh` or to contain no extension.
 * @param opts Options.
 * @return The content of shim.
 */


/**
 * Generate the content of a shim for (Ba)sh in, for example, Cygwin and MSYS(2).
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.sh` or to contain no extension.
 * @param opts Options.
 * @return The content of shim.
 */
function $4d937f14251171092a30224d5e15791b$var$generateShShim(src, to, opts) {
  let shTarget = $4d937f14251171092a30224d5e15791b$var$path.relative($4d937f14251171092a30224d5e15791b$var$path.dirname(to), src);
  let shProg = opts.prog && opts.prog.split('\\').join('/');
  let shLongProg;
  shTarget = shTarget.split('\\').join('/');
  const quotedPathToTarget = $4d937f14251171092a30224d5e15791b$var$path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
  let args = opts.args || '';
  const shNodePath = $4d937f14251171092a30224d5e15791b$var$normalizePathEnvVar(opts.nodePath).posix;

  if (!shProg) {
    shProg = quotedPathToTarget;
    args = '';
    shTarget = '';
  } else {
    shLongProg = `"$basedir/${opts.prog}"`;
    shTarget = quotedPathToTarget;
  }

  let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : ''; // #!/bin/sh
  // basedir=`dirname "$0"`
  //
  // case `uname` in
  //     *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
  // esac
  //
  // export NODE_PATH="<nodepath>"
  //
  // if [ -x "$basedir/node.exe" ]; then
  //   exec "$basedir/node.exe" "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
  // else
  //   exec node "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
  // fi

  // #!/bin/sh
  // basedir=`dirname "$0"`
  //
  // case `uname` in
  //     *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
  // esac
  //
  // export NODE_PATH="<nodepath>"
  //
  // if [ -x "$basedir/node.exe" ]; then
  //   exec "$basedir/node.exe" "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
  // else
  //   exec node "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
  // fi
  let sh = '#!/bin/sh\n';
  sh = sh + "basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")\n" + '\n' + 'case `uname` in\n' + '    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;\n' + 'esac\n' + '\n';
  const env = opts.nodePath ? `export NODE_PATH="${shNodePath}"\n` : '';

  if (shLongProg) {
    sh += env + `if [ -x ${shLongProg} ]; then\n` + `  exec ${shLongProg} ${args} ${shTarget} ${progArgs}"$@"\n` + 'else \n' + `  exec ${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` + 'fi\n';
  } else {
    sh += `${env}${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` + 'exit $?\n';
  }

  return sh;
}
/**
 * Generate the content of a shim for PowerShell.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.ps1`.
 * @param opts Options.
 * @return The content of shim.
 */


/**
 * Generate the content of a shim for PowerShell.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.ps1`.
 * @param opts Options.
 * @return The content of shim.
 */
function $4d937f14251171092a30224d5e15791b$var$generatePwshShim(src, to, opts) {
  let shTarget = $4d937f14251171092a30224d5e15791b$var$path.relative($4d937f14251171092a30224d5e15791b$var$path.dirname(to), src);
  const shProg = opts.prog && opts.prog.split('\\').join('/');
  let pwshProg = shProg && `"${shProg}$exe"`;
  let pwshLongProg;
  shTarget = shTarget.split('\\').join('/');
  const quotedPathToTarget = $4d937f14251171092a30224d5e15791b$var$path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
  let args = opts.args || '';
  let normalizedPathEnvVar = $4d937f14251171092a30224d5e15791b$var$normalizePathEnvVar(opts.nodePath);
  const nodePath = normalizedPathEnvVar.win32;
  const shNodePath = normalizedPathEnvVar.posix;

  if (!pwshProg) {
    pwshProg = quotedPathToTarget;
    args = '';
    shTarget = '';
  } else {
    pwshLongProg = `"$basedir/${opts.prog}$exe"`;
    shTarget = quotedPathToTarget;
  }

  let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : ''; // #!/usr/bin/env pwsh
  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent
  //
  // $ret=0
  // $exe = ""
  // if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {
  //   # Fix case when both the Windows and Linux builds of Node
  //   # are installed in the same directory
  //   $exe = ".exe"
  // }
  // if (Test-Path "$basedir/node") {
  //   # Support pipeline input
  //   if ($MyInvocation.ExpectingInput) {
  //     $input | & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   } else {
  //     & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   }
  //   $ret=$LASTEXITCODE
  // } else {
  //   # Support pipeline input
  //   if ($MyInvocation.ExpectingInput) {
  //     $input | & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   } else {
  //     & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   }
  //   $ret=$LASTEXITCODE
  // }
  // exit $ret

  // #!/usr/bin/env pwsh
  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent
  //
  // $ret=0
  // $exe = ""
  // if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {
  //   # Fix case when both the Windows and Linux builds of Node
  //   # are installed in the same directory
  //   $exe = ".exe"
  // }
  // if (Test-Path "$basedir/node") {
  //   # Support pipeline input
  //   if ($MyInvocation.ExpectingInput) {
  //     $input | & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   } else {
  //     & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   }
  //   $ret=$LASTEXITCODE
  // } else {
  //   # Support pipeline input
  //   if ($MyInvocation.ExpectingInput) {
  //     $input | & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   } else {
  //     & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
  //   }
  //   $ret=$LASTEXITCODE
  // }
  // exit $ret
  let pwsh = '#!/usr/bin/env pwsh\n' + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n' + '\n' + '$exe=""\n' + (opts.nodePath ? '$env_node_path=$env:NODE_PATH\n' + `$env:NODE_PATH="${nodePath}"\n` : '') + 'if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n' + '  # Fix case when both the Windows and Linux builds of Node\n' + '  # are installed in the same directory\n' + '  $exe=".exe"\n' + '}';

  if (opts.nodePath) {
    pwsh = pwsh + ' else {\n' + `  $env:NODE_PATH="${shNodePath}"\n` + '}';
  }

  pwsh += '\n';

  if (pwshLongProg) {
    pwsh = pwsh + '$ret=0\n' + `if (Test-Path ${pwshLongProg}) {\n` + '  # Support pipeline input\n' + '  if ($MyInvocation.ExpectingInput) {\n' + `    $input | & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` + '  } else {\n' + `    & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` + '  }\n' + '  $ret=$LASTEXITCODE\n' + '} else {\n' + '  # Support pipeline input\n' + '  if ($MyInvocation.ExpectingInput) {\n' + `    $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` + '  } else {\n' + `    & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` + '  }\n' + '  $ret=$LASTEXITCODE\n' + '}\n' + (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') + 'exit $ret\n';
  } else {
    pwsh = pwsh + '# Support pipeline input\n' + 'if ($MyInvocation.ExpectingInput) {\n' + `  $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` + '} else {\n' + `  & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` + '}\n' + (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') + 'exit $LASTEXITCODE\n';
  }

  return pwsh;
}
/**
 * Chmod just created shim and make it executable
 *
 * @param to Path to shim.
 */


/**
 * Chmod just created shim and make it executable
 *
 * @param to Path to shim.
 */
function $4d937f14251171092a30224d5e15791b$var$chmodShim(to, opts) {
  return opts.fs_.chmod(to, 0o755);
}

function $4d937f14251171092a30224d5e15791b$var$normalizePathEnvVar(nodePath) {
  if (!nodePath) {
    return {
      win32: '',
      posix: ''
    };
  }

  let split = typeof nodePath === 'string' ? nodePath.split($4d937f14251171092a30224d5e15791b$var$path.delimiter) : Array.from(nodePath);
  let result = {};

  for (let i = 0; i < split.length; i++) {
    const win32 = split[i].split('/').join('\\');
    const posix = $08aafa3f9f314e53b79fadb3cb6b0bf5$exports() ? split[i].split('\\').join('/').replace(/^([^:\\/]*):/, (_, $1) => `/mnt/${$1.toLowerCase()}`) : split[i];
    result.win32 = result.win32 ? `${result.win32};${win32}` : win32;
    result.posix = result.posix ? `${result.posix}:${posix}` : posix;
    result[i] = {
      win32,
      posix
    };
  }

  return result;
}

$4d937f14251171092a30224d5e15791b$exports = $4d937f14251171092a30224d5e15791b$var$cmdShim;
const $727321b616b6b83fee27ff1a2a90cf03$var$cmd_shim_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4d937f14251171092a30224d5e15791b$exports);
const $727321b616b6b83fee27ff1a2a90cf03$var$fs_1 = $4d80ac9757769a55b72ee4f0926c5df8$export$__importDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());
const $727321b616b6b83fee27ff1a2a90cf03$var$STATE_FILE_VERSION = 1;
const $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES = `node_modules`;
const $727321b616b6b83fee27ff1a2a90cf03$var$DOT_BIN = `.bin`;
const $727321b616b6b83fee27ff1a2a90cf03$var$INSTALL_STATE_FILE = `.yarn-state.yml`;

class $727321b616b6b83fee27ff1a2a90cf03$var$NodeModulesLinker {
  supportsPackage(pkg, opts) {
    return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
  }

  async findPackageLocation(locator, opts) {
    const workspace = opts.project.tryWorkspaceByLocator(locator);
    if (workspace) return workspace.cwd;
    const installState = await $727321b616b6b83fee27ff1a2a90cf03$var$findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) throw new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
    const locatorInfo = installState.locatorMap.get($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyLocator(locator));

    if (!locatorInfo) {
      const err = new $58f473d264f81a9cc788ca133b8fa697$export$UsageError(`Couldn't find ${$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
      err.code = `LOCATOR_NOT_INSTALLED`;
      throw err;
    }

    return locatorInfo.locations[0];
  }

  async findPackageLocator(location, opts) {
    const installState = await $727321b616b6b83fee27ff1a2a90cf03$var$findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) return null;
    const {
      locationRoot,
      segments
    } = $727321b616b6b83fee27ff1a2a90cf03$var$parseLocation($ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(location), {
      skipPrefix: opts.project.cwd
    });
    let locationNode = installState.locationTree.get(locationRoot);
    if (!locationNode) return null;
    let locator = locationNode.locator;

    for (const segment of segments) {
      locationNode = locationNode.children.get(segment);
      if (!locationNode) break;
      locator = locationNode.locator || locator;
    }

    return $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locator);
  }

  makeInstaller(opts) {
    return new $727321b616b6b83fee27ff1a2a90cf03$var$NodeModulesInstaller(opts);
  }

}

$727321b616b6b83fee27ff1a2a90cf03$export$NodeModulesLinker = $727321b616b6b83fee27ff1a2a90cf03$var$NodeModulesLinker;
$727321b616b6b83fee27ff1a2a90cf03$exports.NodeModulesLinker = $727321b616b6b83fee27ff1a2a90cf03$export$NodeModulesLinker;

class $727321b616b6b83fee27ff1a2a90cf03$var$NodeModulesInstaller {
  constructor(opts) {
    this.opts = opts; // Stores data that we need to extract in the `installPackage` step but use
    // in the `finalizeInstall` step. Contrary to custom data this isn't persisted
    // anywhere - we literally just use it for the lifetime of the installer then
    // discard it.

    // Stores data that we need to extract in the `installPackage` step but use
    // in the `finalizeInstall` step. Contrary to custom data this isn't persisted
    // anywhere - we literally just use it for the lifetime of the installer then
    // discard it.
    this.localStore = new Map();
    this.customData = {
      store: new Map()
    }; // Nothing to do
  }

  getCustomDataKey() {
    return JSON.stringify({
      name: `NodeModulesInstaller`,
      version: 1
    });
  }

  attachCustomData(customData) {
    this.customData = customData;
  }

  async installPackage(pkg, fetchResult) {
    var _a;

    const packageLocation = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
    let customPackageData = this.customData.store.get(pkg.locatorHash);

    if (typeof customPackageData === `undefined`) {
      customPackageData = await $727321b616b6b83fee27ff1a2a90cf03$var$extractCustomPackageData(pkg, fetchResult);

      if (pkg.linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD) {
        this.customData.store.set(pkg.locatorHash, customPackageData);
      }
    } // We don't link the package at all if it's for an unsupported platform


    // We don't link the package at all if it's for an unsupported platform
    if (!$7793a39caad07442396d48d8137825bd$export$jsInstallUtils.checkAndReportManifestCompatibility(pkg, customPackageData, `link`, {
      configuration: this.opts.project.configuration,
      report: this.opts.report
    })) return {
      packageLocation: null,
      buildDirective: null
    };
    const packageDependencies = new Map();
    const packagePeers = new Set();
    if (!packageDependencies.has($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(pkg))) packageDependencies.set($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(pkg), pkg.reference); // Only virtual packages should have effective peer dependencies, but the
    // workspaces are a special case because the original packages are kept in
    // the dependency tree even after being virtualized; so in their case we
    // just ignore their declared peer dependencies.

    // Only virtual packages should have effective peer dependencies, but the
    // workspaces are a special case because the original packages are kept in
    // the dependency tree even after being virtualized; so in their case we
    // just ignore their declared peer dependencies.
    if ($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.isVirtualLocator(pkg)) {
      for (const descriptor of pkg.peerDependencies.values()) {
        packageDependencies.set($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(descriptor), null);
        packagePeers.add($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(descriptor));
      }
    }

    const pnpNode = {
      packageLocation: `${$ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(packageLocation)}/`,
      packageDependencies,
      packagePeers,
      linkType: pkg.linkType,
      discardFromLookup: (_a = fetchResult.discardFromLookup) !== null && _a !== void 0 ? _a : false
    };
    this.localStore.set(pkg.locatorHash, {
      pkg,
      customPackageData,
      dependencyMeta: this.opts.project.getDependencyMeta(pkg, pkg.version),
      pnpNode
    });
    return {
      packageLocation,
      buildDirective: null
    };
  }

  async attachInternalDependencies(locator, dependencies) {
    const slot = this.localStore.get(locator.locatorHash);
    if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected information object to have been registered`);

    for (const [descriptor, locator] of dependencies) {
      const target = !$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.areIdentsEqual(descriptor, locator) ? [$b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.requirableIdent(locator), locator.reference] : locator.reference;
      slot.pnpNode.packageDependencies.set($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.requirableIdent(descriptor), target);
    }
  }

  async attachExternalDependents(locator, dependentPaths) {
    throw new Error(`External dependencies haven't been implemented for the node-modules linker`);
  }

  async finalizeInstall() {
    if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`) return undefined;
    const defaultFsLayer = new $ea9c1e38c3e8cca334929a597a084311$exports.VirtualFS({
      baseFs: new $ea9c1e38c3e8cca334929a597a084311$exports.ZipOpenFS({
        libzip: await $65fa1f8282605ab74bde1e38aef95806$exports.getLibzipPromise(),
        maxOpenFiles: 80,
        readOnlyArchives: true
      })
    });
    let preinstallState = await $727321b616b6b83fee27ff1a2a90cf03$var$findInstallState(this.opts.project); // Remove build state as well, to force rebuild of all the packages

    // Remove build state as well, to force rebuild of all the packages
    if (preinstallState === null) {
      const bstatePath = this.opts.project.configuration.get(`bstatePath`);
      if (await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsPromise(bstatePath)) await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.unlinkPromise(bstatePath);
      preinstallState = {
        locatorMap: new Map(),
        binSymlinks: new Map(),
        locationTree: new Map()
      };
    }

    const hoistingLimitsByCwd = new Map(this.opts.project.workspaces.map(workspace => {
      var _a, _b;

      let hoistingLimits = this.opts.project.configuration.get(`nmHoistingLimits`);

      try {
        hoistingLimits = $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils.validateEnum($aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits, (_b = (_a = workspace.manifest.installConfig) === null || _a === void 0 ? void 0 : _a.hoistingLimits) !== null && _b !== void 0 ? _b : hoistingLimits);
      } catch (e) {
        const workspaceName = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.prettyWorkspace(this.opts.project.configuration, workspace);
        this.opts.report.reportWarning($b0ffa420366ed37c7cf8ff798018d16e$exports.MessageName.INVALID_MANIFEST, `${workspaceName}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values($aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits).join(`, `)}, using default: "${hoistingLimits}"`);
      }

      return [workspace.relativeCwd, hoistingLimits];
    }));
    const pnpApi = {
      VERSIONS: {
        std: 1
      },
      topLevel: {
        name: null,
        reference: null
      },
      getLocator: (name, referencish) => {
        if (Array.isArray(referencish)) {
          return {
            name: referencish[0],
            reference: referencish[1]
          };
        } else {
          return {
            name,
            reference: referencish
          };
        }
      },
      getDependencyTreeRoots: () => {
        return this.opts.project.workspaces.map(workspace => {
          const anchoredLocator = workspace.anchoredLocator;
          return {
            name: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(workspace.locator),
            reference: anchoredLocator.reference
          };
        });
      },
      getPackageInformation: pnpLocator => {
        const locator = pnpLocator.reference === null ? this.opts.project.topLevelWorkspace.anchoredLocator : $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeLocator($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseIdent(pnpLocator.name), pnpLocator.reference);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the package reference to have been registered`);
        return slot.pnpNode;
      },
      findPackageLocator: location => {
        const workspace = this.opts.project.tryWorkspaceByCwd($ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(location));

        if (workspace !== null) {
          const anchoredLocator = workspace.anchoredLocator;
          return {
            name: $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyIdent(anchoredLocator),
            reference: anchoredLocator.reference
          };
        }

        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveToUnqualified: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveUnqualified: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveRequest: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveVirtual: path => {
        return $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath($ea9c1e38c3e8cca334929a597a084311$exports.VirtualFS.resolveVirtual($ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(path)));
      }
    };
    const nmTree = $aeb9334011cb4a85c526c27a96f15906$exports.buildNodeModulesTree(pnpApi, {
      pnpifyFs: false,
      hoistingLimitsByCwd,
      project: this.opts.project
    });
    const locatorMap = $aeb9334011cb4a85c526c27a96f15906$exports.buildLocatorMap(nmTree);
    await $727321b616b6b83fee27ff1a2a90cf03$var$persistNodeModules(preinstallState, locatorMap, {
      baseFs: defaultFsLayer,
      project: this.opts.project,
      report: this.opts.report,
      loadManifest: async locatorKey => {
        const locator = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locatorKey);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the slot to exist`);
        return slot.customPackageData.manifest;
      }
    });
    const installStatuses = [];

    for (const [locatorKey, installRecord] of locatorMap.entries()) {
      if ($727321b616b6b83fee27ff1a2a90cf03$var$isLinkLocator(locatorKey)) continue;
      const locator = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locatorKey);
      const slot = this.localStore.get(locator.locatorHash);
      if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the slot to exist`);
      const buildScripts = $7793a39caad07442396d48d8137825bd$export$jsInstallUtils.extractBuildScripts(slot.pkg, slot.customPackageData, slot.dependencyMeta, {
        configuration: this.opts.project.configuration,
        report: this.opts.report
      });
      if (buildScripts.length === 0) continue;
      installStatuses.push({
        buildLocations: installRecord.locations,
        locatorHash: locator.locatorHash,
        buildDirective: buildScripts
      });
    }

    return {
      customData: this.customData,
      records: installStatuses
    };
  }

}

async function $727321b616b6b83fee27ff1a2a90cf03$var$extractCustomPackageData(pkg, fetchResult) {
  var _a;

  const manifest = (_a = await $b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest.tryFind(fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  })) !== null && _a !== void 0 ? _a : new $b0ffa420366ed37c7cf8ff798018d16e$exports.Manifest();
  const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);

  for (const scriptName of manifest.scripts.keys()) if (!preservedScripts.has(scriptName)) manifest.scripts.delete(scriptName);

  return {
    manifest: {
      bin: manifest.bin,
      os: manifest.os,
      cpu: manifest.cpu,
      scripts: manifest.scripts
    },
    misc: {
      extractHint: $7793a39caad07442396d48d8137825bd$export$jsInstallUtils.getExtractHint(fetchResult),
      hasBindingGyp: $7793a39caad07442396d48d8137825bd$export$jsInstallUtils.hasBindingGyp(fetchResult)
    }
  };
}

async function $727321b616b6b83fee27ff1a2a90cf03$var$writeInstallState(project, locatorMap, binSymlinks) {
  let locatorState = ``;
  locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will\n`;
  locatorState += `# cause your node_modules installation to become invalidated.\n`;
  locatorState += `\n`;
  locatorState += `__metadata:\n`;
  locatorState += `  version: ${$727321b616b6b83fee27ff1a2a90cf03$var$STATE_FILE_VERSION}\n`;
  const locators = Array.from(locatorMap.keys()).sort();
  const topLevelLocator = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyLocator(project.topLevelWorkspace.anchoredLocator);

  for (const locator of locators) {
    const installRecord = locatorMap.get(locator);
    locatorState += `\n`;
    locatorState += `${JSON.stringify(locator)}:\n`;
    locatorState += `  locations:\n`;

    for (const location of installRecord.locations) {
      const internalPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(project.cwd, location);
      if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
      locatorState += `    - ${JSON.stringify(internalPath)}\n`;
    }

    if (installRecord.aliases.length > 0) {
      locatorState += `  aliases:\n`;

      for (const alias of installRecord.aliases) {
        locatorState += `    - ${JSON.stringify(alias)}\n`;
      }
    }

    if (locator === topLevelLocator && binSymlinks.size > 0) {
      locatorState += `  bin:\n`;

      for (const [location, symlinks] of binSymlinks) {
        const internalPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(project.cwd, location);
        if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
        locatorState += `    ${JSON.stringify(internalPath)}:\n`;

        for (const [name, target] of symlinks) {
          const relativePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES), target);
          locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}\n`;
        }
      }
    }
  }

  const rootPath = project.cwd;
  const installStatePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(rootPath, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES, $727321b616b6b83fee27ff1a2a90cf03$var$INSTALL_STATE_FILE);
  await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.changeFilePromise(installStatePath, locatorState, {
    automaticNewlines: true
  });
}

async function $727321b616b6b83fee27ff1a2a90cf03$var$findInstallState(project, {
  unrollAliases = false
} = {}) {
  const rootPath = project.cwd;
  const installStatePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(rootPath, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES, $727321b616b6b83fee27ff1a2a90cf03$var$INSTALL_STATE_FILE);
  if (!$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(installStatePath)) return null;
  const locatorState = $0e609d03a5066ebec776a5ec6a49b084$exports.parseSyml(await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readFilePromise(installStatePath, `utf8`)); // If we have a higher serialized version than we can handle, ignore the state alltogether

  // If we have a higher serialized version than we can handle, ignore the state alltogether
  if (locatorState.__metadata.version > $727321b616b6b83fee27ff1a2a90cf03$var$STATE_FILE_VERSION) return null;
  const locatorMap = new Map();
  const binSymlinks = new Map();
  delete locatorState.__metadata;

  for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
    const locations = installRecord.locations.map(location => {
      return $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(rootPath, location);
    });
    const recordSymlinks = installRecord.bin;

    if (recordSymlinks) {
      for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
        const location = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(rootPath, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(relativeLocation));
        const symlinks = $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils.getMapWithDefault(binSymlinks, location);

        for (const [name, target] of Object.entries(locationSymlinks)) {
          symlinks.set($ea9c1e38c3e8cca334929a597a084311$exports.toFilename(name), $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath([location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES, target].join($ea9c1e38c3e8cca334929a597a084311$exports.ppath.delimiter)));
        }
      }
    }

    locatorMap.set(locatorStr, {
      target: $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot,
      linkType: $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD,
      locations,
      aliases: installRecord.aliases || []
    });

    if (unrollAliases && installRecord.aliases) {
      for (const reference of installRecord.aliases) {
        const {
          scope,
          name
        } = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locatorStr);
        const alias = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeLocator($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.makeIdent(scope, name), reference);
        const aliasStr = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.stringifyLocator(alias);
        locatorMap.set(aliasStr, {
          target: $ea9c1e38c3e8cca334929a597a084311$exports.PortablePath.dot,
          linkType: $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD,
          locations,
          aliases: []
        });
      }
    }
  }

  return {
    locatorMap,
    binSymlinks,
    locationTree: $727321b616b6b83fee27ff1a2a90cf03$var$buildLocationTree(locatorMap, {
      skipPrefix: project.cwd
    })
  };
}

const $727321b616b6b83fee27ff1a2a90cf03$var$removeDir = async (dir, options) => {
  if (dir.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep).indexOf($727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES) < 0) throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);

  try {
    if (!options.innerLoop) {
      const stats = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.lstatPromise(dir);

      if (stats.isSymbolicLink()) {
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.unlinkPromise(dir);
        return;
      }
    }

    const entries = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readdirPromise(dir, {
      withFileTypes: true
    });

    for (const entry of entries) {
      const targetPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(dir, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(entry.name));

      if (entry.isDirectory()) {
        if (entry.name !== $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES || options && options.innerLoop) {
          await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir(targetPath, {
            innerLoop: true,
            contentsOnly: false
          });
        }
      } else {
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.unlinkPromise(targetPath);
      }
    }

    if (!options.contentsOnly) {
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.rmdirPromise(dir);
    }
  } catch (e) {
    if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
      throw e;
    }
  }
};

const $727321b616b6b83fee27ff1a2a90cf03$var$CONCURRENT_OPERATION_LIMIT = 4;

const $727321b616b6b83fee27ff1a2a90cf03$var$parseLocation = (location, {
  skipPrefix
}) => {
  const projectRelativePath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(skipPrefix, location);
  if (projectRelativePath === null) throw new Error(`Assertion failed: Cannot process a path that isn't part of the requested prefix (${location} isn't within ${skipPrefix})`);
  const allSegments = projectRelativePath.split($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep) // Ignore empty segments (after trailing slashes)
  . // Ignore empty segments (after trailing slashes)
  filter(segment => segment !== ``);
  const nmIndex = allSegments.indexOf($727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES); // Project path, up until the first node_modules segment

  // Project path, up until the first node_modules segment
  const relativeRoot = allSegments.slice(0, nmIndex).join($ea9c1e38c3e8cca334929a597a084311$exports.ppath.sep);
  const locationRoot = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(skipPrefix, relativeRoot); // All segments that follow

  // All segments that follow
  const segments = allSegments.slice(nmIndex);
  return {
    locationRoot,
    segments
  };
};

const $727321b616b6b83fee27ff1a2a90cf03$var$buildLocationTree = (locatorMap, {
  skipPrefix
}) => {
  const locationTree = new Map();
  if (locatorMap === null) return locationTree;

  const makeNode = () => ({
    children: new Map(),
    linkType: $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD
  });

  for (const [locator, info] of locatorMap.entries()) {
    if (info.linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.SOFT) {
      const internalPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(skipPrefix, info.target);

      if (internalPath !== null) {
        const node = $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils.getFactoryWithDefault(locationTree, info.target, makeNode);
        node.locator = locator;
        node.linkType = info.linkType;
      }
    }

    for (const location of info.locations) {
      const {
        locationRoot,
        segments
      } = $727321b616b6b83fee27ff1a2a90cf03$var$parseLocation(location, {
        skipPrefix
      });
      let node = $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils.getFactoryWithDefault(locationTree, locationRoot, makeNode);

      for (let idx = 0; idx < segments.length; ++idx) {
        const segment = segments[idx]; // '.' segment exists only for top-level locator, skip it

        // '.' segment exists only for top-level locator, skip it
        if (segment !== `.`) {
          const nextNode = $b0ffa420366ed37c7cf8ff798018d16e$exports.miscUtils.getFactoryWithDefault(node.children, segment, makeNode);
          node.children.set(segment, nextNode);
          node = nextNode;
        }

        if (idx === segments.length - 1) {
          node.locator = locator;
          node.linkType = info.linkType;
        }
      }
    }
  }

  return locationTree;
};

const $727321b616b6b83fee27ff1a2a90cf03$var$symlinkPromise = async (srcPath, dstPath) => {
  let stats;

  try {
    if ($727321b616b6b83fee27ff1a2a90cf03$var$process.platform === `win32`) {
      stats = $ea9c1e38c3e8cca334929a597a084311$exports.xfs.lstatSync(srcPath);
    }
  } catch (e) {}

  if ($727321b616b6b83fee27ff1a2a90cf03$var$process.platform == `win32` && (!stats || stats.isDirectory())) {
    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.symlinkPromise(srcPath, dstPath, `junction`);
  } else {
    $ea9c1e38c3e8cca334929a597a084311$exports.xfs.symlinkPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.relative($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(dstPath), srcPath), dstPath);
  }
};

const $727321b616b6b83fee27ff1a2a90cf03$var$copyPromise = async (dstDir, srcDir, {
  baseFs,
  innerLoop
}) => {
  await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(dstDir, {
    recursive: true
  });
  const entries = await baseFs.readdirPromise(srcDir, {
    withFileTypes: true
  });

  const copy = async (dstPath, srcPath, srcType) => {
    if (srcType.isFile()) {
      const stat = await baseFs.lstatPromise(srcPath);
      await baseFs.copyFilePromise(srcPath, dstPath);
      const mode = stat.mode & 0o777; // An optimization - files will have rw-r-r permissions (0o644) by default, we can skip chmod for them

      // An optimization - files will have rw-r-r permissions (0o644) by default, we can skip chmod for them
      if (mode !== 0o644) {
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.chmodPromise(dstPath, mode);
      }
    } else if (srcType.isSymbolicLink()) {
      const target = await baseFs.readlinkPromise(srcPath);
      await $727321b616b6b83fee27ff1a2a90cf03$var$symlinkPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(dstPath), target), dstPath);
    } else {
      throw new Error(`Unsupported file type (file: ${srcPath}, mode: 0o${await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.statSync(srcPath).mode.toString(8).padStart(6, `0`)})`);
    }
  };

  for (const entry of entries) {
    const srcPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(srcDir, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(entry.name));
    const dstPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(dstDir, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(entry.name));

    if (entry.isDirectory()) {
      if (entry.name !== $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES || innerLoop) {
        await $727321b616b6b83fee27ff1a2a90cf03$var$copyPromise(dstPath, srcPath, {
          baseFs,
          innerLoop: true
        });
      }
    } else {
      await copy(dstPath, srcPath, entry);
    }
  }
};
/**
 * This function removes node_modules roots that do not exist on the filesystem from the location tree.
 *
 * This is needed to transparently support workflows on CI systems. When
 * user caches only top-level node_modules and forgets to cache node_modules
 * from deeper workspaces. By removing non-existent node_modules roots
 * we make our location tree to represent the real tree on the file system.
 *
 * Please note, that this function doesn't help with any other inconsistency
 * on a deeper level inside node_modules tree, it helps only when some node_modules roots
 * do not exist at all
 *
 * @param locationTree location tree
 *
 * @returns location tree with non-existent node_modules roots stripped
 */


/**
 * This function removes node_modules roots that do not exist on the filesystem from the location tree.
 *
 * This is needed to transparently support workflows on CI systems. When
 * user caches only top-level node_modules and forgets to cache node_modules
 * from deeper workspaces. By removing non-existent node_modules roots
 * we make our location tree to represent the real tree on the file system.
 *
 * Please note, that this function doesn't help with any other inconsistency
 * on a deeper level inside node_modules tree, it helps only when some node_modules roots
 * do not exist at all
 *
 * @param locationTree location tree
 *
 * @returns location tree with non-existent node_modules roots stripped
 */
function $727321b616b6b83fee27ff1a2a90cf03$var$refineNodeModulesRoots(locationTree, binSymlinks) {
  const refinedLocationTree = new Map([...locationTree]);
  const refinedBinSymlinks = new Map([...binSymlinks]);

  for (const [workspaceRoot, node] of locationTree) {
    const nodeModulesRoot = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(workspaceRoot, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES);

    if (!$ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(nodeModulesRoot)) {
      node.children.delete($727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES); // O(m^2) complexity algorithm, but on a very few values, so not worth the trouble to optimize it

      // O(m^2) complexity algorithm, but on a very few values, so not worth the trouble to optimize it
      for (const location of refinedBinSymlinks.keys()) {
        if ($ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(nodeModulesRoot, location) !== null) {
          refinedBinSymlinks.delete(location);
        }
      }
    }
  }

  return {
    locationTree: refinedLocationTree,
    binSymlinks: refinedBinSymlinks
  };
}

function $727321b616b6b83fee27ff1a2a90cf03$var$isLinkLocator(locatorKey) {
  let descriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseDescriptor(locatorKey);
  if ($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.isVirtualDescriptor(descriptor)) descriptor = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`link:`);
}

async function $727321b616b6b83fee27ff1a2a90cf03$var$createBinSymlinkMap(installState, locationTree, projectRoot, {
  loadManifest
}) {
  const locatorScriptMap = new Map();

  for (const [locatorKey, {
    locations
  }] of installState) {
    const manifest = !$727321b616b6b83fee27ff1a2a90cf03$var$isLinkLocator(locatorKey) ? await loadManifest(locatorKey, locations[0]) : null;
    const bin = new Map();

    if (manifest) {
      for (const [name, value] of manifest.bin) {
        const target = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(locations[0], value);

        if (value !== `` && $ea9c1e38c3e8cca334929a597a084311$exports.xfs.existsSync(target)) {
          bin.set(name, value);
        }
      }
    }

    locatorScriptMap.set(locatorKey, bin);
  }

  const binSymlinks = new Map();

  const getBinSymlinks = (location, parentLocatorLocation, node) => {
    const symlinks = new Map();
    const internalPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.contains(projectRoot, location);

    if (node.locator && internalPath !== null) {
      const binScripts = locatorScriptMap.get(node.locator);

      for (const [filename, scriptPath] of binScripts) {
        const symlinkTarget = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $ea9c1e38c3e8cca334929a597a084311$exports.npath.toPortablePath(scriptPath));
        symlinks.set($ea9c1e38c3e8cca334929a597a084311$exports.toFilename(filename), symlinkTarget);
      }

      for (const [childLocation, childNode] of node.children) {
        const absChildLocation = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, childLocation);
        const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);

        if (childSymlinks.size > 0) {
          binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...childSymlinks]));
        }
      }
    } else {
      for (const [childLocation, childNode] of node.children) {
        const childSymlinks = getBinSymlinks($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, childLocation), parentLocatorLocation, childNode);

        for (const [name, symlinkTarget] of childSymlinks) {
          symlinks.set(name, symlinkTarget);
        }
      }
    }

    return symlinks;
  };

  for (const [location, node] of locationTree) {
    const symlinks = getBinSymlinks(location, location, node);

    if (symlinks.size > 0) {
      binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...symlinks]));
    }
  }

  return binSymlinks;
}

const $727321b616b6b83fee27ff1a2a90cf03$var$areRealLocatorsEqual = (locatorKey1, locatorKey2) => {
  if (!locatorKey1 || !locatorKey2) return locatorKey1 === locatorKey2;
  let locator1 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locatorKey1);
  if ($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.isVirtualLocator(locator1)) locator1 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.devirtualizeLocator(locator1);
  let locator2 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.parseLocator(locatorKey2);
  if ($b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.isVirtualLocator(locator2)) locator2 = $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.devirtualizeLocator(locator2);
  return $b0ffa420366ed37c7cf8ff798018d16e$exports.structUtils.areLocatorsEqual(locator1, locator2);
};

async function $727321b616b6b83fee27ff1a2a90cf03$var$persistNodeModules(preinstallState, installState, {
  baseFs,
  project,
  report,
  loadManifest
}) {
  const rootNmDirPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(project.cwd, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES);
  const {
    locationTree: prevLocationTree,
    binSymlinks: prevBinSymlinks
  } = $727321b616b6b83fee27ff1a2a90cf03$var$refineNodeModulesRoots(preinstallState.locationTree, preinstallState.binSymlinks);
  const locationTree = $727321b616b6b83fee27ff1a2a90cf03$var$buildLocationTree(installState, {
    skipPrefix: project.cwd
  });
  const addQueue = [];

  const addModule = async ({
    srcDir,
    dstDir,
    linkType
  }) => {
    const promise = (async () => {
      try {
        if (linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.SOFT) {
          await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.dirname(dstDir), {
            recursive: true
          });
          await $727321b616b6b83fee27ff1a2a90cf03$var$symlinkPromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.resolve(srcDir), dstDir);
        } else {
          await $727321b616b6b83fee27ff1a2a90cf03$var$copyPromise(dstDir, srcDir, {
            baseFs
          });
        }
      } catch (e) {
        e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
        throw e;
      } finally {
        progress.tick();
      }
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > $727321b616b6b83fee27ff1a2a90cf03$var$CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const cloneModule = async (srcDir, dstDir, options) => {
    const promise = (async () => {
      const cloneDir = async (srcDir, dstDir, options) => {
        try {
          if (!options || !options.innerLoop) await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(dstDir, {
            recursive: true
          });
          const entries = await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.readdirPromise(srcDir, {
            withFileTypes: true
          });

          for (const entry of entries) {
            if ((!options || !options.innerLoop) && entry.name === $727321b616b6b83fee27ff1a2a90cf03$var$DOT_BIN) continue;
            const src = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(srcDir, entry.name);
            const dst = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(dstDir, entry.name);

            if (entry.isDirectory()) {
              if (entry.name !== $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES || options && options.innerLoop) {
                await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(dst, {
                  recursive: true
                });
                await cloneDir(src, dst, {
                  innerLoop: true
                });
              }
            } else {
              await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.copyFilePromise(src, dst, $727321b616b6b83fee27ff1a2a90cf03$var$fs_1.default.constants.COPYFILE_FICLONE);
            }
          }
        } catch (e) {
          if (!options || !options.innerLoop) e.message = `While cloning ${srcDir} -> ${dstDir} ${e.message}`;
          throw e;
        } finally {
          if (!options || !options.innerLoop) {
            progress.tick();
          }
        }
      };

      await cloneDir(srcDir, dstDir, options);
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > $727321b616b6b83fee27ff1a2a90cf03$var$CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const removeOutdatedDirs = async (location, prevNode, node) => {
    if (!node) {
      if (prevNode.children.has($727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES)) await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES), {
        contentsOnly: false
      });
      await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir(location, {
        contentsOnly: location === rootNmDirPath
      });
    } else {
      for (const [segment, prevChildNode] of prevNode.children) {
        const childNode = node.children.get(segment);
        await removeOutdatedDirs($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, segment), prevChildNode, childNode);
      }
    }
  }; // Find locations that existed previously, but no longer exist


  // Find locations that existed previously, but no longer exist
  for (const [location, prevNode] of prevLocationTree) {
    const node = locationTree.get(location);

    for (const [segment, prevChildNode] of prevNode.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const childNode = node ? node.children.get(segment) : node;
      await removeOutdatedDirs($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, segment), prevChildNode, childNode);
    }
  }

  const cleanNewDirs = async (location, node, prevNode) => {
    if (!prevNode) {
      // We want to clean only contents of top-level node_modules dir, since we need these dirs to be present
      if (node.children.has($727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES)) await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES), {
        contentsOnly: true
      }); // 1. If old directory is a symlink removeDir will remove it, regardless contentsOnly value
      // 2. If old and new directories are hardlinks - we pass contentsOnly: true
      // so that removeDir cleared only contents
      // 3. If new directory is a symlink - we pass contentsOnly: false
      // so that removeDir removed the whole directory

      // 1. If old directory is a symlink removeDir will remove it, regardless contentsOnly value
      // 2. If old and new directories are hardlinks - we pass contentsOnly: true
      // so that removeDir cleared only contents
      // 3. If new directory is a symlink - we pass contentsOnly: false
      // so that removeDir removed the whole directory
      await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir(location, {
        contentsOnly: node.linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD
      });
    } else {
      if (!$727321b616b6b83fee27ff1a2a90cf03$var$areRealLocatorsEqual(node.locator, prevNode.locator)) await $727321b616b6b83fee27ff1a2a90cf03$var$removeDir(location, {
        contentsOnly: node.linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.HARD
      });

      for (const [segment, childNode] of node.children) {
        const prevChildNode = prevNode.children.get(segment);
        await cleanNewDirs($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, segment), childNode, prevChildNode);
      }
    }
  }; // Find new locations that are being added/changed and need to be cleaned up first


  // Find new locations that are being added/changed and need to be cleaned up first
  for (const [location, node] of locationTree) {
    const prevNode = prevLocationTree.get(location);

    for (const [segment, childNode] of node.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
      await cleanNewDirs($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, segment), childNode, prevChildNode);
    }
  } // Update changed locations


  // Update changed locations
  const addList = [];

  for (const [prevLocator, {
    locations
  }] of preinstallState.locatorMap.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = $727321b616b6b83fee27ff1a2a90cf03$var$parseLocation(location, {
        skipPrefix: project.cwd
      });
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;

      if (node) {
        for (const segment of segments) {
          curLocation = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(curLocation, segment);
          node = node.children.get(segment);

          if (!node) {
            break;
          }
        }

        if (node && !$727321b616b6b83fee27ff1a2a90cf03$var$areRealLocatorsEqual(node.locator, prevLocator)) {
          const info = installState.get(node.locator);
          const srcDir = info.target;
          const dstDir = curLocation;
          const linkType = info.linkType;

          if (srcDir !== dstDir) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
          }
        }
      }
    }
  } // Add new locations


  // Add new locations
  for (const [locator, {
    locations
  }] of installState.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = $727321b616b6b83fee27ff1a2a90cf03$var$parseLocation(location, {
        skipPrefix: project.cwd
      });
      let prevTreeNode = prevLocationTree.get(locationRoot);
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;
      const info = installState.get(locator);
      const srcDir = info.target;
      const dstDir = location;
      if (srcDir === dstDir) continue;
      const linkType = info.linkType;

      for (const segment of segments) node = node.children.get(segment);

      if (!prevTreeNode) {
        addList.push({
          srcDir,
          dstDir,
          linkType
        });
      } else {
        for (const segment of segments) {
          curLocation = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(curLocation, segment);
          prevTreeNode = prevTreeNode.children.get(segment);

          if (!prevTreeNode) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
            break;
          }
        }
      }
    }
  }

  const progress = $b0ffa420366ed37c7cf8ff798018d16e$exports.Report.progressViaCounter(addList.length);
  const reportedProgress = report.reportProgress(progress);

  try {
    const persistedLocations = new Map(); // For the first pass we'll only want to install a single copy for each
    // source directory. We'll later use the resulting install directories for
    // the other instances of the same package (this will avoid us having to
    // crawl the zip archives for each package).

    // For the first pass we'll only want to install a single copy for each
    // source directory. We'll later use the resulting install directories for
    // the other instances of the same package (this will avoid us having to
    // crawl the zip archives for each package).
    for (const entry of addList) {
      if (entry.linkType === $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
        persistedLocations.set(entry.srcDir, entry.dstDir);
        await addModule({ ...entry
        });
      }
    }

    await Promise.all(addQueue);
    addQueue.length = 0; // Second pass: clone module duplicates

    // Second pass: clone module duplicates
    for (const entry of addList) {
      const persistedDir = persistedLocations.get(entry.srcDir);

      if (entry.linkType !== $b0ffa420366ed37c7cf8ff798018d16e$exports.LinkType.SOFT && entry.dstDir !== persistedDir) {
        await cloneModule(persistedDir, entry.dstDir);
      }
    }

    await Promise.all(addQueue);
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(rootNmDirPath, {
      recursive: true
    });
    const binSymlinks = await $727321b616b6b83fee27ff1a2a90cf03$var$createBinSymlinkMap(installState, locationTree, project.cwd, {
      loadManifest
    });
    await $727321b616b6b83fee27ff1a2a90cf03$var$persistBinSymlinks(prevBinSymlinks, binSymlinks);
    await $727321b616b6b83fee27ff1a2a90cf03$var$writeInstallState(project, installState, binSymlinks);
  } finally {
    reportedProgress.stop();
  }
}

async function $727321b616b6b83fee27ff1a2a90cf03$var$persistBinSymlinks(previousBinSymlinks, binSymlinks) {
  // Delete outdated .bin folders
  for (const location of previousBinSymlinks.keys()) {
    if (!binSymlinks.has(location)) {
      const binDir = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES, $727321b616b6b83fee27ff1a2a90cf03$var$DOT_BIN);
      await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(binDir);
    }
  }

  for (const [location, symlinks] of binSymlinks) {
    const binDir = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(location, $727321b616b6b83fee27ff1a2a90cf03$var$NODE_MODULES, $727321b616b6b83fee27ff1a2a90cf03$var$DOT_BIN);
    const prevSymlinks = previousBinSymlinks.get(location) || new Map();
    await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.mkdirPromise(binDir, {
      recursive: true
    });

    for (const name of prevSymlinks.keys()) {
      if (!symlinks.has(name)) {
        // Remove outdated symlinks
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(binDir, name));

        if ($727321b616b6b83fee27ff1a2a90cf03$var$process.platform === `win32`) {
          await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise($ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(binDir, $ea9c1e38c3e8cca334929a597a084311$exports.toFilename(`${name}.cmd`)));
        }
      }
    }

    for (const [name, target] of symlinks) {
      const prevTarget = prevSymlinks.get(name);
      const symlinkPath = $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(binDir, name); // Skip unchanged .bin symlinks

      // Skip unchanged .bin symlinks
      if (prevTarget === target) continue;

      if ($727321b616b6b83fee27ff1a2a90cf03$var$process.platform === `win32`) {
        await $727321b616b6b83fee27ff1a2a90cf03$var$cmd_shim_1.default($ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(target), $ea9c1e38c3e8cca334929a597a084311$exports.npath.fromPortablePath(symlinkPath), {
          createPwshFile: false
        });
      } else {
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.removePromise(symlinkPath);
        await $727321b616b6b83fee27ff1a2a90cf03$var$symlinkPromise(target, symlinkPath);
        await $ea9c1e38c3e8cca334929a597a084311$exports.xfs.chmodPromise(target, 0o755);
      }
    }
  }
}

// const PnpLooseLinker_1 = require("./PnpLooseLinker");
const $6fc135850ae258e138149086dfb3680c$var$getPnpPath = project => $ea9c1e38c3e8cca334929a597a084311$exports.ppath.join(project.cwd, `.pnp.js`);

$6fc135850ae258e138149086dfb3680c$export$getPnpPath = $6fc135850ae258e138149086dfb3680c$var$getPnpPath;
$6fc135850ae258e138149086dfb3680c$exports.getPnpPath = $6fc135850ae258e138149086dfb3680c$export$getPnpPath;
const $6fc135850ae258e138149086dfb3680c$var$plugin = {
  configuration: {
    nmHoistingLimits: {
      description: `Prevent packages can be hoisted past specific levels`,
      type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.STRING,
      values: [$aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits.WORKSPACES, $aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits.DEPENDENCIES, $aeb9334011cb4a85c526c27a96f15906$exports.NodeModulesHoistingLimits.NONE],
      default: `none`
    },
    nodeLinker: {
      description: `The linker used for installing Node packages, one of: "pnp", "node-modules"`,
      type: $b0ffa420366ed37c7cf8ff798018d16e$exports.SettingsType.STRING,
      default: `node-modules`
    }
  },
  linkers: [$727321b616b6b83fee27ff1a2a90cf03$exports.NodeModulesLinker // PnpLooseLinker_1.PnpLooseLinker,
  ]
}; // eslint-disable-next-line arca/no-default-export

var $6fc135850ae258e138149086dfb3680c$export$default = $6fc135850ae258e138149086dfb3680c$var$plugin;
// eslint-disable-next-line arca/no-default-export
$6fc135850ae258e138149086dfb3680c$exports.default = $6fc135850ae258e138149086dfb3680c$export$default;
$4b4b2ca65c544aeebbd8703f9d50bd90$init();
var $cd4941229af683da6f98c7c221b3c668$var$_NpmPlugin$default, $cd4941229af683da6f98c7c221b3c668$var$_NodeModulesPlugin$de;
const {
  Writable: $cd4941229af683da6f98c7c221b3c668$var$Writable
} = $77f1f3b73e58a1193c01fee8e7b8ba28$exports;

class $cd4941229af683da6f98c7c221b3c668$var$CallbackStream extends $cd4941229af683da6f98c7c221b3c668$var$Writable {
  constructor(cb) {
    super();
    this.cb = cb;
  }

  _write(chunk, enc, next) {
    Promise.resolve().then(() => this.cb(JSON.parse(chunk.toString())));
    next();
  }

}

var $48439b5f02e9ef8477201a3c8a138bf4$$interop$default = $parcel$interopDefault($48439b5f02e9ef8477201a3c8a138bf4$exports);
var $6fc135850ae258e138149086dfb3680c$$interop$default = $parcel$interopDefault($6fc135850ae258e138149086dfb3680c$exports);
const $cd4941229af683da6f98c7c221b3c668$var$plugins = new Map([// [`@yarnpkg/plugin-git`, GitPlugin.default ?? GitPlugin],
// [`@yarnpkg/plugin-github`, GithubPlugin.default ?? GithubPlugin],
[`@yarnpkg/plugin-npm`, ($cd4941229af683da6f98c7c221b3c668$var$_NpmPlugin$default = $48439b5f02e9ef8477201a3c8a138bf4$$interop$default.default) !== null && $cd4941229af683da6f98c7c221b3c668$var$_NpmPlugin$default !== void 0 ? $cd4941229af683da6f98c7c221b3c668$var$_NpmPlugin$default : $48439b5f02e9ef8477201a3c8a138bf4$$interop$default], [`@yarnpkg/plugin-node-modules`, ($cd4941229af683da6f98c7c221b3c668$var$_NodeModulesPlugin$de = $6fc135850ae258e138149086dfb3680c$$interop$default.default) !== null && $cd4941229af683da6f98c7c221b3c668$var$_NodeModulesPlugin$de !== void 0 ? $cd4941229af683da6f98c7c221b3c668$var$_NodeModulesPlugin$de : $6fc135850ae258e138149086dfb3680c$$interop$default]]);
const $cd4941229af683da6f98c7c221b3c668$var$DEFAULT_REGISTRY = "registry.npmjs.cf";
var $4b4b2ca65c544aeebbd8703f9d50bd90$$interop$default = $parcel$interopDefault($4b4b2ca65c544aeebbd8703f9d50bd90$init());

async function $cd4941229af683da6f98c7c221b3c668$export$run({
  fs,
  dir,
  options = {},
  progress = () => {}
}) {
  var _options$npmRegistryS;

  $4b4b2ca65c544aeebbd8703f9d50bd90$$interop$default.__override(fs);

  let registry = (_options$npmRegistryS = options.npmRegistryServer) !== null && _options$npmRegistryS !== void 0 ? _options$npmRegistryS : $cd4941229af683da6f98c7c221b3c668$var$DEFAULT_REGISTRY;
  $b1922c2a723c91ba566558ef852a9896$export$__setRegistry(registry);
  const configuration = $b0ffa420366ed37c7cf8ff798018d16e$exports.Configuration.create(dir, dir, $cd4941229af683da6f98c7c221b3c668$var$plugins);
  configuration.useWithSource("override", {
    nodeLinker: "node-modules",
    compressionLevel: 0,
    ...options,
    npmRegistryServer: "https://" + registry,
    enableScripts: false
  }, dir);
  const {
    project
  } = await $b0ffa420366ed37c7cf8ff798018d16e$exports.Project.find(configuration, dir);
  const cache = await $b0ffa420366ed37c7cf8ff798018d16e$exports.Cache.find(configuration);
  let report = await $b0ffa420366ed37c7cf8ff798018d16e$exports.StreamReport.start({
    configuration,
    json: true,
    stdout: new $cd4941229af683da6f98c7c221b3c668$var$CallbackStream(progress),
    includeLogs: true
  }, async report => {
    await project.install({
      cache,
      report
    });
  });
  return {
    report
  };
}

// ASSET: node_modules/memfs/lib/index.js
var $71965ce02cdeb6e23c0ad07dd03f38b2$exports = {};

var $71965ce02cdeb6e23c0ad07dd03f38b2$var$__assign = $71965ce02cdeb6e23c0ad07dd03f38b2$exports && $71965ce02cdeb6e23c0ad07dd03f38b2$exports.__assign || function () {
  $71965ce02cdeb6e23c0ad07dd03f38b2$var$__assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return $71965ce02cdeb6e23c0ad07dd03f38b2$var$__assign.apply(this, arguments);
};

Object.defineProperty($71965ce02cdeb6e23c0ad07dd03f38b2$exports, "__esModule", {
  value: true
});
var $71965ce02cdeb6e23c0ad07dd03f38b2$export$fs = ($71965ce02cdeb6e23c0ad07dd03f38b2$export$createFsFromVolume = ($71965ce02cdeb6e23c0ad07dd03f38b2$export$vol = ($71965ce02cdeb6e23c0ad07dd03f38b2$export$Volume = void 0, $71965ce02cdeb6e23c0ad07dd03f38b2$exports.Volume = $71965ce02cdeb6e23c0ad07dd03f38b2$export$Volume), $71965ce02cdeb6e23c0ad07dd03f38b2$exports.vol = $71965ce02cdeb6e23c0ad07dd03f38b2$export$vol), $71965ce02cdeb6e23c0ad07dd03f38b2$exports.createFsFromVolume = $71965ce02cdeb6e23c0ad07dd03f38b2$export$createFsFromVolume);
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.fs = $71965ce02cdeb6e23c0ad07dd03f38b2$export$fs;
// ASSET: node_modules/memfs/lib/Stats.js
var $3427174026c479434e105c2f49a8e44e$exports = {};
Object.defineProperty($3427174026c479434e105c2f49a8e44e$exports, "__esModule", {
  value: true
});
var $3427174026c479434e105c2f49a8e44e$export$Stats = void 0;
$3427174026c479434e105c2f49a8e44e$exports.Stats = $3427174026c479434e105c2f49a8e44e$export$Stats;
// ASSET: node_modules/memfs/lib/constants.js
var $5ef6d69618112b7fcbc8b307c281ba0d$exports = {};
Object.defineProperty($5ef6d69618112b7fcbc8b307c281ba0d$exports, "__esModule", {
  value: true
});
var $5ef6d69618112b7fcbc8b307c281ba0d$export$constants = void 0;
$5ef6d69618112b7fcbc8b307c281ba0d$exports.constants = $5ef6d69618112b7fcbc8b307c281ba0d$export$constants;
$5ef6d69618112b7fcbc8b307c281ba0d$export$constants = {
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  UV_FS_COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_EXCL: 1,
  COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE_FORCE: 4
};
$5ef6d69618112b7fcbc8b307c281ba0d$exports.constants = $5ef6d69618112b7fcbc8b307c281ba0d$export$constants;
// ASSET: node_modules/memfs/lib/getBigInt.js
var $c2281362e29fa7a625733ec01810d1bd$exports = {};

if (typeof BigInt === 'function') {
  var $c2281362e29fa7a625733ec01810d1bd$export$default = BigInt;
  $c2281362e29fa7a625733ec01810d1bd$exports.default = $c2281362e29fa7a625733ec01810d1bd$export$default;
} else {
  $c2281362e29fa7a625733ec01810d1bd$export$default = function BigIntNotSupported() {
    throw new Error('BigInt is not supported in this environment.');
  };

  $c2281362e29fa7a625733ec01810d1bd$exports.default = $c2281362e29fa7a625733ec01810d1bd$export$default;
}

var $3427174026c479434e105c2f49a8e44e$var$S_IFMT = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFMT,
    $3427174026c479434e105c2f49a8e44e$var$S_IFDIR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFDIR,
    $3427174026c479434e105c2f49a8e44e$var$S_IFREG = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFREG,
    $3427174026c479434e105c2f49a8e44e$var$S_IFBLK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFBLK,
    $3427174026c479434e105c2f49a8e44e$var$S_IFCHR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFCHR,
    $3427174026c479434e105c2f49a8e44e$var$S_IFLNK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFLNK,
    $3427174026c479434e105c2f49a8e44e$var$S_IFIFO = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFIFO,
    $3427174026c479434e105c2f49a8e44e$var$S_IFSOCK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFSOCK;
/**
 * Statistics about a file/directory, like `fs.Stats`.
 */

/**
 * Statistics about a file/directory, like `fs.Stats`.
 */
var $3427174026c479434e105c2f49a8e44e$var$Stats =
/** @class */
function () {
  function Stats() {}

  Stats.build = function (node, bigint) {
    if (bigint === void 0) {
      bigint = false;
    }

    var stats = new Stats();
    var uid = node.uid,
        gid = node.gid,
        atime = node.atime,
        mtime = node.mtime,
        ctime = node.ctime;
    var getStatNumber = !bigint ? function (number) {
      return number;
    } : $c2281362e29fa7a625733ec01810d1bd$exports.default; // Copy all values on Stats from Node, so that if Node values
    // change, values on Stats would still be the old ones,
    // just like in Node fs.

    // Copy all values on Stats from Node, so that if Node values
    // change, values on Stats would still be the old ones,
    // just like in Node fs.
    stats.uid = getStatNumber(uid);
    stats.gid = getStatNumber(gid);
    stats.rdev = getStatNumber(0);
    stats.blksize = getStatNumber(4096);
    stats.ino = getStatNumber(node.ino);
    stats.size = getStatNumber(node.getSize());
    stats.blocks = getStatNumber(1);
    stats.atime = atime;
    stats.mtime = mtime;
    stats.ctime = ctime;
    stats.birthtime = ctime;
    stats.atimeMs = getStatNumber(atime.getTime());
    stats.mtimeMs = getStatNumber(mtime.getTime());
    var ctimeMs = getStatNumber(ctime.getTime());
    stats.ctimeMs = ctimeMs;
    stats.birthtimeMs = ctimeMs;
    stats.dev = getStatNumber(0);
    stats.mode = getStatNumber(node.mode);
    stats.nlink = getStatNumber(node.nlink);
    return stats;
  };

  Stats.prototype._checkModeProperty = function (property) {
    return (Number(this.mode) & $3427174026c479434e105c2f49a8e44e$var$S_IFMT) === property;
  };

  Stats.prototype.isDirectory = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFDIR);
  };

  Stats.prototype.isFile = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFREG);
  };

  Stats.prototype.isBlockDevice = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFBLK);
  };

  Stats.prototype.isCharacterDevice = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFCHR);
  };

  Stats.prototype.isSymbolicLink = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFLNK);
  };

  Stats.prototype.isFIFO = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFIFO);
  };

  Stats.prototype.isSocket = function () {
    return this._checkModeProperty($3427174026c479434e105c2f49a8e44e$var$S_IFSOCK);
  };

  return Stats;
}();

$3427174026c479434e105c2f49a8e44e$export$Stats = $3427174026c479434e105c2f49a8e44e$var$Stats;
$3427174026c479434e105c2f49a8e44e$exports.Stats = $3427174026c479434e105c2f49a8e44e$export$Stats;
var $3427174026c479434e105c2f49a8e44e$export$default = $3427174026c479434e105c2f49a8e44e$var$Stats;
$3427174026c479434e105c2f49a8e44e$exports.default = $3427174026c479434e105c2f49a8e44e$export$default;
// ASSET: node_modules/memfs/lib/Dirent.js
var $625e9897ba6758d68ddb608d84cb5b08$exports = {};
Object.defineProperty($625e9897ba6758d68ddb608d84cb5b08$exports, "__esModule", {
  value: true
});
var $625e9897ba6758d68ddb608d84cb5b08$export$Dirent = void 0;
$625e9897ba6758d68ddb608d84cb5b08$exports.Dirent = $625e9897ba6758d68ddb608d84cb5b08$export$Dirent;
// ASSET: node_modules/memfs/lib/encoding.js
var $8dca1526026dec0132784fc5c16fdf73$exports = {};
Object.defineProperty($8dca1526026dec0132784fc5c16fdf73$exports, "__esModule", {
  value: true
});
var $8dca1526026dec0132784fc5c16fdf73$export$strToEncoding = ($8dca1526026dec0132784fc5c16fdf73$export$assertEncoding = ($8dca1526026dec0132784fc5c16fdf73$export$ENCODING_UTF8 = void 0, $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8 = $8dca1526026dec0132784fc5c16fdf73$export$ENCODING_UTF8), $8dca1526026dec0132784fc5c16fdf73$exports.assertEncoding = $8dca1526026dec0132784fc5c16fdf73$export$assertEncoding);
$8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding = $8dca1526026dec0132784fc5c16fdf73$export$strToEncoding;
// ASSET: node_modules/memfs/lib/internal/buffer.js
var $434ed7719003c4362f61238fc34a36d9$export$Buffer,
    $434ed7719003c4362f61238fc34a36d9$exports = {};

var $434ed7719003c4362f61238fc34a36d9$var$__spreadArray = $434ed7719003c4362f61238fc34a36d9$exports && $434ed7719003c4362f61238fc34a36d9$exports.__spreadArray || function (to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

  return to;
};

Object.defineProperty($434ed7719003c4362f61238fc34a36d9$exports, "__esModule", {
  value: true
});
var $434ed7719003c4362f61238fc34a36d9$export$bufferFrom = ($434ed7719003c4362f61238fc34a36d9$export$bufferAllocUnsafe = ($434ed7719003c4362f61238fc34a36d9$export$Buffer = void 0, $434ed7719003c4362f61238fc34a36d9$exports.Buffer = $434ed7719003c4362f61238fc34a36d9$export$Buffer), $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe = $434ed7719003c4362f61238fc34a36d9$export$bufferAllocUnsafe);
$434ed7719003c4362f61238fc34a36d9$exports.bufferFrom = $434ed7719003c4362f61238fc34a36d9$export$bufferFrom;
var $434ed7719003c4362f61238fc34a36d9$var$buffer_1 = $4bb8553ea3f2a3c18bc67044f716b1cc$init();
Object.defineProperty($434ed7719003c4362f61238fc34a36d9$exports, "Buffer", {
  enumerable: true,
  get: function () {
    return $434ed7719003c4362f61238fc34a36d9$var$buffer_1.Buffer;
  }
});

function $434ed7719003c4362f61238fc34a36d9$var$bufferV0P12Ponyfill(arg0) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  return new ($434ed7719003c4362f61238fc34a36d9$var$buffer_1.Buffer.bind.apply($434ed7719003c4362f61238fc34a36d9$var$buffer_1.Buffer, $434ed7719003c4362f61238fc34a36d9$var$__spreadArray([void 0, arg0], args)))();
}

var $434ed7719003c4362f61238fc34a36d9$var$bufferAllocUnsafe = $434ed7719003c4362f61238fc34a36d9$var$buffer_1.Buffer.allocUnsafe || $434ed7719003c4362f61238fc34a36d9$var$bufferV0P12Ponyfill;
var $434ed7719003c4362f61238fc34a36d9$export$bufferAllocUnsafe = $434ed7719003c4362f61238fc34a36d9$var$bufferAllocUnsafe;
$434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe = $434ed7719003c4362f61238fc34a36d9$export$bufferAllocUnsafe;
var $434ed7719003c4362f61238fc34a36d9$var$bufferFrom = $434ed7719003c4362f61238fc34a36d9$var$buffer_1.Buffer.from || $434ed7719003c4362f61238fc34a36d9$var$bufferV0P12Ponyfill;
$434ed7719003c4362f61238fc34a36d9$export$bufferFrom = $434ed7719003c4362f61238fc34a36d9$var$bufferFrom;
$434ed7719003c4362f61238fc34a36d9$exports.bufferFrom = $434ed7719003c4362f61238fc34a36d9$export$bufferFrom;
// ASSET: node_modules/memfs/lib/internal/errors.js
var $2a83cb6558526f75280326bcc057be8a$exports = {};

// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
var $2a83cb6558526f75280326bcc057be8a$var$__extends = $2a83cb6558526f75280326bcc057be8a$exports && $2a83cb6558526f75280326bcc057be8a$exports.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($2a83cb6558526f75280326bcc057be8a$exports, "__esModule", {
  value: true
});
var $2a83cb6558526f75280326bcc057be8a$export$E = ($2a83cb6558526f75280326bcc057be8a$export$AssertionError = ($2a83cb6558526f75280326bcc057be8a$export$message = ($2a83cb6558526f75280326bcc057be8a$export$RangeError = ($2a83cb6558526f75280326bcc057be8a$export$TypeError = ($2a83cb6558526f75280326bcc057be8a$export$Error = void 0, $2a83cb6558526f75280326bcc057be8a$exports.Error = $2a83cb6558526f75280326bcc057be8a$export$Error), $2a83cb6558526f75280326bcc057be8a$exports.TypeError = $2a83cb6558526f75280326bcc057be8a$export$TypeError), $2a83cb6558526f75280326bcc057be8a$exports.RangeError = $2a83cb6558526f75280326bcc057be8a$export$RangeError), $2a83cb6558526f75280326bcc057be8a$exports.message = $2a83cb6558526f75280326bcc057be8a$export$message), $2a83cb6558526f75280326bcc057be8a$exports.AssertionError = $2a83cb6558526f75280326bcc057be8a$export$AssertionError);
$2a83cb6558526f75280326bcc057be8a$exports.E = $2a83cb6558526f75280326bcc057be8a$export$E;
var $2a83cb6558526f75280326bcc057be8a$var$assert = $034bb26d820f8530f21df3dfc0306a11$init();
var $2a83cb6558526f75280326bcc057be8a$var$util = $69678d3e0618202337016e1b4ed76965$init();
var $2a83cb6558526f75280326bcc057be8a$var$kCode = typeof Symbol === 'undefined' ? '_kCode' : Symbol('code');
var $2a83cb6558526f75280326bcc057be8a$var$messages = {}; // new Map();

// new Map();
function $2a83cb6558526f75280326bcc057be8a$var$makeNodeError(Base) {
  return (
    /** @class */
    function (_super) {
      $2a83cb6558526f75280326bcc057be8a$var$__extends(NodeError, _super);

      function NodeError(key) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _this = _super.call(this, $2a83cb6558526f75280326bcc057be8a$var$message(key, args)) || this;

        _this.code = key;
        _this[$2a83cb6558526f75280326bcc057be8a$var$kCode] = key;
        _this.name = _super.prototype.name + " [" + _this[$2a83cb6558526f75280326bcc057be8a$var$kCode] + "]";
        return _this;
      }

      return NodeError;
    }(Base)
  );
}

var $2a83cb6558526f75280326bcc057be8a$var$AssertionError =
/** @class */
function (_super) {
  $2a83cb6558526f75280326bcc057be8a$var$__extends(AssertionError, _super);

  function AssertionError(options) {
    var _this = this;

    if (typeof options !== 'object' || options === null) {
      throw new $2a83cb6558526f75280326bcc057be8a$exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');
    }

    if (options.message) {
      _this = _super.call(this, options.message) || this;
    } else {
      _this = _super.call(this, $2a83cb6558526f75280326bcc057be8a$var$util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + $2a83cb6558526f75280326bcc057be8a$var$util.inspect(options.expected).slice(0, 128))) || this;
    }

    _this.generatedMessage = !options.message;
    _this.name = 'AssertionError [ERR_ASSERTION]';
    _this.code = 'ERR_ASSERTION';
    _this.actual = options.actual;
    _this.expected = options.expected;
    _this.operator = options.operator;
    $2a83cb6558526f75280326bcc057be8a$exports.Error.captureStackTrace(_this, options.stackStartFunction);
    return _this;
  }

  return AssertionError;
}($parcel$global.Error);

var $2a83cb6558526f75280326bcc057be8a$export$AssertionError = $2a83cb6558526f75280326bcc057be8a$var$AssertionError;
$2a83cb6558526f75280326bcc057be8a$exports.AssertionError = $2a83cb6558526f75280326bcc057be8a$export$AssertionError;

function $2a83cb6558526f75280326bcc057be8a$var$message(key, args) {
  $2a83cb6558526f75280326bcc057be8a$var$assert.strictEqual(typeof key, 'string'); // const msg = messages.get(key);

  // const msg = messages.get(key);
  var msg = $2a83cb6558526f75280326bcc057be8a$var$messages[key];
  $2a83cb6558526f75280326bcc057be8a$var$assert(msg, "An invalid error message key was used: " + key + ".");
  var fmt;

  if (typeof msg === 'function') {
    fmt = msg;
  } else {
    fmt = $2a83cb6558526f75280326bcc057be8a$var$util.format;
    if (args === undefined || args.length === 0) return msg;
    args.unshift(msg);
  }

  return String(fmt.apply(null, args));
}

var $2a83cb6558526f75280326bcc057be8a$export$message = $2a83cb6558526f75280326bcc057be8a$var$message;
$2a83cb6558526f75280326bcc057be8a$exports.message = $2a83cb6558526f75280326bcc057be8a$export$message; // Utility function for registering the error codes. Only used here. Exported
// *only* to allow for testing.

// Utility function for registering the error codes. Only used here. Exported
// *only* to allow for testing.
function $2a83cb6558526f75280326bcc057be8a$var$E(sym, val) {
  $2a83cb6558526f75280326bcc057be8a$var$messages[sym] = typeof val === 'function' ? val : String(val);
}

$2a83cb6558526f75280326bcc057be8a$export$E = $2a83cb6558526f75280326bcc057be8a$var$E;
$2a83cb6558526f75280326bcc057be8a$exports.E = $2a83cb6558526f75280326bcc057be8a$export$E;
var $2a83cb6558526f75280326bcc057be8a$export$Error = $2a83cb6558526f75280326bcc057be8a$var$makeNodeError($parcel$global.Error);
$2a83cb6558526f75280326bcc057be8a$exports.Error = $2a83cb6558526f75280326bcc057be8a$export$Error;
var $2a83cb6558526f75280326bcc057be8a$export$TypeError = $2a83cb6558526f75280326bcc057be8a$var$makeNodeError($parcel$global.TypeError);
$2a83cb6558526f75280326bcc057be8a$exports.TypeError = $2a83cb6558526f75280326bcc057be8a$export$TypeError;
var $2a83cb6558526f75280326bcc057be8a$export$RangeError = $2a83cb6558526f75280326bcc057be8a$var$makeNodeError($parcel$global.RangeError);
$2a83cb6558526f75280326bcc057be8a$exports.RangeError = $2a83cb6558526f75280326bcc057be8a$export$RangeError; // To declare an error message, use the E(sym, val) function above. The sym
// must be an upper case string. The val can be either a function or a string.
// The return value of the function must be a string.
// Examples:
// E('EXAMPLE_KEY1', 'This is the error value');
// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);
//
// Once an error code has been assigned, the code itself MUST NOT change and
// any given error code must never be reused to identify a different error.
//
// Any error code added here should also be added to the documentation
//
// Note: Please try to keep these in alphabetical order

// To declare an error message, use the E(sym, val) function above. The sym
// must be an upper case string. The val can be either a function or a string.
// The return value of the function must be a string.
// Examples:
// E('EXAMPLE_KEY1', 'This is the error value');
// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);
//
// Once an error code has been assigned, the code itself MUST NOT change and
// any given error code must never be reused to identify a different error.
//
// Any error code added here should also be added to the documentation
//
// Note: Please try to keep these in alphabetical order
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_ARG_NOT_ITERABLE', '%s must be iterable');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_ASSERTION', '%s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_BUFFER_OUT_OF_BOUNDS', $2a83cb6558526f75280326bcc057be8a$var$bufferOutOfBounds);
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_CHILD_CLOSED_BEFORE_REPLY', 'Child closed before reply received');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_CONSOLE_WRITABLE_STREAM', 'Console expects a writable stream instance for %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_DNS_SET_SERVERS_FAILED', function (err, servers) {
  return "c-ares failed to set servers: \"" + err + "\" [" + servers + "]";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_FALSY_VALUE_REJECTION', 'Promise was rejected with falsy value');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_ENCODING_NOT_SUPPORTED', function (enc) {
  return "The \"" + enc + "\" encoding is not supported";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_ENCODING_INVALID_ENCODED_DATA', function (enc) {
  return "The encoded data was not valid for encoding " + enc;
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_HTTP_HEADERS_SENT', 'Cannot render headers after they are sent to the client');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_HTTP_TRAILER_INVALID', 'Trailers are invalid with this transfer encoding');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INDEX_OUT_OF_RANGE', 'Index out of range');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_ARG_TYPE', $2a83cb6558526f75280326bcc057be8a$var$invalidArgType);
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_ARRAY_LENGTH', function (name, len, actual) {
  $2a83cb6558526f75280326bcc057be8a$var$assert.strictEqual(typeof actual, 'number');
  return "The array \"" + name + "\" (length " + actual + ") must be of length " + len + ".";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_BUFFER_SIZE', 'Buffer size must be a multiple of %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_CALLBACK', 'Callback must be a function');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_CHAR', 'Invalid character in %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_CURSOR_POS', 'Cannot set cursor row without setting its column');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_FD', '"fd" must be a positive integer: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_FILE_URL_HOST', 'File URL host must be "localhost" or empty on %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_OPT_VALUE', function (name, value) {
  return "The value \"" + String(value) + "\" is invalid for option \"" + name + "\"";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_OPT_VALUE_ENCODING', function (value) {
  return "The value \"" + String(value) + "\" is invalid for option \"encoding\"";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_REPL_EVAL_CONFIG', 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_SYNC_FORK_INPUT', 'Asynchronous forks do not support Buffer, Uint8Array or string input: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_THIS', 'Value of "this" must be of type %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_URL', 'Invalid URL: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_INVALID_URL_SCHEME', function (expected) {
  return "The URL must be " + $2a83cb6558526f75280326bcc057be8a$var$oneOf(expected, 'scheme');
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_IPC_CHANNEL_CLOSED', 'Channel closed');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_MISSING_ARGS', $2a83cb6558526f75280326bcc057be8a$var$missingArgs);
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_NAPI_CONS_PROTOTYPE_OBJECT', 'Constructor.prototype must be an object');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_NO_CRYPTO', 'Node.js is not compiled with OpenSSL crypto support');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_PARSE_HISTORY_DATA', 'Could not parse history data in %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_BAD_TYPE', 'Bad socket type specified. Valid types are: udp4, udp6');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_CLOSED', 'Socket is closed');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_CERT_ALTNAME_INVALID', "Hostname/IP does not match certificate's altnames: %s");
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_DH_PARAM_SIZE', function (size) {
  return "DH parameter size " + size + " is less than 2048";
});
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_RENEGOTIATION_FAILED', 'Failed to renegotiate');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_REQUIRED_SERVER_NAME', '"servername" is required parameter for Server.addContext');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TLS_SESSION_ATTACK', 'TSL session renegotiation attack detected');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TRANSFORM_ALREADY_TRANSFORMING', 'Calling transform done when still transforming');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_TRANSFORM_WITH_LENGTH_0', 'Calling transform done when writableState.length != 0');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');
$2a83cb6558526f75280326bcc057be8a$var$E('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' + 'See https://github.com/nodejs/node/wiki/Intl');

function $2a83cb6558526f75280326bcc057be8a$var$invalidArgType(name, expected, actual) {
  $2a83cb6558526f75280326bcc057be8a$var$assert(name, 'name is required'); // determiner: 'must be' or 'must not be'

  // determiner: 'must be' or 'must not be'
  var determiner;

  if (expected.includes('not ')) {
    determiner = 'must not be';
    expected = expected.split('not ')[1];
  } else {
    determiner = 'must be';
  }

  var msg;

  if (Array.isArray(name)) {
    var names = name.map(function (val) {
      return "\"" + val + "\"";
    }).join(', ');
    msg = "The " + names + " arguments " + determiner + " " + $2a83cb6558526f75280326bcc057be8a$var$oneOf(expected, 'type');
  } else if (name.includes(' argument')) {
    // for the case like 'first argument'
    msg = "The " + name + " " + determiner + " " + $2a83cb6558526f75280326bcc057be8a$var$oneOf(expected, 'type');
  } else {
    var type = name.includes('.') ? 'property' : 'argument';
    msg = "The \"" + name + "\" " + type + " " + determiner + " " + $2a83cb6558526f75280326bcc057be8a$var$oneOf(expected, 'type');
  } // if actual value received, output it


  // if actual value received, output it
  if (arguments.length >= 3) {
    msg += ". Received type " + (actual !== null ? typeof actual : 'null');
  }

  return msg;
}

function $2a83cb6558526f75280326bcc057be8a$var$missingArgs() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  $2a83cb6558526f75280326bcc057be8a$var$assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"" + a + "\"";
  });

  switch (len) {
    case 1:
      msg += args[0] + " argument";
      break;

    case 2:
      msg += args[0] + " and " + args[1] + " arguments";
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and " + args[len - 1] + " arguments";
      break;
  }

  return msg + " must be specified";
}

function $2a83cb6558526f75280326bcc057be8a$var$oneOf(expected, thing) {
  $2a83cb6558526f75280326bcc057be8a$var$assert(expected, 'expected is required');
  $2a83cb6558526f75280326bcc057be8a$var$assert(typeof thing === 'string', 'thing is required');

  if (Array.isArray(expected)) {
    var len = expected.length;
    $2a83cb6558526f75280326bcc057be8a$var$assert(len > 0, 'At least one expected value needs to be specified'); // tslint:disable-next-line

    // tslint:disable-next-line
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of " + thing + " " + expected.slice(0, len - 1).join(', ') + ", or " + expected[len - 1];
    } else if (len === 2) {
      return "one of " + thing + " " + expected[0] + " or " + expected[1];
    } else {
      return "of " + thing + " " + expected[0];
    }
  } else {
    return "of " + thing + " " + String(expected);
  }
}

function $2a83cb6558526f75280326bcc057be8a$var$bufferOutOfBounds(name, isWriting) {
  if (isWriting) {
    return 'Attempt to write outside buffer bounds';
  } else {
    return "\"" + name + "\" is outside of buffer bounds";
  }
}

var $8dca1526026dec0132784fc5c16fdf73$export$ENCODING_UTF8 = 'utf8';
$8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8 = $8dca1526026dec0132784fc5c16fdf73$export$ENCODING_UTF8;

function $8dca1526026dec0132784fc5c16fdf73$var$assertEncoding(encoding) {
  if (encoding && !$434ed7719003c4362f61238fc34a36d9$exports.Buffer.isEncoding(encoding)) throw new $2a83cb6558526f75280326bcc057be8a$exports.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);
}

var $8dca1526026dec0132784fc5c16fdf73$export$assertEncoding = $8dca1526026dec0132784fc5c16fdf73$var$assertEncoding;
$8dca1526026dec0132784fc5c16fdf73$exports.assertEncoding = $8dca1526026dec0132784fc5c16fdf73$export$assertEncoding;

function $8dca1526026dec0132784fc5c16fdf73$var$strToEncoding(str, encoding) {
  if (!encoding || encoding === $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8) return str; // UTF-8

  // UTF-8
  if (encoding === 'buffer') return new $434ed7719003c4362f61238fc34a36d9$exports.Buffer(str); // `buffer` encoding

  // `buffer` encoding
  return new $434ed7719003c4362f61238fc34a36d9$exports.Buffer(str).toString(encoding); // Custom encoding
}

$8dca1526026dec0132784fc5c16fdf73$export$strToEncoding = $8dca1526026dec0132784fc5c16fdf73$var$strToEncoding;
$8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding = $8dca1526026dec0132784fc5c16fdf73$export$strToEncoding;
var $625e9897ba6758d68ddb608d84cb5b08$var$S_IFMT = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFMT,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFDIR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFDIR,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFREG = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFREG,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFBLK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFBLK,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFCHR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFCHR,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFLNK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFLNK,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFIFO = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFIFO,
    $625e9897ba6758d68ddb608d84cb5b08$var$S_IFSOCK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFSOCK;
/**
 * A directory entry, like `fs.Dirent`.
 */

/**
 * A directory entry, like `fs.Dirent`.
 */
var $625e9897ba6758d68ddb608d84cb5b08$var$Dirent =
/** @class */
function () {
  function Dirent() {
    this.name = '';
    this.mode = 0;
  }

  Dirent.build = function (link, encoding) {
    var dirent = new Dirent();
    var mode = link.getNode().mode;
    dirent.name = $8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(link.getName(), encoding);
    dirent.mode = mode;
    return dirent;
  };

  Dirent.prototype._checkModeProperty = function (property) {
    return (this.mode & $625e9897ba6758d68ddb608d84cb5b08$var$S_IFMT) === property;
  };

  Dirent.prototype.isDirectory = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFDIR);
  };

  Dirent.prototype.isFile = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFREG);
  };

  Dirent.prototype.isBlockDevice = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFBLK);
  };

  Dirent.prototype.isCharacterDevice = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFCHR);
  };

  Dirent.prototype.isSymbolicLink = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFLNK);
  };

  Dirent.prototype.isFIFO = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFIFO);
  };

  Dirent.prototype.isSocket = function () {
    return this._checkModeProperty($625e9897ba6758d68ddb608d84cb5b08$var$S_IFSOCK);
  };

  return Dirent;
}();

$625e9897ba6758d68ddb608d84cb5b08$export$Dirent = $625e9897ba6758d68ddb608d84cb5b08$var$Dirent;
$625e9897ba6758d68ddb608d84cb5b08$exports.Dirent = $625e9897ba6758d68ddb608d84cb5b08$export$Dirent;
var $625e9897ba6758d68ddb608d84cb5b08$export$default = $625e9897ba6758d68ddb608d84cb5b08$var$Dirent;
$625e9897ba6758d68ddb608d84cb5b08$exports.default = $625e9897ba6758d68ddb608d84cb5b08$export$default;
// ASSET: node_modules/fs-monkey/lib/correctPath.js
var $11d174ca2ca08b3d4ed4ddb466950335$exports,
    $11d174ca2ca08b3d4ed4ddb466950335$var$process,
    $11d174ca2ca08b3d4ed4ddb466950335$export$unixify,
    $11d174ca2ca08b3d4ed4ddb466950335$export$correctPath,
    $11d174ca2ca08b3d4ed4ddb466950335$var$isWin,
    $11d174ca2ca08b3d4ed4ddb466950335$executed = false;

function $11d174ca2ca08b3d4ed4ddb466950335$var$removeTrailingSeparator(str) {
  var i = str.length - 1;

  if (i < 2) {
    return str;
  }

  while ($11d174ca2ca08b3d4ed4ddb466950335$var$isSeparator(str, i)) {
    i--;
  }

  return str.substr(0, i + 1);
}

function $11d174ca2ca08b3d4ed4ddb466950335$var$isSeparator(str, i) {
  var _char = str[i];
  return i > 0 && (_char === '/' || $11d174ca2ca08b3d4ed4ddb466950335$var$isWin && _char === '\\');
}

function $11d174ca2ca08b3d4ed4ddb466950335$var$normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  str = str.replace(/[\\\/]+/g, '/');

  if (stripTrailing !== false) {
    str = $11d174ca2ca08b3d4ed4ddb466950335$var$removeTrailingSeparator(str);
  }

  return str;
}

function $11d174ca2ca08b3d4ed4ddb466950335$var$unixify(filepath) {
  var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if ($11d174ca2ca08b3d4ed4ddb466950335$var$isWin) {
    filepath = $11d174ca2ca08b3d4ed4ddb466950335$var$normalizePath(filepath, stripTrailing);
    return filepath.replace(/^([a-zA-Z]+:|\.\/)/, '');
  }

  return filepath;
}

function $11d174ca2ca08b3d4ed4ddb466950335$var$correctPath(filepath) {
  return $11d174ca2ca08b3d4ed4ddb466950335$var$unixify(filepath.replace(/^\\\\\?\\.:\\/, '\\'));
}

function $11d174ca2ca08b3d4ed4ddb466950335$exec() {
  $11d174ca2ca08b3d4ed4ddb466950335$exports = {};
  $11d174ca2ca08b3d4ed4ddb466950335$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
  Object.defineProperty($11d174ca2ca08b3d4ed4ddb466950335$exports, "__esModule", {
    value: true
  });
  $11d174ca2ca08b3d4ed4ddb466950335$export$unixify = $11d174ca2ca08b3d4ed4ddb466950335$var$unixify;
  $11d174ca2ca08b3d4ed4ddb466950335$exports.unixify = $11d174ca2ca08b3d4ed4ddb466950335$export$unixify;
  $11d174ca2ca08b3d4ed4ddb466950335$export$correctPath = $11d174ca2ca08b3d4ed4ddb466950335$var$correctPath;
  $11d174ca2ca08b3d4ed4ddb466950335$exports.correctPath = $11d174ca2ca08b3d4ed4ddb466950335$export$correctPath;
  $11d174ca2ca08b3d4ed4ddb466950335$var$isWin = $11d174ca2ca08b3d4ed4ddb466950335$var$process.platform === 'win32';
}

// ASSET: node_modules/memfs/lib/node.js
var $8547ba35338eeeba972d4ace71f97a67$exports = {};

var $8547ba35338eeeba972d4ace71f97a67$var$__extends = $8547ba35338eeeba972d4ace71f97a67$exports && $8547ba35338eeeba972d4ace71f97a67$exports.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($8547ba35338eeeba972d4ace71f97a67$exports, "__esModule", {
  value: true
});
var $8547ba35338eeeba972d4ace71f97a67$export$File = ($8547ba35338eeeba972d4ace71f97a67$export$Link = ($8547ba35338eeeba972d4ace71f97a67$export$Node = ($8547ba35338eeeba972d4ace71f97a67$export$SEP = void 0, $8547ba35338eeeba972d4ace71f97a67$exports.SEP = $8547ba35338eeeba972d4ace71f97a67$export$SEP), $8547ba35338eeeba972d4ace71f97a67$exports.Node = $8547ba35338eeeba972d4ace71f97a67$export$Node), $8547ba35338eeeba972d4ace71f97a67$exports.Link = $8547ba35338eeeba972d4ace71f97a67$export$Link);
$8547ba35338eeeba972d4ace71f97a67$exports.File = $8547ba35338eeeba972d4ace71f97a67$export$File;
// ASSET: node_modules/memfs/lib/setImmediate.js
var $d5051301665947b721edf53bb3d336e1$exports,
    $d5051301665947b721edf53bb3d336e1$var$_setImmediate,
    $d5051301665947b721edf53bb3d336e1$export$default,
    $d5051301665947b721edf53bb3d336e1$executed = false;

function $d5051301665947b721edf53bb3d336e1$exec() {
  $d5051301665947b721edf53bb3d336e1$exports = {};
  Object.defineProperty($d5051301665947b721edf53bb3d336e1$exports, "__esModule", {
    value: true
  });
  if (typeof setImmediate === 'function') $d5051301665947b721edf53bb3d336e1$var$_setImmediate = setImmediate.bind($parcel$global);else $d5051301665947b721edf53bb3d336e1$var$_setImmediate = f => Promise.resolve().then(f);
  $d5051301665947b721edf53bb3d336e1$export$default = $d5051301665947b721edf53bb3d336e1$var$_setImmediate;
  $d5051301665947b721edf53bb3d336e1$exports.default = $d5051301665947b721edf53bb3d336e1$export$default;
}

function $d5051301665947b721edf53bb3d336e1$init() {
  if (!$d5051301665947b721edf53bb3d336e1$executed) {
    $d5051301665947b721edf53bb3d336e1$executed = true;
    $d5051301665947b721edf53bb3d336e1$exec();
  }

  return $d5051301665947b721edf53bb3d336e1$exports;
}

// ASSET: node_modules/memfs/lib/process.js
var $f35591902d49cecff92643cb75f2628b$exports = {};
var $f35591902d49cecff92643cb75f2628b$var$process = $4951c6716fb2ba4f543f4ae0509a18ac$init();
// Here we mock the global `process` variable in case we are not in Node's environment.
Object.defineProperty($f35591902d49cecff92643cb75f2628b$exports, "__esModule", {
  value: true
});
var $f35591902d49cecff92643cb75f2628b$export$createProcess = void 0;
$f35591902d49cecff92643cb75f2628b$exports.createProcess = $f35591902d49cecff92643cb75f2628b$export$createProcess;
/**
 * Looks to return a `process` object, if one is available.
 *
 * The global `process` is returned if defined;
 * otherwise `require('process')` is attempted.
 *
 * If that fails, `undefined` is returned.
 *
 * @return {IProcess | undefined}
 */

/**
 * Looks to return a `process` object, if one is available.
 *
 * The global `process` is returned if defined;
 * otherwise `require('process')` is attempted.
 *
 * If that fails, `undefined` is returned.
 *
 * @return {IProcess | undefined}
 */
var $f35591902d49cecff92643cb75f2628b$var$maybeReturnProcess = function () {
  if (typeof $f35591902d49cecff92643cb75f2628b$var$process !== 'undefined') {
    return $f35591902d49cecff92643cb75f2628b$var$process;
  }

  try {
    return $4951c6716fb2ba4f543f4ae0509a18ac$init();
  } catch (_a) {
    return undefined;
  }
};

function $f35591902d49cecff92643cb75f2628b$var$createProcess() {
  var p = $f35591902d49cecff92643cb75f2628b$var$maybeReturnProcess() || {};
  if (!p.getuid) p.getuid = function () {
    return 0;
  };
  if (!p.getgid) p.getgid = function () {
    return 0;
  };
  if (!p.cwd) p.cwd = function () {
    return '/';
  };
  if (!p.nextTick) p.nextTick = $d5051301665947b721edf53bb3d336e1$init().default;
  if (!p.emitWarning) p.emitWarning = function (message, type) {
    // tslint:disable-next-line:no-console
    console.warn("" + type + (type ? ': ' : '') + message);
  };
  if (!p.env) p.env = {};
  return p;
}

$f35591902d49cecff92643cb75f2628b$export$createProcess = $f35591902d49cecff92643cb75f2628b$var$createProcess;
$f35591902d49cecff92643cb75f2628b$exports.createProcess = $f35591902d49cecff92643cb75f2628b$export$createProcess;
var $f35591902d49cecff92643cb75f2628b$export$default = $f35591902d49cecff92643cb75f2628b$var$createProcess();
$f35591902d49cecff92643cb75f2628b$exports.default = $f35591902d49cecff92643cb75f2628b$export$default;
var $8547ba35338eeeba972d4ace71f97a67$var$S_IFMT = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFMT,
    $8547ba35338eeeba972d4ace71f97a67$var$S_IFDIR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFDIR,
    $8547ba35338eeeba972d4ace71f97a67$var$S_IFREG = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFREG,
    $8547ba35338eeeba972d4ace71f97a67$var$S_IFLNK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.S_IFLNK,
    $8547ba35338eeeba972d4ace71f97a67$var$O_APPEND = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_APPEND;
var $8547ba35338eeeba972d4ace71f97a67$export$SEP = '/';
$8547ba35338eeeba972d4ace71f97a67$exports.SEP = $8547ba35338eeeba972d4ace71f97a67$export$SEP;
/**
 * Node in a file system (like i-node, v-node).
 */

/**
 * Node in a file system (like i-node, v-node).
 */
var $8547ba35338eeeba972d4ace71f97a67$var$Node =
/** @class */
function (_super) {
  $8547ba35338eeeba972d4ace71f97a67$var$__extends(Node, _super);

  function Node(ino, perm) {
    if (perm === void 0) {
      perm = 438;
    }

    var _this = _super.call(this) || this; // User ID and group ID.


    // User ID and group ID.
    _this.uid = $f35591902d49cecff92643cb75f2628b$exports.default.getuid();
    _this.gid = $f35591902d49cecff92643cb75f2628b$exports.default.getgid();
    _this.atime = new Date();
    _this.mtime = new Date();
    _this.ctime = new Date();
    _this.perm = 438; // Permissions `chmod`, `fchmod`

    // Permissions `chmod`, `fchmod`
    _this.mode = $8547ba35338eeeba972d4ace71f97a67$var$S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
    // Number of hard links pointing at this Node.

    // S_IFDIR, S_IFREG, etc.. (file by default?)
    // Number of hard links pointing at this Node.
    _this.nlink = 1;
    _this.perm = perm;
    _this.mode |= perm;
    _this.ino = ino;
    return _this;
  }

  Node.prototype.getString = function (encoding) {
    if (encoding === void 0) {
      encoding = 'utf8';
    }

    return this.getBuffer().toString(encoding);
  };

  Node.prototype.setString = function (str) {
    // this.setBuffer(bufferFrom(str, 'utf8'));
    this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(str, 'utf8');
    this.touch();
  };

  Node.prototype.getBuffer = function () {
    if (!this.buf) this.setBuffer($434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0));
    return $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(this.buf); // Return a copy.
  };

  Node.prototype.setBuffer = function (buf) {
    this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(buf); // Creates a copy of data.

    // Creates a copy of data.
    this.touch();
  };

  Node.prototype.getSize = function () {
    return this.buf ? this.buf.length : 0;
  };

  Node.prototype.setModeProperty = function (property) {
    this.mode = this.mode & ~$8547ba35338eeeba972d4ace71f97a67$var$S_IFMT | property;
  };

  Node.prototype.setIsFile = function () {
    this.setModeProperty($8547ba35338eeeba972d4ace71f97a67$var$S_IFREG);
  };

  Node.prototype.setIsDirectory = function () {
    this.setModeProperty($8547ba35338eeeba972d4ace71f97a67$var$S_IFDIR);
  };

  Node.prototype.setIsSymlink = function () {
    this.setModeProperty($8547ba35338eeeba972d4ace71f97a67$var$S_IFLNK);
  };

  Node.prototype.isFile = function () {
    return (this.mode & $8547ba35338eeeba972d4ace71f97a67$var$S_IFMT) === $8547ba35338eeeba972d4ace71f97a67$var$S_IFREG;
  };

  Node.prototype.isDirectory = function () {
    return (this.mode & $8547ba35338eeeba972d4ace71f97a67$var$S_IFMT) === $8547ba35338eeeba972d4ace71f97a67$var$S_IFDIR;
  };

  Node.prototype.isSymlink = function () {
    // return !!this.symlink;
    return (this.mode & $8547ba35338eeeba972d4ace71f97a67$var$S_IFMT) === $8547ba35338eeeba972d4ace71f97a67$var$S_IFLNK;
  };

  Node.prototype.makeSymlink = function (steps) {
    this.symlink = steps;
    this.setIsSymlink();
  };

  Node.prototype.write = function (buf, off, len, pos) {
    if (off === void 0) {
      off = 0;
    }

    if (len === void 0) {
      len = buf.length;
    }

    if (pos === void 0) {
      pos = 0;
    }

    if (!this.buf) this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0);

    if (pos + len > this.buf.length) {
      var newBuf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(pos + len);
      this.buf.copy(newBuf, 0, 0, this.buf.length);
      this.buf = newBuf;
    }

    buf.copy(this.buf, pos, off, off + len);
    this.touch();
    return len;
  }; // Returns the number of bytes read.


  // Returns the number of bytes read.
  Node.prototype.read = function (buf, off, len, pos) {
    if (off === void 0) {
      off = 0;
    }

    if (len === void 0) {
      len = buf.byteLength;
    }

    if (pos === void 0) {
      pos = 0;
    }

    if (!this.buf) this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0);
    var actualLen = len;

    if (actualLen > buf.byteLength) {
      actualLen = buf.byteLength;
    }

    if (actualLen + pos > this.buf.length) {
      actualLen = this.buf.length - pos;
    }

    this.buf.copy(buf, off, pos, pos + actualLen);
    return actualLen;
  };

  Node.prototype.truncate = function (len) {
    if (len === void 0) {
      len = 0;
    }

    if (!len) this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0);else {
      if (!this.buf) this.buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0);

      if (len <= this.buf.length) {
        this.buf = this.buf.slice(0, len);
      } else {
        var buf = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(0);
        this.buf.copy(buf);
        buf.fill(0, len);
      }
    }
    this.touch();
  };

  Node.prototype.chmod = function (perm) {
    this.perm = perm;
    this.mode = this.mode & ~511 | perm;
    this.touch();
  };

  Node.prototype.chown = function (uid, gid) {
    this.uid = uid;
    this.gid = gid;
    this.touch();
  };

  Node.prototype.touch = function () {
    this.mtime = new Date();
    this.emit('change', this);
  };

  Node.prototype.canRead = function (uid, gid) {
    if (uid === void 0) {
      uid = $f35591902d49cecff92643cb75f2628b$exports.default.getuid();
    }

    if (gid === void 0) {
      gid = $f35591902d49cecff92643cb75f2628b$exports.default.getgid();
    }

    if (this.perm & 4
    /* IROTH */
    )
      /* IROTH */
      {
        return true;
      }

    if (gid === this.gid) {
      if (this.perm & 32
      /* IRGRP */
      )
        /* IRGRP */
        {
          return true;
        }
    }

    if (uid === this.uid) {
      if (this.perm & 256
      /* IRUSR */
      )
        /* IRUSR */
        {
          return true;
        }
    }

    return false;
  };

  Node.prototype.canWrite = function (uid, gid) {
    if (uid === void 0) {
      uid = $f35591902d49cecff92643cb75f2628b$exports.default.getuid();
    }

    if (gid === void 0) {
      gid = $f35591902d49cecff92643cb75f2628b$exports.default.getgid();
    }

    if (this.perm & 2
    /* IWOTH */
    )
      /* IWOTH */
      {
        return true;
      }

    if (gid === this.gid) {
      if (this.perm & 16
      /* IWGRP */
      )
        /* IWGRP */
        {
          return true;
        }
    }

    if (uid === this.uid) {
      if (this.perm & 128
      /* IWUSR */
      )
        /* IWUSR */
        {
          return true;
        }
    }

    return false;
  };

  Node.prototype.del = function () {
    this.emit('delete', this);
  };

  Node.prototype.toJSON = function () {
    return {
      ino: this.ino,
      uid: this.uid,
      gid: this.gid,
      atime: this.atime.getTime(),
      mtime: this.mtime.getTime(),
      ctime: this.ctime.getTime(),
      perm: this.perm,
      mode: this.mode,
      nlink: this.nlink,
      symlink: this.symlink,
      data: this.getString()
    };
  };

  return Node;
}($2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter);

var $8547ba35338eeeba972d4ace71f97a67$export$Node = $8547ba35338eeeba972d4ace71f97a67$var$Node;
$8547ba35338eeeba972d4ace71f97a67$exports.Node = $8547ba35338eeeba972d4ace71f97a67$export$Node;
/**
 * Represents a hard link that points to an i-node `node`.
 */

/**
 * Represents a hard link that points to an i-node `node`.
 */
var $8547ba35338eeeba972d4ace71f97a67$var$Link =
/** @class */
function (_super) {
  $8547ba35338eeeba972d4ace71f97a67$var$__extends(Link, _super);

  function Link(vol, parent, name) {
    var _this = _super.call(this) || this;

    _this.children = {}; // Path to this node as Array: ['usr', 'bin', 'node'].

    // Path to this node as Array: ['usr', 'bin', 'node'].
    _this.steps = []; // "i-node" number of the node.

    // "i-node" number of the node.
    _this.ino = 0; // Number of children.

    // Number of children.
    _this.length = 0;
    _this.vol = vol;
    _this.parent = parent;
    _this.steps = parent ? parent.steps.concat([name]) : [name];
    return _this;
  }

  Link.prototype.setNode = function (node) {
    this.node = node;
    this.ino = node.ino;
  };

  Link.prototype.getNode = function () {
    return this.node;
  };

  Link.prototype.createChild = function (name, node) {
    if (node === void 0) {
      node = this.vol.createNode();
    }

    var link = new Link(this.vol, this, name);
    link.setNode(node);

    if (node.isDirectory()) {// link.setChild('.', link);
      // link.getNode().nlink++;
      // link.setChild('..', this);
      // this.getNode().nlink++;
    }

    this.setChild(name, link);
    return link;
  };

  Link.prototype.setChild = function (name, link) {
    if (link === void 0) {
      link = new Link(this.vol, this, name);
    }

    this.children[name] = link;
    link.parent = this;
    this.length++;
    this.emit('child:add', link, this);
    return link;
  };

  Link.prototype.deleteChild = function (link) {
    delete this.children[link.getName()];
    this.length--;
    this.emit('child:delete', link, this);
  };

  Link.prototype.getChild = function (name) {
    if (Object.hasOwnProperty.call(this.children, name)) {
      return this.children[name];
    }
  };

  Link.prototype.getPath = function () {
    return this.steps.join($8547ba35338eeeba972d4ace71f97a67$exports.SEP);
  };

  Link.prototype.getName = function () {
    return this.steps[this.steps.length - 1];
  }; // del() {
  //     const parent = this.parent;
  //     if(parent) {
  //         parent.deleteChild(link);
  //     }
  //     this.parent = null;
  //     this.vol = null;
  // }

  /**
   * Walk the tree path and return the `Link` at that location, if any.
   * @param steps {string[]} Desired location.
   * @param stop {number} Max steps to go into.
   * @param i {number} Current step in the `steps` array.
   *
   * @return {Link|null}
   */


  // del() {
  //     const parent = this.parent;
  //     if(parent) {
  //         parent.deleteChild(link);
  //     }
  //     this.parent = null;
  //     this.vol = null;
  // }

  /**
   * Walk the tree path and return the `Link` at that location, if any.
   * @param steps {string[]} Desired location.
   * @param stop {number} Max steps to go into.
   * @param i {number} Current step in the `steps` array.
   *
   * @return {Link|null}
   */
  Link.prototype.walk = function (steps, stop, i) {
    if (stop === void 0) {
      stop = steps.length;
    }

    if (i === void 0) {
      i = 0;
    }

    if (i >= steps.length) return this;
    if (i >= stop) return this;
    var step = steps[i];
    var link = this.getChild(step);
    if (!link) return null;
    return link.walk(steps, stop, i + 1);
  };

  Link.prototype.toJSON = function () {
    return {
      steps: this.steps,
      ino: this.ino,
      children: Object.keys(this.children)
    };
  };

  return Link;
}($2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter);

var $8547ba35338eeeba972d4ace71f97a67$export$Link = $8547ba35338eeeba972d4ace71f97a67$var$Link;
$8547ba35338eeeba972d4ace71f97a67$exports.Link = $8547ba35338eeeba972d4ace71f97a67$export$Link;
/**
 * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.
 */

/**
 * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.
 */
var $8547ba35338eeeba972d4ace71f97a67$var$File =
/** @class */
function () {
  /**
   * Open a Link-Node pair. `node` is provided separately as that might be a different node
   * rather the one `link` points to, because it might be a symlink.
   * @param link
   * @param node
   * @param flags
   * @param fd
   */
  function File(link, node, flags, fd) {
    /**
     * A cursor/offset position in a file, where data will be written on write.
     * User can "seek" this position.
     */
    this.position = 0;
    this.link = link;
    this.node = node;
    this.flags = flags;
    this.fd = fd;
  }

  File.prototype.getString = function (encoding) {
    if (encoding === void 0) {
      encoding = 'utf8';
    }

    return this.node.getString();
  };

  File.prototype.setString = function (str) {
    this.node.setString(str);
  };

  File.prototype.getBuffer = function () {
    return this.node.getBuffer();
  };

  File.prototype.setBuffer = function (buf) {
    this.node.setBuffer(buf);
  };

  File.prototype.getSize = function () {
    return this.node.getSize();
  };

  File.prototype.truncate = function (len) {
    this.node.truncate(len);
  };

  File.prototype.seekTo = function (position) {
    this.position = position;
  };

  File.prototype.stats = function () {
    return $3427174026c479434e105c2f49a8e44e$exports.default.build(this.node);
  };

  File.prototype.write = function (buf, offset, length, position) {
    if (offset === void 0) {
      offset = 0;
    }

    if (length === void 0) {
      length = buf.length;
    }

    if (typeof position !== 'number') position = this.position;
    if (this.flags & $8547ba35338eeeba972d4ace71f97a67$var$O_APPEND) position = this.getSize();
    var bytes = this.node.write(buf, offset, length, position);
    this.position = position + bytes;
    return bytes;
  };

  File.prototype.read = function (buf, offset, length, position) {
    if (offset === void 0) {
      offset = 0;
    }

    if (length === void 0) {
      length = buf.byteLength;
    }

    if (typeof position !== 'number') position = this.position;
    var bytes = this.node.read(buf, offset, length, position);
    this.position = position + bytes;
    return bytes;
  };

  File.prototype.chmod = function (perm) {
    this.node.chmod(perm);
  };

  File.prototype.chown = function (uid, gid) {
    this.node.chown(uid, gid);
  };

  return File;
}();

$8547ba35338eeeba972d4ace71f97a67$export$File = $8547ba35338eeeba972d4ace71f97a67$var$File;
$8547ba35338eeeba972d4ace71f97a67$exports.File = $8547ba35338eeeba972d4ace71f97a67$export$File;

function $11d174ca2ca08b3d4ed4ddb466950335$init() {
  if (!$11d174ca2ca08b3d4ed4ddb466950335$executed) {
    $11d174ca2ca08b3d4ed4ddb466950335$executed = true;
    $11d174ca2ca08b3d4ed4ddb466950335$exec();
  }

  return $11d174ca2ca08b3d4ed4ddb466950335$exports;
}

// ASSET: node_modules/memfs/lib/volume.js
var $a3feb61323626a539f5d76e62a53bc0d$export$FLAGS,
    $a3feb61323626a539f5d76e62a53bc0d$exports = {};

var $a3feb61323626a539f5d76e62a53bc0d$var$__extends = $a3feb61323626a539f5d76e62a53bc0d$exports && $a3feb61323626a539f5d76e62a53bc0d$exports.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var $a3feb61323626a539f5d76e62a53bc0d$var$__spreadArray = $a3feb61323626a539f5d76e62a53bc0d$exports && $a3feb61323626a539f5d76e62a53bc0d$exports.__spreadArray || function (to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

  return to;
};

Object.defineProperty($a3feb61323626a539f5d76e62a53bc0d$exports, "__esModule", {
  value: true
});
var $a3feb61323626a539f5d76e62a53bc0d$export$FSWatcher = ($a3feb61323626a539f5d76e62a53bc0d$export$StatWatcher = ($a3feb61323626a539f5d76e62a53bc0d$export$Volume = ($a3feb61323626a539f5d76e62a53bc0d$export$toUnixTimestamp = ($a3feb61323626a539f5d76e62a53bc0d$export$bufferToEncoding = ($a3feb61323626a539f5d76e62a53bc0d$export$dataToBuffer = ($a3feb61323626a539f5d76e62a53bc0d$export$dataToStr = ($a3feb61323626a539f5d76e62a53bc0d$export$pathToSteps = ($a3feb61323626a539f5d76e62a53bc0d$export$filenameToSteps = ($a3feb61323626a539f5d76e62a53bc0d$export$pathToFilename = ($a3feb61323626a539f5d76e62a53bc0d$export$flagsToNumber = ($a3feb61323626a539f5d76e62a53bc0d$export$FLAGS = void 0, $a3feb61323626a539f5d76e62a53bc0d$exports.FLAGS = $a3feb61323626a539f5d76e62a53bc0d$export$FLAGS), $a3feb61323626a539f5d76e62a53bc0d$exports.flagsToNumber = $a3feb61323626a539f5d76e62a53bc0d$export$flagsToNumber), $a3feb61323626a539f5d76e62a53bc0d$exports.pathToFilename = $a3feb61323626a539f5d76e62a53bc0d$export$pathToFilename), $a3feb61323626a539f5d76e62a53bc0d$exports.filenameToSteps = $a3feb61323626a539f5d76e62a53bc0d$export$filenameToSteps), $a3feb61323626a539f5d76e62a53bc0d$exports.pathToSteps = $a3feb61323626a539f5d76e62a53bc0d$export$pathToSteps), $a3feb61323626a539f5d76e62a53bc0d$exports.dataToStr = $a3feb61323626a539f5d76e62a53bc0d$export$dataToStr), $a3feb61323626a539f5d76e62a53bc0d$exports.dataToBuffer = $a3feb61323626a539f5d76e62a53bc0d$export$dataToBuffer), $a3feb61323626a539f5d76e62a53bc0d$exports.bufferToEncoding = $a3feb61323626a539f5d76e62a53bc0d$export$bufferToEncoding), $a3feb61323626a539f5d76e62a53bc0d$exports.toUnixTimestamp = $a3feb61323626a539f5d76e62a53bc0d$export$toUnixTimestamp), $a3feb61323626a539f5d76e62a53bc0d$exports.Volume = $a3feb61323626a539f5d76e62a53bc0d$export$Volume), $a3feb61323626a539f5d76e62a53bc0d$exports.StatWatcher = $a3feb61323626a539f5d76e62a53bc0d$export$StatWatcher);
// ASSET: node_modules/memfs/lib/setTimeoutUnref.js
var $5435f34f25ec65b29f650713af1c297f$exports = {};
Object.defineProperty($5435f34f25ec65b29f650713af1c297f$exports, "__esModule", {
  value: true
});
/**
 * `setTimeoutUnref` is just like `setTimeout`,
 * only in Node's environment it will "unref" its macro task.
 */

/**
 * `setTimeoutUnref` is just like `setTimeout`,
 * only in Node's environment it will "unref" its macro task.
 */
function $5435f34f25ec65b29f650713af1c297f$var$setTimeoutUnref(callback, time, args) {
  var ref = setTimeout.apply(null, arguments);
  if (ref && typeof ref === 'object' && typeof ref.unref === 'function') ref.unref();
  return ref;
}

var $5435f34f25ec65b29f650713af1c297f$export$default = $5435f34f25ec65b29f650713af1c297f$var$setTimeoutUnref;
$5435f34f25ec65b29f650713af1c297f$exports.default = $5435f34f25ec65b29f650713af1c297f$export$default;
$a3feb61323626a539f5d76e62a53bc0d$exports.FSWatcher = $a3feb61323626a539f5d76e62a53bc0d$export$FSWatcher;
var $a3feb61323626a539f5d76e62a53bc0d$var$pathModule = $0111874a9358ffa1d71ad8eb9f6f16f8$init();
var $a3feb61323626a539f5d76e62a53bc0d$var$setImmediate_1 = $d5051301665947b721edf53bb3d336e1$init();
// ASSET: node_modules/memfs/lib/promises.js
var $7fc0743c324e83b71ee3b2dd17db3d94$exports = {};

var $7fc0743c324e83b71ee3b2dd17db3d94$var$__spreadArray = $7fc0743c324e83b71ee3b2dd17db3d94$exports && $7fc0743c324e83b71ee3b2dd17db3d94$exports.__spreadArray || function (to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

  return to;
};

Object.defineProperty($7fc0743c324e83b71ee3b2dd17db3d94$exports, "__esModule", {
  value: true
});
var $7fc0743c324e83b71ee3b2dd17db3d94$export$FileHandle = void 0;
$7fc0743c324e83b71ee3b2dd17db3d94$exports.FileHandle = $7fc0743c324e83b71ee3b2dd17db3d94$export$FileHandle;

function $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, fn, getResult) {
  if (getResult === void 0) {
    getResult = function (input) {
      return input;
    };
  }

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return new Promise(function (resolve, reject) {
      vol[fn].bind(vol).apply(void 0, $7fc0743c324e83b71ee3b2dd17db3d94$var$__spreadArray($7fc0743c324e83b71ee3b2dd17db3d94$var$__spreadArray([], args), [function (error, result) {
        if (error) return reject(error);
        return resolve(getResult(result));
      }]));
    });
  };
}

var $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle =
/** @class */
function () {
  function FileHandle(vol, fd) {
    this.vol = vol;
    this.fd = fd;
  }

  FileHandle.prototype.appendFile = function (data, options) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'appendFile')(this.fd, data, options);
  };

  FileHandle.prototype.chmod = function (mode) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'fchmod')(this.fd, mode);
  };

  FileHandle.prototype.chown = function (uid, gid) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'fchown')(this.fd, uid, gid);
  };

  FileHandle.prototype.close = function () {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'close')(this.fd);
  };

  FileHandle.prototype.datasync = function () {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'fdatasync')(this.fd);
  };

  FileHandle.prototype.read = function (buffer, offset, length, position) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'read', function (bytesRead) {
      return {
        bytesRead: bytesRead,
        buffer: buffer
      };
    })(this.fd, buffer, offset, length, position);
  };

  FileHandle.prototype.readFile = function (options) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'readFile')(this.fd, options);
  };

  FileHandle.prototype.stat = function (options) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'fstat')(this.fd, options);
  };

  FileHandle.prototype.sync = function () {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'fsync')(this.fd);
  };

  FileHandle.prototype.truncate = function (len) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'ftruncate')(this.fd, len);
  };

  FileHandle.prototype.utimes = function (atime, mtime) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'futimes')(this.fd, atime, mtime);
  };

  FileHandle.prototype.write = function (buffer, offset, length, position) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'write', function (bytesWritten) {
      return {
        bytesWritten: bytesWritten,
        buffer: buffer
      };
    })(this.fd, buffer, offset, length, position);
  };

  FileHandle.prototype.writeFile = function (data, options) {
    return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(this.vol, 'writeFile')(this.fd, data, options);
  };

  return FileHandle;
}();

$7fc0743c324e83b71ee3b2dd17db3d94$export$FileHandle = $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle;
$7fc0743c324e83b71ee3b2dd17db3d94$exports.FileHandle = $7fc0743c324e83b71ee3b2dd17db3d94$export$FileHandle;

function $7fc0743c324e83b71ee3b2dd17db3d94$var$createPromisesApi(vol) {
  if (typeof Promise === 'undefined') return null;
  return {
    FileHandle: $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle,
    access: function (path, mode) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'access')(path, mode);
    },
    appendFile: function (path, data, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'appendFile')(path instanceof $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle ? path.fd : path, data, options);
    },
    chmod: function (path, mode) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'chmod')(path, mode);
    },
    chown: function (path, uid, gid) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'chown')(path, uid, gid);
    },
    copyFile: function (src, dest, flags) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'copyFile')(src, dest, flags);
    },
    lchmod: function (path, mode) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'lchmod')(path, mode);
    },
    lchown: function (path, uid, gid) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'lchown')(path, uid, gid);
    },
    link: function (existingPath, newPath) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'link')(existingPath, newPath);
    },
    lstat: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'lstat')(path, options);
    },
    mkdir: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'mkdir')(path, options);
    },
    mkdtemp: function (prefix, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'mkdtemp')(prefix, options);
    },
    open: function (path, flags, mode) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'open', function (fd) {
        return new $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle(vol, fd);
      })(path, flags, mode);
    },
    readdir: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'readdir')(path, options);
    },
    readFile: function (id, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'readFile')(id instanceof $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle ? id.fd : id, options);
    },
    readlink: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'readlink')(path, options);
    },
    realpath: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'realpath')(path, options);
    },
    rename: function (oldPath, newPath) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'rename')(oldPath, newPath);
    },
    rmdir: function (path) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'rmdir')(path);
    },
    stat: function (path, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'stat')(path, options);
    },
    symlink: function (target, path, type) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'symlink')(target, path, type);
    },
    truncate: function (path, len) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'truncate')(path, len);
    },
    unlink: function (path) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'unlink')(path);
    },
    utimes: function (path, atime, mtime) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'utimes')(path, atime, mtime);
    },
    writeFile: function (id, data, options) {
      return $7fc0743c324e83b71ee3b2dd17db3d94$var$promisify(vol, 'writeFile')(id instanceof $7fc0743c324e83b71ee3b2dd17db3d94$var$FileHandle ? id.fd : id, data, options);
    }
  };
}

var $7fc0743c324e83b71ee3b2dd17db3d94$export$default = $7fc0743c324e83b71ee3b2dd17db3d94$var$createPromisesApi;
$7fc0743c324e83b71ee3b2dd17db3d94$exports.default = $7fc0743c324e83b71ee3b2dd17db3d94$export$default;
var $a3feb61323626a539f5d76e62a53bc0d$var$util = $69678d3e0618202337016e1b4ed76965$init();
var $a3feb61323626a539f5d76e62a53bc0d$var$resolveCrossPlatform = $a3feb61323626a539f5d76e62a53bc0d$var$pathModule.resolve;
var $a3feb61323626a539f5d76e62a53bc0d$var$O_RDONLY = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_RDONLY,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_WRONLY,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_RDWR,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_CREAT,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_EXCL = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_EXCL,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_TRUNC,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_APPEND,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_SYNC = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_SYNC,
    $a3feb61323626a539f5d76e62a53bc0d$var$O_DIRECTORY = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.O_DIRECTORY,
    $a3feb61323626a539f5d76e62a53bc0d$var$F_OK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.F_OK,
    $a3feb61323626a539f5d76e62a53bc0d$var$COPYFILE_EXCL = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.COPYFILE_EXCL,
    $a3feb61323626a539f5d76e62a53bc0d$var$COPYFILE_FICLONE_FORCE = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.COPYFILE_FICLONE_FORCE;
var $a3feb61323626a539f5d76e62a53bc0d$var$_a = $a3feb61323626a539f5d76e62a53bc0d$var$pathModule.posix ? $a3feb61323626a539f5d76e62a53bc0d$var$pathModule.posix : $a3feb61323626a539f5d76e62a53bc0d$var$pathModule,
    $a3feb61323626a539f5d76e62a53bc0d$var$sep = $a3feb61323626a539f5d76e62a53bc0d$var$_a.sep,
    $a3feb61323626a539f5d76e62a53bc0d$var$relative = $a3feb61323626a539f5d76e62a53bc0d$var$_a.relative,
    $a3feb61323626a539f5d76e62a53bc0d$var$join = $a3feb61323626a539f5d76e62a53bc0d$var$_a.join,
    $a3feb61323626a539f5d76e62a53bc0d$var$dirname = $a3feb61323626a539f5d76e62a53bc0d$var$_a.dirname;
var $a3feb61323626a539f5d76e62a53bc0d$var$isWin = $f35591902d49cecff92643cb75f2628b$exports.default.platform === 'win32';
var $a3feb61323626a539f5d76e62a53bc0d$var$kMinPoolSpace = 128; // const kMaxLength = require('buffer').kMaxLength;
// ---------------------------------------- Error messages
// TODO: Use `internal/errors.js` in the future.

// const kMaxLength = require('buffer').kMaxLength;
// ---------------------------------------- Error messages
// TODO: Use `internal/errors.js` in the future.
var $a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR = {
  PATH_STR: 'path must be a string or Buffer',
  // FD:             'file descriptor must be a unsigned 32-bit integer',
  FD: 'fd must be a file descriptor',
  MODE_INT: 'mode must be an int',
  CB: 'callback must be a function',
  UID: 'uid must be an unsigned int',
  GID: 'gid must be an unsigned int',
  LEN: 'len must be an integer',
  ATIME: 'atime must be an integer',
  MTIME: 'mtime must be an integer',
  PREFIX: 'filename prefix is required',
  BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',
  OFFSET: 'offset must be an integer',
  LENGTH: 'length must be an integer',
  POSITION: 'position must be an integer'
};

var $a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR_OPTS = function (tipeof) {
  return "Expected options to be either an object or a string, but got " + tipeof + " instead";
}; // const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;


// const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;
var $a3feb61323626a539f5d76e62a53bc0d$var$ENOENT = 'ENOENT';
var $a3feb61323626a539f5d76e62a53bc0d$var$EBADF = 'EBADF';
var $a3feb61323626a539f5d76e62a53bc0d$var$EINVAL = 'EINVAL';
var $a3feb61323626a539f5d76e62a53bc0d$var$EPERM = 'EPERM';
var $a3feb61323626a539f5d76e62a53bc0d$var$EPROTO = 'EPROTO';
var $a3feb61323626a539f5d76e62a53bc0d$var$EEXIST = 'EEXIST';
var $a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR = 'ENOTDIR';
var $a3feb61323626a539f5d76e62a53bc0d$var$EMFILE = 'EMFILE';
var $a3feb61323626a539f5d76e62a53bc0d$var$EACCES = 'EACCES';
var $a3feb61323626a539f5d76e62a53bc0d$var$EISDIR = 'EISDIR';
var $a3feb61323626a539f5d76e62a53bc0d$var$ENOTEMPTY = 'ENOTEMPTY';
var $a3feb61323626a539f5d76e62a53bc0d$var$ENOSYS = 'ENOSYS';

function $a3feb61323626a539f5d76e62a53bc0d$var$formatError(errorCode, func, path, path2) {
  if (func === void 0) {
    func = '';
  }

  if (path === void 0) {
    path = '';
  }

  if (path2 === void 0) {
    path2 = '';
  }

  var pathFormatted = '';
  if (path) pathFormatted = " '" + path + "'";
  if (path2) pathFormatted += " -> '" + path2 + "'";

  switch (errorCode) {
    case $a3feb61323626a539f5d76e62a53bc0d$var$ENOENT:
      return "ENOENT: no such file or directory, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EBADF:
      return "EBADF: bad file descriptor, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EINVAL:
      return "EINVAL: invalid argument, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EPERM:
      return "EPERM: operation not permitted, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EPROTO:
      return "EPROTO: protocol error, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EEXIST:
      return "EEXIST: file already exists, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR:
      return "ENOTDIR: not a directory, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EISDIR:
      return "EISDIR: illegal operation on a directory, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EACCES:
      return "EACCES: permission denied, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$ENOTEMPTY:
      return "ENOTEMPTY: directory not empty, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$EMFILE:
      return "EMFILE: too many open files, " + func + pathFormatted;

    case $a3feb61323626a539f5d76e62a53bc0d$var$ENOSYS:
      return "ENOSYS: function not implemented, " + func + pathFormatted;

    default:
      return errorCode + ": error occurred, " + func + pathFormatted;
  }
}

function $a3feb61323626a539f5d76e62a53bc0d$var$createError(errorCode, func, path, path2, Constructor) {
  if (func === void 0) {
    func = '';
  }

  if (path === void 0) {
    path = '';
  }

  if (path2 === void 0) {
    path2 = '';
  }

  if (Constructor === void 0) {
    Constructor = Error;
  }

  var error = new Constructor($a3feb61323626a539f5d76e62a53bc0d$var$formatError(errorCode, func, path, path2));
  error.code = errorCode;
  return error;
} // ---------------------------------------- Flags
// List of file `flags` as defined by Node.


// ---------------------------------------- Flags
// List of file `flags` as defined by Node.
var $a3feb61323626a539f5d76e62a53bc0d$var$FLAGS;

(function (FLAGS) {
  // Open file for reading. An exception occurs if the file does not exist.
  FLAGS[FLAGS["r"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDONLY] = "r"; // Open file for reading and writing. An exception occurs if the file does not exist.

  // Open file for reading and writing. An exception occurs if the file does not exist.
  FLAGS[FLAGS["r+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR] = "r+"; // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

  // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.
  FLAGS[FLAGS["rs"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_SYNC] = "rs";
  FLAGS[FLAGS["sr"] = FLAGS.rs] = "sr"; // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.

  // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.
  FLAGS[FLAGS["rs+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_SYNC] = "rs+";
  FLAGS[FLAGS["sr+"] = FLAGS['rs+']] = "sr+"; // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).

  // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
  FLAGS[FLAGS["w"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC] = "w"; // Like 'w' but fails if path exists.

  // Like 'w' but fails if path exists.
  FLAGS[FLAGS["wx"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC | $a3feb61323626a539f5d76e62a53bc0d$var$O_EXCL] = "wx";
  FLAGS[FLAGS["xw"] = FLAGS.wx] = "xw"; // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).

  // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
  FLAGS[FLAGS["w+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC] = "w+"; // Like 'w+' but fails if path exists.

  // Like 'w+' but fails if path exists.
  FLAGS[FLAGS["wx+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC | $a3feb61323626a539f5d76e62a53bc0d$var$O_EXCL] = "wx+";
  FLAGS[FLAGS["xw+"] = FLAGS['wx+']] = "xw+"; // Open file for appending. The file is created if it does not exist.

  // Open file for appending. The file is created if it does not exist.
  FLAGS[FLAGS["a"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT] = "a"; // Like 'a' but fails if path exists.

  // Like 'a' but fails if path exists.
  FLAGS[FLAGS["ax"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_EXCL] = "ax";
  FLAGS[FLAGS["xa"] = FLAGS.ax] = "xa"; // Open file for reading and appending. The file is created if it does not exist.

  // Open file for reading and appending. The file is created if it does not exist.
  FLAGS[FLAGS["a+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT] = "a+"; // Like 'a+' but fails if path exists.

  // Like 'a+' but fails if path exists.
  FLAGS[FLAGS["ax+"] = $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND | $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT | $a3feb61323626a539f5d76e62a53bc0d$var$O_EXCL] = "ax+";
  FLAGS[FLAGS["xa+"] = FLAGS['ax+']] = "xa+";
})($a3feb61323626a539f5d76e62a53bc0d$var$FLAGS = $a3feb61323626a539f5d76e62a53bc0d$exports.FLAGS || ($a3feb61323626a539f5d76e62a53bc0d$export$FLAGS = {}, $a3feb61323626a539f5d76e62a53bc0d$exports.FLAGS = $a3feb61323626a539f5d76e62a53bc0d$export$FLAGS));

function $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(flags) {
  if (typeof flags === 'number') return flags;

  if (typeof flags === 'string') {
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$FLAGS[flags];
    if (typeof flagsNum !== 'undefined') return flagsNum;
  } // throw new TypeError(formatError(ERRSTR_FLAG(flags)));


  // throw new TypeError(formatError(ERRSTR_FLAG(flags)));
  throw new $2a83cb6558526f75280326bcc057be8a$exports.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$flagsToNumber = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber;
$a3feb61323626a539f5d76e62a53bc0d$exports.flagsToNumber = $a3feb61323626a539f5d76e62a53bc0d$export$flagsToNumber; // ---------------------------------------- Options

// ---------------------------------------- Options
function $a3feb61323626a539f5d76e62a53bc0d$var$getOptions(defaults, options) {
  var opts;
  if (!options) return defaults;else {
    var tipeof = typeof options;

    switch (tipeof) {
      case 'string':
        opts = Object.assign({}, defaults, {
          encoding: options
        });
        break;

      case 'object':
        opts = Object.assign({}, defaults, options);
        break;

      default:
        throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR_OPTS(tipeof));
    }
  }
  if (opts.encoding !== 'buffer') $8dca1526026dec0132784fc5c16fdf73$exports.assertEncoding(opts.encoding);
  return opts;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator(defaults) {
  return function (options) {
    return $a3feb61323626a539f5d76e62a53bc0d$var$getOptions(defaults, options);
  };
}

function $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback) {
  if (typeof callback !== 'function') throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.CB);
  return callback;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator(getOpts) {
  return function (options, callback) {
    return typeof options === 'function' ? [getOpts(), options] : [getOpts(options), $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback)];
  };
}

var $a3feb61323626a539f5d76e62a53bc0d$var$optsDefaults = {
  encoding: 'utf8'
};
var $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOpts = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$optsDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOptsAndCb = $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator($a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOpts);
var $a3feb61323626a539f5d76e62a53bc0d$var$readFileOptsDefaults = {
  flag: 'r'
};
var $a3feb61323626a539f5d76e62a53bc0d$var$getReadFileOptions = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$readFileOptsDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$writeFileDefaults = {
  encoding: 'utf8',
  mode: 438
  /* DEFAULT */
  ,

  /* DEFAULT */
  flag: $a3feb61323626a539f5d76e62a53bc0d$var$FLAGS[$a3feb61323626a539f5d76e62a53bc0d$var$FLAGS.w]
};
var $a3feb61323626a539f5d76e62a53bc0d$var$getWriteFileOptions = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$writeFileDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$appendFileDefaults = {
  encoding: 'utf8',
  mode: 438
  /* DEFAULT */
  ,

  /* DEFAULT */
  flag: $a3feb61323626a539f5d76e62a53bc0d$var$FLAGS[$a3feb61323626a539f5d76e62a53bc0d$var$FLAGS.a]
};
var $a3feb61323626a539f5d76e62a53bc0d$var$getAppendFileOpts = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$appendFileDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$getAppendFileOptsAndCb = $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator($a3feb61323626a539f5d76e62a53bc0d$var$getAppendFileOpts);
var $a3feb61323626a539f5d76e62a53bc0d$var$realpathDefaults = $a3feb61323626a539f5d76e62a53bc0d$var$optsDefaults;
var $a3feb61323626a539f5d76e62a53bc0d$var$getRealpathOptions = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$realpathDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$getRealpathOptsAndCb = $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator($a3feb61323626a539f5d76e62a53bc0d$var$getRealpathOptions);
var $a3feb61323626a539f5d76e62a53bc0d$var$mkdirDefaults = {
  mode: 511
  /* DIR */
  ,

  /* DIR */
  recursive: false
};

var $a3feb61323626a539f5d76e62a53bc0d$var$getMkdirOptions = function (options) {
  if (typeof options === 'number') return Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$mkdirDefaults, {
    mode: options
  });
  return Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$mkdirDefaults, options);
};

var $a3feb61323626a539f5d76e62a53bc0d$var$rmdirDefaults = {
  recursive: false
};

var $a3feb61323626a539f5d76e62a53bc0d$var$getRmdirOptions = function (options) {
  return Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$rmdirDefaults, options);
};

var $a3feb61323626a539f5d76e62a53bc0d$var$readdirDefaults = {
  encoding: 'utf8',
  withFileTypes: false
};
var $a3feb61323626a539f5d76e62a53bc0d$var$getReaddirOptions = $a3feb61323626a539f5d76e62a53bc0d$var$optsGenerator($a3feb61323626a539f5d76e62a53bc0d$var$readdirDefaults);
var $a3feb61323626a539f5d76e62a53bc0d$var$getReaddirOptsAndCb = $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator($a3feb61323626a539f5d76e62a53bc0d$var$getReaddirOptions);
var $a3feb61323626a539f5d76e62a53bc0d$var$statDefaults = {
  bigint: false
};

var $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions = function (options) {
  if (options === void 0) {
    options = {};
  }

  return Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$statDefaults, options);
};

var $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptsAndCb = function (options, callback) {
  return typeof options === 'function' ? [$a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions(), options] : [$a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions(options), $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback)];
}; // ---------------------------------------- Utility functions


// ---------------------------------------- Utility functions
function $a3feb61323626a539f5d76e62a53bc0d$var$getPathFromURLPosix(url) {
  if (url.hostname !== '') {
    throw new $2a83cb6558526f75280326bcc057be8a$exports.TypeError('ERR_INVALID_FILE_URL_HOST', $f35591902d49cecff92643cb75f2628b$exports.default.platform);
  }

  var pathname = url.pathname;

  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === '%') {
      var third = pathname.codePointAt(n + 2) | 0x20;

      if (pathname[n + 1] === '2' && third === 102) {
        throw new $2a83cb6558526f75280326bcc057be8a$exports.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');
      }
    }
  }

  return decodeURIComponent(pathname);
}

function $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path) {
  if (typeof path !== 'string' && !$434ed7719003c4362f61238fc34a36d9$exports.Buffer.isBuffer(path)) {
    try {
      if (!(path instanceof $01fe9125d93857b2c37f913e6e158a9e$init().URL)) throw new TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.PATH_STR);
    } catch (err) {
      throw new TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.PATH_STR);
    }

    path = $a3feb61323626a539f5d76e62a53bc0d$var$getPathFromURLPosix(path);
  }

  var pathString = String(path);
  $a3feb61323626a539f5d76e62a53bc0d$var$nullCheck(pathString); // return slash(pathString);

  // return slash(pathString);
  return pathString;
}

var $a3feb61323626a539f5d76e62a53bc0d$export$pathToFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename;
$a3feb61323626a539f5d76e62a53bc0d$exports.pathToFilename = $a3feb61323626a539f5d76e62a53bc0d$export$pathToFilename;

var $a3feb61323626a539f5d76e62a53bc0d$var$resolve = function (filename, base) {
  if (base === void 0) {
    base = $f35591902d49cecff92643cb75f2628b$exports.default.cwd();
  }

  return $a3feb61323626a539f5d76e62a53bc0d$var$resolveCrossPlatform(base, filename);
};

if ($a3feb61323626a539f5d76e62a53bc0d$var$isWin) {
  var $a3feb61323626a539f5d76e62a53bc0d$var$_resolve_1 = $a3feb61323626a539f5d76e62a53bc0d$var$resolve;
  var $a3feb61323626a539f5d76e62a53bc0d$var$unixify_1 = $11d174ca2ca08b3d4ed4ddb466950335$init().unixify;

  $a3feb61323626a539f5d76e62a53bc0d$var$resolve = function (filename, base) {
    return $a3feb61323626a539f5d76e62a53bc0d$var$unixify_1($a3feb61323626a539f5d76e62a53bc0d$var$_resolve_1(filename, base));
  };
}

function $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename, base) {
  var fullPath = $a3feb61323626a539f5d76e62a53bc0d$var$resolve(filename, base);
  var fullPathSansSlash = fullPath.substr(1);
  if (!fullPathSansSlash) return [];
  return fullPathSansSlash.split($a3feb61323626a539f5d76e62a53bc0d$var$sep);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$filenameToSteps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps;
$a3feb61323626a539f5d76e62a53bc0d$exports.filenameToSteps = $a3feb61323626a539f5d76e62a53bc0d$export$filenameToSteps;

function $a3feb61323626a539f5d76e62a53bc0d$var$pathToSteps(path) {
  return $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path));
}

var $a3feb61323626a539f5d76e62a53bc0d$export$pathToSteps = $a3feb61323626a539f5d76e62a53bc0d$var$pathToSteps;
$a3feb61323626a539f5d76e62a53bc0d$exports.pathToSteps = $a3feb61323626a539f5d76e62a53bc0d$export$pathToSteps;

function $a3feb61323626a539f5d76e62a53bc0d$var$dataToStr(data, encoding) {
  if (encoding === void 0) {
    encoding = $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8;
  }

  if ($434ed7719003c4362f61238fc34a36d9$exports.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(data).toString(encoding);else return String(data);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$dataToStr = $a3feb61323626a539f5d76e62a53bc0d$var$dataToStr;
$a3feb61323626a539f5d76e62a53bc0d$exports.dataToStr = $a3feb61323626a539f5d76e62a53bc0d$export$dataToStr;

function $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer(data, encoding) {
  if (encoding === void 0) {
    encoding = $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8;
  }

  if ($434ed7719003c4362f61238fc34a36d9$exports.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(data);else return $434ed7719003c4362f61238fc34a36d9$exports.bufferFrom(String(data), encoding);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$dataToBuffer = $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer;
$a3feb61323626a539f5d76e62a53bc0d$exports.dataToBuffer = $a3feb61323626a539f5d76e62a53bc0d$export$dataToBuffer;

function $a3feb61323626a539f5d76e62a53bc0d$var$bufferToEncoding(buffer, encoding) {
  if (!encoding || encoding === 'buffer') return buffer;else return buffer.toString(encoding);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$bufferToEncoding = $a3feb61323626a539f5d76e62a53bc0d$var$bufferToEncoding;
$a3feb61323626a539f5d76e62a53bc0d$exports.bufferToEncoding = $a3feb61323626a539f5d76e62a53bc0d$export$bufferToEncoding;

function $a3feb61323626a539f5d76e62a53bc0d$var$nullCheck(path, callback) {
  if (('' + path).indexOf('\u0000') !== -1) {
    var er = new Error('Path must be a string without null bytes');
    er.code = $a3feb61323626a539f5d76e62a53bc0d$var$ENOENT;
    if (typeof callback !== 'function') throw er;
    $f35591902d49cecff92643cb75f2628b$exports.default.nextTick(callback, er);
    return false;
  }

  return true;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$_modeToNumber(mode, def) {
  if (typeof mode === 'number') return mode;
  if (typeof mode === 'string') return parseInt(mode, 8);
  if (def) return $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(def);
  return undefined;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode, def) {
  var result = $a3feb61323626a539f5d76e62a53bc0d$var$_modeToNumber(mode, def);
  if (typeof result !== 'number' || isNaN(result)) throw new TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.MODE_INT);
  return result;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$isFd(path) {
  return path >>> 0 === path;
}

function $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd) {
  if (!$a3feb61323626a539f5d76e62a53bc0d$var$isFd(fd)) throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.FD);
} // converts Date or number to a fractional UNIX timestamp


// converts Date or number to a fractional UNIX timestamp
function $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(time) {
  // tslint:disable-next-line triple-equals
  if (typeof time === 'string' && +time == time) {
    return +time;
  }

  if (time instanceof Date) {
    return time.getTime() / 1000;
  }

  if (isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    }

    return time;
  }

  throw new Error('Cannot parse time: ' + time);
}

var $a3feb61323626a539f5d76e62a53bc0d$export$toUnixTimestamp = $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp;
$a3feb61323626a539f5d76e62a53bc0d$exports.toUnixTimestamp = $a3feb61323626a539f5d76e62a53bc0d$export$toUnixTimestamp;

function $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid) {
  if (typeof uid !== 'number') throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.UID);
}

function $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid) {
  if (typeof gid !== 'number') throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.GID);
}

function $a3feb61323626a539f5d76e62a53bc0d$var$flattenJSON(nestedJSON) {
  var flatJSON = {};

  function flatten(pathPrefix, node) {
    for (var path in node) {
      var contentOrNode = node[path];
      var joinedPath = $a3feb61323626a539f5d76e62a53bc0d$var$join(pathPrefix, path);

      if (typeof contentOrNode === 'string') {
        flatJSON[joinedPath] = contentOrNode;
      } else if (typeof contentOrNode === 'object' && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
        // empty directories need an explicit entry and therefore get handled in `else`, non-empty ones are implicitly considered
        flatten(joinedPath, contentOrNode);
      } else {
        // without this branch null, empty-object or non-object entries would not be handled in the same way
        // by both fromJSON() and fromNestedJSON()
        flatJSON[joinedPath] = null;
      }
    }
  }

  flatten('', nestedJSON);
  return flatJSON;
}
/**
 * `Volume` represents a file system.
 */


/**
 * `Volume` represents a file system.
 */
var $a3feb61323626a539f5d76e62a53bc0d$var$Volume =
/** @class */
function () {
  function Volume(props) {
    if (props === void 0) {
      props = {};
    } // I-node number counter.


    // I-node number counter.
    this.ino = 0; // A mapping for i-node numbers to i-nodes (`Node`);

    // A mapping for i-node numbers to i-nodes (`Node`);
    this.inodes = {}; // List of released i-node numbers, for reuse.

    // List of released i-node numbers, for reuse.
    this.releasedInos = []; // A mapping for file descriptors to `File`s.

    // A mapping for file descriptors to `File`s.
    this.fds = {}; // A list of reusable (opened and closed) file descriptors, that should be
    // used first before creating a new file descriptor.

    // A list of reusable (opened and closed) file descriptors, that should be
    // used first before creating a new file descriptor.
    this.releasedFds = []; // Max number of open files.

    // Max number of open files.
    this.maxFiles = 10000; // Current number of open files.

    // Current number of open files.
    this.openFiles = 0;
    this.promisesApi = $7fc0743c324e83b71ee3b2dd17db3d94$exports.default(this);
    this.statWatchers = {};
    this.props = Object.assign({
      Node: $8547ba35338eeeba972d4ace71f97a67$exports.Node,
      Link: $8547ba35338eeeba972d4ace71f97a67$exports.Link,
      File: $8547ba35338eeeba972d4ace71f97a67$exports.File
    }, props);
    var root = this.createLink();
    root.setNode(this.createNode(true));
    var self = this; // tslint:disable-line no-this-assignment

    // tslint:disable-line no-this-assignment
    this.StatWatcher =
    /** @class */
    function (_super) {
      $a3feb61323626a539f5d76e62a53bc0d$var$__extends(StatWatcher, _super);

      function StatWatcher() {
        return _super.call(this, self) || this;
      }

      return StatWatcher;
    }($a3feb61323626a539f5d76e62a53bc0d$var$StatWatcher);

    var _ReadStream = $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream;

    this.ReadStream =
    /** @class */
    function (_super) {
      $a3feb61323626a539f5d76e62a53bc0d$var$__extends(class_1, _super);

      function class_1() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return _super.apply(this, $a3feb61323626a539f5d76e62a53bc0d$var$__spreadArray([self], args)) || this;
      }

      return class_1;
    }(_ReadStream);

    var _WriteStream = $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream;

    this.WriteStream =
    /** @class */
    function (_super) {
      $a3feb61323626a539f5d76e62a53bc0d$var$__extends(class_2, _super);

      function class_2() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return _super.apply(this, $a3feb61323626a539f5d76e62a53bc0d$var$__spreadArray([self], args)) || this;
      }

      return class_2;
    }(_WriteStream);

    this.FSWatcher =
    /** @class */
    function (_super) {
      $a3feb61323626a539f5d76e62a53bc0d$var$__extends(FSWatcher, _super);

      function FSWatcher() {
        return _super.call(this, self) || this;
      }

      return FSWatcher;
    }($a3feb61323626a539f5d76e62a53bc0d$var$FSWatcher); // root.setChild('.', root);
    // root.getNode().nlink++;
    // root.setChild('..', root);
    // root.getNode().nlink++;


    // root.setChild('.', root);
    // root.getNode().nlink++;
    // root.setChild('..', root);
    // root.getNode().nlink++;
    this.root = root;
  }

  Volume.fromJSON = function (json, cwd) {
    var vol = new Volume();
    vol.fromJSON(json, cwd);
    return vol;
  };

  Volume.fromNestedJSON = function (json, cwd) {
    var vol = new Volume();
    vol.fromNestedJSON(json, cwd);
    return vol;
  };

  Object.defineProperty(Volume.prototype, "promises", {
    get: function () {
      if (this.promisesApi === null) throw new Error('Promise is not supported in this environment.');
      return this.promisesApi;
    },
    enumerable: false,
    configurable: true
  });

  Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
    if (isDirectory === void 0) {
      isDirectory = false;
    }

    if (!parent) {
      return new this.props.Link(this, null, '');
    }

    if (!name) {
      throw new Error('createLink: name cannot be empty');
    }

    return parent.createChild(name, this.createNode(isDirectory, perm));
  };

  Volume.prototype.deleteLink = function (link) {
    var parent = link.parent;

    if (parent) {
      parent.deleteChild(link);
      return true;
    }

    return false;
  };

  Volume.prototype.newInoNumber = function () {
    var releasedFd = this.releasedInos.pop();
    if (releasedFd) return releasedFd;else {
      this.ino = (this.ino + 1) % 0xffffffff;
      return this.ino;
    }
  };

  Volume.prototype.newFdNumber = function () {
    var releasedFd = this.releasedFds.pop();
    return typeof releasedFd === 'number' ? releasedFd : Volume.fd++;
  };

  Volume.prototype.createNode = function (isDirectory, perm) {
    if (isDirectory === void 0) {
      isDirectory = false;
    }

    var node = new this.props.Node(this.newInoNumber(), perm);
    if (isDirectory) node.setIsDirectory();
    this.inodes[node.ino] = node;
    return node;
  };

  Volume.prototype.getNode = function (ino) {
    return this.inodes[ino];
  };

  Volume.prototype.deleteNode = function (node) {
    node.del();
    delete this.inodes[node.ino];
    this.releasedInos.push(node.ino);
  }; // Generates 6 character long random string, used by `mkdtemp`.


  // Generates 6 character long random string, used by `mkdtemp`.
  Volume.prototype.genRndStr = function () {
    var str = (Math.random() + 1).toString(36).substr(2, 6);
    if (str.length === 6) return str;else return this.genRndStr();
  }; // Returns a `Link` (hard link) referenced by path "split" into steps.


  // Returns a `Link` (hard link) referenced by path "split" into steps.
  Volume.prototype.getLink = function (steps) {
    return this.root.walk(steps);
  }; // Just link `getLink`, but throws a correct user error, if link to found.


  // Just link `getLink`, but throws a correct user error, if link to found.
  Volume.prototype.getLinkOrThrow = function (filename, funcName) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var link = this.getLink(steps);
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, funcName, filename);
    return link;
  }; // Just like `getLink`, but also dereference/resolves symbolic links.


  // Just like `getLink`, but also dereference/resolves symbolic links.
  Volume.prototype.getResolvedLink = function (filenameOrSteps) {
    var steps = typeof filenameOrSteps === 'string' ? $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filenameOrSteps) : filenameOrSteps;
    var link = this.root;
    var i = 0;

    while (i < steps.length) {
      var step = steps[i];
      link = link.getChild(step);
      if (!link) return null;
      var node = link.getNode();

      if (node.isSymlink()) {
        steps = node.symlink.concat(steps.slice(i + 1));
        link = this.root;
        i = 0;
        continue;
      }

      i++;
    }

    return link;
  }; // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.


  // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
  Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
    var link = this.getResolvedLink(filename);
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, funcName, filename);
    return link;
  };

  Volume.prototype.resolveSymlinks = function (link) {
    // let node: Node = link.getNode();
    // while(link && node.isSymlink()) {
    //     link = this.getLink(node.symlink);
    //     if(!link) return null;
    //     node = link.getNode();
    // }
    // return link;
    return this.getResolvedLink(link.steps.slice(1));
  }; // Just like `getLinkOrThrow`, but also verifies that the link is a directory.


  // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
  Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
    var link = this.getLinkOrThrow(filename, funcName);
    if (!link.getNode().isDirectory()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, funcName, filename);
    return link;
  }; // Get the immediate parent directory of the link.


  // Get the immediate parent directory of the link.
  Volume.prototype.getLinkParent = function (steps) {
    return this.root.walk(steps, steps.length - 1);
  };

  Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
    var steps = filenameOrSteps instanceof Array ? filenameOrSteps : $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filenameOrSteps);
    var link = this.getLinkParent(steps);
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, funcName, $a3feb61323626a539f5d76e62a53bc0d$var$sep + steps.join($a3feb61323626a539f5d76e62a53bc0d$var$sep));
    if (!link.getNode().isDirectory()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, funcName, $a3feb61323626a539f5d76e62a53bc0d$var$sep + steps.join($a3feb61323626a539f5d76e62a53bc0d$var$sep));
    return link;
  };

  Volume.prototype.getFileByFd = function (fd) {
    return this.fds[String(fd)];
  };

  Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
    if (!$a3feb61323626a539f5d76e62a53bc0d$var$isFd(fd)) throw TypeError($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.FD);
    var file = this.getFileByFd(fd);
    if (!file) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EBADF, funcName);
    return file;
  };

  Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
    if (typeof id === 'number') {
      var file = this.getFileByFd(id);
      if (!file) throw Error('File nto found');
      return file.node;
    } else {
      var steps = $a3feb61323626a539f5d76e62a53bc0d$var$pathToSteps(id);
      var link = this.getLink(steps);
      if (link) return link.getNode(); // Try creating a node if not found.

      // Try creating a node if not found.
      if (flags & $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT) {
        var dirLink = this.getLinkParent(steps);

        if (dirLink) {
          var name_1 = steps[steps.length - 1];
          link = this.createLink(dirLink, name_1, false, perm);
          return link.getNode();
        }
      }

      throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'getNodeByIdOrCreate', $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(id));
    }
  };

  Volume.prototype.wrapAsync = function (method, args, callback) {
    var _this = this;

    $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback);
    $a3feb61323626a539f5d76e62a53bc0d$var$setImmediate_1.default(function () {
      try {
        callback(null, method.apply(_this, args));
      } catch (err) {
        callback(err);
      }
    });
  };

  Volume.prototype._toJSON = function (link, json, path) {
    var _a;

    if (link === void 0) {
      link = this.root;
    }

    if (json === void 0) {
      json = {};
    }

    var isEmpty = true;
    var children = link.children;

    if (link.getNode().isFile()) {
      children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
      link = link.parent;
    }

    for (var name_2 in children) {
      isEmpty = false;
      var child = link.getChild(name_2);

      if (!child) {
        throw new Error('_toJSON: unexpected undefined');
      }

      var node = child.getNode();

      if (node.isFile()) {
        var filename = child.getPath();
        if (path) filename = $a3feb61323626a539f5d76e62a53bc0d$var$relative(path, filename);
        json[filename] = node.getString();
      } else if (node.isDirectory()) {
        this._toJSON(child, json, path);
      }
    }

    var dirPath = link.getPath();
    if (path) dirPath = $a3feb61323626a539f5d76e62a53bc0d$var$relative(path, dirPath);

    if (dirPath && isEmpty) {
      json[dirPath] = null;
    }

    return json;
  };

  Volume.prototype.toJSON = function (paths, json, isRelative) {
    if (json === void 0) {
      json = {};
    }

    if (isRelative === void 0) {
      isRelative = false;
    }

    var links = [];

    if (paths) {
      if (!(paths instanceof Array)) paths = [paths];

      for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
        var path = paths_1[_i];
        var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
        var link = this.getResolvedLink(filename);
        if (!link) continue;
        links.push(link);
      }
    } else {
      links.push(this.root);
    }

    if (!links.length) return json;

    for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
      var link = links_1[_a];

      this._toJSON(link, json, isRelative ? link.getPath() : '');
    }

    return json;
  };

  Volume.prototype.fromJSON = function (json, cwd) {
    if (cwd === void 0) {
      cwd = $f35591902d49cecff92643cb75f2628b$exports.default.cwd();
    }

    for (var filename in json) {
      var data = json[filename];
      filename = $a3feb61323626a539f5d76e62a53bc0d$var$resolve(filename, cwd);

      if (typeof data === 'string') {
        var dir = $a3feb61323626a539f5d76e62a53bc0d$var$dirname(filename);
        this.mkdirpBase(dir, 511
        /* DIR */
        );
        this.writeFileSync(filename, data);
      } else {
        this.mkdirpBase(filename, 511
        /* DIR */
        );
      }
    }
  };

  Volume.prototype.fromNestedJSON = function (json, cwd) {
    this.fromJSON($a3feb61323626a539f5d76e62a53bc0d$var$flattenJSON(json), cwd);
  };

  Volume.prototype.reset = function () {
    this.ino = 0;
    this.inodes = {};
    this.releasedInos = [];
    this.fds = {};
    this.releasedFds = [];
    this.openFiles = 0;
    this.root = this.createLink();
    this.root.setNode(this.createNode(true));
  }; // Legacy interface


  // Legacy interface
  Volume.prototype.mountSync = function (mountpoint, json) {
    this.fromJSON(json, mountpoint);
  };

  Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
    if (resolveSymlinks === void 0) {
      resolveSymlinks = true;
    }

    if (this.openFiles >= this.maxFiles) {
      // Too many open files.
      throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EMFILE, 'open', link.getPath());
    } // Resolve symlinks.


    // Resolve symlinks.
    var realLink = link;
    if (resolveSymlinks) realLink = this.resolveSymlinks(link);
    if (!realLink) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'open', link.getPath());
    var node = realLink.getNode(); // Check whether node is a directory

    // Check whether node is a directory
    if (node.isDirectory()) {
      if ((flagsNum & ($a3feb61323626a539f5d76e62a53bc0d$var$O_RDONLY | $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR | $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY)) !== $a3feb61323626a539f5d76e62a53bc0d$var$O_RDONLY) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EISDIR, 'open', link.getPath());
    } else {
      if (flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_DIRECTORY) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, 'open', link.getPath());
    } // Check node permissions


    // Check node permissions
    if (!(flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_WRONLY)) {
      if (!node.canRead()) {
        throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EACCES, 'open', link.getPath());
      }
    }

    if (flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR) {}

    var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
    this.fds[file.fd] = file;
    this.openFiles++;
    if (flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_TRUNC) file.truncate();
    return file;
  };

  Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
    if (resolveSymlinks === void 0) {
      resolveSymlinks = true;
    }

    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps); // Try creating a new file, if it does not exist.

    // Try creating a new file, if it does not exist.
    if (!link && flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT) {
      // const dirLink: Link = this.getLinkParent(steps);
      var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1)); // if(!dirLink) throw createError(ENOENT, 'open', filename);

      // if(!dirLink) throw createError(ENOENT, 'open', filename);
      if (!dirLink) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'open', $a3feb61323626a539f5d76e62a53bc0d$var$sep + steps.join($a3feb61323626a539f5d76e62a53bc0d$var$sep));

      if (flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_CREAT && typeof modeNum === 'number') {
        link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
      }
    }

    if (link) return this.openLink(link, flagsNum, resolveSymlinks);
    throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'open', filename);
  };

  Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
    if (resolveSymlinks === void 0) {
      resolveSymlinks = true;
    }

    var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
    if (!file) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'open', filename);
    return file.fd;
  };

  Volume.prototype.openSync = function (path, flags, mode) {
    if (mode === void 0) {
      mode = 438
      /* DEFAULT */
      ;
    } // Validate (1) mode; (2) path; (3) flags - in that order.


    // Validate (1) mode; (2) path; (3) flags - in that order.
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var fileName = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(flags);
    return this.openBase(fileName, flagsNum, modeNum);
  };

  Volume.prototype.open = function (path, flags, a, b) {
    var mode = a;
    var callback = b;

    if (typeof a === 'function') {
      mode = 438
      /* DEFAULT */
      ;
      callback = a;
    }

    mode = mode || 438
    /* DEFAULT */
    ;
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var fileName = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(flags);
    this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
  };

  Volume.prototype.closeFile = function (file) {
    if (!this.fds[file.fd]) return;
    this.openFiles--;
    delete this.fds[file.fd];
    this.releasedFds.push(file.fd);
  };

  Volume.prototype.closeSync = function (fd) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd);
    var file = this.getFileByFdOrThrow(fd, 'close');
    this.closeFile(file);
  };

  Volume.prototype.close = function (fd, callback) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd);
    this.wrapAsync(this.closeSync, [fd], callback);
  };

  Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
    if (typeof id === 'number') {
      var file = this.fds[id];
      if (!file) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT);
      return file;
    } else {
      return this.openFile($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(id), flagsNum, modeNum);
    }
  };

  Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
    var file = this.getFileByFdOrThrow(fd);
    return file.read(buffer, Number(offset), Number(length), position);
  };

  Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd);
    return this.readBase(fd, buffer, offset, length, position);
  };

  Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
    var _this = this;

    $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback); // This `if` branch is from Node.js

    // This `if` branch is from Node.js
    if (length === 0) {
      return $f35591902d49cecff92643cb75f2628b$exports.default.nextTick(function () {
        if (callback) callback(null, 0, buffer);
      });
    }

    $a3feb61323626a539f5d76e62a53bc0d$var$setImmediate_1.default(function () {
      try {
        var bytes = _this.readBase(fd, buffer, offset, length, position);

        callback(null, bytes, buffer);
      } catch (err) {
        callback(err);
      }
    });
  };

  Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
    var result;
    var isUserFd = typeof id === 'number';
    var userOwnsFd = isUserFd && $a3feb61323626a539f5d76e62a53bc0d$var$isFd(id);
    var fd;
    if (userOwnsFd) fd = id;else {
      var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(id);
      var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
      var link = this.getResolvedLink(steps);

      if (link) {
        var node = link.getNode();
        if (node.isDirectory()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EISDIR, 'open', link.getPath());
      }

      fd = this.openSync(id, flagsNum);
    }

    try {
      result = $a3feb61323626a539f5d76e62a53bc0d$var$bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
    } finally {
      if (!userOwnsFd) {
        this.closeSync(fd);
      }
    }

    return result;
  };

  Volume.prototype.readFileSync = function (file, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getReadFileOptions(options);
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(opts.flag);
    return this.readFileBase(file, flagsNum, opts.encoding);
  };

  Volume.prototype.readFile = function (id, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$optsAndCbGenerator($a3feb61323626a539f5d76e62a53bc0d$var$getReadFileOptions)(a, b),
        opts = _a[0],
        callback = _a[1];

    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(opts.flag);
    this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
  };

  Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
    var file = this.getFileByFdOrThrow(fd, 'write');
    return file.write(buf, offset, length, position);
  };

  Volume.prototype.writeSync = function (fd, a, b, c, d) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd);
    var encoding;
    var offset;
    var length;
    var position;
    var isBuffer = typeof a !== 'string';

    if (isBuffer) {
      offset = (b || 0) | 0;
      length = c;
      position = d;
    } else {
      position = b;
      encoding = c;
    }

    var buf = $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer(a, encoding);

    if (isBuffer) {
      if (typeof length === 'undefined') {
        length = buf.length;
      }
    } else {
      offset = 0;
      length = buf.length;
    }

    return this.writeBase(fd, buf, offset, length, position);
  };

  Volume.prototype.write = function (fd, a, b, c, d, e) {
    var _this = this;

    $a3feb61323626a539f5d76e62a53bc0d$var$validateFd(fd);
    var offset;
    var length;
    var position;
    var encoding;
    var callback;
    var tipa = typeof a;
    var tipb = typeof b;
    var tipc = typeof c;
    var tipd = typeof d;

    if (tipa !== 'string') {
      if (tipb === 'function') {
        callback = b;
      } else if (tipc === 'function') {
        offset = b | 0;
        callback = c;
      } else if (tipd === 'function') {
        offset = b | 0;
        length = c;
        callback = d;
      } else {
        offset = b | 0;
        length = c;
        position = d;
        callback = e;
      }
    } else {
      if (tipb === 'function') {
        callback = b;
      } else if (tipc === 'function') {
        position = b;
        callback = c;
      } else if (tipd === 'function') {
        position = b;
        encoding = c;
        callback = d;
      }
    }

    var buf = $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer(a, encoding);

    if (tipa !== 'string') {
      if (typeof length === 'undefined') length = buf.length;
    } else {
      offset = 0;
      length = buf.length;
    }

    var cb = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback);
    $a3feb61323626a539f5d76e62a53bc0d$var$setImmediate_1.default(function () {
      try {
        var bytes = _this.writeBase(fd, buf, offset, length, position);

        if (tipa !== 'string') {
          cb(null, bytes, buf);
        } else {
          cb(null, bytes, a);
        }
      } catch (err) {
        cb(err);
      }
    });
  };

  Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
    // console.log('writeFileBase', id, buf, flagsNum, modeNum);
    // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
    // node.setBuffer(buf);
    var isUserFd = typeof id === 'number';
    var fd;
    if (isUserFd) fd = id;else {
      fd = this.openBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(id), flagsNum, modeNum); // fd = this.openSync(id as PathLike, flagsNum, modeNum);
    }
    var offset = 0;
    var length = buf.length;
    var position = flagsNum & $a3feb61323626a539f5d76e62a53bc0d$var$O_APPEND ? undefined : 0;

    try {
      while (length > 0) {
        var written = this.writeSync(fd, buf, offset, length, position);
        offset += written;
        length -= written;
        if (position !== undefined) position += written;
      }
    } finally {
      if (!isUserFd) this.closeSync(fd);
    }
  };

  Volume.prototype.writeFileSync = function (id, data, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getWriteFileOptions(options);
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(opts.flag);
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(opts.mode);
    var buf = $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer(data, opts.encoding);
    this.writeFileBase(id, buf, flagsNum, modeNum);
  };

  Volume.prototype.writeFile = function (id, data, a, b) {
    var options = a;
    var callback = b;

    if (typeof a === 'function') {
      options = $a3feb61323626a539f5d76e62a53bc0d$var$writeFileDefaults;
      callback = a;
    }

    var cb = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback);
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getWriteFileOptions(options);
    var flagsNum = $a3feb61323626a539f5d76e62a53bc0d$var$flagsToNumber(opts.flag);
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(opts.mode);
    var buf = $a3feb61323626a539f5d76e62a53bc0d$var$dataToBuffer(data, opts.encoding);
    this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
  };

  Volume.prototype.linkBase = function (filename1, filename2) {
    var steps1 = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename1);
    var link1 = this.getLink(steps1);
    if (!link1) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'link', filename1, filename2);
    var steps2 = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename2); // Check new link directory exists.

    // Check new link directory exists.
    var dir2 = this.getLinkParent(steps2);
    if (!dir2) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'link', filename1, filename2);
    var name = steps2[steps2.length - 1]; // Check if new file already exists.

    // Check if new file already exists.
    if (dir2.getChild(name)) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EEXIST, 'link', filename1, filename2);
    var node = link1.getNode();
    node.nlink++;
    dir2.createChild(name, node);
  };

  Volume.prototype.copyFileBase = function (src, dest, flags) {
    var buf = this.readFileSync(src);

    if (flags & $a3feb61323626a539f5d76e62a53bc0d$var$COPYFILE_EXCL) {
      if (this.existsSync(dest)) {
        throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EEXIST, 'copyFile', src, dest);
      }
    }

    if (flags & $a3feb61323626a539f5d76e62a53bc0d$var$COPYFILE_FICLONE_FORCE) {
      throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOSYS, 'copyFile', src, dest);
    }

    this.writeFileBase(dest, buf, $a3feb61323626a539f5d76e62a53bc0d$var$FLAGS.w, 438
    /* DEFAULT */
    );
  };

  Volume.prototype.copyFileSync = function (src, dest, flags) {
    var srcFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(src);
    var destFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(dest);
    return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
  };

  Volume.prototype.copyFile = function (src, dest, a, b) {
    var srcFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(src);
    var destFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(dest);
    var flags;
    var callback;

    if (typeof a === 'function') {
      flags = 0;
      callback = a;
    } else {
      flags = a;
      callback = b;
    }

    $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(callback);
    this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
  };

  Volume.prototype.linkSync = function (existingPath, newPath) {
    var existingPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(existingPath);
    var newPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(newPath);
    this.linkBase(existingPathFilename, newPathFilename);
  };

  Volume.prototype.link = function (existingPath, newPath, callback) {
    var existingPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(existingPath);
    var newPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(newPath);
    this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
  };

  Volume.prototype.unlinkBase = function (filename) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var link = this.getLink(steps);
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'unlink', filename); // TODO: Check if it is file, dir, other...

    // TODO: Check if it is file, dir, other...
    if (link.length) throw Error('Dir not empty...');
    this.deleteLink(link);
    var node = link.getNode();
    node.nlink--; // When all hard links to i-node are deleted, remove the i-node, too.

    // When all hard links to i-node are deleted, remove the i-node, too.
    if (node.nlink <= 0) {
      this.deleteNode(node);
    }
  };

  Volume.prototype.unlinkSync = function (path) {
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.unlinkBase(filename);
  };

  Volume.prototype.unlink = function (path, callback) {
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.unlinkBase, [filename], callback);
  };

  Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
    var pathSteps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(pathFilename); // Check if directory exists, where we about to create a symlink.

    // Check if directory exists, where we about to create a symlink.
    var dirLink = this.getLinkParent(pathSteps);
    if (!dirLink) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'symlink', targetFilename, pathFilename);
    var name = pathSteps[pathSteps.length - 1]; // Check if new file already exists.

    // Check if new file already exists.
    if (dirLink.getChild(name)) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EEXIST, 'symlink', targetFilename, pathFilename); // Create symlink.

    // Create symlink.
    var symlink = dirLink.createChild(name);
    symlink.getNode().makeSymlink($a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(targetFilename));
    return symlink;
  }; // `type` argument works only on Windows.


  // `type` argument works only on Windows.
  Volume.prototype.symlinkSync = function (target, path, type) {
    var targetFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(target);
    var pathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.symlinkBase(targetFilename, pathFilename);
  };

  Volume.prototype.symlink = function (target, path, a, b) {
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'function' ? a : b);
    var targetFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(target);
    var pathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
  };

  Volume.prototype.realpathBase = function (filename, encoding) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var realLink = this.getResolvedLink(steps);
    if (!realLink) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'realpath', filename);
    return $8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(realLink.getPath(), encoding);
  };

  Volume.prototype.realpathSync = function (path, options) {
    return this.realpathBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), $a3feb61323626a539f5d76e62a53bc0d$var$getRealpathOptions(options).encoding);
  };

  Volume.prototype.realpath = function (path, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getRealpathOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1];

    var pathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
  };

  Volume.prototype.lstatBase = function (filename, bigint) {
    if (bigint === void 0) {
      bigint = false;
    }

    var link = this.getLink($a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename));
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'lstat', filename);
    return $3427174026c479434e105c2f49a8e44e$exports.default.build(link.getNode(), bigint);
  };

  Volume.prototype.lstatSync = function (path, options) {
    return this.lstatBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions(options).bigint);
  };

  Volume.prototype.lstat = function (path, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1];

    this.wrapAsync(this.lstatBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), opts.bigint], callback);
  };

  Volume.prototype.statBase = function (filename, bigint) {
    if (bigint === void 0) {
      bigint = false;
    }

    var link = this.getResolvedLink($a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename));
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'stat', filename);
    return $3427174026c479434e105c2f49a8e44e$exports.default.build(link.getNode(), bigint);
  };

  Volume.prototype.statSync = function (path, options) {
    return this.statBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions(options).bigint);
  };

  Volume.prototype.stat = function (path, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1];

    this.wrapAsync(this.statBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), opts.bigint], callback);
  };

  Volume.prototype.fstatBase = function (fd, bigint) {
    if (bigint === void 0) {
      bigint = false;
    }

    var file = this.getFileByFd(fd);
    if (!file) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EBADF, 'fstat');
    return $3427174026c479434e105c2f49a8e44e$exports.default.build(file.node, bigint);
  };

  Volume.prototype.fstatSync = function (fd, options) {
    return this.fstatBase(fd, $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptions(options).bigint);
  };

  Volume.prototype.fstat = function (fd, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getStatOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1];

    this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
  };

  Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
    var link = this.getLink($a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(oldPathFilename));
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'rename', oldPathFilename, newPathFilename); // TODO: Check if it is directory, if non-empty, we cannot move it, right?

    // TODO: Check if it is directory, if non-empty, we cannot move it, right?
    var newPathSteps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(newPathFilename); // Check directory exists for the new location.

    // Check directory exists for the new location.
    var newPathDirLink = this.getLinkParent(newPathSteps);
    if (!newPathDirLink) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'rename', oldPathFilename, newPathFilename); // TODO: Also treat cases with directories and symbolic links.
    // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
    // Remove hard link from old folder.

    // TODO: Also treat cases with directories and symbolic links.
    // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
    // Remove hard link from old folder.
    var oldLinkParent = link.parent;

    if (oldLinkParent) {
      oldLinkParent.deleteChild(link);
    } // Rename should overwrite the new path, if that exists.


    // Rename should overwrite the new path, if that exists.
    var name = newPathSteps[newPathSteps.length - 1];
    link.steps = $a3feb61323626a539f5d76e62a53bc0d$var$__spreadArray($a3feb61323626a539f5d76e62a53bc0d$var$__spreadArray([], newPathDirLink.steps), [name]);
    newPathDirLink.setChild(link.getName(), link);
  };

  Volume.prototype.renameSync = function (oldPath, newPath) {
    var oldPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(oldPath);
    var newPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(newPath);
    this.renameBase(oldPathFilename, newPathFilename);
  };

  Volume.prototype.rename = function (oldPath, newPath, callback) {
    var oldPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(oldPath);
    var newPathFilename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(newPath);
    this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
  };

  Volume.prototype.existsBase = function (filename) {
    return !!this.statBase(filename);
  };

  Volume.prototype.existsSync = function (path) {
    try {
      return this.existsBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path));
    } catch (err) {
      return false;
    }
  };

  Volume.prototype.exists = function (path, callback) {
    var _this = this;

    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    if (typeof callback !== 'function') throw Error($a3feb61323626a539f5d76e62a53bc0d$var$ERRSTR.CB);
    $a3feb61323626a539f5d76e62a53bc0d$var$setImmediate_1.default(function () {
      try {
        callback(_this.existsBase(filename));
      } catch (err) {
        callback(false);
      }
    });
  };

  Volume.prototype.accessBase = function (filename, mode) {
    var link = this.getLinkOrThrow(filename, 'access'); // TODO: Verify permissions
  };

  Volume.prototype.accessSync = function (path, mode) {
    if (mode === void 0) {
      mode = $a3feb61323626a539f5d76e62a53bc0d$var$F_OK;
    }

    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    mode = mode | 0;
    this.accessBase(filename, mode);
  };

  Volume.prototype.access = function (path, a, b) {
    var mode = $a3feb61323626a539f5d76e62a53bc0d$var$F_OK;
    var callback;

    if (typeof a !== 'function') {
      mode = a | 0; // cast to number

      // cast to number
      callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(b);
    } else {
      callback = a;
    }

    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.accessBase, [filename, mode], callback);
  };

  Volume.prototype.appendFileSync = function (id, data, options) {
    if (options === void 0) {
      options = $a3feb61323626a539f5d76e62a53bc0d$var$appendFileDefaults;
    }

    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getAppendFileOpts(options); // force append behavior when using a supplied file descriptor

    // force append behavior when using a supplied file descriptor
    if (!opts.flag || $a3feb61323626a539f5d76e62a53bc0d$var$isFd(id)) opts.flag = 'a';
    this.writeFileSync(id, data, opts);
  };

  Volume.prototype.appendFile = function (id, data, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getAppendFileOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1]; // force append behavior when using a supplied file descriptor


    // force append behavior when using a supplied file descriptor
    if (!opts.flag || $a3feb61323626a539f5d76e62a53bc0d$var$isFd(id)) opts.flag = 'a';
    this.writeFile(id, data, opts, callback);
  };

  Volume.prototype.readdirBase = function (filename, options) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var link = this.getResolvedLink(steps);
    if (!link) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOENT, 'readdir', filename);
    var node = link.getNode();
    if (!node.isDirectory()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, 'scandir', filename);

    if (options.withFileTypes) {
      var list_1 = [];

      for (var name_3 in link.children) {
        var child = link.getChild(name_3);

        if (!child) {
          continue;
        }

        list_1.push($625e9897ba6758d68ddb608d84cb5b08$exports.default.build(child, options.encoding));
      }

      if (!$a3feb61323626a539f5d76e62a53bc0d$var$isWin && options.encoding !== 'buffer') list_1.sort(function (a, b) {
        if (a.name < b.name) return -1;
        if (a.name > b.name) return 1;
        return 0;
      });
      return list_1;
    }

    var list = [];

    for (var name_4 in link.children) {
      list.push($8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(name_4, options.encoding));
    }

    if (!$a3feb61323626a539f5d76e62a53bc0d$var$isWin && options.encoding !== 'buffer') list.sort();
    return list;
  };

  Volume.prototype.readdirSync = function (path, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getReaddirOptions(options);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    return this.readdirBase(filename, opts);
  };

  Volume.prototype.readdir = function (path, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getReaddirOptsAndCb(a, b),
        options = _a[0],
        callback = _a[1];

    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.readdirBase, [filename, options], callback);
  };

  Volume.prototype.readlinkBase = function (filename, encoding) {
    var link = this.getLinkOrThrow(filename, 'readlink');
    var node = link.getNode();
    if (!node.isSymlink()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EINVAL, 'readlink', filename);
    var str = $a3feb61323626a539f5d76e62a53bc0d$var$sep + node.symlink.join($a3feb61323626a539f5d76e62a53bc0d$var$sep);
    return $8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(str, encoding);
  };

  Volume.prototype.readlinkSync = function (path, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOpts(options);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    return this.readlinkBase(filename, opts.encoding);
  };

  Volume.prototype.readlink = function (path, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOptsAndCb(a, b),
        opts = _a[0],
        callback = _a[1];

    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
  };

  Volume.prototype.fsyncBase = function (fd) {
    this.getFileByFdOrThrow(fd, 'fsync');
  };

  Volume.prototype.fsyncSync = function (fd) {
    this.fsyncBase(fd);
  };

  Volume.prototype.fsync = function (fd, callback) {
    this.wrapAsync(this.fsyncBase, [fd], callback);
  };

  Volume.prototype.fdatasyncBase = function (fd) {
    this.getFileByFdOrThrow(fd, 'fdatasync');
  };

  Volume.prototype.fdatasyncSync = function (fd) {
    this.fdatasyncBase(fd);
  };

  Volume.prototype.fdatasync = function (fd, callback) {
    this.wrapAsync(this.fdatasyncBase, [fd], callback);
  };

  Volume.prototype.ftruncateBase = function (fd, len) {
    var file = this.getFileByFdOrThrow(fd, 'ftruncate');
    file.truncate(len);
  };

  Volume.prototype.ftruncateSync = function (fd, len) {
    this.ftruncateBase(fd, len);
  };

  Volume.prototype.ftruncate = function (fd, a, b) {
    var len = typeof a === 'number' ? a : 0;
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'number' ? b : a);
    this.wrapAsync(this.ftruncateBase, [fd, len], callback);
  };

  Volume.prototype.truncateBase = function (path, len) {
    var fd = this.openSync(path, 'r+');

    try {
      this.ftruncateSync(fd, len);
    } finally {
      this.closeSync(fd);
    }
  };

  Volume.prototype.truncateSync = function (id, len) {
    if ($a3feb61323626a539f5d76e62a53bc0d$var$isFd(id)) return this.ftruncateSync(id, len);
    this.truncateBase(id, len);
  };

  Volume.prototype.truncate = function (id, a, b) {
    var len = typeof a === 'number' ? a : 0;
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'number' ? b : a);
    if ($a3feb61323626a539f5d76e62a53bc0d$var$isFd(id)) return this.ftruncate(id, len, callback);
    this.wrapAsync(this.truncateBase, [id, len], callback);
  };

  Volume.prototype.futimesBase = function (fd, atime, mtime) {
    var file = this.getFileByFdOrThrow(fd, 'futimes');
    var node = file.node;
    node.atime = new Date(atime * 1000);
    node.mtime = new Date(mtime * 1000);
  };

  Volume.prototype.futimesSync = function (fd, atime, mtime) {
    this.futimesBase(fd, $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(atime), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(mtime));
  };

  Volume.prototype.futimes = function (fd, atime, mtime, callback) {
    this.wrapAsync(this.futimesBase, [fd, $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(atime), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(mtime)], callback);
  };

  Volume.prototype.utimesBase = function (filename, atime, mtime) {
    var fd = this.openSync(filename, 'r+');

    try {
      this.futimesBase(fd, atime, mtime);
    } finally {
      this.closeSync(fd);
    }
  };

  Volume.prototype.utimesSync = function (path, atime, mtime) {
    this.utimesBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(atime), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(mtime));
  };

  Volume.prototype.utimes = function (path, atime, mtime, callback) {
    this.wrapAsync(this.utimesBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(atime), $a3feb61323626a539f5d76e62a53bc0d$var$toUnixTimestamp(mtime)], callback);
  };

  Volume.prototype.mkdirBase = function (filename, modeNum) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename); // This will throw if user tries to create root dir `fs.mkdirSync('/')`.

    // This will throw if user tries to create root dir `fs.mkdirSync('/')`.
    if (!steps.length) {
      throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EEXIST, 'mkdir', filename);
    }

    var dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir'); // Check path already exists.

    // Check path already exists.
    var name = steps[steps.length - 1];
    if (dir.getChild(name)) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$EEXIST, 'mkdir', filename);
    dir.createChild(name, this.createNode(true, modeNum));
  };
  /**
   * Creates directory tree recursively.
   * @param filename
   * @param modeNum
   */


  /**
   * Creates directory tree recursively.
   * @param filename
   * @param modeNum
   */
  Volume.prototype.mkdirpBase = function (filename, modeNum) {
    var steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(filename);
    var link = this.root;

    for (var i = 0; i < steps.length; i++) {
      var step = steps[i];
      if (!link.getNode().isDirectory()) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, 'mkdir', link.getPath());
      var child = link.getChild(step);

      if (child) {
        if (child.getNode().isDirectory()) link = child;else throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTDIR, 'mkdir', child.getPath());
      } else {
        link = link.createChild(step, this.createNode(true, modeNum));
      }
    }
  };

  Volume.prototype.mkdirSync = function (path, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getMkdirOptions(options);
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(opts.mode, 511);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
  };

  Volume.prototype.mkdir = function (path, a, b) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getMkdirOptions(a);
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'function' ? a : b);
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(opts.mode, 511);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
  }; // legacy interface


  // legacy interface
  Volume.prototype.mkdirpSync = function (path, mode) {
    this.mkdirSync(path, {
      mode: mode,
      recursive: true
    });
  };

  Volume.prototype.mkdirp = function (path, a, b) {
    var mode = typeof a === 'function' ? undefined : a;
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'function' ? a : b);
    this.mkdir(path, {
      mode: mode,
      recursive: true
    }, callback);
  };

  Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
    if (retry === void 0) {
      retry = 5;
    }

    var filename = prefix + this.genRndStr();

    try {
      this.mkdirBase(filename, 511
      /* DIR */
      );
      return $8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(filename, encoding);
    } catch (err) {
      if (err.code === $a3feb61323626a539f5d76e62a53bc0d$var$EEXIST) {
        if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);else throw Error('Could not create temp dir.');
      } else throw err;
    }
  };

  Volume.prototype.mkdtempSync = function (prefix, options) {
    var encoding = $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOpts(options).encoding;
    if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
    $a3feb61323626a539f5d76e62a53bc0d$var$nullCheck(prefix);
    return this.mkdtempBase(prefix, encoding);
  };

  Volume.prototype.mkdtemp = function (prefix, a, b) {
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOptsAndCb(a, b),
        encoding = _a[0].encoding,
        callback = _a[1];

    if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
    if (!$a3feb61323626a539f5d76e62a53bc0d$var$nullCheck(prefix)) return;
    this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
  };

  Volume.prototype.rmdirBase = function (filename, options) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getRmdirOptions(options);
    var link = this.getLinkAsDirOrThrow(filename, 'rmdir'); // Check directory is empty.

    // Check directory is empty.
    if (link.length && !opts.recursive) throw $a3feb61323626a539f5d76e62a53bc0d$var$createError($a3feb61323626a539f5d76e62a53bc0d$var$ENOTEMPTY, 'rmdir', filename);
    this.deleteLink(link);
  };

  Volume.prototype.rmdirSync = function (path, options) {
    this.rmdirBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), options);
  };

  Volume.prototype.rmdir = function (path, a, b) {
    var opts = $a3feb61323626a539f5d76e62a53bc0d$var$getRmdirOptions(a);
    var callback = $a3feb61323626a539f5d76e62a53bc0d$var$validateCallback(typeof a === 'function' ? a : b);
    this.wrapAsync(this.rmdirBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), opts], callback);
  };

  Volume.prototype.fchmodBase = function (fd, modeNum) {
    var file = this.getFileByFdOrThrow(fd, 'fchmod');
    file.chmod(modeNum);
  };

  Volume.prototype.fchmodSync = function (fd, mode) {
    this.fchmodBase(fd, $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode));
  };

  Volume.prototype.fchmod = function (fd, mode, callback) {
    this.wrapAsync(this.fchmodBase, [fd, $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode)], callback);
  };

  Volume.prototype.chmodBase = function (filename, modeNum) {
    var fd = this.openSync(filename, 'r+');

    try {
      this.fchmodBase(fd, modeNum);
    } finally {
      this.closeSync(fd);
    }
  };

  Volume.prototype.chmodSync = function (path, mode) {
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.chmodBase(filename, modeNum);
  };

  Volume.prototype.chmod = function (path, mode, callback) {
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
  };

  Volume.prototype.lchmodBase = function (filename, modeNum) {
    var fd = this.openBase(filename, $a3feb61323626a539f5d76e62a53bc0d$var$O_RDWR, 0, false);

    try {
      this.fchmodBase(fd, modeNum);
    } finally {
      this.closeSync(fd);
    }
  };

  Volume.prototype.lchmodSync = function (path, mode) {
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.lchmodBase(filename, modeNum);
  };

  Volume.prototype.lchmod = function (path, mode, callback) {
    var modeNum = $a3feb61323626a539f5d76e62a53bc0d$var$modeToNumber(mode);
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
  };

  Volume.prototype.fchownBase = function (fd, uid, gid) {
    this.getFileByFdOrThrow(fd, 'fchown').chown(uid, gid);
  };

  Volume.prototype.fchownSync = function (fd, uid, gid) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.fchownBase(fd, uid, gid);
  };

  Volume.prototype.fchown = function (fd, uid, gid, callback) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
  };

  Volume.prototype.chownBase = function (filename, uid, gid) {
    var link = this.getResolvedLinkOrThrow(filename, 'chown');
    var node = link.getNode();
    node.chown(uid, gid); // if(node.isFile() || node.isSymlink()) {
    //
    // } else if(node.isDirectory()) {
    //
    // } else {
    // TODO: What do we do here?
    // }
  };

  Volume.prototype.chownSync = function (path, uid, gid) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.chownBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), uid, gid);
  };

  Volume.prototype.chown = function (path, uid, gid, callback) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.wrapAsync(this.chownBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), uid, gid], callback);
  };

  Volume.prototype.lchownBase = function (filename, uid, gid) {
    this.getLinkOrThrow(filename, 'lchown').getNode().chown(uid, gid);
  };

  Volume.prototype.lchownSync = function (path, uid, gid) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.lchownBase($a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), uid, gid);
  };

  Volume.prototype.lchown = function (path, uid, gid, callback) {
    $a3feb61323626a539f5d76e62a53bc0d$var$validateUid(uid);
    $a3feb61323626a539f5d76e62a53bc0d$var$validateGid(gid);
    this.wrapAsync(this.lchownBase, [$a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path), uid, gid], callback);
  };

  Volume.prototype.watchFile = function (path, a, b) {
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    var options = a;
    var listener = b;

    if (typeof options === 'function') {
      listener = a;
      options = null;
    }

    if (typeof listener !== 'function') {
      throw Error('"watchFile()" requires a listener function');
    }

    var interval = 5007;
    var persistent = true;

    if (options && typeof options === 'object') {
      if (typeof options.interval === 'number') interval = options.interval;
      if (typeof options.persistent === 'boolean') persistent = options.persistent;
    }

    var watcher = this.statWatchers[filename];

    if (!watcher) {
      watcher = new this.StatWatcher();
      watcher.start(filename, persistent, interval);
      this.statWatchers[filename] = watcher;
    }

    watcher.addListener('change', listener);
    return watcher;
  };

  Volume.prototype.unwatchFile = function (path, listener) {
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    var watcher = this.statWatchers[filename];
    if (!watcher) return;

    if (typeof listener === 'function') {
      watcher.removeListener('change', listener);
    } else {
      watcher.removeAllListeners('change');
    }

    if (watcher.listenerCount('change') === 0) {
      watcher.stop();
      delete this.statWatchers[filename];
    }
  };

  Volume.prototype.createReadStream = function (path, options) {
    return new this.ReadStream(path, options);
  };

  Volume.prototype.createWriteStream = function (path, options) {
    return new this.WriteStream(path, options);
  }; // watch(path: PathLike): FSWatcher;
  // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;


  // watch(path: PathLike): FSWatcher;
  // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
  Volume.prototype.watch = function (path, options, listener) {
    var filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    var givenOptions = options;

    if (typeof options === 'function') {
      listener = options;
      givenOptions = null;
    } // tslint:disable-next-line prefer-const


    // tslint:disable-next-line prefer-const
    var _a = $a3feb61323626a539f5d76e62a53bc0d$var$getDefaultOpts(givenOptions),
        persistent = _a.persistent,
        recursive = _a.recursive,
        encoding = _a.encoding;

    if (persistent === undefined) persistent = true;
    if (recursive === undefined) recursive = false;
    var watcher = new this.FSWatcher();
    watcher.start(filename, persistent, recursive, encoding);

    if (listener) {
      watcher.addListener('change', listener);
    }

    return watcher;
  };
  /**
   * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
   * up, so here, in order not to conflict with them, we choose some big number and descrease
   * the file descriptor of every new opened file.
   * @type {number}
   * @todo This should not be static, right?
   */


  /**
   * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
   * up, so here, in order not to conflict with them, we choose some big number and descrease
   * the file descriptor of every new opened file.
   * @type {number}
   * @todo This should not be static, right?
   */
  Volume.fd = 10;
  return Volume;
}();

var $a3feb61323626a539f5d76e62a53bc0d$export$Volume = $a3feb61323626a539f5d76e62a53bc0d$var$Volume;
$a3feb61323626a539f5d76e62a53bc0d$exports.Volume = $a3feb61323626a539f5d76e62a53bc0d$export$Volume;

function $a3feb61323626a539f5d76e62a53bc0d$var$emitStop(self) {
  self.emit('stop');
}

var $a3feb61323626a539f5d76e62a53bc0d$var$StatWatcher =
/** @class */
function (_super) {
  $a3feb61323626a539f5d76e62a53bc0d$var$__extends(StatWatcher, _super);

  function StatWatcher(vol) {
    var _this = _super.call(this) || this;

    _this.onInterval = function () {
      try {
        var stats = _this.vol.statSync(_this.filename);

        if (_this.hasChanged(stats)) {
          _this.emit('change', stats, _this.prev);

          _this.prev = stats;
        }
      } finally {
        _this.loop();
      }
    };

    _this.vol = vol;
    return _this;
  }

  StatWatcher.prototype.loop = function () {
    this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
  };

  StatWatcher.prototype.hasChanged = function (stats) {
    // if(!this.prev) return false;
    if (stats.mtimeMs > this.prev.mtimeMs) return true;
    if (stats.nlink !== this.prev.nlink) return true;
    return false;
  };

  StatWatcher.prototype.start = function (path, persistent, interval) {
    if (persistent === void 0) {
      persistent = true;
    }

    if (interval === void 0) {
      interval = 5007;
    }

    this.filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this.setTimeout = persistent ? setTimeout : $5435f34f25ec65b29f650713af1c297f$exports.default;
    this.interval = interval;
    this.prev = this.vol.statSync(this.filename);
    this.loop();
  };

  StatWatcher.prototype.stop = function () {
    clearTimeout(this.timeoutRef);
    $f35591902d49cecff92643cb75f2628b$exports.default.nextTick($a3feb61323626a539f5d76e62a53bc0d$var$emitStop, this);
  };

  return StatWatcher;
}($2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter);

var $a3feb61323626a539f5d76e62a53bc0d$export$StatWatcher = $a3feb61323626a539f5d76e62a53bc0d$var$StatWatcher;
$a3feb61323626a539f5d76e62a53bc0d$exports.StatWatcher = $a3feb61323626a539f5d76e62a53bc0d$export$StatWatcher;
var $a3feb61323626a539f5d76e62a53bc0d$var$pool;

function $a3feb61323626a539f5d76e62a53bc0d$var$allocNewPool(poolSize) {
  $a3feb61323626a539f5d76e62a53bc0d$var$pool = $434ed7719003c4362f61238fc34a36d9$exports.bufferAllocUnsafe(poolSize);
  $a3feb61323626a539f5d76e62a53bc0d$var$pool.used = 0;
}

$a3feb61323626a539f5d76e62a53bc0d$var$util.inherits($a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream, $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable);
var $a3feb61323626a539f5d76e62a53bc0d$export$ReadStream = $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream;
$a3feb61323626a539f5d76e62a53bc0d$exports.ReadStream = $a3feb61323626a539f5d76e62a53bc0d$export$ReadStream;

function $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream(vol, path, options) {
  if (!(this instanceof $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream)) return new $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream(vol, path, options);
  this._vol = vol; // a little bit bigger buffer and water marks by default

  // a little bit bigger buffer and water marks by default
  options = Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$getOptions(options, {}));
  if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
  $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Readable.call(this, options);
  this.path = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 438 : options.mode;
  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }

    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('"end" option must be a Number');
    }

    if (this.start > this.end) {
      throw new Error('"start" option must be <= "end" option');
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== 'number') this.open();
  this.on('end', function () {
    if (this.autoClose) {
      if (this.destroy) this.destroy();
    }
  });
}

$a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype.open = function () {
  var self = this; // tslint:disable-line no-this-assignment

  // tslint:disable-line no-this-assignment
  this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
    if (er) {
      if (self.autoClose) {
        if (self.destroy) self.destroy();
      }

      self.emit('error', er);
      return;
    }

    self.fd = fd;
    self.emit('open', fd); // start the flow of data.

    // start the flow of data.
    self.read();
  });
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype._read = function (n) {
  if (typeof this.fd !== 'number') {
    return this.once('open', function () {
      this._read(n);
    });
  }

  if (this.destroyed) return;

  if (!$a3feb61323626a539f5d76e62a53bc0d$var$pool || $a3feb61323626a539f5d76e62a53bc0d$var$pool.length - $a3feb61323626a539f5d76e62a53bc0d$var$pool.used < $a3feb61323626a539f5d76e62a53bc0d$var$kMinPoolSpace) {
    // discard the old pool.
    $a3feb61323626a539f5d76e62a53bc0d$var$allocNewPool(this._readableState.highWaterMark);
  } // Grab another reference to the pool in the case that while we're
  // in the thread pool another read() finishes up the pool, and
  // allocates a new one.


  // Grab another reference to the pool in the case that while we're
  // in the thread pool another read() finishes up the pool, and
  // allocates a new one.
  var thisPool = $a3feb61323626a539f5d76e62a53bc0d$var$pool;
  var toRead = Math.min($a3feb61323626a539f5d76e62a53bc0d$var$pool.length - $a3feb61323626a539f5d76e62a53bc0d$var$pool.used, n);
  var start = $a3feb61323626a539f5d76e62a53bc0d$var$pool.used;
  if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead); // already read everything we were supposed to read!
  // treat as EOF.

  // already read everything we were supposed to read!
  // treat as EOF.
  if (toRead <= 0) return this.push(null); // the actual read.

  // the actual read.
  var self = this; // tslint:disable-line no-this-assignment

  // tslint:disable-line no-this-assignment
  this._vol.read(this.fd, $a3feb61323626a539f5d76e62a53bc0d$var$pool, $a3feb61323626a539f5d76e62a53bc0d$var$pool.used, toRead, this.pos, onread); // move the pool positions, and internal position for reading.


  // move the pool positions, and internal position for reading.
  if (this.pos !== undefined) this.pos += toRead;
  $a3feb61323626a539f5d76e62a53bc0d$var$pool.used += toRead;

  function onread(er, bytesRead) {
    if (er) {
      if (self.autoClose && self.destroy) {
        self.destroy();
      }

      self.emit('error', er);
    } else {
      var b = null;

      if (bytesRead > 0) {
        self.bytesRead += bytesRead;
        b = thisPool.slice(start, start + bytesRead);
      }

      self.push(b);
    }
  }
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype._destroy = function (err, cb) {
  this.close(function (err2) {
    cb(err || err2);
  });
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype.close = function (cb) {
  var _this = this;

  if (cb) this.once('close', cb);

  if (this.closed || typeof this.fd !== 'number') {
    if (typeof this.fd !== 'number') {
      this.once('open', $a3feb61323626a539f5d76e62a53bc0d$var$closeOnOpen);
      return;
    }

    return $f35591902d49cecff92643cb75f2628b$exports.default.nextTick(function () {
      return _this.emit('close');
    });
  }

  this.closed = true;

  this._vol.close(this.fd, function (er) {
    if (er) _this.emit('error', er);else _this.emit('close');
  });

  this.fd = null;
}; // needed because as it will be called with arguments
// that does not match this.close() signature


// needed because as it will be called with arguments
// that does not match this.close() signature
function $a3feb61323626a539f5d76e62a53bc0d$var$closeOnOpen(fd) {
  this.close();
}

$a3feb61323626a539f5d76e62a53bc0d$var$util.inherits($a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream, $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable);
var $a3feb61323626a539f5d76e62a53bc0d$export$WriteStream = $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream;
$a3feb61323626a539f5d76e62a53bc0d$exports.WriteStream = $a3feb61323626a539f5d76e62a53bc0d$export$WriteStream;

function $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream(vol, path, options) {
  if (!(this instanceof $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream)) return new $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream(vol, path, options);
  this._vol = vol;
  options = Object.assign({}, $a3feb61323626a539f5d76e62a53bc0d$var$getOptions(options, {}));
  $77f1f3b73e58a1193c01fee8e7b8ba28$exports.Writable.call(this, options);
  this.path = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 438 : options.mode;
  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }

    if (this.start < 0) {
      throw new Error('"start" must be >= zero');
    }

    this.pos = this.start;
  }

  if (options.encoding) this.setDefaultEncoding(options.encoding);
  if (typeof this.fd !== 'number') this.open(); // dispose on finish.

  // dispose on finish.
  this.once('finish', function () {
    if (this.autoClose) {
      this.close();
    }
  });
}

$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype.open = function () {
  this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
    if (er) {
      if (this.autoClose && this.destroy) {
        this.destroy();
      }

      this.emit('error', er);
      return;
    }

    this.fd = fd;
    this.emit('open', fd);
  }.bind(this));
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype._write = function (data, encoding, cb) {
  if (!(data instanceof $434ed7719003c4362f61238fc34a36d9$exports.Buffer)) return this.emit('error', new Error('Invalid data'));

  if (typeof this.fd !== 'number') {
    return this.once('open', function () {
      this._write(data, encoding, cb);
    });
  }

  var self = this; // tslint:disable-line no-this-assignment

  // tslint:disable-line no-this-assignment
  this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
    if (er) {
      if (self.autoClose && self.destroy) {
        self.destroy();
      }

      return cb(er);
    }

    self.bytesWritten += bytes;
    cb();
  });

  if (this.pos !== undefined) this.pos += data.length;
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype._writev = function (data, cb) {
  if (typeof this.fd !== 'number') {
    return this.once('open', function () {
      this._writev(data, cb);
    });
  }

  var self = this; // tslint:disable-line no-this-assignment

  // tslint:disable-line no-this-assignment
  var len = data.length;
  var chunks = new Array(len);
  var size = 0;

  for (var i = 0; i < len; i++) {
    var chunk = data[i].chunk;
    chunks[i] = chunk;
    size += chunk.length;
  }

  var buf = $434ed7719003c4362f61238fc34a36d9$exports.Buffer.concat(chunks);

  this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
    if (er) {
      if (self.destroy) self.destroy();
      return cb(er);
    }

    self.bytesWritten += bytes;
    cb();
  });

  if (this.pos !== undefined) this.pos += size;
};

$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype._destroy = $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype._destroy;
$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype.close = $a3feb61323626a539f5d76e62a53bc0d$var$FsReadStream.prototype.close; // There is no shutdown() for files.

// There is no shutdown() for files.
$a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype.destroySoon = $a3feb61323626a539f5d76e62a53bc0d$var$FsWriteStream.prototype.end; // ---------------------------------------- FSWatcher

// ---------------------------------------- FSWatcher
var $a3feb61323626a539f5d76e62a53bc0d$var$FSWatcher =
/** @class */
function (_super) {
  $a3feb61323626a539f5d76e62a53bc0d$var$__extends(FSWatcher, _super);

  function FSWatcher(vol) {
    var _this = _super.call(this) || this;

    _this._filename = '';
    _this._filenameEncoded = ''; // _persistent: boolean = true;

    // _persistent: boolean = true;
    _this._recursive = false;
    _this._encoding = $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8;

    _this._onNodeChange = function () {
      _this._emit('change');
    };

    _this._onParentChild = function (link) {
      if (link.getName() === _this._getName()) {
        _this._emit('rename');
      }
    };

    _this._emit = function (type) {
      _this.emit('change', type, _this._filenameEncoded);
    };

    _this._persist = function () {
      _this._timer = setTimeout(_this._persist, 1e6);
    };

    _this._vol = vol;
    return _this; // TODO: Emit "error" messages when watching.
    // this._handle.onchange = function(status, eventType, filename) {
    //     if (status < 0) {
    //         self._handle.close();
    //         const error = !filename ?
    //             errnoException(status, 'Error watching file for changes:') :
    //             errnoException(status, `Error watching file ${filename} for changes:`);
    //         error.filename = filename;
    //         self.emit('error', error);
    //     } else {
    //         self.emit('change', eventType, filename);
    //     }
    // };
  }

  FSWatcher.prototype._getName = function () {
    return this._steps[this._steps.length - 1];
  };

  FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
    if (persistent === void 0) {
      persistent = true;
    }

    if (recursive === void 0) {
      recursive = false;
    }

    if (encoding === void 0) {
      encoding = $8dca1526026dec0132784fc5c16fdf73$exports.ENCODING_UTF8;
    }

    this._filename = $a3feb61323626a539f5d76e62a53bc0d$var$pathToFilename(path);
    this._steps = $a3feb61323626a539f5d76e62a53bc0d$var$filenameToSteps(this._filename);
    this._filenameEncoded = $8dca1526026dec0132784fc5c16fdf73$exports.strToEncoding(this._filename); // this._persistent = persistent;

    // this._persistent = persistent;
    this._recursive = recursive;
    this._encoding = encoding;

    try {
      this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');
    } catch (err) {
      var error = new Error("watch " + this._filename + " " + err.code);
      error.code = err.code;
      error.errno = err.code;
      throw error;
    }

    this._link.getNode().on('change', this._onNodeChange);

    this._link.on('child:add', this._onNodeChange);

    this._link.on('child:delete', this._onNodeChange);

    var parent = this._link.parent;

    if (parent) {
      // parent.on('child:add', this._onParentChild);
      parent.setMaxListeners(parent.getMaxListeners() + 1);
      parent.on('child:delete', this._onParentChild);
    }

    if (persistent) this._persist();
  };

  FSWatcher.prototype.close = function () {
    clearTimeout(this._timer);

    this._link.getNode().removeListener('change', this._onNodeChange);

    var parent = this._link.parent;

    if (parent) {
      // parent.removeListener('child:add', this._onParentChild);
      parent.removeListener('child:delete', this._onParentChild);
    }
  };

  return FSWatcher;
}($2bae5ce106cac4278e8cb55eab7c7380$exports.EventEmitter);

$a3feb61323626a539f5d76e62a53bc0d$export$FSWatcher = $a3feb61323626a539f5d76e62a53bc0d$var$FSWatcher;
$a3feb61323626a539f5d76e62a53bc0d$exports.FSWatcher = $a3feb61323626a539f5d76e62a53bc0d$export$FSWatcher;
// ASSET: node_modules/fs-monkey/lib/util/lists.js
var $631c9ca290a793b34e289402ce212a92$exports = {};
Object.defineProperty($631c9ca290a793b34e289402ce212a92$exports, "__esModule", {
  value: true
});
var $631c9ca290a793b34e289402ce212a92$export$fsAsyncMethods = ($631c9ca290a793b34e289402ce212a92$export$fsSyncMethods = ($631c9ca290a793b34e289402ce212a92$export$fsProps = void 0, $631c9ca290a793b34e289402ce212a92$exports.fsProps = $631c9ca290a793b34e289402ce212a92$export$fsProps), $631c9ca290a793b34e289402ce212a92$exports.fsSyncMethods = $631c9ca290a793b34e289402ce212a92$export$fsSyncMethods);
$631c9ca290a793b34e289402ce212a92$exports.fsAsyncMethods = $631c9ca290a793b34e289402ce212a92$export$fsAsyncMethods;
var $631c9ca290a793b34e289402ce212a92$var$fsProps = ['constants', 'F_OK', 'R_OK', 'W_OK', 'X_OK', 'Stats'];
var $631c9ca290a793b34e289402ce212a92$export$fsProps = $631c9ca290a793b34e289402ce212a92$var$fsProps;
$631c9ca290a793b34e289402ce212a92$exports.fsProps = $631c9ca290a793b34e289402ce212a92$export$fsProps;
var $631c9ca290a793b34e289402ce212a92$var$fsSyncMethods = ['renameSync', 'ftruncateSync', 'truncateSync', 'chownSync', 'fchownSync', 'lchownSync', 'chmodSync', 'fchmodSync', 'lchmodSync', 'statSync', 'lstatSync', 'fstatSync', 'linkSync', 'symlinkSync', 'readlinkSync', 'realpathSync', 'unlinkSync', 'rmdirSync', 'mkdirSync', 'mkdirpSync', 'readdirSync', 'closeSync', 'openSync', 'utimesSync', 'futimesSync', 'fsyncSync', 'writeSync', 'readSync', 'readFileSync', 'writeFileSync', 'appendFileSync', 'existsSync', 'accessSync', 'fdatasyncSync', 'mkdtempSync', 'copyFileSync', 'createReadStream', 'createWriteStream'];
var $631c9ca290a793b34e289402ce212a92$export$fsSyncMethods = $631c9ca290a793b34e289402ce212a92$var$fsSyncMethods;
$631c9ca290a793b34e289402ce212a92$exports.fsSyncMethods = $631c9ca290a793b34e289402ce212a92$export$fsSyncMethods;
var $631c9ca290a793b34e289402ce212a92$var$fsAsyncMethods = ['rename', 'ftruncate', 'truncate', 'chown', 'fchown', 'lchown', 'chmod', 'fchmod', 'lchmod', 'stat', 'lstat', 'fstat', 'link', 'symlink', 'readlink', 'realpath', 'unlink', 'rmdir', 'mkdir', 'mkdirp', 'readdir', 'close', 'open', 'utimes', 'futimes', 'fsync', 'write', 'read', 'readFile', 'writeFile', 'appendFile', 'exists', 'access', 'fdatasync', 'mkdtemp', 'copyFile', 'watchFile', 'unwatchFile', 'watch'];
$631c9ca290a793b34e289402ce212a92$export$fsAsyncMethods = $631c9ca290a793b34e289402ce212a92$var$fsAsyncMethods;
$631c9ca290a793b34e289402ce212a92$exports.fsAsyncMethods = $631c9ca290a793b34e289402ce212a92$export$fsAsyncMethods;
var $71965ce02cdeb6e23c0ad07dd03f38b2$var$fsSyncMethods = $631c9ca290a793b34e289402ce212a92$exports.fsSyncMethods,
    $71965ce02cdeb6e23c0ad07dd03f38b2$var$fsAsyncMethods = $631c9ca290a793b34e289402ce212a92$exports.fsAsyncMethods;
var $71965ce02cdeb6e23c0ad07dd03f38b2$var$F_OK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.F_OK,
    $71965ce02cdeb6e23c0ad07dd03f38b2$var$R_OK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.R_OK,
    $71965ce02cdeb6e23c0ad07dd03f38b2$var$W_OK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.W_OK,
    $71965ce02cdeb6e23c0ad07dd03f38b2$var$X_OK = $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants.X_OK;
var $71965ce02cdeb6e23c0ad07dd03f38b2$export$Volume = $a3feb61323626a539f5d76e62a53bc0d$exports.Volume;
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.Volume = $71965ce02cdeb6e23c0ad07dd03f38b2$export$Volume; // Default volume.

var $71965ce02cdeb6e23c0ad07dd03f38b2$export$vol = new $a3feb61323626a539f5d76e62a53bc0d$exports.Volume();
// Default volume.
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.vol = $71965ce02cdeb6e23c0ad07dd03f38b2$export$vol;

function $71965ce02cdeb6e23c0ad07dd03f38b2$var$createFsFromVolume(vol) {
  var fs = {
    F_OK: $71965ce02cdeb6e23c0ad07dd03f38b2$var$F_OK,
    R_OK: $71965ce02cdeb6e23c0ad07dd03f38b2$var$R_OK,
    W_OK: $71965ce02cdeb6e23c0ad07dd03f38b2$var$W_OK,
    X_OK: $71965ce02cdeb6e23c0ad07dd03f38b2$var$X_OK,
    constants: $5ef6d69618112b7fcbc8b307c281ba0d$exports.constants,
    Stats: $3427174026c479434e105c2f49a8e44e$exports.default,
    Dirent: $625e9897ba6758d68ddb608d84cb5b08$exports.default
  }; // Bind FS methods.

  // Bind FS methods.
  for (var _i = 0, fsSyncMethods_1 = $71965ce02cdeb6e23c0ad07dd03f38b2$var$fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
    var method = fsSyncMethods_1[_i];
    if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
  }

  for (var _a = 0, fsAsyncMethods_1 = $71965ce02cdeb6e23c0ad07dd03f38b2$var$fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
    var method = fsAsyncMethods_1[_a];
    if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
  }

  fs.StatWatcher = vol.StatWatcher;
  fs.FSWatcher = vol.FSWatcher;
  fs.WriteStream = vol.WriteStream;
  fs.ReadStream = vol.ReadStream;
  fs.promises = vol.promises;
  fs._toUnixTimestamp = $a3feb61323626a539f5d76e62a53bc0d$exports.toUnixTimestamp;
  return fs;
}

var $71965ce02cdeb6e23c0ad07dd03f38b2$export$createFsFromVolume = $71965ce02cdeb6e23c0ad07dd03f38b2$var$createFsFromVolume;
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.createFsFromVolume = $71965ce02cdeb6e23c0ad07dd03f38b2$export$createFsFromVolume;
$71965ce02cdeb6e23c0ad07dd03f38b2$export$fs = $71965ce02cdeb6e23c0ad07dd03f38b2$var$createFsFromVolume($71965ce02cdeb6e23c0ad07dd03f38b2$exports.vol);
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.fs = $71965ce02cdeb6e23c0ad07dd03f38b2$export$fs;
$71965ce02cdeb6e23c0ad07dd03f38b2$exports = $71965ce02cdeb6e23c0ad07dd03f38b2$var$__assign($71965ce02cdeb6e23c0ad07dd03f38b2$var$__assign({}, $71965ce02cdeb6e23c0ad07dd03f38b2$exports), $71965ce02cdeb6e23c0ad07dd03f38b2$exports.fs);
var $71965ce02cdeb6e23c0ad07dd03f38b2$export$semantic = true;
$71965ce02cdeb6e23c0ad07dd03f38b2$exports.semantic = $71965ce02cdeb6e23c0ad07dd03f38b2$export$semantic;
var $71965ce02cdeb6e23c0ad07dd03f38b2$$interop$default = $parcel$interopDefault($71965ce02cdeb6e23c0ad07dd03f38b2$exports);
window.yarnLoader = {
  run: $cd4941229af683da6f98c7c221b3c668$export$run,
  memfs: $71965ce02cdeb6e23c0ad07dd03f38b2$$interop$default
};
